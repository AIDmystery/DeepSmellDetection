projectName,methodOfClass,methodName,,size,lcom1,lcom2,lcom4,coh,cc,dr,noav,wma,decor_label,dense_label,code
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,StreamScanner,,22,80,69,6,0.1015,0.037,0,4,2,0,1,"/*
    ///////////////////////////////////////////////////////////
    // Life-cycle
    ///////////////////////////////////////////////////////////
     */

    /**
     * Constructor used when creating a complete new (main-level) reader that
     * does not share its input buffers or state with another reader.
     */
    protected StreamScanner(WstxInputSource input, ReaderConfig cfg,
                            XMLResolver res)
    {
        super();
        mInput = input;
        // 17-Jun-2004, TSa: Need to know root-level input source
        mRootInput = input;

        mConfig = cfg;
        mSymbols = cfg.getSymbols();
        int cf = cfg.getConfigFlags();
        mCfgNsEnabled = (cf & CFG_NAMESPACE_AWARE) != 0;
        mCfgReplaceEntities = (cf & CFG_REPLACE_ENTITY_REFS) != 0;

        mNormalizeLFs = mConfig.willNormalizeLFs();
        mInputBuffer = null;
        mInputPtr = mInputEnd = 0;
        mEntityResolver = res;
        
        mCfgTreatCharRefsAsEntities = mConfig.willTreatCharRefsAsEnts();
        mCachedEntities = mCfgTreatCharRefsAsEntities ? new HashMap() : Collections.EMPTY_MAP;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,throwWfcException,,9,12,9,4,0.2778,0.1429,0,3,2,0,1,"/*
    ///////////////////////////////////////////////////////////
    // InputProblemReporter implementation
    ///////////////////////////////////////////////////////////
     */

    public WstxException throwWfcException(String msg, boolean deferErrors)
        throws WstxException
    {
        WstxException ex = constructWfcException(msg);
        if (!deferErrors) {
            throw ex;
        }
        return ex;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,reportProblem,,11,10,5,2,0.2576,0.0986,0,7,5,0,1,"public void reportProblem(Location loc, String probType,
                              String format, Object arg, Object arg2)
        throws XMLStreamException
    {
        XMLReporter rep = mConfig.getXMLReporter();
        if (rep != null) {
            String msg = (arg != null || arg2 != null) ?
                MessageFormat.format(format, new Object[] { arg, arg2 }) : format;
            _reportProblem(rep, probType, msg, loc);
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,_reportProblem,,22,33,0,3,0.4722,0.259,0,3,5,0,1,"protected void _reportProblem(XMLReporter rep, XMLValidationProblem prob)
        throws XMLStreamException
    {
        if (rep != null) {
            Location loc = prob.getLocation();
            if (loc == null) {
                loc = getLastCharLocation();
                prob.setLocation(loc);
            }
            // Backwards-compatibility fix: add non-null type, if missing:
            if (prob.getType() == null) {
                prob.setType(ErrorConsts.WT_VALIDATION);
            }
            // [WSTX-154]: was catching and dropping thrown exception: shouldn't.
            // [WTSX-157]: need to support XMLReporter2
            if (rep instanceof XMLReporter2) {
                ((XMLReporter2) rep).report(prob);
            } else {
                rep.report(prob.getMessage(), prob.getType(), prob, loc);
            }
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,reportValidationProblem,,29,13,0,2,0.4167,0.3274,0,2,4,0,1,"/**
     *<p>
     * Note: this is the base implementation used for implementing
     * <code>ValidationContext</code>
     */
    public void reportValidationProblem(XMLValidationProblem prob)
        throws XMLStreamException
    {
        // !!! TBI: Fail-fast vs. deferred modes?
        /* For now let's implement basic functionality: warnings get
         * reported via XMLReporter, errors and fatal errors result in
         * immediate exceptions.
         */
        /* 27-May-2008, TSa: [WSTX-153] Above is incorrect: as per Stax
         *   javadocs for XMLReporter, both warnings and non-fatal errors
         *   (which includes all validation errors) should be reported via
         *   XMLReporter interface, and only fatals should cause an
         *   immediate stream exception (by-passing reporter)
         */
        if (prob.getSeverity() > XMLValidationProblem.SEVERITY_ERROR) {
            throw WstxValidationException.create(prob);
        }
        XMLReporter rep = mConfig.getXMLReporter();
        if (rep != null) {
            _reportProblem(rep, prob);
        } else {
            /* If no reporter, regular non-fatal errors are to be reported
             * as exceptions as well, for backwards compatibility
             */
            if (prob.getSeverity() >= XMLValidationProblem.SEVERITY_ERROR) {
                throw WstxValidationException.create(prob);
            }
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,throwInvalidSpace,,19,56,34,4,0.2051,0.158,0,5,4,0,1,"protected WstxException throwInvalidSpace(int i, boolean deferErrors)
        throws WstxException
    {
        char c = (char) i;
        WstxException ex;
        if (c == CHAR_NULL) {
            ex = constructNullCharException();
        } else {
            String msg = ""Illegal character (""+getCharDesc(c)+"")"";
            if (mXml11) {
                msg += "" [note: in XML 1.1, it could be included via entity expansion]"";
            }
            ex = new WstxUnexpectedCharException(msg, getLastCharLocation(), c);
        }
        if (!deferErrors) {
            throw ex;
        }
        return ex;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,throwFromStrE,,10,13,5,3,0.5,0.25,0,2,2,0,1,"protected void throwFromStrE(XMLStreamException strex)
        throws WstxException
    {
        if (strex instanceof WstxException) {
            throw (WstxException) strex;
        }
        WstxException newEx = new WstxException(strex);
        ExceptionUtil.setInitCause(newEx, strex);
        throw newEx;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,skipCRLF,,15,39,33,7,0.175,0.1538,0,2,3,0,1,"/**
     * Method called when a CR has been spotted in input; checks if next
     * char is LF, and if so, skips it. Note that next character has to
     * come from the current input source, to qualify; it can never come
     * from another (nested) input source.
     *
     * @return True, if passed in char is '\r' and next one is '\n'.
     */
    protected final boolean skipCRLF(char c) 
        throws XMLStreamException
    {
        boolean result;

        if (c == '\r' && peekNext() == '\n') {
            ++mInputPtr;
            result = true;
        } else {
            result = false;
        }
        ++mCurrInputRow;
        mCurrInputRowStart = mInputPtr;
        return result;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,initInputSource,,23,42,39,7,0.13,0.0333,0,3,2,0,1,"/*
    ///////////////////////////////////////////////////////////
    // Sub-class overridable input handling methods
    ///////////////////////////////////////////////////////////
     */

    /**
     * Method called when an entity has been expanded (new input source
     * has been created). Needs to initialize location information and change
     * active input source.
     *
     * @param entityId Name of the entity being expanded
     */
    protected void initInputSource(WstxInputSource newInput, boolean isExt,
                                   String entityId)
        throws XMLStreamException
    {
        mInput = newInput;
        // Let's make sure new input will be read next time input is needed:
        mInputPtr = 0;
        mInputEnd = 0;
        /* Plus, reset the input location so that'll be accurate for
         * error reporting etc.
         */
        mInputTopDepth = mCurrDepth;
        mInput.initInputLocation(this, mCurrDepth);

        /* 21-Feb-2006, TSa: Linefeeds are NOT normalized when expanding
         *   internal entities (XML, 2.11)
         */
        if (isExt) {
            mNormalizeLFs = true;
        } else {
            mNormalizeLFs = false;
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,loadMore,,54,157,83,5,0.1154,0.1382,0,4,8,0,1,"/**
     * Method that will try to read one or more characters from currently
     * open input sources; closing input sources if necessary.
     *
     * @return true if reading succeeded (or may succeed), false if
     *   we reached EOF.
     */
    protected boolean loadMore()
        throws XMLStreamException
    {
        WstxInputSource input = mInput;
        do {
            /* Need to make sure offsets are properly updated for error
             * reporting purposes, and do this now while previous amounts
             * are still known.
             */
            mCurrInputProcessed += mInputEnd;
            mCurrInputRowStart -= mInputEnd;
            int count;
            try {
                count = input.readInto(this);
                if (count > 0) {
                    return true;
                }
                input.close();
            } catch (IOException ioe) {
                throw constructFromIOE(ioe);
            }
            if (input == mRootInput) {
                /* Note: no need to check entity/input nesting in this
                 * particular case, since it will be handled by higher level
                 * parsing code (results in an unexpected EOF)
                 */
                return false;
            }
            WstxInputSource parent = input.getParent();
            if (parent == null) { // sanity check!
                throwNullParent(input);
            }
            /* 13-Feb-2006, TSa: Ok, do we violate a proper nesting constraints
             *   with this input block closure?
             */
            if (mCurrDepth != input.getScopeId()) {
                handleIncompleteEntityProblem(input);
            }

            mInput = input = parent;
            input.restoreContext(this);
            mInputTopDepth = input.getScopeId();
            /* 21-Feb-2006, TSa: Since linefeed normalization needs to be
             *   suppressed for internal entity expansion, we may need to
             *   change the state...
             */
            if (!mNormalizeLFs) {
                mNormalizeLFs = !input.fromInternalEntity();
            }
            // Maybe there are leftovers from that input in buffer now?
        } while (mInputPtr >= mInputEnd);

        return true;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,loadMore,,8,6,6,4,0.25,0,0,1,2,0,1,"protected final boolean loadMore(String errorMsg)
        throws XMLStreamException
    {
        if (!loadMore()) {
            throwUnexpectedEOF(errorMsg);
        }
        return true;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,loadMoreFromCurrent,,13,18,15,4,0.2041,0.0794,0,2,2,0,1,"protected boolean loadMoreFromCurrent()
        throws XMLStreamException
    {
        // Need to update offsets properly
        mCurrInputProcessed += mInputEnd;
        mCurrInputRowStart -= mInputEnd;
        try {
            int count = mInput.readInto(this);
            return (count > 0);
        } catch (IOException ie) {
            throw constructFromIOE(ie);
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,loadMoreFromCurrent,,8,6,6,4,0.25,0,0,1,2,0,1,"protected final boolean loadMoreFromCurrent(String errorMsg)
        throws XMLStreamException
    {
        if (!loadMoreFromCurrent()) {
            throwUnexpectedEOB(errorMsg);
        }
        return true;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,ensureInput,,13,18,15,4,0.2041,0.075,0,3,3,0,1,"/**
     * Method called to make sure current main-level input buffer has at
     * least specified number of characters available consequtively,
     * without having to call {@link #loadMore}. It can only be called
     * when input comes from main-level buffer; further, call can shift
     * content in input buffer, so caller has to flush any data still
     * pending. In short, caller has to know exactly what it's doing. :-)
     *<p>
     * Note: method does not check for any other input sources than the
     * current one -- if current source can not fulfill the request, a
     * failure is indicated.
     *
     * @return true if there's now enough data; false if not (EOF)
     */
    protected boolean ensureInput(int minAmount)
        throws XMLStreamException
    {
        int currAmount = mInputEnd - mInputPtr;
        if (currAmount >= minAmount) {
            return true;
        }
        try {
            return mInput.readMore(this, minAmount);
        } catch (IOException ie) {
            throw constructFromIOE(ie);
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,closeAllInput,,24,54,30,5,0.2051,0.1677,0,4,6,0,1,"protected void closeAllInput(boolean force)
        throws XMLStreamException
    {
        WstxInputSource input = mInput;
        while (true) {
            try {
                if (force) {
                    input.closeCompletely();
                } else {
                    input.close();
                }
            } catch (IOException ie) {
                throw constructFromIOE(ie);
            }
            if (input == mRootInput) {
                break;
            }
            WstxInputSource parent = input.getParent();
            if (parent == null) { // sanity check!
                throwNullParent(input);
            }
            mInput = input = parent;
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,resolveSimpleEntity,,115,731,0,4,0.1932,0.2359,0,8,43,1,1,"/*
    ///////////////////////////////////////////////////////////
    // Entity resolution
    ///////////////////////////////////////////////////////////
     */

    /**
     * Method that tries to resolve a character entity, or (if caller so
     * specifies), a pre-defined internal entity (lt, gt, amp, apos, quot).
     * It will succeed iff:
     * <ol>
     *  <li>Entity in question is a simple character entity (either one of
     *    5 pre-defined ones, or using decimal/hex notation), AND
     *   <li>
     *  <li>Entity fits completely inside current input buffer.
     *   <li>
     * </ol>
     * If so, character value of entity is returned. Character 0 is returned
     * otherwise; if so, caller needs to do full resolution.
     *<p>
     * Note: On entry we are guaranteed there are at least 3 more characters
     * in this buffer; otherwise we shouldn't be called.
     *
     * @param checkStd If true, will check pre-defined internal entities
     *   (gt, lt, amp, apos, quot); if false, will only check actual
     *   character entities.
     *
     * @return (Valid) character value, if entity is a character reference,
     *   and could be resolved from current input buffer (does not span
     *   buffer boundary); null char (code 0) if not (either non-char
     *   entity, or spans input buffer boundary).
     */
    protected int resolveSimpleEntity(boolean checkStd)
        throws XMLStreamException
    {
        char[] buf = mInputBuffer;
        int ptr = mInputPtr;
        char c = buf[ptr++];

        // Numeric reference?
        if (c == '#') {
            c = buf[ptr++];
            int value = 0;
            int inputLen = mInputEnd;
            if (c == 'x') { // hex
                while (ptr < inputLen) {
                    c = buf[ptr++];
                    if (c == ';') {
                        break;
                    }
                    value = value << 4;
                    if (c <= '9' && c >= '0') {
                        value += (c - '0');
                    } else if (c >= 'a' && c <= 'f') {
                        value += (10 + (c - 'a'));
                    } else if (c >= 'A' && c <= 'F') {
                        value += (10 + (c - 'A'));
                    } else {
                        mInputPtr = ptr; // so error points to correct char
                        throwUnexpectedChar(c, ""; expected a hex digit (0-9a-fA-F)."");
                    }
                    /* Need to check for overflow; easiest to do right as
                     * it happens...
                     */
                    if (value > MAX_UNICODE_CHAR) {
                        reportUnicodeOverflow();
                    }
                }
            } else { // numeric (decimal)
                while (c != ';') {
                    if (c <= '9' && c >= '0') {
                        value = (value * 10) + (c - '0');
                        // Overflow?
                        if (value > MAX_UNICODE_CHAR) {
                            reportUnicodeOverflow();
                        }
                    } else {
                        mInputPtr = ptr; // so error points to correct char
                        throwUnexpectedChar(c, ""; expected a decimal number."");
                    }
                    if (ptr >= inputLen) {
                        break;
                    }
                    c = buf[ptr++];
                }
            }
            /* We get here either if we got it all, OR if we ran out of
             * input in current buffer.
             */
            if (c == ';') { // got the full thing
                mInputPtr = ptr;
                validateChar(value);
                return value;
            }

            /* If we ran out of input, need to just fall back, gets
             * resolved via 'full' resolution mechanism.
             */
        } else if (checkStd) {
            /* Caller may not want to resolve these quite yet...
             * (when it wants separate events for non-char entities)
             */
            if (c == 'a') { // amp or apos?
                c = buf[ptr++];
                
                if (c == 'm') { // amp?
                    if (buf[ptr++] == 'p') {
                        if (ptr < mInputEnd && buf[ptr++] == ';') {
                            mInputPtr = ptr;
                            return '&';
                        }
                    }
                } else if (c == 'p') { // apos?
                    if (buf[ptr++] == 'o') {
                        int len = mInputEnd;
                        if (ptr < len && buf[ptr++] == 's') {
                            if (ptr < len && buf[ptr++] == ';') {
                                mInputPtr = ptr;
                                return '\'';
                            }
                        }
                    }
                }
            } else if (c == 'g') { // gt?
                if (buf[ptr++] == 't' && buf[ptr++] == ';') {
                    mInputPtr = ptr;
                    return '>';
                }
            } else if (c == 'l') { // lt?
                if (buf[ptr++] == 't' && buf[ptr++] == ';') {
                    mInputPtr = ptr;
                    return '<';
                }
            } else if (c == 'q') { // quot?
                if (buf[ptr++] == 'u' && buf[ptr++] == 'o') {
                    int len = mInputEnd;
                    if (ptr < len && buf[ptr++] == 't') {
                        if (ptr < len && buf[ptr++] == ';') {
                            mInputPtr = ptr;
                            return '""';
                        }
                    }
                }
            }
        }
        return 0;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,resolveCharOnlyEntity,,84,272,166,7,0.2041,0.1515,0,4,30,0,1,"/**
     * Method called to resolve character entities, and only character
     * entities (except that pre-defined char entities -- amp, apos, lt,
     * gt, quote -- MAY be ""char entities"" in this sense, depending on
     * arguments).
     * Otherwise it is to return the null char; if so,
     * the input pointer will point to the same point as when method
     * entered (char after ampersand), plus the ampersand itself is
     * guaranteed to be in the input buffer (so caller can just push it
     * back if necessary).
     *<p>
     * Most often this method is called when reader is not to expand
     * non-char entities automatically, but to return them as separate
     * events.
     *<p>
     * Main complication here is that we need to do 5-char lookahead. This
     * is problematic if chars are on input buffer boundary. This is ok
     * for the root level input buffer, but not for some nested buffers.
     * However, according to XML specs, such split entities are actually
     * illegal... so we can throw an exception in those cases.
     *
     * @param checkStd If true, will check pre-defined internal entities
     *   (gt, lt, amp, apos, quot) as character entities; if false, will only
     *   check actual 'real' character entities.
     *
     * @return (Valid) character value, if entity is a character reference,
     *   and could be resolved from current input buffer (does not span
     *   buffer boundary); null char (code 0) if not (either non-char
     *   entity, or spans input buffer boundary).
     */
    protected int resolveCharOnlyEntity(boolean checkStd)
        throws XMLStreamException
    {
        //int avail = inputInBuffer();
        int avail = mInputEnd - mInputPtr;
        if (avail < 6) {
            // split entity, or buffer boundary
            /* Don't want to lose leading '&' (in case we can not expand
             * the entity), so let's push it back first
             */
            --mInputPtr;
            /* Shortest valid reference would be 3 chars ('&a;'); which
             * would only be legal from an expanded entity...
             */
            if (!ensureInput(6)) {
                avail = inputInBuffer();
                if (avail < 3) {
                    throwUnexpectedEOF(SUFFIX_IN_ENTITY_REF);
                }
            } else {
                avail = 6;
            }
            // ... and now we can move pointer back as well:
            ++mInputPtr;
        }

        /* Ok, now we have one more character to check, and that's enough
         * to determine type decisively.
         */
        char c = mInputBuffer[mInputPtr];

        // A char reference?
        if (c == '#') { // yup
            ++mInputPtr;
            return resolveCharEnt(null);
        }

        // nope... except may be a pre-def?
        if (checkStd) {
            if (c == 'a') {
                char d = mInputBuffer[mInputPtr+1];
                if (d == 'm') {
                    if (avail >= 4
                        && mInputBuffer[mInputPtr+2] == 'p'
                        && mInputBuffer[mInputPtr+3] == ';') {
                        mInputPtr += 4;
                        return '&';
                    }
                } else if (d == 'p') {
                    if (avail >= 5
                        && mInputBuffer[mInputPtr+2] == 'o'
                        && mInputBuffer[mInputPtr+3] == 's'
                        && mInputBuffer[mInputPtr+4] == ';') {
                        mInputPtr += 5;
                        return '\'';
                    }
                }
            } else if (c == 'l') {
                if (avail >= 3
                    && mInputBuffer[mInputPtr+1] == 't'
                    && mInputBuffer[mInputPtr+2] == ';') {
                    mInputPtr += 3;
                    return '<';
                }
            } else if (c == 'g') {
                if (avail >= 3
                    && mInputBuffer[mInputPtr+1] == 't'
                    && mInputBuffer[mInputPtr+2] == ';') {
                    mInputPtr += 3;
                    return '>';
                }
            } else if (c == 'q') {
                if (avail >= 5
                    && mInputBuffer[mInputPtr+1] == 'u'
                    && mInputBuffer[mInputPtr+2] == 'o'
                    && mInputBuffer[mInputPtr+3] == 't'
                    && mInputBuffer[mInputPtr+4] == ';') {
                    mInputPtr += 5;
                    return '""';
                }
            }
        }
        return 0;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,resolveNonCharEntity,,87,229,133,8,0.1538,0.1639,0,4,29,0,1,"/**
     * Reverse of {@link #resolveCharOnlyEntity}; will only resolve entity
     * if it is NOT a character entity (or pre-defined 'generic' entity;
     * amp, apos, lt, gt or quot). Only used in cases where entities
     * are to be separately returned unexpanded (in non-entity-replacing
     * mode); which means it's never called from dtd handler.
     */
    protected EntityDecl resolveNonCharEntity()
        throws XMLStreamException
    {
        //int avail = inputInBuffer();
        int avail = mInputEnd - mInputPtr;
        if (avail < 6) {
            // split entity, or buffer boundary
            /* Don't want to lose leading '&' (in case we can not expand
             * the entity), so let's push it back first
             */
            --mInputPtr;

            /* Shortest valid reference would be 3 chars ('&a;'); which
             * would only be legal from an expanded entity...
             */
            if (!ensureInput(6)) {
                avail = inputInBuffer();
                if (avail < 3) {
                    throwUnexpectedEOF(SUFFIX_IN_ENTITY_REF);
                }
            } else {
                avail = 6;
            }
            // ... and now we can move pointer back as well:
            ++mInputPtr;
        }

        // We don't care about char entities:
        char c = mInputBuffer[mInputPtr];
        if (c == '#') {
            return null;
        }

        /* 19-Aug-2004, TSa: Need special handling for pre-defined
         *   entities; they are not counted as 'real' general parsed
         *   entities, but more as character entities...
         */

        // have chars at least up to mInputPtr+4 by now
        if (c == 'a') {
            char d = mInputBuffer[mInputPtr+1];
            if (d == 'm') {
                if (avail >= 4
                    && mInputBuffer[mInputPtr+2] == 'p'
                    && mInputBuffer[mInputPtr+3] == ';') {
                    // If not automatically expanding:
                    //return sEntityAmp;
                    // mInputPtr += 4;
                    return null;
                }
            } else if (d == 'p') {
                if (avail >= 5
                    && mInputBuffer[mInputPtr+2] == 'o'
                    && mInputBuffer[mInputPtr+3] == 's'
                    && mInputBuffer[mInputPtr+4] == ';') {
                    return null;
                }
            }
        } else if (c == 'l') {
            if (avail >= 3
                && mInputBuffer[mInputPtr+1] == 't'
                && mInputBuffer[mInputPtr+2] == ';') {
                return null;
            }
        } else if (c == 'g') {
            if (avail >= 3
                && mInputBuffer[mInputPtr+1] == 't'
                && mInputBuffer[mInputPtr+2] == ';') {
                return null;
            }
        } else if (c == 'q') {
            if (avail >= 5
                && mInputBuffer[mInputPtr+1] == 'u'
                && mInputBuffer[mInputPtr+2] == 'o'
                && mInputBuffer[mInputPtr+3] == 't'
                && mInputBuffer[mInputPtr+4] == ';') {
                return null;
            }
        }

        // Otherwise, let's just parse in generic way:
        ++mInputPtr; // since we already read the first letter
        String id = parseEntityName(c);
        mCurrName = id;

        return findEntity(id, null);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,fullyResolveEntity,,62,427,293,3,0.1222,0.1379,0,9,17,0,1,"/**
     * Method that does full resolution of an entity reference, be it
     * character entity, internal entity or external entity, including
     * updating of input buffers, and depending on whether result is
     * a character entity (or one of 5 pre-defined entities), returns
     * char in question, or null character (code 0) to indicate it had
     * to change input source.
     *
     * @param allowExt If true, is allowed to expand external entities
     *   (expanding text); if false, is not (expanding attribute value).
     *
     * @return Either single-character replacement (which is NOT to be
     *    reparsed), or null char (0) to indicate expansion is done via
     *    input source.
     */
    protected int fullyResolveEntity(boolean allowExt)
        throws XMLStreamException
    {
        char c = getNextCharFromCurrent(SUFFIX_IN_ENTITY_REF);
        // Do we have a (numeric) character entity reference?
        if (c == '#') { // numeric
            final StringBuffer originalSurface = new StringBuffer(""#"");
            int ch = resolveCharEnt(originalSurface);
            if (mCfgTreatCharRefsAsEntities) {
                final char[] originalChars = new char[originalSurface.length()];
                originalSurface.getChars(0, originalSurface.length(), originalChars, 0);
                mCurrEntity = getIntEntity(ch, originalChars);
                return 0;
            }
            return ch;
        }

        String id = parseEntityName(c);
 
        // Perhaps we have a pre-defined char reference?
        c = id.charAt(0);
        /*
         * 16-May-2004, TSa: Should custom entities (or ones defined in int/ext subset) override
         * pre-defined settings for these?
         */
        char d = CHAR_NULL;
        if (c == 'a') { // amp or apos?
            if (id.equals(""amp"")) {
                d = '&';
            } else if (id.equals(""apos"")) {
                d = '\'';
            }
        } else if (c == 'g') { // gt?
            if (id.length() == 2 && id.charAt(1) == 't') {
                d = '>';
            }
        } else if (c == 'l') { // lt?
            if (id.length() == 2 && id.charAt(1) == 't') {
                d = '<';
            }
        } else if (c == 'q') { // quot?
            if (id.equals(""quot"")) {
                d = '""';
            }
        }

        if (d != CHAR_NULL) {
            if (mCfgTreatCharRefsAsEntities) {
                final char[] originalChars = new char[id.length()];
                id.getChars(0, id.length(), originalChars, 0);
                mCurrEntity = getIntEntity(d, originalChars);
                return 0;
            }
            return d;
        }

        final EntityDecl e = expandEntity(id, allowExt, null);
        if (mCfgTreatCharRefsAsEntities) {
            mCurrEntity = e;
        }
        return 0;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,expandEntity,,28,31,17,3,0.1875,0.1259,0,4,5,0,1,"/**
     * Helper method that will try to expand a parsed entity (parameter or
     * generic entity).
     *<p>
     * note: called by sub-classes (dtd parser), needs to be protected.
     *
     * @param id Name of the entity being expanded 
     * @param allowExt Whether external entities can be expanded or not; if
     *   not, and the entity to expand would be external one, an exception
     *   will be thrown
     */
    protected EntityDecl expandEntity(String id, boolean allowExt,
                                      Object extraArg)
        throws XMLStreamException
    {
        mCurrName = id;

        EntityDecl ed = findEntity(id, extraArg);

        if (ed == null) {
            /* 30-Sep-2005, TSa: As per [WSTX-5], let's only throw exception
             *   if we have to resolve it (otherwise it's just best-effort, 
             *   and null is ok)
             */
            /* 02-Oct-2005, TSa: Plus, [WSTX-4] adds ""undeclared entity
             *    resolver""
             */
            if (mCfgReplaceEntities) {
                mCurrEntity = expandUnresolvedEntity(id);
            }
            return null;
        }
        
        if (!mCfgTreatCharRefsAsEntities || this instanceof MinimalDTDReader) {
            expandEntity(ed, allowExt);
        }
        
        return ed;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,expandEntity,,51,184,137,4,0.1189,0.0924,0,8,8,0,1,"/**
     *
     *<p>
     * note: defined as private for documentation, ie. it's just called
     * from within this class (not sub-classes), from one specific method
     * (see above)
     *
     * @param ed Entity to be expanded
     * @param allowExt Whether external entities are allowed or not.
     */
    private void expandEntity(EntityDecl ed, boolean allowExt)
        throws XMLStreamException
    {
        String id = ed.getName();

        /* Very first thing; we can immediately check if expanding
         * this entity would result in infinite recursion:
         */
        if (mInput.isOrIsExpandedFrom(id)) {
            throwRecursionError(id);
        }

        /* Should not refer unparsed entities from attribute values
         * or text content (except via notation mechanism, but that's
         * not parsed here)
         */
        if (!ed.isParsed()) {
            throwParseError(""Illegal reference to unparsed external entity \""{0}\"""", id, null);
        }

        // 28-Jun-2004, TSa: Do we support external entity expansion?
        boolean isExt = ed.isExternal();
        if (isExt) {
            if (!allowExt) { // never ok in attribute value...
                throwParseError(""Encountered a reference to external parsed entity \""{0}\"" when expanding attribute value: not legal as per XML 1.0/1.1 #3.1"", id, null);
            }
            if (!mConfig.willSupportExternalEntities()) {
                throwParseError(""Encountered a reference to external entity \""{0}\"", but stream reader has feature \""{1}\"" disabled"",
                                id, XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES);
            }
        }

        // First, let's give current context chance to save its stuff
        WstxInputSource oldInput = mInput;
        oldInput.saveContext(this);
        WstxInputSource newInput = null;
        try {
            newInput = ed.expand(oldInput, mEntityResolver, mConfig, mDocXmlVersion);
        } catch (FileNotFoundException fex) {
            /* Let's catch and rethrow this just so we get more meaningful
             * description (with input source position etc)
             */
            throwParseError(""(was {0}) {1}"", fex.getClass().getName(), fex.getMessage());
        } catch (IOException ioe) {
            throw constructFromIOE(ioe);
        }
        /* And then we'll need to make sure new input comes from the new
         * input source
         */
        initInputSource(newInput, isExt, id);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,expandUnresolvedEntity,,42,142,94,4,0.1233,0.0839,0,6,7,0,1,"/**
     *<p>
     * note: only called from the local expandEntity() method
     */
    private EntityDecl expandUnresolvedEntity(String id)
        throws XMLStreamException
    {
        XMLResolver resolver = mConfig.getUndeclaredEntityResolver();
        if (resolver != null) {
            /* Ok, we can check for recursion here; but let's only do that
             * if there is any chance that it might get resolved by
             * the special resolver (it must have been resolved this way
             * earlier, too...)
             */
            if (mInput.isOrIsExpandedFrom(id)) {
                throwRecursionError(id);
            }

            WstxInputSource oldInput = mInput;
            oldInput.saveContext(this);
            // null, null -> no public or system ids
            int xmlVersion = mDocXmlVersion;
            // 05-Feb-2006, TSa: If xmlVersion not explicitly known, defaults to 1.0
            if (xmlVersion == XmlConsts.XML_V_UNKNOWN) {
                xmlVersion = XmlConsts.XML_V_10;
            }
            WstxInputSource newInput;
            try {
                newInput = DefaultInputResolver.resolveEntityUsing
                    (oldInput, id, null, null, resolver, mConfig, xmlVersion);
                if (mCfgTreatCharRefsAsEntities) {
                    return new IntEntity(WstxInputLocation.getEmptyLocation(), newInput.getEntityId(),
                            newInput.getSource(), new char[]{}, WstxInputLocation.getEmptyLocation());
                }
            } catch (IOException ioe) {
                throw constructFromIOE(ioe);
            }
            if (newInput != null) {
                // true -> is external
                initInputSource(newInput, true, id);
                return null;
            }
        }
        handleUndeclaredEntity(id);
        return null;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseLocalName,,46,117,44,2,0.1636,0.1836,0,6,7,0,1,"/*
    ///////////////////////////////////////////////////////////
    // Basic tokenization
    ///////////////////////////////////////////////////////////
     */

    /**
     * Method that will parse name token (roughly equivalent to XML specs;
     * although bit lenier for more efficient handling); either uri prefix,
     * or local name.
     *<p>
     * Much of complexity in this method has to do with the intention to 
     * try to avoid any character copies. In this optimal case algorithm
     * would be fairly simple. However, this only works if all data is
     * already in input buffer... if not, copy has to be made halfway
     * through parsing, and that complicates things.
     *<p>
     * One thing to note is that String returned has been canonicalized
     * and (if necessary) added to symbol table. It can thus be compared
     * against other such (usually id) Strings, with simple equality operator.
     *
     * @param c First character of the name; not yet checked for validity
     *
     * @return Canonicalized name String (which may have length 0, if
     *    EOF or non-name-start char encountered)
     */
    protected String parseLocalName(char c)
        throws XMLStreamException
    {
        /* Has to start with letter, or '_' (etc); we won't allow ':' as that
         * is taken as namespace separator; no use trying to optimize
         * heavily as it's 98% likely it is a valid char...
         */
        if (!isNameStartChar(c)) {
            if (c == ':') {
                throwUnexpectedChar(c, "" (missing namespace prefix?)"");
            }
            throwUnexpectedChar(c, "" (expected a name start character)"");
        }

        int ptr = mInputPtr;
        int hash = (int) c;
        final int inputLen = mInputEnd;
        int startPtr = ptr-1; // already read previous char
        final char[] inputBuf = mInputBuffer;

        /* After which there may be zero or more name chars
         * we have to consider
         */
        while (true) {
            if (ptr >= inputLen) {
                /* Ok, identifier may continue past buffer end, need
                 * to continue with part 2 (separate method, as this is
                 * not as common as having it all in buffer)
                 */
                mInputPtr = ptr;
                return parseLocalName2(startPtr, hash);
            }
            // Ok, we have the char... is it a name char?
            c = inputBuf[ptr];
            if (c < CHAR_LOWEST_LEGAL_LOCALNAME_CHAR) {
                break;
            }
            if (!isNameChar(c)) {
                break;
            }
            hash = (hash * 31) + (int) c;
            ++ptr;
        }
        mInputPtr = ptr;
        return mSymbols.findSymbol(mInputBuffer, startPtr, ptr - startPtr, hash);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseLocalName2,,37,108,63,4,0.141,0.0998,0,6,8,0,1,"/**
     * Second part of name token parsing; called when name can continue
     * past input buffer end (so only part was read before calling this
     * method to read the rest).
     *<p>
     * Note that this isn't heavily optimized, on assumption it's not
     * called very often.
     */
    protected String parseLocalName2(int start, int hash)
        throws XMLStreamException
    {
        int ptr = mInputEnd - start;
        // Let's assume fairly short names
        char[] outBuf = getNameBuffer(ptr+8);

        if (ptr > 0) {
            System.arraycopy(mInputBuffer, start, outBuf, 0, ptr);
        }

        int outLen = outBuf.length;
        while (true) {
            // note: names can not cross input block (entity) boundaries...
            if (mInputPtr >= mInputEnd) {
                if (!loadMoreFromCurrent()) {
                    break;
                }
            }
            char c = mInputBuffer[mInputPtr];
            if (c < CHAR_LOWEST_LEGAL_LOCALNAME_CHAR) {
                break;
            }
            if (!isNameChar(c)) {
                break;
            }
            ++mInputPtr;
            if (ptr >= outLen) {
                mNameBuffer = outBuf = expandBy50Pct(outBuf);
                outLen = outBuf.length;
            }
            outBuf[ptr++] = c;
            hash = (hash * 31) + (int) c;
        }
        // Still need to canonicalize the name:
        return mSymbols.findSymbol(outBuf, 0, ptr, hash);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseFullName,,8,6,6,4,0.25,0,0,0,2,0,1,"/**
     * Method that will parse 'full' name token; what full means depends on
     * whether reader is namespace aware or not. If it is, full name means
     * local name with no namespace prefix (PI target, entity/notation name);
     * if not, name can contain arbitrary number of colons. Note that
     * element and attribute names are NOT parsed here, so actual namespace
     * prefix separation can be handled properly there.
     *<p>
     * Similar to {@link #parseLocalName}, much of complexity stems from
     * trying to avoid copying name characters from input buffer.
     *<p>
     * Note that returned String will be canonicalized, similar to
     * {@link #parseLocalName}, but without separating prefix/local name.
      *
     * @return Canonicalized name String (which may have length 0, if
     *    EOF or non-name-start char encountered)
     */
    protected String parseFullName()
        throws XMLStreamException
    {
        if (mInputPtr >= mInputEnd) {
            loadMoreFromCurrent();
        }
        return parseFullName(mInputBuffer[mInputPtr++]);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseFullName,,55,194,63,2,0.1573,0.2099,0,5,11,0,1,"protected String parseFullName(char c)
        throws XMLStreamException
    {
        // First char has special handling:
        if (!isNameStartChar(c)) {
            if (c == ':') { // no name.... generally an error:
                if (mCfgNsEnabled) {
                    throwNsColonException(parseFNameForError());
                }
                // Ok, that's fine actually
            } else {
                if (c <= CHAR_SPACE) {
                    throwUnexpectedChar(c, "" (missing name?)"");
                }
                throwUnexpectedChar(c, "" (expected a name start character)"");
            }
        }

        int ptr = mInputPtr;
        int hash = (int) c;
        int inputLen = mInputEnd;
        int startPtr = ptr-1; // to account for the first char

        /* After which there may be zero or more name chars
         * we have to consider
         */
        while (true) {
            if (ptr >= inputLen) {
                /* Ok, identifier may continue past buffer end, need
                 * to continue with part 2 (separate method, as this is
                 * not as common as having it all in buffer)
                 */
                mInputPtr = ptr;
                return parseFullName2(startPtr, hash);
            }
            c = mInputBuffer[ptr];
            if (c == ':') { // colon only allowed in non-NS mode
                if (mCfgNsEnabled) {
                    mInputPtr = ptr;
                    throwNsColonException(new String(mInputBuffer, startPtr, ptr - startPtr) + parseFNameForError());
                }
            } else {
                if (c < CHAR_LOWEST_LEGAL_LOCALNAME_CHAR) {
                    break;
                }
                if (!isNameChar(c)) {
                    break;
                }
            }
            hash = (hash * 31) + (int) c;
            ++ptr;
        }
        mInputPtr = ptr;
        return mSymbols.findSymbol(mInputBuffer, startPtr, ptr - startPtr, hash);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseFullName2,,46,126,62,4,0.13,0.1113,0,6,10,0,1,"protected String parseFullName2(int start, int hash)
        throws XMLStreamException
    {
        int ptr = mInputEnd - start;
        // Let's assume fairly short names
        char[] outBuf = getNameBuffer(ptr+8);

        if (ptr > 0) {
            System.arraycopy(mInputBuffer, start, outBuf, 0, ptr);
        }

        int outLen = outBuf.length;
        while (true) {
            /* 06-Sep-2004, TSa: Name tokens are not allowed to continue
             *   past entity expansion ranges... that is, all characters
             *   have to come from the same input source. Thus, let's only
             *   load things from same input level
             */
            if (mInputPtr >= mInputEnd) {
                if (!loadMoreFromCurrent()) {
                    break;
                }
            }
            char c = mInputBuffer[mInputPtr];
            if (c == ':') { // colon only allowed in non-NS mode
                if (mCfgNsEnabled) {
                    throwNsColonException(new String(outBuf, 0, ptr) + c + parseFNameForError());
                }
            } else if (c < CHAR_LOWEST_LEGAL_LOCALNAME_CHAR) {
                break;
            } else if (!isNameChar(c)) {
                break;
            }
            ++mInputPtr;

            if (ptr >= outLen) {
                mNameBuffer = outBuf = expandBy50Pct(outBuf);
                outLen = outBuf.length;
            }
            outBuf[ptr++] = c;
            hash = (hash * 31) + (int) c;
        }

        // Still need to canonicalize the name:
        return mSymbols.findSymbol(outBuf, 0, ptr, hash);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseFNameForError,,24,50,34,4,0.1944,0.1283,0,3,6,0,1,"/**
     * Method called to read in full name, including unlimited number of
     * namespace separators (':'), for the purpose of displaying name in
     * an error message. Won't do any further validations, and parsing
     * is not optimized: main need is just to get more meaningful error
     * messages.
     */
    protected String parseFNameForError()
        throws XMLStreamException
    {
        StringBuffer sb = new StringBuffer(100);
        while (true) {
            char c;

            if (mInputPtr < mInputEnd) {
                c = mInputBuffer[mInputPtr++];
            } else { // can't error here, so let's accept EOF for now:
                int i = getNext();
                if (i < 0) {
                    break;
                }
                c = (char) i;
            }
            if (c != ':' && !isNameChar(c)) {
                --mInputPtr;
                break;
            }
            sb.append(c);
        }
        return sb.toString();
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseEntityName,,16,25,14,4,0.2444,0.1762,0,2,4,0,1,"protected final String parseEntityName(char c)
        throws XMLStreamException
    {
        String id = parseFullName(c);
        // Needs to be followed by a semi-colon, too.. from same input source:
        if (mInputPtr >= mInputEnd) {
            if (!loadMoreFromCurrent()) {
                throwParseError(""Missing semicolon after reference for entity \""{0}\"""", id, null);
            }
        }
        c = mInputBuffer[mInputPtr++];
        if (c != ';') {
            throwUnexpectedChar(c, ""; expected a semi-colon after the reference for entity '""+id+""'"");
        }
        return id;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,skipFullName,,22,30,24,5,0.2,0.1364,0,2,6,0,1,"/**
     * Note: does not check for number of colons, amongst other things.
     * Main idea is to skip through what superficially seems like a valid
     * id, nothing more. This is only done when really skipping through
     * something we do not care about at all: not even whether names/ids
     * would be valid (for example, when ignoring internal DTD subset).
     *
     * @return Length of skipped name.
     */
    protected int skipFullName(char c)
        throws XMLStreamException
    {
        if (!isNameStartChar(c)) {
            --mInputPtr;
            return 0;
        }

        /* After which there may be zero or more name chars
         * we have to consider
         */
        int count = 1;
        while (true) {
            c = (mInputPtr < mInputEnd) ?
                mInputBuffer[mInputPtr++] : getNextChar(SUFFIX_EOF_EXP_NAME);
            if (c != ':' && !isNameChar(c)) {
                break;
            }
            ++count;
        }
        return count;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseSystemId,,46,141,72,5,0.164,0.1608,0,6,12,0,1,"/**
     * Simple parsing method that parses system ids, which are generally
     * used in entities (from DOCTYPE declaration to internal/external
     * subsets).
     *<p>
     * NOTE: returned String is not canonicalized, on assumption that
     * external ids may be longish, and are not shared all that often, as
     * they are generally just used for resolving paths, if anything.
     *<br />
     * Also note that this method is not heavily optimized, as it's not
     * likely to be a bottleneck for parsing.
     */
    protected final String parseSystemId(char quoteChar, boolean convertLFs,
                                         String errorMsg)
        throws XMLStreamException
    {
        char[] buf = getNameBuffer(-1);
        int ptr = 0;

        while (true) {
            char c = (mInputPtr < mInputEnd) ?
                mInputBuffer[mInputPtr++] : getNextChar(errorMsg);
            if (c == quoteChar) {
                break;
            }
            /* ??? 14-Jun-2004, TSa: Should we normalize linefeeds or not?
             *   It seems like we should, for all input... so that's the way it
             *   works.
             */
            if (c == '\n') {
                markLF();
            } else if (c == '\r') {
                if (peekNext() == '\n') {
                    ++mInputPtr;
                    if (!convertLFs) {
                        /* The only tricky thing; need to preserve 2-char LF; need to
                         * output one char from here, then can fall back to default:
                         */
                        if (ptr >= buf.length) {
                            buf = expandBy50Pct(buf);
                        }
                        buf[ptr++] = '\r';
                    }
                    c = '\n';
                } else if (convertLFs) {
                    c = '\n';
                }
            }

            // Other than that, let's just append it:
            if (ptr >= buf.length) {
                buf = expandBy50Pct(buf);
            }
            buf[ptr++] = c;
        }

        return (ptr == 0) ? """" : new String(buf, 0, ptr);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parsePublicId,,62,248,145,5,0.1197,0.1517,0,6,16,0,1,"/**
     * Simple parsing method that parses system ids, which are generally
     * used in entities (from DOCTYPE declaration to internal/external
     * subsets).
     *<p>
     * As per xml specs, the contents are actually normalized.
     *<p>
     * NOTE: returned String is not canonicalized, on assumption that
     * external ids may be longish, and are not shared all that often, as
     * they are generally just used for resolving paths, if anything.
     *<br />
     * Also note that this method is not heavily optimized, as it's not
     * likely to be a bottleneck for parsing.
     */
    protected final String parsePublicId(char quoteChar, String errorMsg)
        throws XMLStreamException
    {
        char[] buf = getNameBuffer(-1);
        int ptr = 0;
        boolean spaceToAdd = false;

        while (true) {
            char c = (mInputPtr < mInputEnd) ?
                mInputBuffer[mInputPtr++] : getNextChar(errorMsg);
            if (c == quoteChar) {
                break;
            }
            if (c == '\n') {
                markLF();
                spaceToAdd = true;
                continue;
            } else if (c == '\r') {
                if (peekNext() == '\n') {
                    ++mInputPtr;
                }
                spaceToAdd = true;
                continue;
            } else if (c == CHAR_SPACE) {
                spaceToAdd = true;
                continue;
            } else {
                // Verify it's a legal pubid char (see XML spec, #13, from 2.3)
                if ((c >= VALID_PUBID_CHAR_COUNT)
                    || sPubidValidity[c] != PUBID_CHAR_VALID_B) {
                    throwUnexpectedChar(c, "" in public identifier"");
                }
            }
        
            // Other than that, let's just append it:
            if (ptr >= buf.length) {
                buf = expandBy50Pct(buf);
            }
            /* Space-normalization means scrapping leading and trailing
             * white space, and coalescing remaining ws into single spaces.
             */
            if (spaceToAdd) { // pending white space to add?
                if (c == CHAR_SPACE) { // still a space; let's skip
                    continue;
                }
                /* ok: if we have non-space, we'll either forget about
                 * space(s) (if nothing has been output, ie. leading space),
                 * or output a single space (in-between non-white space)
                 */
                spaceToAdd = false;
                if (ptr > 0) {
                    buf[ptr++] = CHAR_SPACE;
                    if (ptr >= buf.length) {
                        buf = expandBy50Pct(buf);
                    }
                }
            }
            buf[ptr++] = c;
        }
      
        return (ptr == 0) ? """" : new String(buf, 0, ptr);
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,parseUntil,,67,599,337,4,0.1365,0.1116,0,12,16,0,1,"protected final void parseUntil(TextBuffer tb, char endChar, boolean convertLFs,
                                    String errorMsg)
        throws XMLStreamException
    {
        // Let's first ensure we have some data in there...
        if (mInputPtr >= mInputEnd) {
            loadMore(errorMsg);
        }
        while (true) {
            // Let's loop consequtive 'easy' spans:
            char[] inputBuf = mInputBuffer;
            int inputLen = mInputEnd;
            int ptr = mInputPtr;
            int startPtr = ptr;
            while (ptr < inputLen) {
                char c = inputBuf[ptr++];
                if (c == endChar) {
                    int thisLen = ptr - startPtr - 1;
                    if (thisLen > 0) {
                        tb.append(inputBuf, startPtr, thisLen);
                    }
                    mInputPtr = ptr;
                    return;
                }
                if (c == '\n') {
                    mInputPtr = ptr; // markLF() requires this
                    markLF();
                } else if (c == '\r') {
                    if (!convertLFs && ptr < inputLen) {
                        if (inputBuf[ptr] == '\n') {
                            ++ptr;
                        }
                        mInputPtr = ptr;
                        markLF();
                    } else {
                        int thisLen = ptr - startPtr - 1;
                        if (thisLen > 0) {
                            tb.append(inputBuf, startPtr, thisLen);
                        }
                        mInputPtr = ptr;
                        c = getNextChar(errorMsg);
                        if (c != '\n') {
                            --mInputPtr; // pusback
                            tb.append(convertLFs ? '\n' : '\r');
                        } else {
                            if (convertLFs) {
                                tb.append('\n');
                            } else {
                                tb.append('\r');
                                tb.append('\n');
                            }
                        }
                        startPtr = ptr = mInputPtr;
                        markLF();
                    }
                }
            }
            int thisLen = ptr - startPtr;
            if (thisLen > 0) {
                tb.append(inputBuf, startPtr, thisLen);
            }
            loadMore(errorMsg);
            startPtr = ptr = mInputPtr;
            inputBuf = mInputBuffer;
            inputLen = mInputEnd;
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,resolveCharEnt,,58,190,0,4,0.2444,0.3078,0,3,21,0,1,"/*
    ///////////////////////////////////////////////////////////
    // Internal methods
    ///////////////////////////////////////////////////////////
     */

    private int resolveCharEnt(StringBuffer originalCharacters)
        throws XMLStreamException
    {
        int value = 0;
        char c = getNextChar(SUFFIX_IN_ENTITY_REF);
        
        if (originalCharacters != null) {
            originalCharacters.append(c);
        }
        
        if (c == 'x') { // hex
            while (true) {
                c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++]
                    : getNextCharFromCurrent(SUFFIX_IN_ENTITY_REF);
                if (c == ';') {
                    break;
                }
                
                if (originalCharacters != null) {
                    originalCharacters.append(c);
                }
                value = value << 4;
                if (c <= '9' && c >= '0') {
                    value += (c - '0');
                } else if (c >= 'a' && c <= 'f') {
                    value += 10 + (c - 'a');
                } else if (c >= 'A' && c <= 'F') {
                    value += 10 + (c - 'A');
                } else {
                    throwUnexpectedChar(c, ""; expected a hex digit (0-9a-fA-F)."");
                }
                // Overflow?
                if (value > MAX_UNICODE_CHAR) {
                    reportUnicodeOverflow();
                }
            }
        } else { // numeric (decimal)
            while (c != ';') {
                if (c <= '9' && c >= '0') {
                    value = (value * 10) + (c - '0');
                    // Overflow?
                    if (value > MAX_UNICODE_CHAR) {
                        reportUnicodeOverflow();
                    }
                } else {
                    throwUnexpectedChar(c, ""; expected a decimal number."");
                }
                c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++]
                    : getNextCharFromCurrent(SUFFIX_IN_ENTITY_REF);
                
                if (originalCharacters != null && c != ';') {
                    originalCharacters.append(c);
                }
            }
        }
        validateChar(value);
        return value;
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,validateChar,,32,33,0,4,0.3654,0.36,0,1,13,0,1,"/**
     * Method that will verify that expanded Unicode codepoint is a valid
     * XML content character.
     */
    private final void validateChar(int value)
        throws XMLStreamException
    {
        /* 24-Jan-2006, TSa: Ok, ""high"" Unicode chars are problematic,
         *   need to be reported by a surrogate pair..
         */
        if (value >= 0xD800) {
            if (value < 0xE000) { // no surrogates via entity expansion
                reportIllegalChar(value);
            }
            if (value > 0xFFFF) {
                // Within valid range at all?
                if (value > MAX_UNICODE_CHAR) {
                    reportUnicodeOverflow();
                }
            } else if (value >= 0xFFFE) { // 0xFFFE and 0xFFFF are illegal too
                reportIllegalChar(value);
            }
            // Ok, fine as is
        } else if (value < 32) {
            if (value == 0) {
                throwParseError(""Invalid character reference: null character not allowed in XML content."");
            }
            // XML 1.1 allows most other chars; 1.0 does not:
            if (!mXml10AllowAllEscapedChars) {
                if (!mXml11 &&
                    (value != 0x9 && value != 0xA && value != 0xD)) {
                    reportIllegalChar(value);
                }
            }
        }
    }"
davmail-4.5.1,com.ctc.wstx.sr.StreamScanner,expandBy50Pct,,7,11,7,3,0.3333,0.1429,0,3,1,0,1,"protected final char[] expandBy50Pct(char[] buf)
    {
        int len = buf.length;
        char[] newBuf = new char[len + (len >> 1)];
        System.arraycopy(buf, 0, newBuf, 0, len);
        return newBuf;
    }"
davmail-4.5.1,davmail.DavGateway,start,,67,422,348,2,0.0848,0.0557,0.764705882,13,15,1,1,"/**
     * Start DavMail listeners.
     */
    public static void start() {
        // register custom SSL Socket factory
        DavGatewaySSLProtocolSocketFactory.register();

        // prepare HTTP connection pool
        DavGatewayHttpClientFacade.start();

        SERVER_LIST.clear();

        int smtpPort = Settings.getIntProperty(""davmail.smtpPort"");
        if (smtpPort != 0) {
            SERVER_LIST.add(new SmtpServer(smtpPort));
        }
        int popPort = Settings.getIntProperty(""davmail.popPort"");
        if (popPort != 0) {
            SERVER_LIST.add(new PopServer(popPort));
        }
        int imapPort = Settings.getIntProperty(""davmail.imapPort"");
        if (imapPort != 0) {
            SERVER_LIST.add(new ImapServer(imapPort));
        }
        int caldavPort = Settings.getIntProperty(""davmail.caldavPort"");
        if (caldavPort != 0) {
            SERVER_LIST.add(new CaldavServer(caldavPort));
        }
        int ldapPort = Settings.getIntProperty(""davmail.ldapPort"");
        if (ldapPort != 0) {
            SERVER_LIST.add(new LdapServer(ldapPort));
        }

        BundleMessage.BundleMessageList messages = new BundleMessage.BundleMessageList();
        BundleMessage.BundleMessageList errorMessages = new BundleMessage.BundleMessageList();
        for (AbstractServer server : SERVER_LIST) {
            try {
                server.bind();
                server.start();
                messages.add(new BundleMessage(""LOG_PROTOCOL_PORT"", server.getProtocolName(), server.getPort()));
            } catch (DavMailException e) {
                errorMessages.add(e.getBundleMessage());
            } catch (IOException e) {
                errorMessages.add(new BundleMessage(""LOG_SOCKET_BIND_FAILED"", server.getProtocolName(), server.getPort()));
            }
        }

        final String currentVersion = getCurrentVersion();
        boolean showStartupBanner = Settings.getBooleanProperty(""davmail.showStartupBanner"", true);
        if (showStartupBanner) {
            DavGatewayTray.info(new BundleMessage(""LOG_DAVMAIL_GATEWAY_LISTENING"",
                    currentVersion == null ? """" : currentVersion, messages));
        }
        if (!errorMessages.isEmpty()) {
            DavGatewayTray.error(new BundleMessage(""LOG_MESSAGE"", errorMessages));
        }

        // check for new version in a separate thread
        new Thread(""CheckRelease"") {
            @Override
            public void run() {
                String releasedVersion = getReleasedVersion();
                if (currentVersion != null && currentVersion.length() > 0 && releasedVersion != null && currentVersion.compareTo(releasedVersion) < 0) {
                    DavGatewayTray.info(new BundleMessage(""LOG_NEW_VERSION_AVAILABLE"", releasedVersion));
                }

            }
        }.start();

    }"
davmail-4.5.1,davmail.DavGateway,stop,,9,20,19,6,0.1786,0.05,0.8,0,1,0,1,"/**
     * Stop all listeners, shutdown connection pool and clear session cache.
     */
    public static void stop() {
        DavGateway.stopServers();
        // close pooled connections
        DavGatewayHttpClientFacade.stop();
        // clear session cache
        ExchangeSessionFactory.reset();
        DavGatewayTray.info(new BundleMessage(""LOG_GATEWAY_STOP""));
        DavGatewayTray.dispose();
    }"
davmail-4.5.1,davmail.DavGateway,stopServers,,10,17,13,4,0.25,0.125,1,2,3,0,1,"private static void stopServers() {
        for (AbstractServer server : SERVER_LIST) {
            server.close();
            try {
                server.join();
            } catch (InterruptedException e) {
                DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_WAITING_SERVER_THREAD_DIE""), e);
            }
        }
    }"
davmail-4.5.1,davmail.Settings,load,,31,149,127,8,0.1429,0.0895,0.666666667,4,6,0,1,"/**
     * Load properties from current file path (command line or default).
     */
    public static synchronized void load() {
        FileInputStream fileInputStream = null;
        try {
            if (configFilePath == null) {
                //noinspection AccessOfSystemProperties
                configFilePath = System.getProperty(""user.home"") + ""/.davmail.properties"";
            }
            File configFile = new File(configFilePath);
            if (configFile.exists()) {
                fileInputStream = new FileInputStream(configFile);
                load(fileInputStream);
            } else {
                isFirstStart = true;

                // first start : set default values, ports above 1024 for unix/linux
                setDefaultSettings();
                save();
            }
        } catch (IOException e) {
            DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_LOAD_SETTINGS""), e);
        } finally {
            if (fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    DavGatewayTray.debug(new BundleMessage(""LOG_ERROR_CLOSING_CONFIG_FILE""), e);
                }
            }
        }
        updateLoggingConfig();
    }"
davmail-4.5.1,davmail.Settings,updateLoggingConfig,,59,564,425,7,0.1075,0.1112,1,7,13,0,1,"/**
     * Update Log4J config from settings.
     */
    public static void updateLoggingConfig() {
        String logFilePath = getLogFilePath();

        try {
            if (logFilePath != null && logFilePath.length() > 0) {
                File logFile = new File(logFilePath);
                // create parent directory if needed
                File logFileDir = logFile.getParentFile();
                if (logFileDir != null && !logFileDir.exists()) {
                    if (!logFileDir.mkdirs()) {
                        DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_CREATE_LOG_FILE_DIR""));
                        throw new IOException();
                    }
                }
            } else {
                logFilePath = ""davmail.log"";
            }
            synchronized (Logger.getRootLogger()) {
                // Build file appender
                FileAppender fileAppender = (FileAppender) Logger.getRootLogger().getAppender(""FileAppender"");
                if (fileAppender == null) {
                    String logFileSize = Settings.getProperty(""davmail.logFileSize"");
                    if (logFileSize == null || logFileSize.length() == 0) {
                        logFileSize = ""1MB"";
                    }
                    // set log file size to 0 to use an external rotation mechanism, e.g. logrotate
                    if (""0"".equals(logFileSize)) {
                        fileAppender = new FileAppender();
                    } else {
                        fileAppender = new RollingFileAppender();
                        ((RollingFileAppender) fileAppender).setMaxBackupIndex(2);
                        ((RollingFileAppender) fileAppender).setMaxFileSize(logFileSize);
                    }
                    fileAppender.setName(""FileAppender"");
                    fileAppender.setEncoding(""UTF-8"");
                    fileAppender.setLayout(new PatternLayout(""%d{ISO8601} %-5p [%t] %c %x - %m%n""));
                }
                fileAppender.setFile(logFilePath, true, false, 8192);
                Logger.getRootLogger().addAppender(fileAppender);
            }

            // disable ConsoleAppender in gui mode
            if (!Settings.getBooleanProperty(""davmail.server"")) {
                ConsoleAppender consoleAppender = (ConsoleAppender) Logger.getRootLogger().getAppender(""ConsoleAppender"");
                if (consoleAppender != null) {
                    consoleAppender.setThreshold(Level.OFF);
                }
            }

        } catch (IOException e) {
            DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_SET_LOG_FILE_PATH""));
        }

        // update logging levels
        Settings.setLoggingLevel(""rootLogger"", Settings.getLoggingLevel(""rootLogger""));
        Settings.setLoggingLevel(""davmail"", Settings.getLoggingLevel(""davmail""));
        Settings.setLoggingLevel(""httpclient.wire"", Settings.getLoggingLevel(""httpclient.wire""));
        Settings.setLoggingLevel(""org.apache.commons.httpclient"", Settings.getLoggingLevel(""org.apache.commons.httpclient""));
    }"
davmail-4.5.1,davmail.Settings,save,,21,48,30,4,0.2222,0.15,0.666666667,3,5,0,1,"/**
     * Save settings in current file path (command line or default).
     */
    public static synchronized void save() {
        // configFilePath is null in some test cases
        if (configFilePath != null) {
            FileOutputStream fileOutputStream = null;
            try {
                fileOutputStream = new FileOutputStream(configFilePath);
                SETTINGS.store(fileOutputStream, ""DavMail settings"");
            } catch (IOException e) {
                DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_STORE_SETTINGS""), e);
            } finally {
                if (fileOutputStream != null) {
                    try {
                        fileOutputStream.close();
                    } catch (IOException e) {
                        DavGatewayTray.debug(new BundleMessage(""LOG_ERROR_CLOSING_CONFIG_FILE""), e);
                    }
                }
            }
        }
        updateLoggingConfig();
    }"
davmail-4.5.1,davmail.AbstractServer,AbstractServer,,9,18,15,5,0.25,0.0833,0,5,2,0,1,"/**
     * Create a ServerSocket to listen for connections.
     * Start the thread.
     *
     * @param name        thread name
     * @param port        tcp socket chosen port
     * @param defaultPort tcp socket default port
     */
    public AbstractServer(String name, int port, int defaultPort) {
        super(name);
        setDaemon(true);
        if (port == 0) {
            this.port = defaultPort;
        } else {
            this.port = port;
        }
    }"
davmail-4.5.1,davmail.AbstractServer,bind,,56,347,288,5,0.0887,0.054,0.8,11,13,1,1,"/**
     * Bind server socket on defined port.
     *
     * @throws DavMailException unable to create server socket
     */
    public void bind() throws DavMailException {
        String bindAddress = Settings.getProperty(""davmail.bindAddress"");
        String keystoreFile = Settings.getProperty(""davmail.ssl.keystoreFile"");

        ServerSocketFactory serverSocketFactory;
        if (keystoreFile == null || keystoreFile.length() == 0 || nosslFlag) {
            serverSocketFactory = ServerSocketFactory.getDefault();
        } else {
            FileInputStream keyStoreInputStream = null;
            try {
                keyStoreInputStream = new FileInputStream(keystoreFile);
                // keystore for keys and certificates
                // keystore and private keys should be password protected...
                KeyStore keystore = KeyStore.getInstance(Settings.getProperty(""davmail.ssl.keystoreType""));
                keystore.load(keyStoreInputStream, Settings.getCharArrayProperty(""davmail.ssl.keystorePass""));

                // KeyManagerFactory to create key managers
                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());

                // initialize KMF to work with keystore
                kmf.init(keystore, Settings.getCharArrayProperty(""davmail.ssl.keyPass""));

                // SSLContext is environment for implementing JSSE...
                // create ServerSocketFactory
                SSLContext sslContext = SSLContext.getInstance(""SSLv3"");

                // initialize sslContext to work with key managers
                sslContext.init(kmf.getKeyManagers(), null, null);

                // create ServerSocketFactory from sslContext
                serverSocketFactory = sslContext.getServerSocketFactory();
            } catch (IOException ex) {
                throw new DavMailException(""LOG_EXCEPTION_CREATING_SSL_SERVER_SOCKET"", getProtocolName(), port, ex.getMessage() == null ? ex.toString() : ex.getMessage());
            } catch (GeneralSecurityException ex) {
                throw new DavMailException(""LOG_EXCEPTION_CREATING_SSL_SERVER_SOCKET"", getProtocolName(), port, ex.getMessage() == null ? ex.toString() : ex.getMessage());
            } finally {
                if (keyStoreInputStream != null) {
                    try {
                        keyStoreInputStream.close();
                    } catch (IOException exc) {
                        DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_CLOSING_KEYSTORE_INPUT_STREAM""), exc);
                    }
                }
            }
        }
        try {
            // create the server socket
            if (bindAddress == null || bindAddress.length() == 0) {
                serverSocket = serverSocketFactory.createServerSocket(port);
            } else {
                serverSocket = serverSocketFactory.createServerSocket(port, 0, Inet4Address.getByName(bindAddress));
            }
        } catch (IOException e) {
            throw new DavMailException(""LOG_SOCKET_BIND_FAILED"", getProtocolName(), port);
        }
    }"
davmail-4.5.1,davmail.AbstractServer,run,,39,152,94,3,0.1837,0.1595,0.666666667,4,9,0,1,"/**
     * The body of the server thread.  Loop forever, listening for and
     * accepting connections from clients.  For each connection,
     * create a Connection object to handle communication through the
     * new Socket.
     */
    @Override
    public void run() {
        Socket clientSocket = null;
        AbstractConnection connection = null;
        try {
            //noinspection InfiniteLoopStatement
            while (true) {
                clientSocket = serverSocket.accept();
                // set default timeout to 5 minutes
                clientSocket.setSoTimeout(Settings.getIntProperty(""davmail.clientSoTimeout"", 300)*1000);
                DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_FROM"", clientSocket.getInetAddress(), port));
                // only accept localhost connections for security reasons
                if (Settings.getBooleanProperty(""davmail.allowRemote"") ||
                        clientSocket.getInetAddress().isLoopbackAddress()) {
                    connection = createConnectionHandler(clientSocket);
                    connection.start();
                } else {
                    clientSocket.close();
                    DavGatewayTray.warn(new BundleMessage(""LOG_EXTERNAL_CONNECTION_REFUSED""));
                }
            }
        } catch (IOException e) {
            // do not warn if exception on socket close (gateway restart)
            if (!serverSocket.isClosed()) {
                DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_LISTENING_FOR_CONNECTIONS""), e);
            }
        } finally {
            try {
                if (clientSocket != null) {
                    clientSocket.close();
                }
            } catch (IOException e) {
                DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_CLOSING_CLIENT_SOCKET""), e);
            }
            if (connection != null) {
                connection.close();
            }
        }
    }"
davmail-4.5.1,davmail.AbstractServer,close,,9,13,11,4,0.2778,0.1071,1,1,3,0,1,"/**
     * Close server socket
     */
    public void close() {
        try {
            if (serverSocket != null) {
                serverSocket.close();
            }
        } catch (IOException e) {
            DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_CLOSING_SERVER_SOCKET""), e);
        }
    }"
davmail-4.5.1,davmail.AbstractConnection,AbstractConnection,,11,31,26,5,0.1556,0.0439,1,5,2,0,1,"/**
     * Initialize the streams and set thread name.
     *
     * @param name         thread type name
     * @param clientSocket client socket
     * @param encoding     socket stream encoding
     */
    public AbstractConnection(String name, Socket clientSocket, String encoding) {
        super(name + '-' + clientSocket.getPort());
        this.client = clientSocket;
        try {
            in = new LineReaderInputStream(client.getInputStream(), encoding);
            os = new BufferedOutputStream(client.getOutputStream());
        } catch (IOException e) {
            close();
            DavGatewayTray.error(new BundleMessage(""LOG_EXCEPTION_GETTING_SOCKET_STREAMS""), e);
        }
    }"
davmail-4.5.1,davmail.AbstractConnection,sendClient,,12,29,13,3,0.25,0.1439,1,2,2,0,1,"/**
     * Send prefix and message to client followed by CRLF.
     *
     * @param prefix  prefix
     * @param message message
     * @throws IOException on error
     */
    public void sendClient(String prefix, String message) throws IOException {
        if (prefix != null) {
            os.write(prefix.getBytes(""UTF-8""));
            DavGatewayTray.debug(new BundleMessage(""LOG_SEND_CLIENT_PREFIX_MESSAGE"", prefix, message));
        } else {
            DavGatewayTray.debug(new BundleMessage(""LOG_SEND_CLIENT_MESSAGE"", message));
        }
        os.write(message.getBytes(""UTF-8""));
        os.write((char) 13);
        os.write((char) 10);
        os.flush();
    }"
davmail-4.5.1,davmail.AbstractConnection,readClient,,26,62,19,3,0.2267,0.3109,0.75,1,10,0,1,"/**
     * Read a line from the client connection.
     * Log message to logger
     *
     * @return command line or null
     * @throws IOException when unable to read line
     */
    public String readClient() throws IOException {
        String line = in.readLine();
        if (line != null) {
            if (line.startsWith(""PASS"")) {
                DavGatewayTray.debug(new BundleMessage(""LOG_READ_CLIENT_PASS""));
                // SMTP LOGIN
            } else if (line.startsWith(""AUTH LOGIN "")) {
                DavGatewayTray.debug(new BundleMessage(""LOG_READ_CLIENT_AUTH_LOGIN""));
                // IMAP LOGIN
            } else if (state == State.INITIAL && line.indexOf(' ') >= 0 &&
                    line.substring(line.indexOf(' ') + 1).toUpperCase().startsWith(""LOGIN"")) {
                DavGatewayTray.debug(new BundleMessage(""LOG_READ_CLIENT_LOGIN""));
            } else if (state == State.PASSWORD) {
                DavGatewayTray.debug(new BundleMessage(""LOG_READ_CLIENT_PASSWORD""));
                // HTTP Basic Authentication
            } else if (line.startsWith(""Authorization:"")) {
                DavGatewayTray.debug(new BundleMessage(""LOG_READ_CLIENT_AUTHORIZATION""));
            } else if (line.startsWith(""AUTH PLAIN"")) {
                DavGatewayTray.debug(new BundleMessage(""LOG_READ_CLIENT_AUTH_PLAIN""));
            } else {
                DavGatewayTray.debug(new BundleMessage(""LOG_READ_CLIENT_LINE"", line));
            }
        }
        DavGatewayTray.switchIcon();
        return line;
    }"
davmail-4.5.1,davmail.AbstractConnection,close,,21,61,44,6,0.2154,0.1623,1,3,6,0,1,"/**
     * Close client connection, streams and Exchange session .
     */
    public void close() {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e2) {
                DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_CLOSING_CLIENT_INPUT_STREAM""), e2);
            }
        }
        if (os != null) {
            try {
                os.close();
            } catch (IOException e2) {
                DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_CLOSING_CLIENT_OUTPUT_STREAM""), e2);
            }
        }
        try {
            client.close();
        } catch (IOException e2) {
            DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_CLOSING_CLIENT_SOCKET""), e2);
        }
    }"
davmail-4.5.1,davmail.BundleMessage,format,,27,77,1,3,0.2222,0.2371,1,7,9,0,1,"/**
     * Get formatted message for message key and values with the given locale.
     *
     * @param locale    resource bundle locale
     * @param key       message key in resource bundle
     * @param arguments message values
     * @return formatted message
     */
    public static String format(Locale locale, String key, Object... arguments) {
        Object[] formattedArguments = null;
        if (arguments != null) {
            formattedArguments = new Object[arguments.length];
            for (int i = 0; i < arguments.length; i++) {
                if (arguments[i] instanceof BundleMessage) {
                    formattedArguments[i] = ((BundleMessage) arguments[i]).format(locale);
                } else if (arguments[i] instanceof BundleMessageList) {
                    StringBuilder buffer = new StringBuilder();
                    for (BundleMessage bundleMessage : (BundleMessageList) arguments[i]) {
                        buffer.append(bundleMessage.format(locale));
                    }
                    formattedArguments[i] = buffer.toString();
                } else if (arguments[i] instanceof DavMailException) {
                    formattedArguments[i] = ((DavMailException) arguments[i]).getMessage(locale);
                } else if (arguments[i] instanceof Throwable) {
                    formattedArguments[i] = ((Throwable) arguments[i]).getMessage();
                    if (formattedArguments[i] == null) {
                        formattedArguments[i] = arguments[i].toString();
                    }
                } else {
                    formattedArguments[i] = arguments[i];
                }
            }
        }
        return MessageFormat.format(getBundle(locale).getString(key), formattedArguments);
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,encodePath,,7,9,8,4,0.3,0.0741,1,2,2,0,1,"static String encodePath(CaldavRequest request, String path) throws URIException {
        if (request.isIcal5()) {
            return URIUtil.encode(path, ical_allowed_abs_path, ""UTF-8"");
        } else {
            return URIUtil.encodePath(path, ""UTF-8"");
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,parseHeaders,,13,40,25,4,0.2364,0.1304,1,3,4,0,1,"protected Map<String, String> parseHeaders() throws IOException {
        HashMap<String, String> headers = new HashMap<String, String>();
        String line;
        while ((line = readClient()) != null && line.length() > 0) {
            int index = line.indexOf(':');
            if (index <= 0) {
                wireLogger.warn(""Invalid header: "" + line);
                throw new DavMailException(""EXCEPTION_INVALID_HEADER"");
            }
            headers.put(line.substring(0, index).toLowerCase(), line.substring(index + 1).trim());
        }
        return headers;
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,run,,62,697,614,10,0.0637,0.0677,0.7,12,12,0,1,"@Override
    public void run() {
        String line;
        StringTokenizer tokens;

        try {
            while (!closed) {
                line = readClient();
                // unable to read line, connection closed ?
                if (line == null) {
                    break;
                }
                tokens = new StringTokenizer(line);
                String command = tokens.nextToken();
                Map<String, String> headers = parseHeaders();
                String encodedPath = StringUtil.encodePlusSign(tokens.nextToken());
                String path = URIUtil.decode(encodedPath);
                String content = getContent(headers.get(""content-length""));
                setSocketTimeout(headers.get(""keep-alive""));
                // client requested connection close
                closed = ""close"".equals(headers.get(""connection""));
                if (""OPTIONS"".equals(command)) {
                    sendOptions();
                } else if (!headers.containsKey(""authorization"")) {
                    sendUnauthorized();
                } else {
                    decodeCredentials(headers.get(""authorization""));
                    // need to check session on each request, credentials may have changed or session expired
                    try {
                        session = ExchangeSessionFactory.getInstance(userName, password);
                        handleRequest(command, path, headers, content);
                    } catch (DavMailAuthenticationException e) {
                        if (Settings.getBooleanProperty(""davmail.enableKerberos"")) {
                            // authentication failed in Kerberos mode => not available
                            throw new HttpServerErrorException(""Kerberos authentication failed"");
                        } else {
                            sendUnauthorized();
                        }
                    }
                }

                os.flush();
                DavGatewayTray.resetIcon();
            }
        } catch (SocketTimeoutException e) {
            DavGatewayTray.debug(new BundleMessage(""LOG_CLOSE_CONNECTION_ON_TIMEOUT""));
        } catch (SocketException e) {
            DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
        } catch (Exception e) {
            if (!(e instanceof HttpNotFoundException)) {
                DavGatewayTray.log(e);
            }
            try {
                sendErr(e);
            } catch (IOException e2) {
                DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
            }
        } finally {
            close();
        }
        DavGatewayTray.resetIcon();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,handleRequest,,26,65,10,6,0.1875,0.4273,0.142857143,5,13,0,1,"/**
     * Handle caldav request.
     *
     * @param command Http command
     * @param path    request path
     * @param headers Http headers map
     * @param body    request body
     * @throws IOException on error
     */
    public void handleRequest(String command, String path, Map<String, String> headers, String body) throws IOException {
        CaldavRequest request = new CaldavRequest(command, path, headers, body);
        if (request.isOptions()) {
            sendOptions();
        } else if (request.isPropFind() && request.isRoot()) {
            sendRoot(request);
        } else if (request.isGet() && request.isRoot()) {
            sendGetRoot();
        } else if (request.isPath(1, ""principals"")) {
            handlePrincipals(request);
        } else if (request.isPath(1, ""users"")) {
            if (request.isPropFind() && request.isPathLength(3)) {
                sendUserRoot(request);
            } else {
                handleFolderOrItem(request);
            }
        } else if (request.isPath(1, ""public"")) {
            handleFolderOrItem(request);
        } else if (request.isPath(1, ""directory"")) {
            sendDirectory(request);
        } else if (request.isPath(1, "".well-known"")) {
            sendWellKnown();
        } else {
            sendUnsupported(request);
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,handlePrincipals,,23,34,0,3,0.2714,0.3611,0.25,3,10,0,1,"protected void handlePrincipals(CaldavRequest request) throws IOException {
        if (request.isPath(2, ""users"")) {
            if (request.isPropFind() && request.isPathLength(4)) {
                sendPrincipal(request, ""users"", URIUtil.decode(request.getPathElement(3)));
                // send back principal on search
            } else if (request.isReport() && request.isPathLength(3)) {
                sendPrincipal(request, ""users"", session.getEmail());
                // iCal current-user-principal request
            } else if (request.isPropFind() && request.isPathLength(3)) {
                sendPrincipalsFolder(request);
            } else {
                sendUnsupported(request);
            }
        } else if (request.isPath(2, ""public"")) {
            StringBuilder prefixBuffer = new StringBuilder(""public"");
            for (int i = 3; i < request.getPathLength() - 1; i++) {
                prefixBuffer.append('/').append(request.getPathElement(i));
            }
            sendPrincipal(request, URIUtil.decode(prefixBuffer.toString()), URIUtil.decode(request.getLastPath()));
        } else {
            sendUnsupported(request);
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,handleFolderOrItem,,101,1411,869,3,0.0726,0.1218,0.210526316,21,27,0,1,"protected void handleFolderOrItem(CaldavRequest request) throws IOException {
        String lastPath = StringUtil.xmlDecode(request.getLastPath());
        // folder requests
        if (request.isPropFind() && ""inbox"".equals(lastPath)) {
            sendInbox(request);
        } else if (request.isPropFind() && ""outbox"".equals(lastPath)) {
            sendOutbox(request);
        } else if (request.isPost() && ""outbox"".equals(lastPath)) {
            if (request.isFreeBusy()) {
                sendFreeBusy(request.getBody());
            } else {
                int status = session.sendEvent(request.getBody());
                // TODO: implement Itip response body
                sendHttpResponse(status);
            }
        } else if (request.isPropFind()) {
            sendFolderOrItem(request);
        } else if (request.isPropPatch()) {
            patchCalendar(request);
        } else if (request.isReport()) {
            reportItems(request);
            // event requests
        } else if (request.isPut()) {
            String etag = request.getHeader(""if-match"");
            String noneMatch = request.getHeader(""if-none-match"");
            ExchangeSession.ItemResult itemResult = session.createOrUpdateItem(request.getFolderPath(), lastPath, request.getBody(), etag, noneMatch);
            sendHttpResponse(itemResult.status, buildEtagHeader(itemResult.etag), null, """", true);

        } else if (request.isDelete()) {
            if (request.getFolderPath().endsWith(""inbox"")) {
                session.processItem(request.getFolderPath(), lastPath);
            } else {
                session.deleteItem(request.getFolderPath(), lastPath);
            }
            sendHttpResponse(HttpStatus.SC_OK);
        } else if (request.isGet()) {
            if (request.path.endsWith(""/"")) {
                // GET request on a folder => build ics content of all folder events
                String folderPath = request.getFolderPath();
                ExchangeSession.Folder folder = session.getFolder(folderPath);
                if (folder.isContact()) {
                    List<ExchangeSession.Contact> contacts = session.getAllContacts(folderPath);
                    ChunkedResponse response = new ChunkedResponse(HttpStatus.SC_OK, ""text/vcard;charset=UTF-8"");

                    for (ExchangeSession.Contact contact : contacts) {
                        String contactBody = contact.getBody();
                        if (contactBody != null) {
                            response.append(contactBody);
                            response.append(""\n"");
                        }
                    }
                    response.close();

                } else if (folder.isCalendar() || folder.isTask()) {
                    List<ExchangeSession.Event> events = session.getAllEvents(folderPath);
                    ChunkedResponse response = new ChunkedResponse(HttpStatus.SC_OK, ""text/calendar;charset=UTF-8"");
                    response.append(""BEGIN:VCALENDAR\r\n"");
                    response.append(""VERSION:2.0\r\n"");
                    response.append(""PRODID:-//davmail.sf.net/NONSGML DavMail Calendar V1.1//EN\r\n"");
                    response.append(""METHOD:PUBLISH\r\n"");

                    for (ExchangeSession.Event event : events) {
                        String icsContent = StringUtil.getToken(event.getBody(), ""BEGIN:VTIMEZONE"", ""END:VCALENDAR"");
                        if (icsContent != null) {
                            response.append(""BEGIN:VTIMEZONE"");
                            response.append(icsContent);
                        } else {
                            icsContent = StringUtil.getToken(event.getBody(), ""BEGIN:VEVENT"", ""END:VCALENDAR"");
                            if (icsContent != null) {
                                response.append(""BEGIN:VEVENT"");
                                response.append(icsContent);
                            }
                        }
                    }
                    response.append(""END:VCALENDAR"");
                    response.close();
                } else {
                    sendHttpResponse(HttpStatus.SC_OK, buildEtagHeader(folder.etag), ""text/html"", (byte[]) null, true);
                }
            } else {
                ExchangeSession.Item item = session.getItem(request.getFolderPath(), lastPath);
                sendHttpResponse(HttpStatus.SC_OK, buildEtagHeader(item.getEtag()), item.getContentType(), item.getBody(), true);
            }
        } else if (request.isHead()) {
            // test event
            ExchangeSession.Item item = session.getItem(request.getFolderPath(), lastPath);
            sendHttpResponse(HttpStatus.SC_OK, buildEtagHeader(item.getEtag()), item.getContentType(), (byte[]) null, true);
        } else if (request.isMkCalendar()) {
            HashMap<String, String> properties = new HashMap<String, String>();
            //properties.put(""displayname"", request.getProperty(""displayname""));
            int status = session.createCalendarFolder(request.getFolderPath(), properties);
            sendHttpResponse(status, null);
        } else if (request.isMove()) {
            String destinationUrl = request.getHeader(""destination"");
            session.moveItem(request.path, URIUtil.decode(new URL(destinationUrl).getPath()));
            sendHttpResponse(HttpStatus.SC_CREATED, null);
        } else {
            sendUnsupported(request);
        }

    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,buildEtagHeader,,9,11,7,3,0.4167,0.1786,0,2,2,0,1,"protected HashMap<String, String> buildEtagHeader(String etag) {
        if (etag != null) {
            HashMap<String, String> etagHeader = new HashMap<String, String>();
            etagHeader.put(""ETag"", etag);
            return etagHeader;
        } else {
            return null;
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,appendContactsResponses,,9,23,18,2,0.2031,0.0475,0.666666667,6,2,0,1,"private void appendContactsResponses(CaldavResponse response, CaldavRequest request, List<ExchangeSession.Contact> contacts) throws IOException {
        int size = contacts.size();
        int count = 0;
        for (ExchangeSession.Contact contact : contacts) {
            DavGatewayTray.debug(new BundleMessage(""LOG_LISTING_ITEM"", ++count, size));
            DavGatewayTray.switchIcon();
            appendItemResponse(response, request, contact);
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,appendEventsResponses,,9,23,18,2,0.2031,0.0475,0.666666667,6,2,0,1,"protected void appendEventsResponses(CaldavResponse response, CaldavRequest request, List<ExchangeSession.Event> events) throws IOException {
        int size = events.size();
        int count = 0;
        for (ExchangeSession.Event event : events) {
            DavGatewayTray.debug(new BundleMessage(""LOG_LISTING_ITEM"", ++count, size));
            DavGatewayTray.switchIcon();
            appendItemResponse(response, request, event);
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,appendItemResponse,,35,223,95,3,0.2063,0.2084,0.307692308,5,12,0,1,"protected void appendItemResponse(CaldavResponse response, CaldavRequest request, ExchangeSession.Item item) throws IOException {
        StringBuilder eventPath = new StringBuilder();
        eventPath.append(encodePath(request, request.getPath()));
        if (!(eventPath.charAt(eventPath.length() - 1) == '/')) {
            eventPath.append('/');
        }
        String itemName = StringUtil.xmlEncode(item.getName());
        eventPath.append(URIUtil.encodeWithinQuery(itemName));
        response.startResponse(eventPath.toString());
        response.startPropstat();
        if (request.hasProperty(""calendar-data"") && item instanceof ExchangeSession.Event) {
            response.appendCalendarData(item.getBody());
        }
        if (request.hasProperty(""address-data"") && item instanceof ExchangeSession.Contact) {
            response.appendContactData(item.getBody());
        }
        if (request.hasProperty(""getcontenttype"")) {
            if (item instanceof ExchangeSession.Event) {
                response.appendProperty(""D:getcontenttype"", ""text/calendar; component=vevent"");
            } else if (item instanceof ExchangeSession.Contact) {
                response.appendProperty(""D:getcontenttype"", ""text/vcard"");
            }
        }
        if (request.hasProperty(""getetag"")) {
            response.appendProperty(""D:getetag"", item.getEtag());
        }
        if (request.hasProperty(""resourcetype"")) {
            response.appendProperty(""D:resourcetype"");
        }
        if (request.hasProperty(""displayname"")) {
            response.appendProperty(""D:displayname"", itemName);
        }
        response.endPropStatOK();
        response.endResponse();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,appendFolderOrItem,,68,433,0,3,0.2093,0.3089,0.285714286,5,22,0,1,"/**
     * Append folder object to Caldav response.
     *
     * @param response  Caldav response
     * @param request   Caldav request
     * @param folder    folder object
     * @param subFolder calendar folder path relative to request path
     * @throws IOException on error
     */
    public void appendFolderOrItem(CaldavResponse response, CaldavRequest request, ExchangeSession.Folder folder, String subFolder) throws IOException {
        response.startResponse(encodePath(request, request.getPath(subFolder)));
        response.startPropstat();

        if (request.hasProperty(""resourcetype"")) {
            if (folder.isContact()) {
                response.appendProperty(""D:resourcetype"", ""<D:collection/>"" +
                        ""<E:addressbook/>"");
            } else if (folder.isCalendar() || folder.isTask()) {
                response.appendProperty(""D:resourcetype"", ""<D:collection/>"" + ""<C:calendar/>"");
            } else {
                response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
            }

        }
        if (request.hasProperty(""owner"")) {
            if (""users"".equals(request.getPathElement(1))) {
                response.appendHrefProperty(""D:owner"", ""/principals/users/"" + request.getPathElement(2));
            } else {
                response.appendHrefProperty(""D:owner"", ""/principals"" + request.getPath());
            }
        }
        if (request.hasProperty(""getcontenttype"")) {
            if (folder.isContact()) {
                response.appendProperty(""D:getcontenttype"", ""text/x-vcard"");
            } else if (folder.isCalendar()) {
                response.appendProperty(""D:getcontenttype"", ""text/calendar; component=vevent"");
            } else if (folder.isTask()) {
                response.appendProperty(""D:getcontenttype"", ""text/calendar; component=vtodo"");
            }
        }
        if (request.hasProperty(""getetag"")) {
            response.appendProperty(""D:getetag"", folder.etag);
        }
        if (request.hasProperty(""getctag"")) {
            response.appendProperty(""CS:getctag"", ""CS=\""http://calendarserver.org/ns/\"""",
                    IOUtil.encodeBase64AsString(folder.ctag));
        }
        if (request.hasProperty(""displayname"")) {
            if (subFolder == null || subFolder.length() == 0) {
                // use i18n calendar name as display name
                String displayname = request.getLastPath();
                if (""calendar"".equals(displayname)) {
                    displayname = folder.displayName;
                }
                response.appendProperty(""D:displayname"", displayname);
            } else {
                response.appendProperty(""D:displayname"", subFolder);
            }
        }
        if (request.hasProperty(""calendar-description"")) {
            response.appendProperty(""C:calendar-description"", """");
        }
        if (request.hasProperty(""supported-calendar-component-set"")) {
            if (folder.isCalendar()) {
                response.appendProperty(""C:supported-calendar-component-set"", ""<C:comp name=\""VEVENT\""/><C:comp name=\""VTODO\""/>"");
            } else if (folder.isTask()) {
                response.appendProperty(""C:supported-calendar-component-set"", ""<C:comp name=\""VTODO\""/>"");
            }
        }

        if (request.hasProperty(""current-user-privilege-set"")) {
            response.appendProperty(""D:current-user-privilege-set"", ""<D:privilege><D:read/><D:write/></D:privilege>"");
        }

        response.endPropStatOK();
        response.endResponse();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,appendInbox,,37,227,154,3,0.13,0.1426,0.461538462,8,8,0,1,"/**
     * Append calendar inbox object to Caldav response.
     *
     * @param response  Caldav response
     * @param request   Caldav request
     * @param subFolder inbox folder path relative to request path
     * @throws IOException on error
     */
    public void appendInbox(CaldavResponse response, CaldavRequest request, String subFolder) throws IOException {
        String ctag = ""0"";
        String etag = ""0"";
        String folderPath = request.getFolderPath(subFolder);
        // do not try to access inbox on shared calendar
        if (!session.isSharedFolder(folderPath)) {
            try {
                ExchangeSession.Folder folder = session.getFolder(folderPath);
                ctag = IOUtil.encodeBase64AsString(folder.ctag);
                etag = IOUtil.encodeBase64AsString(folder.etag);
            } catch (HttpException e) {
                // unauthorized access, probably an inbox on shared calendar
                DavGatewayTray.debug(new BundleMessage(""LOG_ACCESS_FORBIDDEN"", folderPath, e.getMessage()));
            }
        }
        response.startResponse(encodePath(request, request.getPath(subFolder)));
        response.startPropstat();

        if (request.hasProperty(""resourcetype"")) {
            response.appendProperty(""D:resourcetype"", ""<D:collection/>"" +
                    ""<C:schedule-inbox xmlns:C=\""urn:ietf:params:xml:ns:caldav\""/>"");
        }
        if (request.hasProperty(""getcontenttype"")) {
            response.appendProperty(""D:getcontenttype"", ""text/calendar; component=vevent"");
        }
        if (request.hasProperty(""getctag"")) {
            response.appendProperty(""CS:getctag"", ""CS=\""http://calendarserver.org/ns/\"""", ctag);
        }
        if (request.hasProperty(""getetag"")) {
            response.appendProperty(""D:getetag"", etag);
        }
        if (request.hasProperty(""displayname"")) {
            response.appendProperty(""D:displayname"", ""inbox"");
        }
        response.endPropStatOK();
        response.endResponse();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,appendOutbox,,21,53,15,3,0.3333,0.3407,0.285714286,3,5,0,1,"/**
     * Append calendar outbox object to Caldav response.
     *
     * @param response  Caldav response
     * @param request   Caldav request
     * @param subFolder outbox folder path relative to request path
     * @throws IOException on error
     */
    public void appendOutbox(CaldavResponse response, CaldavRequest request, String subFolder) throws IOException {
        response.startResponse(encodePath(request, request.getPath(subFolder)));
        response.startPropstat();

        if (request.hasProperty(""resourcetype"")) {
            response.appendProperty(""D:resourcetype"", ""<D:collection/>"" +
                    ""<C:schedule-outbox xmlns:C=\""urn:ietf:params:xml:ns:caldav\""/>"");
        }
        if (request.hasProperty(""getctag"")) {
            response.appendProperty(""CS:getctag"", ""CS=\""http://calendarserver.org/ns/\"""",
                    ""0"");
        }
        if (request.hasProperty(""getetag"")) {
            response.appendProperty(""D:getetag"", ""0"");
        }
        if (request.hasProperty(""displayname"")) {
            response.appendProperty(""D:displayname"", ""outbox"");
        }
        response.endPropStatOK();
        response.endResponse();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendInbox,,20,61,31,3,0.2245,0.1604,0.545454545,4,5,0,1,"/**
     * Send inbox response for request.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void sendInbox(CaldavRequest request) throws IOException {
        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        appendInbox(response, request, null);
        // do not try to access inbox on shared calendar
        if (!session.isSharedFolder(request.getFolderPath(null)) && request.getDepth() == 1
                && !request.isLightning()) {
            try {
                DavGatewayTray.debug(new BundleMessage(""LOG_SEARCHING_CALENDAR_MESSAGES""));
                List<ExchangeSession.Event> events = session.getEventMessages(request.getFolderPath());
                DavGatewayTray.debug(new BundleMessage(""LOG_FOUND_CALENDAR_MESSAGES"", events.size()));
                appendEventsResponses(response, request, events);
            } catch (HttpException e) {
                // unauthorized access, probably an inbox on shared calendar
                DavGatewayTray.debug(new BundleMessage(""LOG_ACCESS_FORBIDDEN"", request.getFolderPath(), e.getMessage()));
            }
        }
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendFolderOrItem,,37,218,85,3,0.1926,0.1594,0.384615385,8,12,0,1,"/**
     * Send calendar response for request.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void sendFolderOrItem(CaldavRequest request) throws IOException {
        String folderPath = request.getFolderPath();
        // process request before sending response to avoid sending headers twice on error
        ExchangeSession.Folder folder = session.getFolder(folderPath);
        List<ExchangeSession.Contact> contacts = null;
        List<ExchangeSession.Event> events = null;
        List<ExchangeSession.Folder> folderList = null;
        if (request.getDepth() == 1) {
            if (folder.isContact()) {
                contacts = session.getAllContacts(folderPath);
            } else if (folder.isCalendar() || folder.isTask()) {
                events = session.getAllEvents(folderPath);
                if (!folderPath.startsWith(""/public"")) {
                    folderList = session.getSubCalendarFolders(folderPath, false);
                }
            }
        }

        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        appendFolderOrItem(response, request, folder, null);
        if (request.getDepth() == 1) {
            if (folder.isContact()) {
                appendContactsResponses(response, request, contacts);
            } else if (folder.isCalendar() || folder.isTask()) {
                appendEventsResponses(response, request, events);
                // Send sub folders for multi-calendar support under iCal, except for public folders
                if (folderList != null) {
                    for (ExchangeSession.Folder subFolder : folderList) {
                        appendFolderOrItem(response, request, subFolder, subFolder.folderPath.substring(subFolder.folderPath.indexOf('/') + 1));
                    }
                }
            }
        }
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,patchCalendar,,25,120,69,4,0.2105,0.2299,0.333333333,5,7,0,1,"/**
     * Fake PROPPATCH response for request.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void patchCalendar(CaldavRequest request) throws IOException {
        String displayname = request.getProperty(""displayname"");
        String folderPath = request.getFolderPath();
        if (displayname != null) {
            String targetPath = request.getParentFolderPath() + '/' + displayname;
            if (!targetPath.equals(folderPath)) {
                session.moveFolder(folderPath, targetPath);
            }
        }
        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        // ical calendar folder proppatch
        if (request.hasProperty(""calendar-color"") || request.hasProperty(""calendar-order"")) {
            response.startPropstat();
            if (request.hasProperty(""calendar-color"")) {
                response.appendProperty(""x1:calendar-color"", ""x1=\""http://apple.com/ns/ical/\"""", null);
            }
            if (request.hasProperty(""calendar-order"")) {
                response.appendProperty(""x1:calendar-order"", ""x1=\""http://apple.com/ns/ical/\"""", null);
            }
            response.endPropStatOK();
        }
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,reportItems,,65,638,415,4,0.099,0.108,0.318181818,14,17,0,1,"/**
     * Report items listed in request.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void reportItems(CaldavRequest request) throws IOException {
        String folderPath = request.getFolderPath();
        List<ExchangeSession.Event> events;
        List<String> notFound = new ArrayList<String>();

        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        if (request.isMultiGet()) {
            int count = 0;
            int total = request.getHrefs().size();
            for (String href : request.getHrefs()) {
                DavGatewayTray.debug(new BundleMessage(""LOG_REPORT_ITEM"", ++count, total));
                DavGatewayTray.switchIcon();
                String eventName = getEventFileNameFromPath(href);
                try {
                    // ignore cases for Sunbird
                    if (eventName != null && eventName.length() > 0
                            && !""inbox"".equals(eventName) && !""calendar"".equals(eventName)) {
                        ExchangeSession.Item item;
                        try {
                            item = session.getItem(folderPath, eventName);
                        } catch (HttpNotFoundException e) {
                            // workaround for Lightning bug
                            if (request.isBrokenLightning() && eventName.indexOf('%') >= 0) {
                                item = session.getItem(folderPath, URIUtil.decode(StringUtil.encodePlusSign(eventName)));
                            } else {
                                throw e;
                            }

                        }
                        appendItemResponse(response, request, item);
                    }
                } catch (SocketException e) {
                    // rethrow SocketException (client closed connection)
                    throw e;
                } catch (Exception e) {
                    wireLogger.debug(e.getMessage(), e);
                    DavGatewayTray.warn(new BundleMessage(""LOG_ITEM_NOT_AVAILABLE"", eventName, href));
                    notFound.add(href);
                }
            }
        } else if (request.isPath(1, ""users"") && request.isPath(3, ""inbox"")) {
            events = session.getEventMessages(request.getFolderPath());
            appendEventsResponses(response, request, events);
        } else {
            // TODO: handle contacts ?
            if (request.vTodoOnly) {
                events = session.searchTasksOnly(request.getFolderPath());
            } else if (request.vEventOnly) {
                events = session.searchEventsOnly(request.getFolderPath(), request.timeRangeStart, request.timeRangeEnd);
            } else {
                events = session.searchEvents(request.getFolderPath(), request.timeRangeStart, request.timeRangeEnd);
            }
            appendEventsResponses(response, request, events);
        }

        // send not found events errors
        for (String href : notFound) {
            response.startResponse(encodePath(request, href));
            response.appendPropstatNotFound();
            response.endResponse();
        }
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendPrincipalsFolder,,14,28,0,3,0.3611,0.4359,0.333333333,2,2,0,1,"/**
     * Send principals folder.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void sendPrincipalsFolder(CaldavRequest request) throws IOException {
        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        response.startResponse(encodePath(request, request.getPath()));
        response.startPropstat();

        if (request.hasProperty(""current-user-principal"")) {
            response.appendHrefProperty(""D:current-user-principal"", encodePath(request, ""/principals/users/"" + session.getEmail()));
        }
        response.endPropStatOK();
        response.endResponse();
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendUserRoot,,28,93,0,3,0.2424,0.3572,0.3125,3,5,0,1,"/**
     * Send user response for request.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void sendUserRoot(CaldavRequest request) throws IOException {
        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        response.startResponse(encodePath(request, request.getPath()));
        response.startPropstat();

        if (request.hasProperty(""resourcetype"")) {
            response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
        }
        if (request.hasProperty(""displayname"")) {
            response.appendProperty(""D:displayname"", request.getLastPath());
        }
        if (request.hasProperty(""getctag"")) {
            ExchangeSession.Folder rootFolder = session.getFolder("""");
            response.appendProperty(""CS:getctag"", ""CS=\""http://calendarserver.org/ns/\"""",
                    IOUtil.encodeBase64AsString(rootFolder.ctag));
        }
        response.endPropStatOK();
        if (request.getDepth() == 1) {
            appendInbox(response, request, ""inbox"");
            appendOutbox(response, request, ""outbox"");
            appendFolderOrItem(response, request, session.getFolder(request.getFolderPath(""calendar"")), ""calendar"");
            appendFolderOrItem(response, request, session.getFolder(request.getFolderPath(""contacts"")), ""contacts"");
        }
        response.endResponse();
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendRoot,,62,447,0,3,0.3481,0.4931,0.333333333,2,13,0,1,"/**
     * Send caldav response for / request.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void sendRoot(CaldavRequest request) throws IOException {
        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        response.startResponse(""/"");
        response.startPropstat();

        if (request.hasProperty(""principal-collection-set"")) {
            response.appendHrefProperty(""D:principal-collection-set"", ""/principals/users/"");
        }
        if (request.hasProperty(""displayname"")) {
            response.appendProperty(""D:displayname"", ""ROOT"");
        }
        if (request.hasProperty(""resourcetype"")) {
            response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
        }
        if (request.hasProperty(""current-user-principal"")) {
            response.appendHrefProperty(""D:current-user-principal"", encodePath(request, ""/principals/users/"" + session.getEmail()));
        }
        response.endPropStatOK();
        response.endResponse();
        if (request.depth == 1) {
            // iPhone workaround: send calendar subfolder
            response.startResponse(""/users/"" + session.getEmail() + ""/calendar"");
            response.startPropstat();
            if (request.hasProperty(""resourcetype"")) {
                response.appendProperty(""D:resourcetype"", ""<D:collection/>"" +
                        ""<C:calendar xmlns:C=\""urn:ietf:params:xml:ns:caldav\""/>"");
            }
            if (request.hasProperty(""displayname"")) {
                response.appendProperty(""D:displayname"", session.getEmail());
            }
            if (request.hasProperty(""supported-calendar-component-set"")) {
                response.appendProperty(""C:supported-calendar-component-set"", ""<C:comp name=\""VEVENT\""/>"");
            }
            response.endPropStatOK();
            response.endResponse();

            response.startResponse(""/users"");
            response.startPropstat();
            if (request.hasProperty(""displayname"")) {
                response.appendProperty(""D:displayname"", ""users"");
            }
            if (request.hasProperty(""resourcetype"")) {
                response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
            }
            response.endPropStatOK();
            response.endResponse();

            response.startResponse(""/principals"");
            response.startPropstat();
            if (request.hasProperty(""displayname"")) {
                response.appendProperty(""D:displayname"", ""principals"");
            }
            if (request.hasProperty(""resourcetype"")) {
                response.appendProperty(""D:resourcetype"", ""<D:collection/>"");
            }
            response.endPropStatOK();
            response.endResponse();
        }
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendDirectory,,13,30,0,4,0.4167,0.5538,0.3,2,2,0,1,"/**
     * Send caldav response for /directory/ request.
     *
     * @param request Caldav request
     * @throws IOException on error
     */
    public void sendDirectory(CaldavRequest request) throws IOException {
        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        response.startResponse(""/directory/"");
        response.startPropstat();
        if (request.hasProperty(""current-user-privilege-set"")) {
            response.appendProperty(""D:current-user-privilege-set"", ""<D:privilege><D:read/></D:privilege>"");
        }
        response.endPropStatOK();
        response.endResponse();
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendPrincipal,,73,274,0,2,0.2601,0.3182,0.235294118,5,23,0,1,"/**
     * Send Caldav principal response.
     *
     * @param request   Caldav request
     * @param prefix    principal prefix (users or public)
     * @param principal principal name (email address for users)
     * @throws IOException on error
     */
    public void sendPrincipal(CaldavRequest request, String prefix, String principal) throws IOException {
        // actual principal is email address
        String actualPrincipal = principal;
        if (""users"".equals(prefix) &&
                (principal.equalsIgnoreCase(session.getAlias()) || (principal.equalsIgnoreCase(session.getAliasFromLogin())))) {
            actualPrincipal = session.getEmail();
        }

        CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
        response.startMultistatus();
        response.startResponse(encodePath(request, ""/principals/"" + prefix + '/' + principal));
        response.startPropstat();

        if (request.hasProperty(""principal-URL"") && request.isIcal5()) {
            response.appendHrefProperty(""D:principal-URL"", encodePath(request, ""/principals/"" + prefix + '/' + actualPrincipal));
        }


        if (request.hasProperty(""calendar-home-set"")) {
            if (""users"".equals(prefix)) {
                response.appendHrefProperty(""C:calendar-home-set"", encodePath(request, ""/users/"" + actualPrincipal + ""/calendar/""));
            } else {
                response.appendHrefProperty(""C:calendar-home-set"", encodePath(request, '/' + prefix + '/' + actualPrincipal));
            }
        }

        if (request.hasProperty(""calendar-user-address-set"") && ""users"".equals(prefix)) {
            response.appendHrefProperty(""C:calendar-user-address-set"", ""mailto:"" + actualPrincipal);
        }

        if (request.hasProperty(""addressbook-home-set"")) {
            if (request.isUserAgent(""Address%20Book"") || request.isUserAgent(""Darwin"")) {
                response.appendHrefProperty(""E:addressbook-home-set"", encodePath(request, '/' + prefix + '/' + actualPrincipal + '/'));
            } else if (""users"".equals(prefix)) {
                response.appendHrefProperty(""E:addressbook-home-set"", encodePath(request, ""/users/"" + actualPrincipal + ""/contacts/""));
            } else {
                response.appendHrefProperty(""E:addressbook-home-set"", encodePath(request, '/' + prefix + '/' + actualPrincipal + '/'));
            }
        }

        if (""users"".equals(prefix)) {
            if (request.hasProperty(""schedule-inbox-URL"")) {
                response.appendHrefProperty(""C:schedule-inbox-URL"", encodePath(request, ""/users/"" + actualPrincipal + ""/inbox/""));
            }

            if (request.hasProperty(""schedule-outbox-URL"")) {
                response.appendHrefProperty(""C:schedule-outbox-URL"", encodePath(request, ""/users/"" + actualPrincipal + ""/outbox/""));
            }
        } else {
            // public calendar, send root href as inbox url (always empty) for Lightning
            if (request.isLightning() && request.hasProperty(""schedule-inbox-URL"")) {
                response.appendHrefProperty(""C:schedule-inbox-URL"", ""/"");
            }
            // send user outbox
            if (request.hasProperty(""schedule-outbox-URL"")) {
                response.appendHrefProperty(""C:schedule-outbox-URL"", encodePath(request, ""/users/"" + session.getEmail() + ""/outbox/""));
            }
        }

        if (request.hasProperty(""displayname"")) {
            response.appendProperty(""D:displayname"", actualPrincipal);
        }
        if (request.hasProperty(""resourcetype"")) {
            response.appendProperty(""D:resourcetype"", ""<D:collection/><D:principal/>"");
        }
        if (request.hasProperty(""supported-report-set"")) {
            response.appendProperty(""D:supported-report-set"", ""<D:supported-report><D:report><C:calendar-multiget/></D:report></D:supported-report>"");
        }
        response.endPropStatOK();
        response.endResponse();
        response.endMultistatus();
        response.close();
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendFreeBusy,,65,643,545,3,0.0791,0.0536,0.5,18,8,0,1,"/**
     * Send free busy response for body request.
     *
     * @param body request body
     * @throws IOException on error
     */
    public void sendFreeBusy(String body) throws IOException {
        HashMap<String, String> valueMap = new HashMap<String, String>();
        ArrayList<String> attendees = new ArrayList<String>();
        HashMap<String, String> attendeeKeyMap = new HashMap<String, String>();
        ICSBufferedReader reader = new ICSBufferedReader(new StringReader(body));
        String line;
        String key;
        while ((line = reader.readLine()) != null) {
            int index = line.indexOf(':');
            if (index <= 0) {
                throw new DavMailException(""EXCEPTION_INVALID_REQUEST"", body);
            }
            String fullkey = line.substring(0, index);
            String value = line.substring(index + 1);
            int semicolonIndex = fullkey.indexOf(';');
            if (semicolonIndex > 0) {
                key = fullkey.substring(0, semicolonIndex);
            } else {
                key = fullkey;
            }
            if (""ATTENDEE"".equals(key)) {
                attendees.add(value);
                attendeeKeyMap.put(value, fullkey);
            } else {
                valueMap.put(key, value);
            }
        }
        // get freebusy for each attendee
        HashMap<String, ExchangeSession.FreeBusy> freeBusyMap = new HashMap<String, ExchangeSession.FreeBusy>();
        for (String attendee : attendees) {
            ExchangeSession.FreeBusy freeBusy = session.getFreebusy(attendee, valueMap.get(""DTSTART""), valueMap.get(""DTEND""));
            if (freeBusy != null) {
                freeBusyMap.put(attendee, freeBusy);
            }
        }
        CaldavResponse response = new CaldavResponse(HttpStatus.SC_OK);
        response.startScheduleResponse();

        for (Map.Entry<String, ExchangeSession.FreeBusy> entry : freeBusyMap.entrySet()) {
            String attendee = entry.getKey();
            response.startRecipientResponse(attendee);

            StringBuilder ics = new StringBuilder();
            ics.append(""BEGIN:VCALENDAR"").append((char) 13).append((char) 10)
                    .append(""VERSION:2.0"").append((char) 13).append((char) 10)
                    .append(""PRODID:-//davmail.sf.net/NONSGML DavMail Calendar V1.1//EN"").append((char) 13).append((char) 10)
                    .append(""METHOD:REPLY"").append((char) 13).append((char) 10)
                    .append(""BEGIN:VFREEBUSY"").append((char) 13).append((char) 10)
                    .append(""DTSTAMP:"").append(valueMap.get(""DTSTAMP"")).append("""").append((char) 13).append((char) 10)
                    .append(""ORGANIZER:"").append(valueMap.get(""ORGANIZER"")).append("""").append((char) 13).append((char) 10)
                    .append(""DTSTART:"").append(valueMap.get(""DTSTART"")).append("""").append((char) 13).append((char) 10)
                    .append(""DTEND:"").append(valueMap.get(""DTEND"")).append("""").append((char) 13).append((char) 10)
                    .append(""UID:"").append(valueMap.get(""UID"")).append("""").append((char) 13).append((char) 10)
                    .append(attendeeKeyMap.get(attendee)).append(':').append(attendee).append("""").append((char) 13).append((char) 10);
            entry.getValue().appendTo(ics);
            ics.append(""END:VFREEBUSY"").append((char) 13).append((char) 10)
                    .append(""END:VCALENDAR"");
            response.appendCalendarData(ics.toString());
            response.endRecipientResponse();

        }
        response.endScheduleResponse();
        response.close();

    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendErr,,19,38,21,5,0.25,0.2222,0,3,5,0,1,"/**
     * Send Http error response for exception
     *
     * @param e exception
     * @throws IOException on error
     */
    public void sendErr(Exception e) throws IOException {
        String message = e.getMessage();
        if (message == null) {
            message = e.toString();
        }
        if (e instanceof HttpNotFoundException) {
            sendErr(HttpStatus.SC_NOT_FOUND, message);
        } else if (e instanceof HttpPreconditionFailedException) {
            sendErr(HttpStatus.SC_PRECONDITION_FAILED, message);
        } else {
            // workaround for Lightning bug: sleep for 1 second
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ie) {
                // ignore
            }
            sendErr(HttpStatus.SC_SERVICE_UNAVAILABLE, message);
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,sendHttpResponse,,37,344,310,3,0.0824,0.0574,1,8,14,0,1,"/**
     * Send Http response with given status, headers, content type and content.
     * Close connection if keepAlive is false
     *
     * @param status      Http status
     * @param headers     Http headers
     * @param contentType MIME content type
     * @param content     response body as byte array
     * @param keepAlive   keep connection open
     * @throws IOException on error
     */
    public void sendHttpResponse(int status, Map<String, String> headers, String contentType, byte[] content, boolean keepAlive) throws IOException {
        sendClient(""HTTP/1.1 "" + status + ' ' + HttpStatus.getStatusText(status));
        if (status != HttpStatus.SC_UNAUTHORIZED) {
            sendClient(""Server: DavMail Gateway "" + DavGateway.getCurrentVersion());
            sendClient(""DAV: 1, calendar-access, calendar-schedule, calendarserver-private-events, addressbook"");
            SimpleDateFormat formatter = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss Z"", Locale.ENGLISH);
            // force GMT timezone
            formatter.setTimeZone(ExchangeSession.GMT_TIMEZONE);
            String now = formatter.format(new Date());
            sendClient(""Date: "" + now);
            sendClient(""Expires: "" + now);
            sendClient(""Cache-Control: private, max-age=0"");
        }
        if (headers != null) {
            for (Map.Entry<String, String> header : headers.entrySet()) {
                sendClient(header.getKey() + "": "" + header.getValue());
            }
        }
        if (contentType != null) {
            sendClient(""Content-Type: "" + contentType);
        }
        closed = closed || !keepAlive;
        sendClient(""Connection: "" + (closed ? ""close"" : ""keep-alive""));
        if (content != null && content.length > 0) {
            sendClient(""Content-Length: "" + content.length);
        } else if (headers == null || !""chunked"".equals(headers.get(""Transfer-Encoding""))) {
            sendClient(""Content-Length: 0"");
        }
        sendClient("""");
        if (content != null && content.length > 0) {
            // full debug trace
            if (wireLogger.isDebugEnabled()) {
                wireLogger.debug(""> "" + new String(content, ""UTF-8""));
            }
            sendClient(content);
        }
    }"
davmail-4.5.1,davmail.caldav.CaldavConnection,decodeCredentials,,21,364,322,19,0.0611,0.0383,1,5,4,0,1,"/**
     * Decode HTTP credentials
     *
     * @param authorization http authorization header value
     * @throws IOException if invalid credentials
     */
    protected void decodeCredentials(String authorization) throws IOException {
        int index = authorization.indexOf(' ');
        if (index > 0) {
            String mode = authorization.substring(0, index).toLowerCase();
            if (!""basic"".equals(mode)) {
                throw new DavMailException(""EXCEPTION_UNSUPPORTED_AUTHORIZATION_MODE"", mode);
            }
            String encodedCredentials = authorization.substring(index + 1);
            String decodedCredentials = IOUtil.decodeBase64AsString(encodedCredentials);
            index = decodedCredentials.indexOf(':');
            if (index > 0) {
                userName = decodedCredentials.substring(0, index);
                password = decodedCredentials.substring(index + 1);
            } else {
                throw new DavMailException(""EXCEPTION_INVALID_CREDENTIALS"");
            }
        } else {
            throw new DavMailException(""EXCEPTION_INVALID_CREDENTIALS"");
        }

    }"
davmail-4.5.1,davmail.exchange.VProperty,VProperty,,85,907,44,3,0.265,0.2308,0,7,28,0,1,"/**
     * Create VProperty from line.
     *
     * @param line card line
     */
    public VProperty(String line) {
        if (line != null && !""END:VCARD"".equals(line)) {
            State state = State.KEY;
            String paramName = null;
            List<String> paramValues = null;
            int startIndex = 0;
            for (int i = 0; i < line.length(); i++) {
                char currentChar = line.charAt(i);
                if (state == State.KEY) {
                    if (currentChar == ':') {
                        setKey(line.substring(startIndex, i));
                        state = State.VALUE;
                        startIndex = i + 1;
                    } else if (currentChar == ';') {
                        setKey(line.substring(startIndex, i));
                        state = State.PARAM_NAME;
                        startIndex = i + 1;
                    }
                } else if (state == State.PARAM_NAME) {
                    if (currentChar == '=') {
                        paramName = line.substring(startIndex, i).toUpperCase();
                        state = State.PARAM_VALUE;
                        paramValues = new ArrayList<String>();
                        startIndex = i + 1;
                    } else if (currentChar == ';') {
                        // param with no value
                        paramName = line.substring(startIndex, i).toUpperCase();
                        addParam(paramName);
                        state = State.PARAM_NAME;
                        startIndex = i + 1;
                    } else if (currentChar == ':') {
                        // param with no value
                        paramName = line.substring(startIndex, i).toUpperCase();
                        addParam(paramName);
                        state = State.VALUE;
                        startIndex = i + 1;
                    }
                } else if (state == State.PARAM_VALUE) {
                    if (currentChar == '""') {
                        state = State.QUOTED_PARAM_VALUE;
                        startIndex = i + 1;
                    } else if (currentChar == ':') {
                        if (startIndex < i) {
                            paramValues = addParamValue(paramValues, line.substring(startIndex, i));
                        }
                        addParam(paramName, paramValues);
                        state = State.VALUE;
                        startIndex = i + 1;
                    } else if (currentChar == ';') {
                        if (startIndex < i) {
                            paramValues = addParamValue(paramValues, line.substring(startIndex, i));
                        }
                        addParam(paramName, paramValues);
                        state = State.PARAM_NAME;
                        startIndex = i + 1;
                    } else if (currentChar == ',') {
                        if (startIndex < i) {
                            paramValues = addParamValue(paramValues, line.substring(startIndex, i));
                        }
                        startIndex = i + 1;
                    }
                } else if (state == State.QUOTED_PARAM_VALUE) {
                    if (currentChar == '""') {
                        state = State.PARAM_VALUE;
                        paramValues = addParamValue(paramValues, line.substring(startIndex, i));
                        startIndex = i + 1;
                    }
                } else if (state == State.VALUE) {
                    if (currentChar == '\\') {
                        state = State.BACKSLASH;
                    } else if (currentChar == ';' || (MULTIVALUED_PROPERTIES.contains(key) && currentChar == ',')) {
                        addValue(line.substring(startIndex, i));
                        startIndex = i + 1;
                    }
                } else if (state == State.BACKSLASH) {
                    state = State.VALUE;
                }
            }
            if (state == State.VALUE) {
                addValue(line.substring(startIndex));
            } else {
                throw new IllegalArgumentException(""Invalid property line: "" + line);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VProperty,removeParam,,8,10,5,3,0.3889,0.1905,0,2,3,0,1,"/**
     * Remove param from property.
     *
     * @param paramName param name
     */
    public void removeParam(String paramName) {
        if (params != null) {
            Param param = getParam(paramName);
            if (param != null) {
                params.remove(param);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VProperty,containsIgnoreCase,,8,5,4,3,0.3333,0.0667,0,3,3,0,1,"protected boolean containsIgnoreCase(List<String> stringCollection, String value) {
        for (String collectionValue : stringCollection) {
            if (value.equalsIgnoreCase(collectionValue)) {
                return true;
            }
        }
        return false;
    }"
davmail-4.5.1,davmail.exchange.VProperty,addParamValue,,8,11,1,3,0.3333,0.3167,0,3,2,0,1,"/**
     * Add value to paramValues and return list, create list if null.
     *
     * @param paramValues value list
     * @param value new value
     * @return updated value list
     */
    protected List<String> addParamValue(List<String> paramValues, String value) {
        List<String> result = paramValues;
        if (result == null) {
            result = new ArrayList<String>();
        }
        result.add(value);
        return result;
    }"
davmail-4.5.1,davmail.exchange.VProperty,addParam,,7,11,7,3,0.3333,0.131,0,3,2,0,1,"/**
     * Add param value on property.
     *
     * @param paramName  param name
     * @param paramValue param value
     */
    public void addParam(String paramName, String paramValue) {
        if (paramValue != null) {
            List<String> paramValues = new ArrayList<String>();
            paramValues.add(paramValue);
            addParam(paramName, paramValues);
        }
    }"
davmail-4.5.1,davmail.exchange.VProperty,addParam,,12,27,9,3,0.2333,0.1761,0.5,3,3,0,1,"protected void addParam(String paramName, List<String> paramValues) {
        if (params == null) {
            params = new ArrayList<Param>();
        }
        Param currentParam = getParam(paramName);
        if (currentParam == null) {
            currentParam = new Param();
            currentParam.name = paramName;
            params.add(currentParam);
        }
        currentParam.addAll(paramValues);
    }"
davmail-4.5.1,davmail.exchange.VProperty,decodeValue,,37,80,7,3,0.2685,0.2396,0,4,15,0,1,"protected String decodeValue(String value) {
        if (value == null || (value.indexOf('\\') < 0 && value.indexOf(',') < 0)) {
            return value;
        } else {
            // decode value
            StringBuilder decodedValue = new StringBuilder();
            for (int i = 0; i < value.length(); i++) {
                char c = value.charAt(i);
                if (c == '\\') {
                    //noinspection AssignmentToForLoopParameter
                    i++;
                    if (i == value.length()) {
                        break;
                    }
                    c = value.charAt(i);
                    if (c == 'n' || c == 'N') {
                        c = '\n';
                    } else if (c == 'r') {
                        c = '\r';
                    }
                }
                // iPhone encodes category separator
                if (c == ',' &&
                        // multivalued properties
                        (""N"".equals(key) ||
                                ""ADR"".equals(key) ||
                                ""CATEGORIES"".equals(key) ||
                                ""NICKNAME"".equals(key)
                        )) {
                    // convert multiple values to multiline values (e.g. street)
                    c = '\n';
                }
                decodedValue.append(c);
            }
            return decodedValue.toString();
        }
    }"
davmail-4.5.1,davmail.exchange.VProperty,toString,,25,119,67,3,0.1637,0.1631,0,4,7,0,1,"public String toString() {
        StringBuilder buffer = new StringBuilder();
        buffer.append(key);
        if (params != null) {
            for (Param param : params) {
                buffer.append(';').append(param.name);
                appendParamValues(buffer, param);
            }
        }
        buffer.append(':');
        if (values != null) {
            boolean firstValue = true;
            for (String value : values) {
                if (firstValue) {
                    firstValue = false;
                } else if (MULTIVALUED_PROPERTIES.contains(key)) {
                    buffer.append(',');
                } else {
                    buffer.append(';');
                }
                appendMultilineEncodedValue(buffer, value);
            }
        }
        return buffer.toString();
    }"
davmail-4.5.1,davmail.exchange.VProperty,appendParamValues,,23,50,34,3,0.2361,0.1449,0,4,10,0,1,"protected void appendParamValues(StringBuilder buffer, Param param) {
        if (param.values != null) {
            buffer.append('=');
            boolean first = true;
            for (String value : param.values) {
                if (first) {
                    first = false;
                } else {
                    buffer.append(',');
                }
                // always quote CN param
                if (""CN"".equalsIgnoreCase(param.name)
                        // quote param values with special characters
                        || value.indexOf(';') >= 0 || value.indexOf(',') >= 0
                        || value.indexOf('(') >= 0 || value.indexOf('/') >= 0
                        || value.indexOf(':') >= 0) {
                    buffer.append('""').append(value).append('""');
                } else {
                    buffer.append(value);
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VProperty,appendMultilineEncodedValue,,12,27,18,3,0.2593,0.1248,0,4,5,0,1,"/**
     * Append and encode \n to \\n in value.
     *
     * @param buffer line buffer
     * @param value  value
     */
    protected void appendMultilineEncodedValue(StringBuilder buffer, String value) {
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);
            if (c == '\n') {
                buffer.append(""\\n"");
            } else if (MULTIVALUED_PROPERTIES.contains(key) && c == ',') {
                buffer.append('\\').append(',');
            } else {
                buffer.append(value.charAt(i));
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,ExchangeSession,,79,871,661,4,0.1008,0.0878,0.363636364,20,15,0,1,"/**
     * Create an exchange session for the given URL.
     * The session is established for given userName and password
     *
     * @param url      Exchange url
     * @param userName user login name
     * @param password user password
     * @throws IOException on error
     */
    public ExchangeSession(String url, String userName, String password) throws IOException {
        this.userName = userName;
        try {
            httpClient = DavGatewayHttpClientFacade.getInstance(url);
            // set private connection pool
            DavGatewayHttpClientFacade.createMultiThreadedHttpConnectionManager(httpClient);
            boolean isBasicAuthentication = isBasicAuthentication(httpClient, url);
            // clear cookies created by authentication test
            httpClient.getState().clearCookies();

            // The user may have configured an OTP pre-auth username. It is processed
            // so early because OTP pre-auth may disappear in the Exchange LAN and this
            // helps the user to not change is account settings in mail client at each network change.
            if (preAuthUsername == null) {
                // Searches for the delimiter in configured username for the pre-auth user. 
                // The double-quote is not allowed inside email addresses anyway.
                int doubleQuoteIndex = this.userName.indexOf('""');
                if (doubleQuoteIndex > 0) {
                    preAuthUsername = this.userName.substring(0, doubleQuoteIndex);
                    this.userName = this.userName.substring(doubleQuoteIndex + 1);
                } else {
                    // No doublequote: the pre-auth user is the full username, or it is not used at all.
                    preAuthUsername = this.userName;
                }
            }

            DavGatewayHttpClientFacade.setCredentials(httpClient, userName, password);

            // get webmail root url
            // providing credentials
            // manually follow redirect
            HttpMethod method = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, url);

            if (!this.isAuthenticated(method)) {
                if (isBasicAuthentication) {
                    int status = method.getStatusCode();

                    if (status == HttpStatus.SC_UNAUTHORIZED) {
                        method.releaseConnection();
                        throw new DavMailAuthenticationException(""EXCEPTION_AUTHENTICATION_FAILED"");
                    } else if (status != HttpStatus.SC_OK) {
                        method.releaseConnection();
                        throw DavGatewayHttpClientFacade.buildHttpException(method);
                    }
                    // workaround for basic authentication on /exchange and form based authentication at /owa
                    if (""/owa/auth/logon.aspx"".equals(method.getPath())) {
                        method = formLogin(httpClient, method, userName, password);
                    }
                } else {
                    method = formLogin(httpClient, method, userName, password);
                }
            }

            // avoid 401 roundtrips, only if NTLM is disabled and basic authentication enabled
            if (isBasicAuthentication && !DavGatewayHttpClientFacade.hasNTLMorNegotiate(httpClient)) {
                httpClient.getParams().setParameter(HttpClientParams.PREEMPTIVE_AUTHENTICATION, true);
            }

            buildSessionInfo(method);

        } catch (DavMailAuthenticationException exc) {
            LOGGER.error(exc.getMessage());
            throw exc;
        } catch (ConnectException exc) {
            BundleMessage message = new BundleMessage(""EXCEPTION_CONNECT"", exc.getClass().getName(), exc.getMessage());
            ExchangeSession.LOGGER.error(message);
            throw new DavMailException(""EXCEPTION_DAVMAIL_CONFIGURATION"", message);
        } catch (UnknownHostException exc) {
            BundleMessage message = new BundleMessage(""EXCEPTION_CONNECT"", exc.getClass().getName(), exc.getMessage());
            ExchangeSession.LOGGER.error(message);
            throw new DavMailException(""EXCEPTION_DAVMAIL_CONFIGURATION"", message);
        } catch (WebdavNotAvailableException exc) {
            throw exc;
        } catch (IOException exc) {
            LOGGER.error(BundleMessage.formatLog(""EXCEPTION_EXCHANGE_LOGIN_FAILED"", exc));
            throw new DavMailException(""EXCEPTION_EXCHANGE_LOGIN_FAILED"", exc);
        }
        LOGGER.debug(""Session "" + this + "" created"");
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,isExpired,,14,46,37,6,0.2424,0.1731,0,4,4,0,1,"/**
     * Test if the session expired.
     *
     * @return true this session expired
     * @throws NoRouteToHostException on error
     * @throws UnknownHostException   on error
     */
    public boolean isExpired() throws NoRouteToHostException, UnknownHostException {
        boolean isExpired = false;
        try {
            getFolder("""");
        } catch (UnknownHostException exc) {
            throw exc;
        } catch (NoRouteToHostException exc) {
            throw exc;
        } catch (IOException e) {
            isExpired = true;
        }

        return isExpired;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,buildLogonMethod,,127,2265,1829,4,0.0518,0.0467,0.6,34,30,0,1,"/**
     * Try to find logon method path from logon form body.
     *
     * @param httpClient httpClient instance
     * @param initmethod form body http method
     * @return logon method
     * @throws IOException on error
     */
    protected HttpMethod buildLogonMethod(HttpClient httpClient, HttpMethod initmethod) throws IOException {

        HttpMethod logonMethod = null;

        // create an instance of HtmlCleaner
        HtmlCleaner cleaner = new HtmlCleaner();

        // A OTP token authentication form in a previous page could have username fields with different names
        userNameInputs.clear();

        try {
            TagNode node = cleaner.clean(initmethod.getResponseBodyAsStream());
            List forms = node.getElementListByName(""form"", true);
            TagNode logonForm = null;
            // select form
            if (forms.size() == 1) {
                logonForm = (TagNode) forms.get(0);
            } else if (forms.size() > 1) {
                for (Object form : forms) {
                    if (""logonForm"".equals(((TagNode) form).getAttributeByName(""name""))) {
                        logonForm = ((TagNode) form);
                    }
                }
            }
            if (logonForm != null) {
                String logonMethodPath = logonForm.getAttributeByName(""action"");

                // workaround for broken form with empty action
                if (logonMethodPath != null && logonMethodPath.length() == 0) {
                    logonMethodPath = ""/owa/auth.owa"";
                }

                logonMethod = new PostMethod(getAbsoluteUri(initmethod, logonMethodPath));

                // retrieve lost inputs attached to body
                List inputList = node.getElementListByName(""input"", true);

                for (Object input : inputList) {
                    String type = ((TagNode) input).getAttributeByName(""type"");
                    String name = ((TagNode) input).getAttributeByName(""name"");
                    String value = ((TagNode) input).getAttributeByName(""value"");
                    if (""hidden"".equalsIgnoreCase(type) && name != null && value != null) {
                        ((PostMethod) logonMethod).addParameter(name, value);
                    }
                    // custom login form
                    if (USER_NAME_FIELDS.contains(name)) {
                        userNameInputs.add(name);
                    } else if (PASSWORD_FIELDS.contains(name)) {
                        passwordInput = name;
                    } else if (""addr"".equals(name)) {
                        // this is not a logon form but a redirect form
                        HttpMethod newInitMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, logonMethod);
                        logonMethod = buildLogonMethod(httpClient, newInitMethod);
                    } else if (TOKEN_FIELDS.contains(name)) {
                        // one time password, ask it to the user
                        ((PostMethod) logonMethod).addParameter(name, DavGatewayOTPPrompt.getOneTimePassword());
                    } else if (""otc"".equals(name)) {
                        // captcha image, get image and ask user
                        String pinsafeUser = getAliasFromLogin();
                        if (pinsafeUser == null) {
                            pinsafeUser = userName;
                        }
                        GetMethod getMethod = new GetMethod(""/PINsafeISAFilter.dll?username="" + pinsafeUser);
                        try {
                            int status = httpClient.executeMethod(getMethod);
                            if (status != HttpStatus.SC_OK) {
                                throw DavGatewayHttpClientFacade.buildHttpException(getMethod);
                            }
                            BufferedImage captchaImage = ImageIO.read(getMethod.getResponseBodyAsStream());
                            ((PostMethod) logonMethod).addParameter(name, DavGatewayOTPPrompt.getCaptchaValue(captchaImage));

                        } finally {
                            getMethod.releaseConnection();
                        }
                    }
                }
            } else {
                List frameList = node.getElementListByName(""frame"", true);
                if (frameList.size() == 1) {
                    String src = ((TagNode) frameList.get(0)).getAttributeByName(""src"");
                    if (src != null) {
                        LOGGER.debug(""Frames detected in form page, try frame content"");
                        initmethod.releaseConnection();
                        HttpMethod newInitMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, src);
                        logonMethod = buildLogonMethod(httpClient, newInitMethod);
                    }
                } else {
                    // another failover for script based logon forms (Exchange 2007)
                    List scriptList = node.getElementListByName(""script"", true);
                    for (Object script : scriptList) {
                        List contents = ((TagNode) script).getChildren();
                        for (Object content : contents) {
                            if (content instanceof CommentNode) {
                                String scriptValue = ((CommentNode) content).getCommentedContent();
                                String sUrl = StringUtil.getToken(scriptValue, ""var a_sUrl = \"""", ""\"""");
                                String sLgn = StringUtil.getToken(scriptValue, ""var a_sLgnQS = \"""", ""\"""");
                                if (sLgn == null) {
                                    sLgn = StringUtil.getToken(scriptValue, ""var a_sLgn = \"""", ""\"""");
                                }
                                if (sUrl != null && sLgn != null) {
                                    String src = getScriptBasedFormURL(initmethod, sLgn + sUrl);
                                    LOGGER.debug(""Detected script based logon, redirect to form at "" + src);
                                    HttpMethod newInitMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, src);
                                    logonMethod = buildLogonMethod(httpClient, newInitMethod);
                                }

                            } else if (content instanceof ContentNode) {
                                // Microsoft Forefront Unified Access Gateway redirect
                                String scriptValue = ((ContentNode) content).getContent().toString();
                                String location = StringUtil.getToken(scriptValue, ""window.location.replace(\"""", ""\"""");
                                if (location != null) {
                                    LOGGER.debug(""Post logon redirect to: "" + location);
                                    logonMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, location);
                                }
                            }
                        }
                    }
                }
            }
        } catch (IOException e) {
            LOGGER.error(""Error parsing login form at "" + initmethod.getURI());
        } finally {
            initmethod.releaseConnection();
        }

        return logonMethod;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,postLogonMethod,,46,30,0,3,0.1771,0.3287,1,4,8,0,1,"protected HttpMethod postLogonMethod(HttpClient httpClient, HttpMethod logonMethod, String userName, String password) throws IOException {

        setAuthFormFields(logonMethod, httpClient, password);

        // add exchange 2010 PBack cookie in compatibility mode
        httpClient.getState().addCookie(new Cookie(httpClient.getHostConfiguration().getHost(), ""PBack"", ""0"", ""/"", null, false));

        logonMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, logonMethod);

        // test form based authentication
        checkFormLoginQueryString(logonMethod);

        // workaround for post logon script redirect
        if (!isAuthenticated(logonMethod)) {
            // try to get new method from script based redirection
            logonMethod = buildLogonMethod(httpClient, logonMethod);

            if (logonMethod != null) {
                if (otpPreAuthFound && otpPreAuthRetries < MAX_OTP_RETRIES) {
                    // A OTP pre-auth page has been found, it is needed to restart the login process.
                    // This applies to both the case the user entered a good OTP code (the usual login process
                    // takes place) and the case the user entered a wrong OTP code (another code will be asked to him).
                    // The user has up to MAX_OTP_RETRIES chances to input a valid OTP key.
                    return postLogonMethod(httpClient, logonMethod, userName, password);
                }

                // if logonMethod is not null, try to follow redirection
                logonMethod = DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, logonMethod);
                checkFormLoginQueryString(logonMethod);
                // also check cookies
                if (!isAuthenticated(logonMethod)) {
                    throwAuthenticationFailed();
                }
            } else {
                // authentication failed
                throwAuthenticationFailed();
            }
        }

        // check for language selection form
        if (logonMethod != null && ""/owa/languageselection.aspx"".equals(logonMethod.getPath())) {
            // need to submit form
            logonMethod = submitLanguageSelectionForm(logonMethod);
        }
        return logonMethod;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,formLogin,,12,24,12,3,0.2407,0.1686,0,5,2,0,1,"protected HttpMethod formLogin(HttpClient httpClient, HttpMethod initmethod, String userName, String password) throws IOException {
        LOGGER.debug(""Form based authentication detected"");

        HttpMethod logonMethod = buildLogonMethod(httpClient, initmethod);
        if (logonMethod == null) {
            LOGGER.debug(""Authentication form not found at "" + initmethod.getURI() + "", trying default url"");
            logonMethod = new PostMethod(""/owa/auth/owaauth.dll"");
        }
        logonMethod = postLogonMethod(httpClient, logonMethod, userName, password);

        return logonMethod;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,submitLanguageSelectionForm,,52,501,441,5,0.0701,0.0364,1,19,11,0,1,"protected HttpMethod submitLanguageSelectionForm(HttpMethod logonMethod) throws IOException {
        PostMethod postLanguageFormMethod;
        // create an instance of HtmlCleaner
        HtmlCleaner cleaner = new HtmlCleaner();

        try {
            TagNode node = cleaner.clean(logonMethod.getResponseBodyAsStream());
            List forms = node.getElementListByName(""form"", true);
            TagNode languageForm;
            // select form
            if (forms.size() == 1) {
                languageForm = (TagNode) forms.get(0);
            } else {
                throw new IOException(""Form not found"");
            }
            String languageMethodPath = languageForm.getAttributeByName(""action"");

            postLanguageFormMethod = new PostMethod(getAbsoluteUri(logonMethod, languageMethodPath));

            List inputList = languageForm.getElementListByName(""input"", true);
            for (Object input : inputList) {
                String name = ((TagNode) input).getAttributeByName(""name"");
                String value = ((TagNode) input).getAttributeByName(""value"");
                if (name != null && value != null) {
                    postLanguageFormMethod.addParameter(name, value);
                }
            }
            List selectList = languageForm.getElementListByName(""select"", true);
            for (Object select : selectList) {
                String name = ((TagNode) select).getAttributeByName(""name"");
                List optionList = ((TagNode) select).getElementListByName(""option"", true);
                String value = null;
                for (Object option : optionList) {
                    if (((TagNode) option).getAttributeByName(""selected"") != null) {
                        value = ((TagNode) option).getAttributeByName(""value"");
                        break;
                    }
                }
                if (name != null && value != null) {
                    postLanguageFormMethod.addParameter(name, value);
                }
            }
        } catch (IOException e) {
            String errorMessage = ""Error parsing language selection form at "" + logonMethod.getURI();
            LOGGER.error(errorMessage);
            throw new IOException(errorMessage);
        } finally {
            logonMethod.releaseConnection();
        }

        return DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, postLanguageFormMethod);
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,isAuthenticated,,23,28,20,4,0.25,0.1952,0,3,8,0,1,"/**
     * Look for session cookies.
     *
     * @return true if session cookies are available
     */
    protected boolean isAuthenticated(HttpMethod method) {
        boolean authenticated = false;
        if (method.getStatusCode() == HttpStatus.SC_OK
                && ""/ews/services.wsdl"".equalsIgnoreCase(method.getPath())) {
            // direct EWS access returned wsdl
            authenticated = true;
        } else {
            // check cookies
            for (Cookie cookie : httpClient.getState().getCookies()) {
                // Exchange 2003 cookies
                if (cookie.getName().startsWith(""cadata"") || ""sessionid"".equals(cookie.getName())
                        // Exchange 2007 cookie
                        || ""UserContext"".equals(cookie.getName())
                        // Direct EWS access
                        || ""exchangecookie"".equals(cookie.getName())
                        ) {
                    authenticated = true;
                    break;
                }
            }
        }
        return authenticated;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,checkFormLoginQueryString,,7,13,11,4,0.3333,0.0833,0,2,4,0,1,"protected void checkFormLoginQueryString(HttpMethod logonMethod) throws DavMailAuthenticationException {
        String queryString = logonMethod.getQueryString();
        if (queryString != null && (queryString.contains(""reason=2"") || queryString.contains(""reason=4""))) {
            logonMethod.releaseConnection();
            throwAuthenticationFailed();
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,throwAuthenticationFailed,,7,10,10,5,0.2,0,1,2,3,0,1,"protected void throwAuthenticationFailed() throws DavMailAuthenticationException {
        if (this.userName != null && this.userName.contains(""\\"")) {
            throw new DavMailAuthenticationException(""EXCEPTION_AUTHENTICATION_FAILED"");
        } else {
            throw new DavMailAuthenticationException(""EXCEPTION_AUTHENTICATION_FAILED_RETRY"");
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,purgeOldestTrashAndSentMessages,,11,21,14,3,0.25,0.1111,1,2,3,0,1,"/**
     * Delete oldest messages in trash.
     * keepDelay is the number of days to keep messages in trash before delete
     *
     * @throws IOException when unable to purge messages
     */
    public void purgeOldestTrashAndSentMessages() throws IOException {
        int keepDelay = Settings.getIntProperty(""davmail.keepDelay"");
        if (keepDelay != 0) {
            purgeOldestFolderMessages(TRASH, keepDelay);
        }
        // this is a new feature, default is : do nothing
        int sentKeepDelay = Settings.getIntProperty(""davmail.sentKeepDelay"");
        if (sentKeepDelay != 0) {
            purgeOldestFolderMessages(SENT, sentKeepDelay);
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,purgeOldestFolderMessages,,12,20,12,3,0.2188,0.0864,1,5,2,0,1,"protected void purgeOldestFolderMessages(String folderPath, int keepDelay) throws IOException {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DAY_OF_MONTH, -keepDelay);
        LOGGER.debug(""Delete messages in "" + folderPath + "" not modified since "" + cal.getTime());

        MessageList messages = searchMessages(folderPath, UID_MESSAGE_ATTRIBUTES,
                lt(""lastmodified"", formatSearchDate(cal.getTime())));

        for (Message message : messages) {
            message.delete();
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,convertResentHeader,,10,26,16,4,0.3111,0.1571,0,4,3,0,1,"protected void convertResentHeader(MimeMessage mimeMessage, String headerName) throws MessagingException {
        String[] resentHeader = mimeMessage.getHeader(""Resent-"" + headerName);
        if (resentHeader != null) {
            mimeMessage.removeHeader(""Resent-"" + headerName);
            mimeMessage.removeHeader(headerName);
            for (String value : resentHeader) {
                mimeMessage.addHeader(headerName, value);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,sendMessage,,34,151,92,4,0.1172,0.1746,1,7,8,0,1,"/**
     * Send message in reader to recipients.
     * Detect visible recipients in message body to determine bcc recipients
     *
     * @param rcptToRecipients recipients list
     * @param mimeMessage      mime message
     * @throws IOException        on error
     * @throws MessagingException on error
     */
    public void sendMessage(List<String> rcptToRecipients, MimeMessage mimeMessage) throws IOException, MessagingException {
        // detect duplicate send command
        String messageId = mimeMessage.getMessageID();
        if (lastSentMessageId != null && lastSentMessageId.equals(messageId)) {
            LOGGER.debug(""Dropping message id "" + messageId + "": already sent"");
            return;
        }
        lastSentMessageId = messageId;

        convertResentHeader(mimeMessage, ""From"");
        convertResentHeader(mimeMessage, ""To"");
        convertResentHeader(mimeMessage, ""Cc"");
        convertResentHeader(mimeMessage, ""Bcc"");
        convertResentHeader(mimeMessage, ""Message-Id"");

        // do not allow send as another user on Exchange 2003
        if (""Exchange2003"".equals(serverVersion) || Settings.getBooleanProperty(""davmail.smtpStripFrom"", false)) {
            mimeMessage.removeHeader(""From"");
        }

        // remove visible recipients from list
        Set<String> visibleRecipients = new HashSet<String>();
        List<InternetAddress> recipients = getAllRecipients(mimeMessage);
        for (InternetAddress address : recipients) {
            visibleRecipients.add((address.getAddress().toLowerCase()));
        }
        for (String recipient : rcptToRecipients) {
            if (!visibleRecipients.contains(recipient.toLowerCase())) {
                mimeMessage.addRecipient(javax.mail.Message.RecipientType.BCC, new InternetAddress(recipient));
            }
        }
        sendMessage(mimeMessage);

    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,refreshFolder,,21,36,0,3,0.4107,0.4528,1,2,5,0,1,"/**
     * Check folder ctag and reload messages as needed.
     *
     * @param currentFolder current folder
     * @return true if folder changed
     * @throws IOException on error
     */
    public boolean refreshFolder(Folder currentFolder) throws IOException {
        Folder newFolder = getFolder(currentFolder.folderPath);
        if (currentFolder.ctag == null || !currentFolder.ctag.equals(newFolder.ctag)) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(""Contenttag changed on "" + currentFolder.folderPath + ' '
                        + currentFolder.ctag + "" => "" + newFolder.ctag + "", reloading messages"");
            }
            currentFolder.hasChildren = newFolder.hasChildren;
            currentFolder.noInferiors = newFolder.noInferiors;
            currentFolder.unreadCount = newFolder.unreadCount;
            currentFolder.ctag = newFolder.ctag;
            currentFolder.etag = newFolder.etag;
            if (newFolder.uidNext > currentFolder.uidNext) {
                currentFolder.uidNext = newFolder.uidNext;
            }
            currentFolder.loadMessages();
            return true;
        } else {
            return false;
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,convertKeywordToFlag,,23,70,49,2,0.1825,0.081,1,7,5,0,1,"/**
     * Convert keyword value to IMAP flag.
     *
     * @param value keyword value
     * @return IMAP flag
     */
    public String convertKeywordToFlag(String value) {
        // first test for keyword in settings
        Properties flagSettings = Settings.getSubProperties(""davmail.imapFlags"");
        Enumeration flagSettingsEnum = flagSettings.propertyNames();
        while (flagSettingsEnum.hasMoreElements()) {
            String key = (String) flagSettingsEnum.nextElement();
            if (value.equalsIgnoreCase(flagSettings.getProperty(key))) {
                return key;
            }
        }

        ResourceBundle flagBundle = ResourceBundle.getBundle(""imapflags"");
        Enumeration<String> flagBundleEnum = flagBundle.getKeys();
        while (flagBundleEnum.hasMoreElements()) {
            String key = flagBundleEnum.nextElement();
            if (value.equalsIgnoreCase(flagBundle.getString(key))) {
                return key;
            }
        }

        // fall back to raw value
        return value;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,convertFlagToKeyword,,19,245,237,17,0.0565,0.0132,1,5,3,0,1,"/**
     * Convert IMAP flag to keyword value.
     *
     * @param value IMAP flag
     * @return keyword value
     */
    public String convertFlagToKeyword(String value) {
        // first test for flag in settings
        Properties flagSettings = Settings.getSubProperties(""davmail.imapFlags"");
        String flagValue = flagSettings.getProperty(value);
        if (flagValue != null) {
            return flagValue;
        }

        // fall back to predefined flags
        ResourceBundle flagBundle = ResourceBundle.getBundle(""imapflags"");
        try {
            return flagBundle.getString(value);
        } catch (MissingResourceException e) {
            // ignore
        }

        // fall back to raw value
        return value;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,searchEvents,,11,11,7,3,0.2667,0.1278,1,3,3,0,1,"/**
     * Search calendar events in provided folder.
     *
     * @param folderPath Exchange folder path
     * @param filter     search filter
     * @return list of calendar events
     * @throws IOException on error
     */
    public List<Event> searchEvents(String folderPath, Condition filter) throws IOException {

        Condition privateCondition = null;
        if (isSharedFolder(folderPath) && Settings.getBooleanProperty(""davmail.excludePrivateEvents"", true)) {
            LOGGER.debug(""Shared or public calendar: exclude private events"");
            privateCondition = isEqualTo(""sensitivity"", 0);
        }

        return searchEvents(folderPath, getItemProperties(),
                and(filter, privateCondition));
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,replaceIcal4Principal,,7,33,30,7,0.1852,0.1,0,1,3,0,1,"/**
     * Replace iCal4 (Snow Leopard) principal paths with mailto expression
     *
     * @param value attendee value or ics line
     * @return fixed value
     */
    protected String replaceIcal4Principal(String value) {
        if (value != null && value.contains(""/principals/__uuids__/"")) {
            return value.replaceAll(""/principals/__uuids__/([^/]*)__AT__([^/]*)/"", ""mailto:$1@$2"");
        } else {
            return value;
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,createOrUpdateItem,,9,56,46,8,0.1389,0.0577,1,5,3,0,1,"/**
     * Create or update item (event or contact) on the Exchange server
     *
     * @param folderPath Exchange folder path
     * @param itemName   event name
     * @param itemBody   event body in iCalendar format
     * @param etag       previous event etag to detect concurrent updates
     * @param noneMatch  if-none-match header value
     * @return HTTP response event result (status and etag)
     * @throws IOException on error
     */
    public ItemResult createOrUpdateItem(String folderPath, String itemName, String itemBody, String etag, String noneMatch) throws IOException {
        if (itemBody.startsWith(""BEGIN:VCALENDAR"")) {
            return internalCreateOrUpdateEvent(folderPath, itemName, ""urn:content-classes:appointment"", itemBody, etag, noneMatch);
        } else if (itemBody.startsWith(""BEGIN:VCARD"")) {
            return createOrUpdateContact(folderPath, itemName, itemBody, etag, noneMatch);
        } else {
            throw new IOException(BundleMessage.format(""EXCEPTION_INVALID_MESSAGE_CONTENT"", itemBody));
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,convertContactProperties,,7,7,4,3,0.45,0.213,0,4,4,0,1,"protected void convertContactProperties(Map<String, String> properties, String[] contactProperties, List<String> values) {
        for (int i = 0; i < values.size() && i < contactProperties.length; i++) {
            if (contactProperties[i] != null) {
                properties.put(contactProperties[i], values.get(i));
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,createOrUpdateContact,,129,409,0,2,0.1076,0.5498,0.428571429,10,55,0,1,"protected ItemResult createOrUpdateContact(String folderPath, String itemName, String itemBody, String etag, String noneMatch) throws IOException {
        // parse VCARD body to build contact property map
        Map<String, String> properties = new HashMap<String, String>();
        properties.put(""outlookmessageclass"", ""IPM.Contact"");

        VObject vcard = new VObject(new ICSBufferedReader(new StringReader(itemBody)));
        for (VProperty property : vcard.getProperties()) {
            if (""FN"".equals(property.getKey())) {
                properties.put(""cn"", property.getValue());
                properties.put(""subject"", property.getValue());
                properties.put(""fileas"", property.getValue());

            } else if (""N"".equals(property.getKey())) {
                convertContactProperties(properties, VCARD_N_PROPERTIES, property.getValues());
            } else if (""NICKNAME"".equals(property.getKey())) {
                properties.put(""nickname"", property.getValue());
            } else if (""TEL"".equals(property.getKey())) {
                if (property.hasParam(""TYPE"", ""cell"") || property.hasParam(""X-GROUP"", ""cell"")) {
                    properties.put(""mobile"", property.getValue());
                } else if (property.hasParam(""TYPE"", ""work"") || property.hasParam(""X-GROUP"", ""work"")) {
                    properties.put(""telephoneNumber"", property.getValue());
                } else if (property.hasParam(""TYPE"", ""home"") || property.hasParam(""X-GROUP"", ""home"")) {
                    properties.put(""homePhone"", property.getValue());
                } else if (property.hasParam(""TYPE"", ""fax"")) {
                    if (property.hasParam(""TYPE"", ""home"")) {
                        properties.put(""homefax"", property.getValue());
                    } else {
                        properties.put(""facsimiletelephonenumber"", property.getValue());
                    }
                } else if (property.hasParam(""TYPE"", ""pager"")) {
                    properties.put(""pager"", property.getValue());
                } else if (property.hasParam(""TYPE"", ""car"")) {
                    properties.put(""othermobile"", property.getValue());
                } else {
                    properties.put(""otherTelephone"", property.getValue());
                }
            } else if (""ADR"".equals(property.getKey())) {
                // address
                if (property.hasParam(""TYPE"", ""home"")) {
                    convertContactProperties(properties, VCARD_ADR_HOME_PROPERTIES, property.getValues());
                } else if (property.hasParam(""TYPE"", ""work"")) {
                    convertContactProperties(properties, VCARD_ADR_WORK_PROPERTIES, property.getValues());
                    // any other type goes to other address
                } else {
                    convertContactProperties(properties, VCARD_ADR_OTHER_PROPERTIES, property.getValues());
                }
            } else if (""EMAIL"".equals(property.getKey())) {
                if (property.hasParam(""TYPE"", ""home"")) {
                    properties.put(""email2"", property.getValue());
                    properties.put(""smtpemail2"", property.getValue());
                } else if (property.hasParam(""TYPE"", ""other"")) {
                    properties.put(""email3"", property.getValue());
                    properties.put(""smtpemail3"", property.getValue());
                } else {
                    properties.put(""email1"", property.getValue());
                    properties.put(""smtpemail1"", property.getValue());
                }
            } else if (""ORG"".equals(property.getKey())) {
                convertContactProperties(properties, VCARD_ORG_PROPERTIES, property.getValues());
            } else if (""URL"".equals(property.getKey())) {
                if (property.hasParam(""TYPE"", ""work"")) {
                    properties.put(""businesshomepage"", property.getValue());
                } else if (property.hasParam(""TYPE"", ""home"")) {
                    properties.put(""personalHomePage"", property.getValue());
                } else {
                    // default: set personal home page
                    properties.put(""personalHomePage"", property.getValue());
                }
            } else if (""TITLE"".equals(property.getKey())) {
                properties.put(""title"", property.getValue());
            } else if (""NOTE"".equals(property.getKey())) {
                properties.put(""description"", property.getValue());
            } else if (""CUSTOM1"".equals(property.getKey())) {
                properties.put(""extensionattribute1"", property.getValue());
            } else if (""CUSTOM2"".equals(property.getKey())) {
                properties.put(""extensionattribute2"", property.getValue());
            } else if (""CUSTOM3"".equals(property.getKey())) {
                properties.put(""extensionattribute3"", property.getValue());
            } else if (""CUSTOM4"".equals(property.getKey())) {
                properties.put(""extensionattribute4"", property.getValue());
            } else if (""ROLE"".equals(property.getKey())) {
                properties.put(""profession"", property.getValue());
            } else if (""X-AIM"".equals(property.getKey())) {
                properties.put(""im"", property.getValue());
            } else if (""BDAY"".equals(property.getKey())) {
                properties.put(""bday"", convertBDayToZulu(property.getValue()));
            } else if (""ANNIVERSARY"".equals(property.getKey()) || ""X-ANNIVERSARY"".equals(property.getKey())) {
                properties.put(""anniversary"", convertBDayToZulu(property.getValue()));
            } else if (""CATEGORIES"".equals(property.getKey())) {
                properties.put(""keywords"", property.getValue());
            } else if (""CLASS"".equals(property.getKey())) {
                if (""PUBLIC"".equals(property.getValue())) {
                    properties.put(""sensitivity"", ""0"");
                    properties.put(""private"", ""false"");
                } else {
                    properties.put(""sensitivity"", ""2"");
                    properties.put(""private"", ""true"");
                }
            } else if (""SEX"".equals(property.getKey())) {
                String propertyValue = property.getValue();
                if (""1"".equals(propertyValue)) {
                    properties.put(""gender"", ""2"");
                } else if (""2"".equals(propertyValue)) {
                    properties.put(""gender"", ""1"");
                }
            } else if (""FBURL"".equals(property.getKey())) {
                properties.put(""fburl"", property.getValue());
            } else if (""X-ASSISTANT"".equals(property.getKey())) {
                properties.put(""secretarycn"", property.getValue());
            } else if (""X-MANAGER"".equals(property.getKey())) {
                properties.put(""manager"", property.getValue());
            } else if (""X-SPOUSE"".equals(property.getKey())) {
                properties.put(""spousecn"", property.getValue());
            } else if (""PHOTO"".equals(property.getKey())) {
                properties.put(""photo"", property.getValue());
                properties.put(""haspicture"", ""true"");
            }
        }
        LOGGER.debug(""Create or update contact "" + itemName + "": "" + properties);
        // reset missing properties to null
        for (String key : CONTACT_ATTRIBUTES) {
            if (!""imapUid"".equals(key) && !""etag"".equals(key) && !""urlcompname"".equals(key)
                    && !""lastmodified"".equals(key) && !""sensitivity"".equals(key) &&
                    !properties.containsKey(key)) {
                properties.put(key, null);
            }
        }
        return internalCreateOrUpdateContact(folderPath, itemName, properties, etag, noneMatch);
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,convertZuluDateToBday,,15,52,38,4,0.1771,0.0787,0,5,4,0,1,"protected String convertZuluDateToBday(String value) {
        String result = null;
        if (value != null && value.length() > 0) {
            try {
                SimpleDateFormat parser = ExchangeSession.getZuluDateFormat();
                Calendar cal = Calendar.getInstance();
                cal.setTime(parser.parse(value));
                cal.add(Calendar.HOUR_OF_DAY, 12);
                result = ExchangeSession.getVcardBdayFormat().format(cal.getTime());
            } catch (ParseException e) {
                LOGGER.warn(""Invalid date: "" + value);
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSession,convertBDayToZulu,,21,67,43,4,0.1939,0.1285,0,4,6,0,1,"protected String convertBDayToZulu(String value) {
        String result = null;
        if (value != null && value.length() > 0) {
            try {
                SimpleDateFormat parser;
                if (value.length() == 10) {
                    parser = ExchangeSession.getVcardBdayFormat();
                } else if (value.length() == 15) {
                    parser = new SimpleDateFormat(""yyyyMMdd'T'HHmmss"", Locale.ENGLISH);
                    parser.setTimeZone(GMT_TIMEZONE);
                } else {
                    parser = ExchangeSession.getExchangeZuluDateFormat();
                }
                result = ExchangeSession.getExchangeZuluDateFormatMillisecond().format(parser.parse(value));
            } catch (ParseException e) {
                LOGGER.warn(""Invalid date: "" + value);
            }
        }

        return result;
    }"
davmail-4.5.1,davmail.exchange.FolderLoadThread,run,,9,14,13,5,0.2222,0.0714,1,1,2,0,1,"public void run() {
        try {
            folder.loadMessages();
        } catch (IOException e) {
            exception = e;
        } finally {
            isComplete = true;
        }
    }"
davmail-4.5.1,davmail.exchange.FolderLoadThread,loadFolder,,21,67,43,5,0.1633,0.1941,1,4,5,0,1,"/**
     * Load folder in a separate thread.
     *
     * @param folder       current folder
     * @param outputStream client connection
     * @throws InterruptedException on error
     * @throws IOException          on error
     */
    public static void loadFolder(ExchangeSession.Folder folder, OutputStream outputStream) throws InterruptedException, IOException {
        FolderLoadThread folderLoadThread = new FolderLoadThread(currentThread().getName(), folder);
        folderLoadThread.start();
        while (!folderLoadThread.isComplete) {
            folderLoadThread.join(20000);
            LOGGER.debug(""Still loading "" + folder.folderPath + "" ("" + folder.count() + "" messages)"");
            if (Settings.getBooleanProperty(""davmail.enableKeepAlive"", false)) {
                try {
                    outputStream.write(' ');
                    outputStream.flush();
                } catch (SocketException e) {
                    folderLoadThread.interrupt();
                    throw e;
                }
            }
        }
        if (folderLoadThread.exception != null) {
            throw folderLoadThread.exception;
        }

    }"
davmail-4.5.1,davmail.exchange.ICSBufferedReader,readLine,,25,31,0,3,0.5417,0.3769,0,0,9,0,1,"/**
     * Read a line from input reader, unwrap long lines.
     */
    @Override
    public String readLine() throws IOException {
        if (nextLine == null) {
            return null;
        } else {
            currentLine.setLength(0);
            currentLine.append(nextLine);
            nextLine = super.readLine();
            while (nextLine != null && !(nextLine.length() == 0) &&
                    (nextLine.charAt(0) == ' ' || nextLine.charAt(0) == '\t'
                            // workaround for broken items with \n as first line character
                            || nextLine.charAt(0) == '\\'
                            // workaround for Exchange 2010 bug
                            || nextLine.charAt(0) == ':')) {
                // Timezone ends with \n => next line starts with :
                if (nextLine.charAt(0) == ':') {
                    currentLine.append(nextLine);
                } else {
                    currentLine.append(nextLine.substring(1));
                }
                nextLine = super.readLine();
            }
            return currentLine.toString();
        }
    }"
davmail-4.5.1,davmail.exchange.ICSBufferedWriter,writeLine,,15,51,36,5,0.2708,0.1361,0,3,3,0,1,"/**
     * Write line with or without continuation prefix.
     *
     * @param line   line content
     * @param prefix continuation flag
     */
    public void writeLine(String line, boolean prefix) {
        int maxLength = 77;
        if (prefix) {
            maxLength--;
            buffer.append(' ');
        }
        if (line.length() > maxLength) {
            buffer.append(line.substring(0, maxLength));
            newLine();
            writeLine(line.substring(maxLength), true);
        } else {
            buffer.append(line);
            newLine();
        }
    }"
davmail-4.5.1,davmail.exchange.ICSBufferedWriter,appendProperty,,10,10,0,2,0.381,0.3254,0,3,3,0,1,"/**
     * Append single value property
     *
     * @param propertyName  property name
     * @param propertyValue property value
     */
    public void appendProperty(String propertyName, String propertyValue) {
        if ((propertyValue != null) && (propertyValue.length() > 0)) {
            StringBuilder lineBuffer = new StringBuilder();
            lineBuffer.append(propertyName);
            lineBuffer.append(':');
            appendMultilineEncodedValue(lineBuffer, propertyValue);
            writeLine(lineBuffer.toString());
        }

    }"
davmail-4.5.1,davmail.exchange.ICSBufferedWriter,appendMultilineEncodedValue,,11,16,11,3,0.3571,0.125,0,4,4,0,1,"/**
     * Append and encode \n to \\n in value.
     *
     * @param buffer line buffer
     * @param value  value
     */
    protected void appendMultilineEncodedValue(StringBuilder buffer, String value) {
        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);
            if (c == '\n') {
                buffer.append(""\\n"");
            // skip carriage return
            } else if (c != '\r') {
                buffer.append(value.charAt(i));
            }
        }
    }"
davmail-4.5.1,davmail.exchange.MimeOutputStreamWriter,writeHeader,,9,14,13,3,0.2222,0.0417,0,2,3,0,1,"/**
     * Write MIME header
     *
     * @param header header name
     * @param value  header value
     * @throws IOException on error
     */
    public void writeHeader(String header, String value) throws IOException {
        // do not write empty headers
        if (value != null && value.length() > 0) {
            write(header);
            write("": "");
            write(MimeUtility.encodeText(value, ""UTF-8"", null));
            writeLn();
        }
    }"
davmail-4.5.1,davmail.exchange.DoubleDotOutputStream,write,,11,15,9,3,0.381,0.1583,0,1,5,0,1,"@Override
    public void write(int b) throws IOException {
        if (b == '.' && (buf[0] == '\r' || buf[0] == '\n' || buf[0] == 0)) {
            // line starts with '.', prepend it with an additional '.'
            out.write('.');
        }
        out.write(b);

        buf[1] = buf[0];
        buf[0] = b;
    }"
davmail-4.5.1,davmail.exchange.DoubleDotOutputStream,close,,10,18,8,4,0.375,0.3704,0,0,3,0,1,"/**
     * RFC 1939: 3 Basic Operations
     * [...]
     * Hence a multi-line response is terminated with the five octets
     * ""CRLF.CRLF""
     * <p/>
     * Do not close actual outputstream
     *
     * @throws IOException on error
     */
    @Override
    public void close() throws IOException {
        if (buf[1] != '\r' || buf[0] != '\n') {
            out.write('\r');
            out.write('\n');
        }
        out.write('.');
        out.write('\r');
        out.write('\n');
    }"
davmail-4.5.1,davmail.exchange.ExchangeSessionFactory,convertUserName,,9,14,7,3,0.3571,0.1542,1,3,4,0,1,"private static String convertUserName(String userName) {
        String result = userName;
        // prepend default windows domain prefix
        String defaultDomain = Settings.getProperty(""davmail.defaultDomain"");
        if (defaultDomain != null && userName.indexOf('\\') < 0 && userName.indexOf('@') < 0) {
            result = defaultDomain + '\\' + userName;
        }
        return result;
    }"
davmail-4.5.1,davmail.exchange.ExchangeSessionFactory,checkConfig,,26,78,51,5,0.16,0.104,0.6,5,8,0,1,"/**
     * Send a request to Exchange server to check current settings.
     *
     * @throws IOException if unable to access Exchange server
     */
    public static void checkConfig() throws IOException {
        String url = Settings.getProperty(""davmail.url"");
        if (url == null || (!url.startsWith(""http://"") && !url.startsWith(""https://""))) {
             throw new DavMailException(""LOG_INVALID_URL"", url);
        }
        HttpClient httpClient = DavGatewayHttpClientFacade.getInstance(url);
        GetMethod testMethod = new GetMethod(url);
        try {
            // get webMail root url (will not follow redirects)
            int status = DavGatewayHttpClientFacade.executeTestMethod(httpClient, testMethod);
            ExchangeSession.LOGGER.debug(""Test configuration status: "" + status);
            if (status != HttpStatus.SC_OK && status != HttpStatus.SC_UNAUTHORIZED
                    && !DavGatewayHttpClientFacade.isRedirect(status)) {
                throw new DavMailException(""EXCEPTION_CONNECTION_FAILED"", url, status);
            }
            // session opened, future failure will mean network down
            configChecked = true;
            // Reset so next time an problem occurs message will be sent once
            errorSent = false;
        } catch (Exception exc) {
            handleNetworkDown(exc);
        } finally {
            testMethod.releaseConnection();
        }

    }"
davmail-4.5.1,davmail.exchange.ExchangeSessionFactory,handleNetworkDown,,22,71,51,4,0.2024,0.1231,0.75,2,6,0,1,"private static void handleNetworkDown(Exception exc) throws DavMailException {
        if (!checkNetwork() || configChecked) {
            ExchangeSession.LOGGER.warn(BundleMessage.formatLog(""EXCEPTION_NETWORK_DOWN""));
            // log full stack trace for unknown errors
            if (!((exc instanceof UnknownHostException)||(exc instanceof NetworkDownException))) {
                ExchangeSession.LOGGER.debug(exc, exc);
            }
            throw new NetworkDownException(""EXCEPTION_NETWORK_DOWN"");
        } else {
            BundleMessage message = new BundleMessage(""EXCEPTION_CONNECT"", exc.getClass().getName(), exc.getMessage());
            if (errorSent) {
                ExchangeSession.LOGGER.warn(message);
                throw new NetworkDownException(""EXCEPTION_DAVMAIL_CONFIGURATION"", message);
            } else {
                // Mark that an error has been sent so you only get one
                // error in a row (not a repeating string of errors).
                errorSent = true;
                ExchangeSession.LOGGER.error(message);
                throw new DavMailException(""EXCEPTION_DAVMAIL_CONFIGURATION"", message);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ExchangeSessionFactory,checkNetwork,,21,82,59,5,0.1714,0.1218,0,5,8,0,1,"/**
     * Check if at least one network interface is up and active (i.e. has an address)
     *
     * @return true if network available
     */
    static boolean checkNetwork() {
        boolean up = false;
        Enumeration<NetworkInterface> enumeration;
        try {
            enumeration = NetworkInterface.getNetworkInterfaces();
            if (enumeration != null) {
                while (!up && enumeration.hasMoreElements()) {
                    NetworkInterface networkInterface = enumeration.nextElement();
                    //noinspection Since15
                    up = networkInterface.isUp() && !networkInterface.isLoopback()
                            && networkInterface.getInetAddresses().hasMoreElements();
                }
            }
        } catch (NoSuchMethodError error) {
            ExchangeSession.LOGGER.debug(""Unable to test network interfaces (not available under Java 1.5)"");
            up = true;
        } catch (SocketException exc) {
            ExchangeSession.LOGGER.error(""DavMail configuration exception: \n Error listing network interfaces "" + exc.getMessage(), exc);
        }
        return up;
    }"
davmail-4.5.1,davmail.exchange.MessageCreateThread,run,,9,14,13,5,0.1905,0.0714,1,1,2,0,1,"public void run() {
        try {
            session.createMessage(folderPath, messageName, properties, mimeMessage);
        } catch (IOException e) {
            exception = e;
        } finally {
            isComplete = true;
        }
    }"
davmail-4.5.1,davmail.exchange.MessageCreateThread,createMessage,,26,117,81,5,0.1071,0.1435,1,9,6,0,1,"/**
     * Create message in a separate thread.
     *
     * @param folder       current folder
     * @param outputStream client connection
     * @throws InterruptedException on error
     * @throws IOException          on error
     */
    public static void createMessage(ExchangeSession session, String folderPath, String messageName, HashMap<String, String> properties, MimeMessage mimeMessage, OutputStream outputStream, String capabilities) throws InterruptedException, IOException {
        MessageCreateThread messageCreateThread = new MessageCreateThread(currentThread().getName(), session, folderPath, messageName, properties, mimeMessage);
        messageCreateThread.start();
        while (!messageCreateThread.isComplete) {
            messageCreateThread.join(20000);
            if (!messageCreateThread.isComplete) {
                if (Settings.getBooleanProperty(""davmail.enableKeepAlive"", false)) {
                    LOGGER.debug(""Still loading message, send capabilities untagged response to avoid timeout"");
                    try {
                        LOGGER.debug(""* ""+capabilities);
                        outputStream.write((""* ""+capabilities).getBytes(""ASCII""));
                        outputStream.write((char) 13);
                        outputStream.write((char) 10);
                        outputStream.flush();
                    } catch (SocketException e) {
                        messageCreateThread.interrupt();
                        throw e;
                    }
                }
            }
        }
        if (messageCreateThread.exception != null) {
            throw messageCreateThread.exception;
        }

    }"
davmail-4.5.1,davmail.exchange.DoubleDotInputStream,read,,32,59,13,3,0.3333,0.3686,0,1,9,0,1,"@Override
    public int read() throws IOException {
        int b = super.read();
        if (b == '\r') {
            // \r\n
            if (readNextByte() == '\n') {
                // \r\n.
                if (readNextByte() == '.') {
                    // \r\n.\r
                    if (readNextByte() == '\r') {
                        // \r\n.\r\n
                        if (readNextByte() == '\n') {
                            // end of stream
                            index = -1;
                            b = -1;
                        }
                        // \r\n..
                    } else if (buffer[index] == '.') {
                        // replace double dot
                        index--;
                    }
                }
            }
            // push back characters
            if (index >= 0) {
                while (index >= 0) {
                    unread(buffer[index--]);
                }
            }
        }
        return b;
    }"
davmail-4.5.1,davmail.exchange.MessageLoadThread,run,,11,22,16,5,0.25,0.2222,1,2,3,0,1,"public void run() {
        try {
            message.loadMimeMessage();
        } catch (IOException e) {
            ioException = e;
        } catch (MessagingException e) {
            messagingException = e;
        } finally {
            isComplete = true;
        }
    }"
davmail-4.5.1,davmail.exchange.MessageLoadThread,loadMimeMessage,,34,195,137,6,0.1553,0.1766,0.4,5,8,0,1,"/**
     * Load mime message in a separate thread if over 1MB.
     * Send a space character every ten seconds to avoid client timeouts
     *
     * @param message      message
     * @param outputStream output stream
     * @throws IOException        on error
     * @throws MessagingException on error
     */
    public static void loadMimeMessage(ExchangeSession.Message message, OutputStream outputStream) throws IOException, MessagingException {
        if (message.size < 1024 * 1024) {
            message.loadMimeMessage();
        } else {
            LOGGER.debug(""Load large message "" + (message.size / 1024) + ""KB uid "" + message.getUid() + "" imapUid "" + message.getImapUid() + "" in a separate thread"");
            try {
                MessageLoadThread messageLoadThread = new MessageLoadThread(currentThread().getName(), message);
                messageLoadThread.start();
                while (!messageLoadThread.isComplete) {
                    messageLoadThread.join(10000);
                    LOGGER.debug(""Still loading uid "" + message.getUid() + "" imapUid "" + message.getImapUid());
                    if (Settings.getBooleanProperty(""davmail.enableKeepAlive"", false)) {
                        try {
                            outputStream.write(' ');
                            outputStream.flush();
                        } catch (SocketException e) {
                            // client closed connection, stop thread
                            message.dropMimeMessage();
                            messageLoadThread.interrupt();
                            throw e;
                        }
                    }
                }
                if (messageLoadThread.ioException != null) {
                    throw messageLoadThread.ioException;
                }
                if (messageLoadThread.messagingException != null) {
                    throw messageLoadThread.messagingException;
                }
            } catch (InterruptedException e) {
                throw new IOException(e + "" "" + e.getMessage());
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VCardWriter,appendProperty,,24,109,82,4,0.1681,0.1333,1,7,7,0,1,"/**
     * Append compound value
     *
     * @param propertyName  property name
     * @param propertyValue property values
     */
    public void appendProperty(String propertyName, String... propertyValue) {
        boolean hasValue = false;
        for (String value : propertyValue) {
            if ((value != null) && (value.length() > 0)) {
                hasValue = true;
                break;
            }
        }
        if (hasValue) {
            boolean first = true;
            StringBuilder lineBuffer = new StringBuilder();
            lineBuffer.append(propertyName);
            lineBuffer.append(':');
            for (String value : propertyValue) {
                if (first) {
                    first = false;
                } else {
                    lineBuffer.append(';');
                }
                appendEncodedValue(lineBuffer, value);
            }
            writeLine(lineBuffer.toString());
        }
    }"
davmail-4.5.1,davmail.exchange.VCardWriter,appendEncodedValue,,15,27,9,3,0.375,0.2083,0,4,6,0,1,"/**
     * Encode and append value to buffer
     *
     * @param buffer current buffer
     * @param value  property value
     */
    private void appendEncodedValue(StringBuilder buffer, String value) {
        if (value != null) {
            for (int i = 0; i < value.length(); i++) {
                char c = value.charAt(i);
                if (c == ',' || c == ';') {
                    buffer.append('\\');
                }
                if (c == '\n') {
                    buffer.append(""\\n"");
                } else {
                    buffer.append(value.charAt(i));
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VObject,VObject,,19,68,45,4,0.2262,0.1307,0.5,5,6,0,1,"/**
     * Create VObject with given type
     *
     * @param beginProperty first line property
     * @param reader        stream reader just after the BEGIN:TYPE line
     * @throws IOException on error
     */
    public VObject(VProperty beginProperty, BufferedReader reader) throws IOException {
        if (!""BEGIN"".equals(beginProperty.getKey())) {
            throw new IOException(""Invalid first line: "" + beginProperty);
        }
        type = beginProperty.getValue();
        String beginLine = ""BEGIN:"" + type;
        String endLine = ""END:"" + type;
        String line = reader.readLine();
        while (line != null && !line.startsWith(endLine)) {
            // ignore invalid BEGIN line inside object (Sogo Carddav issue)
            if (!beginLine.equals(line)) {
                handleLine(line, reader);
            }
            line = reader.readLine();
        }
        if (line == null) {
            throw new IOException(""Unexpected end of stream"");
        }
    }"
davmail-4.5.1,davmail.exchange.VObject,handleLine,,12,8,0,2,0.3929,0.3373,0.5,3,4,0,1,"protected void handleLine(String line, BufferedReader reader) throws IOException {
        // skip empty lines
        if (line.length() > 0) {
            VProperty property = new VProperty(line);
            // inner object
            if (""BEGIN"".equals(property.getKey())) {
                addVObject(new VObject(property, reader));
            } else if (property.getKey() != null) {
                addProperty(property);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VObject,writeTo,,16,47,28,3,0.2222,0.1436,0.666666667,3,5,0,1,"/**
     * Write VObject to writer.
     *
     * @param writer buffered writer
     */
    public void writeTo(ICSBufferedWriter writer) {
        writer.write(""BEGIN:"");
        writer.writeLine(type);
        if (properties != null) {
            for (VProperty property : properties) {
                writer.writeLine(property.toString());
            }
        }
        if (vObjects != null) {
            for (VObject object : vObjects) {
                object.writeTo(writer);
            }
        }
        writer.write(""END:"");
        writer.writeLine(type);
    }"
davmail-4.5.1,davmail.exchange.VObject,addPropertyValue,,6,8,6,3,0.3333,0.0741,1,3,2,0,1,"/**
     * Add vProperty value on vObject.
     *
     * @param name  property name
     * @param value property value
     */
    public void addPropertyValue(String name, String value) {
        if (value != null) {
            VProperty property = new VProperty(name, value);
            addProperty(property);
        }
    }"
davmail-4.5.1,davmail.exchange.VObject,removeProperty,,8,10,5,3,0.3889,0.1905,0,2,3,0,1,"/**
     * Remove vProperty from vObject.
     *
     * @param name property name
     */
    public void removeProperty(String name) {
        if (properties != null) {
            VProperty property = getProperty(name);
            if (property != null) {
                properties.remove(property);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VCalendar,VCalendar,,11,27,26,7,0.15,0.04,0,5,4,0,1,"/**
     * Create VCalendar object from reader;
     *
     * @param reader    stream reader
     * @param email     current user email
     * @param vTimezone user OWA timezone
     * @throws IOException on error
     */
    public VCalendar(BufferedReader reader, String email, VObject vTimezone) throws IOException {
        super(reader);
        if (!""VCALENDAR"".equals(type)) {
            throw new IOException(""Invalid type: "" + type);
        }
        this.email = email;
        // set OWA timezone information
        if (this.vTimezone == null && vTimezone != null) {
            setTimezone(vTimezone);
        }
    }"
davmail-4.5.1,davmail.exchange.VCalendar,addVObject,,10,11,1,3,0.381,0.2833,0,1,5,0,1,"@Override
    public void addVObject(VObject vObject) {
        super.addVObject(vObject);
        if (firstVevent == null && (""VEVENT"".equals(vObject.type) || ""VTODO"".equals(vObject.type))) {
            firstVevent = vObject;
        }
        if (""VTIMEZONE"".equals(vObject.type)) {
            vTimezone = vObject;
        }
    }"
davmail-4.5.1,davmail.exchange.VCalendar,fixVCalendar,,150,1917,513,4,0.0787,0.2093,0.375,16,44,0,1,"protected void fixVCalendar(boolean fromServer) {
        // set iCal 4 global X-CALENDARSERVER-ACCESS from CLASS
        if (fromServer) {
            setPropertyValue(""X-CALENDARSERVER-ACCESS"", getCalendarServerAccess());
        }

        // iCal 4 global X-CALENDARSERVER-ACCESS
        String calendarServerAccess = getPropertyValue(""X-CALENDARSERVER-ACCESS"");
        String now = ExchangeSession.getZuluDateFormat().format(new Date());

        // fix method from iPhone
        if (!fromServer && getPropertyValue(""METHOD"") == null) {
            setPropertyValue(""METHOD"", ""PUBLISH"");
        }

        // rename TZID for maximum iCal/iPhone compatibility
        String tzid = null;
        if (fromServer) {
            // get current tzid
            VObject vObject = vTimezone;
            if (vObject != null) {
                String currentTzid = vObject.getPropertyValue(""TZID"");
                // fix TZID with \n (Exchange 2010 bug)
                if (currentTzid != null && currentTzid.endsWith(""\n"")) {
                    currentTzid = currentTzid.substring(0, currentTzid.length() - 1);
                    vObject.setPropertyValue(""TZID"", currentTzid);
                }
                if (currentTzid != null && currentTzid.indexOf(' ') >= 0) {
                    try {
                        tzid = ResourceBundle.getBundle(""timezones"").getString(currentTzid);
                        vObject.setPropertyValue(""TZID"", tzid);
                    } catch (MissingResourceException e) {
                        LOGGER.debug(""Timezone "" + currentTzid + "" not found in rename table"");
                    }
                }
            }
        }

        if (!fromServer) {
            fixTimezone();
        }

        // iterate over vObjects
        for (VObject vObject : vObjects) {
            if (""VEVENT"".equals(vObject.type)) {
                if (calendarServerAccess != null) {
                    vObject.setPropertyValue(""CLASS"", getEventClass(calendarServerAccess));
                    // iCal 3, get X-CALENDARSERVER-ACCESS from local VEVENT
                } else if (vObject.getPropertyValue(""X-CALENDARSERVER-ACCESS"") != null) {
                    vObject.setPropertyValue(""CLASS"", getEventClass(vObject.getPropertyValue(""X-CALENDARSERVER-ACCESS"")));
                }
                if (fromServer) {
                    // remove organizer line for event without attendees for iPhone
                    if (vObject.getProperty(""ATTENDEE"") == null) {
                        vObject.setPropertyValue(""ORGANIZER"", null);
                    }
                    // detect allday and update date properties
                    if (isCdoAllDay(vObject)) {
                        setClientAllday(vObject.getProperty(""DTSTART""));
                        setClientAllday(vObject.getProperty(""DTEND""));
                        setClientAllday(vObject.getProperty(""RECURRENCE-ID""));
                    }
                    String cdoBusyStatus = vObject.getPropertyValue(""X-MICROSOFT-CDO-BUSYSTATUS"");
                    if (cdoBusyStatus != null) {
                        vObject.setPropertyValue(""TRANSP"",
                                !""FREE"".equals(cdoBusyStatus) ? ""OPAQUE"" : ""TRANSPARENT"");
                    }

                    // Apple iCal doesn't understand this key, and it's entourage
                    // specific (i.e. not needed by any caldav client): strip it out
                    vObject.removeProperty(""X-ENTOURAGE_UUID"");

                    splitExDate(vObject);

                    // remove empty properties
                    if ("""".equals(vObject.getPropertyValue(""LOCATION""))) {
                        vObject.removeProperty(""LOCATION"");
                    }
                    if ("""".equals(vObject.getPropertyValue(""DESCRIPTION""))) {
                        vObject.removeProperty(""DESCRIPTION"");
                    }
                    if ("""".equals(vObject.getPropertyValue(""CLASS""))) {
                        vObject.removeProperty(""CLASS"");
                    }
                    // rename TZID
                    if (tzid != null) {
                        VProperty dtStart = vObject.getProperty(""DTSTART"");
                        if (dtStart != null && dtStart.getParam(""TZID"") != null) {
                            dtStart.setParam(""TZID"", tzid);
                        }
                        VProperty dtEnd = vObject.getProperty(""DTEND"");
                        if (dtEnd != null && dtEnd.getParam(""TZID"") != null) {
                            dtEnd.setParam(""TZID"", tzid);
                        }
                        VProperty reccurrenceId = vObject.getProperty(""RECURRENCE-ID"");
                        if (reccurrenceId != null && reccurrenceId.getParam(""TZID"") != null) {
                            reccurrenceId.setParam(""TZID"", tzid);
                        }
                    }
                    // remove unsupported attachment reference
                    if (vObject.getProperty(""ATTACH"") != null) {
                        List<String> toRemoveValues = null;
                        List<String> values = vObject.getProperty(""ATTACH"").getValues();
                        for (String value : values) {
                            if (value.contains(""CID:"")) {
                                if (toRemoveValues == null) {
                                    toRemoveValues = new ArrayList<String>();
                                }
                                toRemoveValues.add(value);
                            }
                        }
                        if (toRemoveValues != null) {
                            values.removeAll(toRemoveValues);
                            if (values.size() == 0) {
                                vObject.removeProperty(""ATTACH"");
                            }
                        }
                    }
                } else {
                    // add organizer line to all events created in Exchange for active sync
                    String organizer = getEmailValue(vObject.getProperty(""ORGANIZER""));
                    if (organizer == null) {
                        vObject.setPropertyValue(""ORGANIZER"", ""MAILTO:"" + email);
                    } else if (!email.equalsIgnoreCase(organizer) && vObject.getProperty(""X-MICROSOFT-CDO-REPLYTIME"") == null) {
                        vObject.setPropertyValue(""X-MICROSOFT-CDO-REPLYTIME"", now);
                    }
                    // set OWA allday flag
                    vObject.setPropertyValue(""X-MICROSOFT-CDO-ALLDAYEVENT"", isAllDay(vObject) ? ""TRUE"" : ""FALSE"");
                    if (vObject.getPropertyValue(""TRANSP"") != null) {
                        vObject.setPropertyValue(""X-MICROSOFT-CDO-BUSYSTATUS"",
                                !""TRANSPARENT"".equals(vObject.getPropertyValue(""TRANSP"")) ? ""BUSY"" : ""FREE"");
                    }

                    if (isAllDay(vObject)) {
                        // convert date values to outlook compatible values
                        setServerAllday(vObject.getProperty(""DTSTART""));
                        setServerAllday(vObject.getProperty(""DTEND""));
                    } else {
                        fixTzid(vObject.getProperty(""DTSTART""));
                        fixTzid(vObject.getProperty(""DTEND""));
                    }
                }

                fixAttendees(vObject, fromServer);

                fixAlarm(vObject, fromServer);
            }
        }

    }"
davmail-4.5.1,davmail.exchange.VCalendar,fixTimezone,,38,141,29,3,0.2609,0.2097,0.666666667,5,21,0,1,"private void fixTimezone() {
        if (vTimezone != null && vTimezone.vObjects != null && vTimezone.vObjects.size() > 2) {
            VObject standard = null;
            VObject daylight = null;
            for (VObject vObject : vTimezone.vObjects) {
                if (""STANDARD"".equals(vObject.type)) {
                    if (standard == null ||
                            (vObject.getPropertyValue(""DTSTART"").compareTo(standard.getPropertyValue(""DTSTART"")) > 0)) {
                        standard = vObject;
                    }
                }
                if (""DAYLIGHT"".equals(vObject.type)) {
                    if (daylight == null ||
                            (vObject.getPropertyValue(""DTSTART"").compareTo(daylight.getPropertyValue(""DTSTART"")) > 0)) {
                        daylight = vObject;
                    }
                }
            }
            vTimezone.vObjects.clear();
            vTimezone.vObjects.add(standard);
            vTimezone.vObjects.add(daylight);
        }
        // fix 3569922: quick workaround for broken Israeli Timezone issue
        if (vTimezone != null && vTimezone.vObjects != null) {
            for (VObject vObject:vTimezone.vObjects) {
                VProperty rrule = vObject.getProperty(""RRULE"");
                if (rrule != null && rrule.getValues().size() == 3 && ""BYDAY=-2SU"".equals(rrule.getValues().get(1))) {
                    rrule.getValues().set(1, ""BYDAY=4SU"");
                }
                // Fix 555 another broken Israeli timezone
                if (rrule != null && rrule.getValues().size() == 4 && ""BYDAY=FR"".equals(rrule.getValues().get(1))
                        && ""BYMONTHDAY=23,24,25,26,27,28,29"".equals(rrule.getValues().get(2))) {
                    rrule.getValues().set(1, ""BYDAY=-1FR"");
                    rrule.getValues().remove(2);
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VCalendar,splitExDate,,17,44,22,3,0.2639,0.1205,0.285714286,6,5,0,1,"protected void splitExDate(VObject vObject) {
        List<VProperty> exDateProperties = vObject.getProperties(""EXDATE"");
        if (exDateProperties != null) {
            for (VProperty property : exDateProperties) {
                String value = property.getValue();
                if (value.indexOf(',') >= 0) {
                    // split property
                    vObject.removeProperty(property);
                    for (String singleValue : value.split("","")) {
                        VProperty singleProperty = new VProperty(""EXDATE"", singleValue);
                        singleProperty.setParams(property.getParams());
                        vObject.addProperty(singleProperty);
                    }
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VCalendar,fixAlarm,,46,184,115,3,0.1609,0.1141,0.428571429,8,16,0,1,"protected void fixAlarm(VObject vObject, boolean fromServer) {
        if (vObject.vObjects != null) {
            if (Settings.getBooleanProperty(""davmail.caldavDisableReminders"", false)) {
                ArrayList<VObject> vAlarms = null;
                for (VObject vAlarm : vObject.vObjects) {
                    if (""VALARM"".equals(vAlarm.type)) {
                        if (vAlarms == null) {
                            vAlarms = new ArrayList<VObject>();
                        }
                        vAlarms.add(vAlarm);
                    }
                }
                // remove all vAlarms
                if (vAlarms != null) {
                    for (VObject vAlarm : vAlarms) {
                        vObject.vObjects.remove(vAlarm);
                    }
                }

            } else {
                for (VObject vAlarm : vObject.vObjects) {
                    if (""VALARM"".equals(vAlarm.type)) {
                        String action = vAlarm.getPropertyValue(""ACTION"");
                        if (fromServer && ""DISPLAY"".equals(action)
                                // convert DISPLAY to AUDIO only if user defined an alarm sound
                                && Settings.getProperty(""davmail.caldavAlarmSound"") != null) {
                            // Convert alarm to audio for iCal
                            vAlarm.setPropertyValue(""ACTION"", ""AUDIO"");

                            if (vAlarm.getPropertyValue(""ATTACH"") == null) {
                                // Add defined sound into the audio alarm
                                VProperty vProperty = new VProperty(""ATTACH"", Settings.getProperty(""davmail.caldavAlarmSound""));
                                vProperty.addParam(""VALUE"", ""URI"");
                                vAlarm.addProperty(vProperty);
                            }

                        } else if (!fromServer && ""AUDIO"".equals(action)) {
                            // Use the alarm action that exchange (and blackberry) understand
                            // (exchange and blackberry don't understand audio actions)
                            vAlarm.setPropertyValue(""ACTION"", ""DISPLAY"");
                        }
                    }
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.VCalendar,fixAttendees,,23,18,0,2,0.4074,0.2963,0.166666667,3,8,0,1,"private void fixAttendees(VObject vObject, boolean fromServer) {
        if (vObject.properties != null) {
            for (VProperty property : vObject.properties) {
                if (""ATTENDEE"".equalsIgnoreCase(property.getKey())) {
                    if (fromServer) {
                        // If this is coming from the server, strip out RSVP for this
                        // user as an attendee where the partstat is something other
                        // than PARTSTAT=NEEDS-ACTION since the RSVP confuses iCal4 into
                        // thinking the attendee has not replied
                        if (isCurrentUser(property) && property.hasParam(""RSVP"", ""TRUE"")) {
                            if (!""NEEDS-ACTION"".equals(property.getParamValue(""PARTSTAT""))) {
                                property.removeParam(""RSVP"");
                            }
                        }
                    } else {
                        property.setValue(replaceIcal4Principal(property.getValue()));
                    }
                }

            }
        }

    }"
davmail-4.5.1,davmail.exchange.VCalendar,hasVAlarm,,12,7,4,3,0.5,0.2222,0,1,5,0,1,"/**
     * Check if VCalendar has a VALARM item.
     *
     * @return true if VCalendar has a VALARM
     */
    public boolean hasVAlarm() {
        if (vObjects != null) {
            for (VObject vObject : vObjects) {
                if (""VEVENT"".equals(vObject.type)) {
                    if (vObject.vObjects != null) {
                        return true;
                    }
                }
            }
        }
        return false;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,isExpired,,20,29,13,4,0.22,0.2889,0,2,4,0,1,"@Override
    public boolean isExpired() throws NoRouteToHostException, UnknownHostException {
        // experimental: try to reset session timeout
        if (""Exchange2007"".equals(serverVersion)) {
            GetMethod getMethod = null;
            try {
                getMethod = new GetMethod(""/owa/"");
                getMethod.setFollowRedirects(false);
                httpClient.executeMethod(getMethod);
            } catch (IOException e) {
                LOGGER.warn(e.getMessage());
            } finally {
                if (getMethod != null) {
                    getMethod.releaseConnection();
                }
            }
        }

        return super.isExpired();
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,galFind,,19,82,59,4,0.163,0.0856,1,5,3,0,1,"protected Map<String, Map<String, String>> galFind(String query) throws IOException {
        Map<String, Map<String, String>> results;
        String path = getCmdBasePath() + ""?Cmd=galfind"" + query;
        GetMethod getMethod = new GetMethod(path);
        try {
            DavGatewayHttpClientFacade.executeGetMethod(httpClient, getMethod, true);
            results = XMLStreamUtil.getElementContentsAsMap(getMethod.getResponseBodyAsStream(), ""item"", ""AN"");
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(path + "": "" + results.size() + "" result(s)"");
            }
        } catch (IOException e) {
            LOGGER.debug(""GET "" + path + "" failed: "" + e + ' ' + e.getMessage());
            disableGalFind = true;
            throw e;
        } finally {
            getMethod.releaseConnection();
        }
        return results;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,galFind,,70,723,456,2,0.1121,0.0988,0.625,18,20,0,1,"@Override
    public Map<String, ExchangeSession.Contact> galFind(Condition condition, Set<String> returningAttributes, int sizeLimit) throws IOException {
        Map<String, ExchangeSession.Contact> contacts = new HashMap<String, ExchangeSession.Contact>();
        //noinspection StatementWithEmptyBody
        if (disableGalFind) {
            // do nothing
        } else if (condition instanceof MultiCondition) {
            List<Condition> conditions = ((ExchangeSession.MultiCondition) condition).getConditions();
            Operator operator = ((ExchangeSession.MultiCondition) condition).getOperator();
            if (operator == Operator.Or) {
                for (Condition innerCondition : conditions) {
                    contacts.putAll(galFind(innerCondition, returningAttributes, sizeLimit));
                }
            } else if (operator == Operator.And && !conditions.isEmpty()) {
                Map<String, ExchangeSession.Contact> innerContacts = galFind(conditions.get(0), returningAttributes, sizeLimit);
                for (ExchangeSession.Contact contact : innerContacts.values()) {
                    if (condition.isMatch(contact)) {
                        contacts.put(contact.getName().toLowerCase(), contact);
                    }
                }
            }
        } else if (condition instanceof AttributeCondition) {
            String searchAttributeName = ((ExchangeSession.AttributeCondition) condition).getAttributeName();
            String searchAttribute = GALFIND_CRITERIA_MAP.get(searchAttributeName);
            if (searchAttribute != null) {
                String searchValue = ((ExchangeSession.AttributeCondition) condition).getValue();
                StringBuilder query = new StringBuilder();
                if (""EM"".equals(searchAttribute)) {
                    // mail search, split
                    int atIndex = searchValue.indexOf('@');
                    // remove suffix
                    if (atIndex >= 0) {
                        searchValue = searchValue.substring(0, atIndex);
                    }
                    // split firstname.lastname
                    int dotIndex = searchValue.indexOf('.');
                    if (dotIndex >= 0) {
                        // assume mail starts with firstname
                        query.append(""&FN="").append(URIUtil.encodeWithinQuery(searchValue.substring(0, dotIndex)));
                        query.append(""&LN="").append(URIUtil.encodeWithinQuery(searchValue.substring(dotIndex + 1)));
                    } else {
                        query.append(""&FN="").append(URIUtil.encodeWithinQuery(searchValue));
                    }
                } else {
                    query.append('&').append(searchAttribute).append('=').append(URIUtil.encodeWithinQuery(searchValue));
                }
                Map<String, Map<String, String>> results = galFind(query.toString());
                for (Map<String, String> result : results.values()) {
                    Contact contact = new Contact();
                    contact.setName(result.get(""AN""));
                    contact.put(""imapUid"", result.get(""AN""));
                    buildGalfindContact(contact, result);
                    if (needGalLookup(searchAttributeName, returningAttributes)) {
                        galLookup(contact);
                        // iCal fix to suit both iCal 3 and 4:  move cn to sn, remove cn
                    } else if (returningAttributes.contains(""apple-serviceslocator"")) {
                        if (contact.get(""cn"") != null && returningAttributes.contains(""sn"")) {
                            contact.put(""sn"", contact.get(""cn""));
                            contact.remove(""cn"");
                        }
                    }
                    if (condition.isMatch(contact)) {
                        contacts.put(contact.getName().toLowerCase(), contact);
                    }
                }
            }

        }
        return contacts;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,needGalLookup,,22,11,7,3,0.2917,0.1556,0,3,8,0,1,"protected boolean needGalLookup(String searchAttributeName, Set<String> returningAttributes) {
        // return all attributes => call gallookup
        if (returningAttributes == null || returningAttributes.isEmpty()) {
            return true;
            // iCal search, do not call gallookup
        } else if (returningAttributes.contains(""apple-serviceslocator"")) {
            return false;
            // Lightning search, no need to gallookup
        } else if (""sn"".equals(searchAttributeName)) {
            return returningAttributes.contains(""sn"");
            // search attribute is gallookup attribute, need to fetch value for isMatch
        } else if (GALLOOKUP_ATTRIBUTES.contains(searchAttributeName)) {
            return true;
        }

        for (String attributeName : GALLOOKUP_ATTRIBUTES) {
            if (returningAttributes.contains(attributeName)) {
                return true;
            }
        }
        return false;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,galLookup,,25,95,54,4,0.1604,0.1163,1,5,6,0,1,"/**
     * Get extended address book information for person with gallookup.
     * Does not work with Exchange 2007
     *
     * @param contact galfind contact
     */
    public void galLookup(Contact contact) {
        if (!disableGalLookup) {
            LOGGER.debug(""galLookup("" + contact.get(""smtpemail1"") + ')');
            GetMethod getMethod = null;
            try {
                getMethod = new GetMethod(URIUtil.encodePathQuery(getCmdBasePath() + ""?Cmd=gallookup&ADDR="" + contact.get(""smtpemail1"")));
                DavGatewayHttpClientFacade.executeGetMethod(httpClient, getMethod, true);
                Map<String, Map<String, String>> results = XMLStreamUtil.getElementContentsAsMap(getMethod.getResponseBodyAsStream(), ""person"", ""alias"");
                // add detailed information
                if (!results.isEmpty()) {
                    Map<String, String> personGalLookupDetails = results.get(contact.get(""uid"").toLowerCase());
                    if (personGalLookupDetails != null) {
                        buildGalfindContact(contact, personGalLookupDetails);
                    }
                }
            } catch (IOException e) {
                LOGGER.warn(""Unable to gallookup person: "" + contact + "", disable GalLookup"");
                disableGalLookup = true;
            } finally {
                if (getMethod != null) {
                    getMethod.releaseConnection();
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,buildGalfindContact,,8,10,5,3,0.3,0.119,0,4,3,0,1,"protected void buildGalfindContact(Contact contact, Map<String, String> response) {
        for (Map.Entry<String, String> entry : GALFIND_ATTRIBUTE_MAP.entrySet()) {
            String attributeValue = response.get(entry.getValue());
            if (attributeValue != null) {
                contact.put(entry.getKey(), attributeValue);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,buildMailPath,,45,139,125,8,0.127,0.0746,1,3,8,0,1,"protected void buildMailPath(HttpMethod method) throws DavMailAuthenticationException {
        // get mailPath from welcome page on Exchange 2003
        mailPath = getMailpathFromWelcomePage(method);

        //noinspection VariableNotUsedInsideIf
        if (mailPath != null) {
            // Exchange 2003
            serverVersion = ""Exchange2003"";
            fixClientHost(method);
            checkPublicFolder();
            try {
                buildEmail(method.getURI().getHost());
            } catch (URIException uriException) {
                LOGGER.warn(uriException);
            }
        } else {
            // Exchange 2007 : get alias and email from options page
            serverVersion = ""Exchange2007"";

            // Gallookup is an Exchange 2003 only feature
            disableGalLookup = true;
            fixClientHost(method);
            getEmailAndAliasFromOptions();

            checkPublicFolder();

            // failover: try to get email through Webdav and Galfind
            if (alias == null || email == null) {
                try {
                    buildEmail(method.getURI().getHost());
                } catch (URIException uriException) {
                    LOGGER.warn(uriException);
                }
            }

            // build standard mailbox link with email
            mailPath = ""/exchange/"" + email + '/';
        }

        if (mailPath == null || email == null) {
            throw new DavMailAuthenticationException(""EXCEPTION_AUTHENTICATION_FAILED_PASSWORD_EXPIRED"");
        }
        LOGGER.debug(""Current user email is "" + email + "", alias is "" + alias + "", mailPath is "" + mailPath + "" on "" + serverVersion);
        rootPath = mailPath.substring(0, mailPath.lastIndexOf('/', mailPath.length() - 2) + 1);
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,buildEmail,,51,261,57,3,0.1864,0.2164,1,4,11,0,1,"/**
     * Determine user email through various means.
     *
     * @param hostName Exchange server host name for last failover
     */
    public void buildEmail(String hostName) {
        String mailBoxPath = getMailboxPath();
        // mailPath contains either alias or email
        if (mailBoxPath != null && mailBoxPath.indexOf('@') >= 0) {
            email = mailBoxPath;
            alias = getAliasFromMailboxDisplayName();
            if (alias == null) {
                alias = getAliasFromLogin();
            }
        } else {
            // use mailbox name as alias
            alias = mailBoxPath;
            email = getEmail(alias);
            if (email == null) {
                // failover: try to get email from login name
                alias = getAliasFromLogin();
                email = getEmail(alias);
            }
            // another failover : get alias from mailPath display name
            if (email == null) {
                alias = getAliasFromMailboxDisplayName();
                email = getEmail(alias);
            }
            if (email == null) {
                LOGGER.debug(""Unable to get user email with alias "" + mailBoxPath
                        + "" or "" + getAliasFromLogin()
                        + "" or "" + alias
                );
                // last failover: build email from domain name and mailbox display name
                StringBuilder buffer = new StringBuilder();
                // most reliable alias
                if (mailBoxPath != null) {
                    alias = mailBoxPath;
                } else {
                    alias = getAliasFromLogin();
                }
                buffer.append(alias);
                if (alias.indexOf('@') < 0) {
                    buffer.append('@');
                    if (hostName == null) {
                        hostName = ""mail.unknown.com"";
                    }
                    int dotIndex = hostName.indexOf('.');
                    if (dotIndex >= 0) {
                        buffer.append(hostName.substring(dotIndex + 1));
                    }
                }
                email = buffer.toString();
            }
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,fixClientHost,,11,17,13,4,0.2286,0.0917,0,3,5,0,1,"protected void fixClientHost(HttpMethod method) {
        try {
            // update client host, workaround for Exchange 2003 mailbox with an Exchange 2007 frontend
            URI currentUri = method.getURI();
            if (currentUri != null && currentUri.getHost() != null && currentUri.getScheme() != null) {
                httpClient.getHostConfiguration().setHost(currentUri.getHost(), currentUri.getPort(), currentUri.getScheme());
            }
        } catch (URIException e) {
            LOGGER.warn(""Unable to update http client host:"" + e.getMessage(), e);
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,checkPublicFolder,,29,109,65,4,0.1778,0.1234,0.5,5,5,0,1,"protected void checkPublicFolder() {
        synchronized (httpClient.getState()) {
            Cookie[] currentCookies = httpClient.getState().getCookies();
            // check public folder access
            try {
                publicFolderUrl = httpClient.getHostConfiguration().getHostURL() + PUBLIC_ROOT;
                DavPropertyNameSet davPropertyNameSet = new DavPropertyNameSet();
                davPropertyNameSet.add(Field.getPropertyName(""displayname""));
                PropFindMethod propFindMethod = new PropFindMethod(publicFolderUrl, davPropertyNameSet, 0);
                try {
                    DavGatewayHttpClientFacade.executeMethod(httpClient, propFindMethod);
                } catch (IOException e) {
                    // workaround for NTLM authentication only on /public
                    if (!DavGatewayHttpClientFacade.hasNTLMorNegotiate(httpClient)) {
                        DavGatewayHttpClientFacade.addNTLM(httpClient);
                        DavGatewayHttpClientFacade.executeMethod(httpClient, propFindMethod);
                    }
                }
                // update public folder URI
                publicFolderUrl = propFindMethod.getURI().getURI();
            } catch (IOException e) {
                // restore cookies on error
                httpClient.getState().addCookies(currentCookies);
                LOGGER.warn(""Public folders not available: "" + (e.getMessage() == null ? e : e.getMessage()));
                // default public folder path
                publicFolderUrl = PUBLIC_ROOT;
            }
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,isTrue,,8,7,4,3,0.4,0.2222,1,2,3,0,1,"@Override
    public Condition isTrue(String attributeName) {
        if (""Exchange2003"".equals(this.serverVersion) && ""deleted"".equals(attributeName)) {
            return isEqualTo(attributeName, ""1"");
        } else {
            return new MonoCondition(attributeName, Operator.IsTrue);
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,isFalse,,8,12,9,4,0.3333,0.1667,1,2,3,0,1,"@Override
    public Condition isFalse(String attributeName) {
        if (""Exchange2003"".equals(this.serverVersion) && ""deleted"".equals(attributeName)) {
            return or(isEqualTo(attributeName, ""0""), isNull(attributeName));
        } else {
            return new MonoCondition(attributeName, Operator.IsFalse);
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,buildFolder,,55,995,559,10,0.0811,0.1282,1,7,18,0,1,"protected Folder buildFolder(MultiStatusResponse entity) throws IOException {
        String href = URIUtil.decode(entity.getHref());
        Folder folder = new Folder();
        DavPropertySet properties = entity.getProperties(HttpStatus.SC_OK);
        folder.displayName = getPropertyIfExists(properties, ""displayname"");
        folder.folderClass = getPropertyIfExists(properties, ""folderclass"");
        folder.hasChildren = ""1"".equals(getPropertyIfExists(properties, ""hassubs""));
        folder.noInferiors = ""1"".equals(getPropertyIfExists(properties, ""nosubs""));
        folder.count = getIntPropertyIfExists(properties, ""count"");
        folder.unreadCount = getIntPropertyIfExists(properties, ""unreadcount"");
        // fake recent value
        folder.recent = folder.unreadCount;
        folder.ctag = getPropertyIfExists(properties, ""contenttag"");
        folder.etag = getPropertyIfExists(properties, ""lastmodified"");

        folder.uidNext = getIntPropertyIfExists(properties, ""uidNext"");

        // replace well known folder names
        if (inboxUrl != null && href.startsWith(inboxUrl)) {
            folder.folderPath = href.replaceFirst(inboxUrl, INBOX);
        } else if (sentitemsUrl != null && href.startsWith(sentitemsUrl)) {
            folder.folderPath = href.replaceFirst(sentitemsUrl, SENT);
        } else if (draftsUrl != null && href.startsWith(draftsUrl)) {
            folder.folderPath = href.replaceFirst(draftsUrl, DRAFTS);
        } else if (deleteditemsUrl != null && href.startsWith(deleteditemsUrl)) {
            folder.folderPath = href.replaceFirst(deleteditemsUrl, TRASH);
        } else if (calendarUrl != null && href.startsWith(calendarUrl)) {
            folder.folderPath = href.replaceFirst(calendarUrl, CALENDAR);
        } else if (contactsUrl != null && href.startsWith(contactsUrl)) {
            folder.folderPath = href.replaceFirst(contactsUrl, CONTACTS);
        } else {
            int index = href.indexOf(mailPath.substring(0, mailPath.length() - 1));
            if (index >= 0) {
                if (index + mailPath.length() > href.length()) {
                    folder.folderPath = """";
                } else {
                    folder.folderPath = href.substring(index + mailPath.length());
                }
            } else {
                try {
                    URI folderURI = new URI(href, false);
                    folder.folderPath = folderURI.getPath();
                    if (folder.folderPath == null) {
                        throw new URIException();
                    }
                } catch (URIException e) {
                    throw new DavMailException(""EXCEPTION_INVALID_FOLDER_URL"", href);
                }
            }
        }
        if (folder.folderPath.endsWith(""/"")) {
            folder.folderPath = folder.folderPath.substring(0, folder.folderPath.length() - 1);
        }
        return folder;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,internalGetFolder,,11,11,1,2,0.2653,0.2041,1,3,2,0,1,"/**
     * @inheritDoc
     */
    @Override
    protected Folder internalGetFolder(String folderPath) throws IOException {
        MultiStatusResponse[] responses = DavGatewayHttpClientFacade.executePropFindMethod(
                httpClient, URIUtil.encodePath(getFolderPath(folderPath)), 0, FOLDER_PROPERTIES_NAME_SET);
        Folder folder = null;
        if (responses.length > 0) {
            folder = buildFolder(responses[0]);
            folder.folderPath = folderPath;
        }
        return folder;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,createFolder,,23,107,94,8,0.125,0.0519,1,7,4,0,1,"/**
     * @inheritDoc
     */
    @Override
    public int createFolder(String folderPath, String folderClass, Map<String, String> properties) throws IOException {
        Set<PropertyValue> propertyValues = new HashSet<PropertyValue>();
        if (properties != null) {
            for (Map.Entry<String, String> entry : properties.entrySet()) {
                propertyValues.add(Field.createPropertyValue(entry.getKey(), entry.getValue()));
            }
        }
        propertyValues.add(Field.createPropertyValue(""folderclass"", folderClass));

        // standard MkColMethod does not take properties, override PropPatchMethod instead
        ExchangePropPatchMethod method = new ExchangePropPatchMethod(URIUtil.encodePath(getFolderPath(folderPath)), propertyValues) {
            @Override
            public String getName() {
                return ""MKCOL"";
            }
        };
        int status = DavGatewayHttpClientFacade.executeHttpMethod(httpClient, method);
        if (status == HttpStatus.SC_MULTI_STATUS) {
            status = method.getResponseStatusCode();
        }
        return status;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,updateFolder,,17,42,29,3,0.1818,0.0932,1,6,4,0,1,"/**
     * @inheritDoc
     */
    @Override
    public int updateFolder(String folderPath, Map<String, String> properties) throws IOException {
        Set<PropertyValue> propertyValues = new HashSet<PropertyValue>();
        if (properties != null) {
            for (Map.Entry<String, String> entry : properties.entrySet()) {
                propertyValues.add(Field.createPropertyValue(entry.getKey(), entry.getValue()));
            }
        }

        // standard MkColMethod does not take properties, override PropPatchMethod instead
        ExchangePropPatchMethod method = new ExchangePropPatchMethod(URIUtil.encodePath(getFolderPath(folderPath)), propertyValues);
        int status = DavGatewayHttpClientFacade.executeHttpMethod(httpClient, method);
        if (status == HttpStatus.SC_MULTI_STATUS) {
            status = method.getResponseStatusCode();
        }
        return status;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,moveFolder,,18,43,31,5,0.1818,0.1122,1,4,4,0,1,"/**
     * @inheritDoc
     */
    @Override
    public void moveFolder(String folderPath, String targetPath) throws IOException {
        MoveMethod method = new MoveMethod(URIUtil.encodePath(getFolderPath(folderPath)),
                URIUtil.encodePath(getFolderPath(targetPath)), false);
        try {
            int statusCode = httpClient.executeMethod(method);
            if (statusCode == HttpStatus.SC_PRECONDITION_FAILED) {
                throw new HttpPreconditionFailedException(BundleMessage.format(""EXCEPTION_UNABLE_TO_MOVE_FOLDER""));
            } else if (statusCode != HttpStatus.SC_CREATED) {
                throw DavGatewayHttpClientFacade.buildHttpException(method);
            } else if (folderPath.equalsIgnoreCase(""/users/"" + getEmail() + ""/calendar"")) {
                // calendar renamed, need to reload well known folders 
                getWellKnownFolders();
            }
        } finally {
            method.releaseConnection();
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,moveItem,,12,30,24,5,0.2593,0.1111,1,2,4,0,1,"protected void moveItem(MoveMethod method) throws IOException {
        try {
            int statusCode = httpClient.executeMethod(method);
            if (statusCode == HttpStatus.SC_PRECONDITION_FAILED) {
                throw new DavMailException(""EXCEPTION_UNABLE_TO_MOVE_ITEM"");
            } else if (statusCode != HttpStatus.SC_CREATED && statusCode != HttpStatus.SC_OK) {
                throw DavGatewayHttpClientFacade.buildHttpException(method);
            }
        } finally {
            method.releaseConnection();
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,buildMessage,,39,182,0,3,0.1906,0.2902,1,6,7,0,1,"protected Message buildMessage(MultiStatusResponse responseEntity) throws URIException, DavMailException {
        Message message = new Message();
        message.messageUrl = URIUtil.decode(responseEntity.getHref());
        DavPropertySet properties = responseEntity.getProperties(HttpStatus.SC_OK);

        message.permanentUrl = getURLPropertyIfExists(properties, ""permanenturl"");
        message.size = getIntPropertyIfExists(properties, ""messageSize"");
        message.uid = getPropertyIfExists(properties, ""uid"");
        message.contentClass = getPropertyIfExists(properties, ""contentclass"");
        message.imapUid = getLongPropertyIfExists(properties, ""imapUid"");
        message.read = ""1"".equals(getPropertyIfExists(properties, ""read""));
        message.junk = ""1"".equals(getPropertyIfExists(properties, ""junk""));
        message.flagged = ""2"".equals(getPropertyIfExists(properties, ""flagStatus""));
        message.draft = (getIntPropertyIfExists(properties, ""messageFlags"") & 8) != 0;
        String lastVerbExecuted = getPropertyIfExists(properties, ""lastVerbExecuted"");
        message.answered = ""102"".equals(lastVerbExecuted) || ""103"".equals(lastVerbExecuted);
        message.forwarded = ""104"".equals(lastVerbExecuted);
        message.date = convertDateFromExchange(getPropertyIfExists(properties, ""date""));
        message.deleted = ""1"".equals(getPropertyIfExists(properties, ""deleted""));

        String lastmodified = convertDateFromExchange(getPropertyIfExists(properties, ""lastmodified""));
        message.recent = !message.read && lastmodified != null && lastmodified.equals(message.date);

        message.keywords = getPropertyIfExists(properties, ""keywords"");

        if (LOGGER.isDebugEnabled()) {
            StringBuilder buffer = new StringBuilder();
            buffer.append(""Message"");
            if (message.imapUid != 0) {
                buffer.append("" IMAP uid: "").append(message.imapUid);
            }
            if (message.uid != null) {
                buffer.append("" uid: "").append(message.uid);
            }
            buffer.append("" href: "").append(responseEntity.getHref()).append("" permanenturl:"").append(message.permanentUrl);
            LOGGER.debug(buffer.toString());
        }
        return message;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,searchMessages,,14,40,25,3,0.1727,0.1534,1,8,2,0,1,"@Override
    public MessageList searchMessages(String folderPath, Set<String> attributes, Condition condition) throws IOException {
        MessageList messages = new MessageList();
        int maxCount = Settings.getIntProperty(""davmail.folderSizeLimit"", 0);
        MultiStatusResponse[] responses = searchItems(folderPath, attributes, and(isFalse(""isfolder""), isFalse(""ishidden""), condition), FolderQueryTraversal.Shallow, maxCount);

        for (MultiStatusResponse response : responses) {
            Message message = buildMessage(response);
            message.messageList = messages;
            messages.add(message);
        }
        Collections.sort(messages);
        return messages;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,searchContacts,,11,94,68,5,0.125,0.2023,1,7,2,0,1,"/**
     * @inheritDoc
     */
    @Override
    public List<ExchangeSession.Contact> searchContacts(String folderPath, Set<String> attributes, Condition condition, int maxCount) throws IOException {
        List<ExchangeSession.Contact> contacts = new ArrayList<ExchangeSession.Contact>();
        MultiStatusResponse[] responses = searchItems(folderPath, attributes,
                and(isEqualTo(""outlookmessageclass"", ""IPM.Contact""), isFalse(""isfolder""), isFalse(""ishidden""), condition),
                FolderQueryTraversal.Shallow, maxCount);
        for (MultiStatusResponse response : responses) {
            contacts.add(new Contact(response));
        }
        return contacts;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,searchEvents,,24,68,45,2,0.1488,0.1033,1,9,4,0,1,"@Override
    public List<ExchangeSession.Event> searchEvents(String folderPath, Set<String> attributes, Condition condition) throws IOException {
        List<ExchangeSession.Event> events = new ArrayList<ExchangeSession.Event>();
        MultiStatusResponse[] responses = searchItems(folderPath, attributes, and(isFalse(""isfolder""), isFalse(""ishidden""), condition), FolderQueryTraversal.Shallow, 0);
        for (MultiStatusResponse response : responses) {
            String instancetype = getPropertyIfExists(response.getProperties(HttpStatus.SC_OK), ""instancetype"");
            Event event = new Event(response);
            //noinspection VariableNotUsedInsideIf
            if (instancetype == null) {
                // check ics content
                try {
                    event.getBody();
                    // getBody success => add event or task
                    events.add(event);
                } catch (IOException e) {
                    // invalid event: exclude from list
                    LOGGER.warn(""Invalid event "" + event.displayName + "" found at "" + response.getHref(), e);
                }
            } else {
                events.add(event);
            }
        }
        return events;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,searchItems,,28,439,350,5,0.0875,0.0882,1,9,5,0,1,"protected MultiStatusResponse[] searchItems(String folderPath, Set<String> attributes, Condition condition,
                                                FolderQueryTraversal folderQueryTraversal, int maxCount) throws IOException {
        String folderUrl;
        if (folderPath.startsWith(""http"")) {
            folderUrl = folderPath;
        } else {
            folderUrl = getFolderPath(folderPath);
        }
        StringBuilder searchRequest = new StringBuilder();
        searchRequest.append(""SELECT "")
                .append(Field.getRequestPropertyString(""permanenturl""));
        if (attributes != null) {
            for (String attribute : attributes) {
                searchRequest.append(',').append(Field.getRequestPropertyString(attribute));
            }
        }
        searchRequest.append("" FROM SCOPE('"").append(folderQueryTraversal).append("" TRAVERSAL OF \"""").append(folderUrl).append(""\""')"");
        if (condition != null) {
            searchRequest.append("" WHERE "");
            condition.appendTo(searchRequest);
        }
        searchRequest.append("" ORDER BY "").append(Field.getRequestPropertyString(""imapUid"")).append("" DESC"");
        DavGatewayTray.debug(new BundleMessage(""LOG_SEARCH_QUERY"", searchRequest));
        MultiStatusResponse[] responses = DavGatewayHttpClientFacade.executeSearchMethod(
                httpClient, encodeAndFixUrl(folderUrl), searchRequest.toString(), maxCount);
        DavGatewayTray.debug(new BundleMessage(""LOG_SEARCH_RESULT"", responses.length));
        return responses;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,sendEvent,,12,24,20,5,0.2,0.0773,1,3,2,0,1,"@Override
    public int sendEvent(String icsBody) throws IOException {
        String itemName = UUID.randomUUID().toString() + "".EML"";
        byte[] mimeContent = (new Event(getFolderPath(DRAFTS), itemName, ""urn:content-classes:calendarmessage"", icsBody, null, null)).createMimeContent();
        if (mimeContent == null) {
            // no recipients, cancel
            return HttpStatus.SC_NO_CONTENT;
        } else {
            sendMessage(mimeContent);
            return HttpStatus.SC_OK;
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,deleteItem,,13,23,10,3,0.2469,0.1105,1,4,4,0,1,"@Override
    public void deleteItem(String folderPath, String itemName) throws IOException {
        String eventPath = URIUtil.encodePath(getFolderPath(folderPath) + '/' + convertItemNameToEML(itemName));
        int status = DavGatewayHttpClientFacade.executeDeleteMethod(httpClient, eventPath);
        if (status == HttpStatus.SC_NOT_FOUND && isMainCalendar(folderPath)) {
            // retry in tasks folder
            eventPath = URIUtil.encodePath(getFolderPath(TASKS) + '/' + convertItemNameToEML(itemName));
            status = DavGatewayHttpClientFacade.executeDeleteMethod(httpClient, eventPath);
        }
        if (status == HttpStatus.SC_NOT_FOUND) {
            LOGGER.debug(""Unable to delete "" + itemName + "": item not found"");
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,processItem,,10,20,12,3,0.2188,0.1198,1,5,1,0,1,"@Override
    public void processItem(String folderPath, String itemName) throws IOException {
        String eventPath = URIUtil.encodePath(getFolderPath(folderPath) + '/' + convertItemNameToEML(itemName));
        // do not delete calendar messages, mark read and processed
        ArrayList<PropEntry> list = new ArrayList<PropEntry>();
        list.add(Field.createDavProperty(""processed"", ""true""));
        list.add(Field.createDavProperty(""read"", ""1""));
        PropPatchMethod patchMethod = new PropPatchMethod(eventPath, list);
        DavGatewayHttpClientFacade.executeMethod(httpClient, patchMethod);
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,loadVtimezone,,73,793,683,9,0.0698,0.0577,1,12,10,0,1,"/**
     * create a fake event to get VTIMEZONE body
     */
    @Override
    protected void loadVtimezone() {
        try {
            // create temporary folder
            String folderPath = getFolderPath(""davmailtemp"");
            createCalendarFolder(folderPath, null);

            String fakeEventUrl = null;
            if (""Exchange2003"".equals(serverVersion)) {
                PostMethod postMethod = new PostMethod(URIUtil.encodePath(folderPath));
                postMethod.addParameter(""Cmd"", ""saveappt"");
                postMethod.addParameter(""FORMTYPE"", ""appointment"");
                try {
                    // create fake event
                    int statusCode = httpClient.executeMethod(postMethod);
                    if (statusCode == HttpStatus.SC_OK) {
                        fakeEventUrl = StringUtil.getToken(postMethod.getResponseBodyAsString(), ""<span id=\""itemHREF\"">"", ""</span>"");
                        if (fakeEventUrl != null) {
                            fakeEventUrl = URIUtil.decode(fakeEventUrl);
                        }
                    }
                } finally {
                    postMethod.releaseConnection();
                }
            }
            // failover for Exchange 2007, use PROPPATCH with forced timezone
            if (fakeEventUrl == null) {
                ArrayList<PropEntry> propertyList = new ArrayList<PropEntry>();
                propertyList.add(Field.createDavProperty(""contentclass"", ""urn:content-classes:appointment""));
                propertyList.add(Field.createDavProperty(""outlookmessageclass"", ""IPM.Appointment""));
                propertyList.add(Field.createDavProperty(""instancetype"", ""0""));

                // get forced timezone id from settings
                String timezoneId = Settings.getProperty(""davmail.timezoneId"");
                if (timezoneId == null) {
                    // get timezoneid from OWA settings
                    timezoneId = getTimezoneIdFromExchange();
                }
                // without a timezoneId, use Exchange timezone
                if (timezoneId != null) {
                    propertyList.add(Field.createDavProperty(""timezoneid"", timezoneId));
                }
                String patchMethodUrl = folderPath + '/' + UUID.randomUUID().toString() + "".EML"";
                PropPatchMethod patchMethod = new PropPatchMethod(URIUtil.encodePath(patchMethodUrl), propertyList);
                try {
                    int statusCode = httpClient.executeMethod(patchMethod);
                    if (statusCode == HttpStatus.SC_MULTI_STATUS) {
                        fakeEventUrl = patchMethodUrl;
                    }
                } finally {
                    patchMethod.releaseConnection();
                }
            }
            if (fakeEventUrl != null) {
                // get fake event body
                GetMethod getMethod = new GetMethod(URIUtil.encodePath(fakeEventUrl));
                getMethod.setRequestHeader(""Translate"", ""f"");
                try {
                    httpClient.executeMethod(getMethod);
                    this.vTimezone = new VObject(""BEGIN:VTIMEZONE"" +
                            StringUtil.getToken(getMethod.getResponseBodyAsString(), ""BEGIN:VTIMEZONE"", ""END:VTIMEZONE"") +
                            ""END:VTIMEZONE\r\n"");
                } finally {
                    getMethod.releaseConnection();
                }
            }

            // delete temporary folder
            deleteFolder(""davmailtemp"");
        } catch (IOException e) {
            LOGGER.warn(""Unable to get VTIMEZONE info: "" + e, e);
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,buildProperties,,33,78,0,3,0.5227,0.3891,1,3,14,0,1,"protected List<PropEntry> buildProperties(Map<String, String> properties) {
        ArrayList<PropEntry> list = new ArrayList<PropEntry>();
        if (properties != null) {
            for (Map.Entry<String, String> entry : properties.entrySet()) {
                if (""read"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""read"", entry.getValue()));
                } else if (""junk"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""junk"", entry.getValue()));
                } else if (""flagged"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""flagStatus"", entry.getValue()));
                } else if (""answered"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""lastVerbExecuted"", entry.getValue()));
                    if (""102"".equals(entry.getValue())) {
                        list.add(Field.createDavProperty(""iconIndex"", ""261""));
                    }
                } else if (""forwarded"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""lastVerbExecuted"", entry.getValue()));
                    if (""104"".equals(entry.getValue())) {
                        list.add(Field.createDavProperty(""iconIndex"", ""262""));
                    }
                } else if (""bcc"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""bcc"", entry.getValue()));
                } else if (""deleted"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""deleted"", entry.getValue()));
                } else if (""datereceived"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""datereceived"", entry.getValue()));
                } else if (""keywords"".equals(entry.getKey())) {
                    list.add(Field.createDavProperty(""keywords"", entry.getValue()));
                }
            }
        }
        return list;
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,createMessage,,130,2237,1846,6,0.0666,0.0573,0.8,23,25,0,1,"/**
     * Create message in specified folder.
     * Will overwrite an existing message with same messageName in the same folder
     *
     * @param folderPath  Exchange folder path
     * @param messageName message name
     * @param properties  message properties (flags)
     * @param mimeMessage MIME message
     * @throws IOException when unable to create message
     */
    @Override
    public void createMessage(String folderPath, String messageName, HashMap<String, String> properties, MimeMessage mimeMessage) throws IOException {
        String messageUrl = URIUtil.encodePathQuery(getFolderPath(folderPath) + '/' + messageName);
        PropPatchMethod patchMethod;
        List<PropEntry> davProperties = buildProperties(properties);

        if (properties != null && properties.containsKey(""draft"")) {
            // note: draft is readonly after create, create the message first with requested messageFlags
            davProperties.add(Field.createDavProperty(""messageFlags"", properties.get(""draft"")));
        }
        if (properties != null && properties.containsKey(""mailOverrideFormat"")) {
            davProperties.add(Field.createDavProperty(""mailOverrideFormat"", properties.get(""mailOverrideFormat"")));
        }
        if (properties != null && properties.containsKey(""messageFormat"")) {
            davProperties.add(Field.createDavProperty(""messageFormat"", properties.get(""messageFormat"")));
        }
        if (!davProperties.isEmpty()) {
            patchMethod = new PropPatchMethod(messageUrl, davProperties);
            try {
                // update message with blind carbon copy and other flags
                int statusCode = httpClient.executeMethod(patchMethod);
                if (statusCode != HttpStatus.SC_MULTI_STATUS) {
                    throw new DavMailException(""EXCEPTION_UNABLE_TO_CREATE_MESSAGE"", messageUrl, statusCode, ' ', patchMethod.getStatusLine());
                }

            } finally {
                patchMethod.releaseConnection();
            }
        }

        // update message body
        PutMethod putmethod = new PutMethod(messageUrl);
        putmethod.setRequestHeader(""Translate"", ""f"");
        putmethod.setRequestHeader(""Content-Type"", ""message/rfc822"");

        try {
            // use same encoding as client socket reader
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            mimeMessage.writeTo(baos);
            baos.close();
            putmethod.setRequestEntity(new ByteArrayRequestEntity(baos.toByteArray()));
            int code = httpClient.executeMethod(putmethod);

            // workaround for misconfigured Exchange server
            if (code == HttpStatus.SC_NOT_ACCEPTABLE) {
                LOGGER.warn(""Draft message creation failed, failover to property update. Note: attachments are lost"");

                ArrayList<PropEntry> propertyList = new ArrayList<PropEntry>();
                propertyList.add(Field.createDavProperty(""to"", mimeMessage.getHeader(""to"", "","")));
                propertyList.add(Field.createDavProperty(""cc"", mimeMessage.getHeader(""cc"", "","")));
                propertyList.add(Field.createDavProperty(""message-id"", mimeMessage.getHeader(""message-id"", "","")));

                MimePart mimePart = mimeMessage;
                if (mimeMessage.getContent() instanceof MimeMultipart) {
                    MimeMultipart multiPart = (MimeMultipart) mimeMessage.getContent();
                    for (int i = 0; i < multiPart.getCount(); i++) {
                        String contentType = multiPart.getBodyPart(i).getContentType();
                        if (contentType.startsWith(""text/"")) {
                            mimePart = (MimePart) multiPart.getBodyPart(i);
                            break;
                        }
                    }
                }

                String contentType = mimePart.getContentType();

                if (contentType.startsWith(""text/plain"")) {
                    propertyList.add(Field.createDavProperty(""description"", (String) mimePart.getContent()));
                } else if (contentType.startsWith(""text/html"")) {
                    propertyList.add(Field.createDavProperty(""htmldescription"", (String) mimePart.getContent()));
                } else {
                    LOGGER.warn(""Unsupported content type: "" + contentType + "" message body will be empty"");
                }

                propertyList.add(Field.createDavProperty(""subject"", mimeMessage.getHeader(""subject"", "","")));
                PropPatchMethod propPatchMethod = new PropPatchMethod(messageUrl, propertyList);
                try {
                    int patchStatus = DavGatewayHttpClientFacade.executeHttpMethod(httpClient, propPatchMethod);
                    if (patchStatus == HttpStatus.SC_MULTI_STATUS) {
                        code = HttpStatus.SC_OK;
                    }
                } finally {
                    propPatchMethod.releaseConnection();
                }
            }

            if (code != HttpStatus.SC_OK && code != HttpStatus.SC_CREATED) {

                // first delete draft message
                if (!davProperties.isEmpty()) {
                    try {
                        DavGatewayHttpClientFacade.executeDeleteMethod(httpClient, messageUrl);
                    } catch (IOException e) {
                        LOGGER.warn(""Unable to delete draft message"");
                    }
                }
                if (code == HttpStatus.SC_INSUFFICIENT_STORAGE) {
                    throw new InsufficientStorageException(putmethod.getStatusText());
                } else {
                    throw new DavMailException(""EXCEPTION_UNABLE_TO_CREATE_MESSAGE"", messageUrl, code, ' ', putmethod.getStatusLine());
                }
            }
        } catch (MessagingException e) {
            throw new IOException(e.getMessage());
        } finally {
            putmethod.releaseConnection();
        }

        try {
            // need to update bcc after put
            if (mimeMessage.getHeader(""Bcc"") != null) {
                davProperties = new ArrayList<PropEntry>();
                davProperties.add(Field.createDavProperty(""bcc"", mimeMessage.getHeader(""Bcc"", "","")));
                patchMethod = new PropPatchMethod(messageUrl, davProperties);
                try {
                    // update message with blind carbon copy
                    int statusCode = httpClient.executeMethod(patchMethod);
                    if (statusCode != HttpStatus.SC_MULTI_STATUS) {
                        throw new DavMailException(""EXCEPTION_UNABLE_TO_CREATE_MESSAGE"", messageUrl, statusCode, ' ', patchMethod.getStatusLine());
                    }

                } finally {
                    patchMethod.releaseConnection();
                }
            }
        } catch (MessagingException e) {
            throw new IOException(e.getMessage());
        }

    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,updateMessage,,18,51,47,8,0.1364,0.0319,1,6,2,0,1,"/**
     * @inheritDoc
     */
    @Override
    public void updateMessage(ExchangeSession.Message message, Map<String, String> properties) throws IOException {
        PropPatchMethod patchMethod = new PropPatchMethod(encodeAndFixUrl(message.permanentUrl), buildProperties(properties)) {
            @Override
            protected void processResponseBody(HttpState httpState, HttpConnection httpConnection) {
                // ignore response body, sometimes invalid with exchange mapi properties
            }
        };
        try {
            int statusCode = httpClient.executeMethod(patchMethod);
            if (statusCode != HttpStatus.SC_MULTI_STATUS) {
                throw new DavMailException(""EXCEPTION_UNABLE_TO_UPDATE_MESSAGE"");
            }

        } finally {
            patchMethod.releaseConnection();
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,sendMessage,,26,131,109,7,0.0938,0.0768,1,6,5,0,1,"//protected static final long MAC_ATTACH_ENCODING_UUENCODE = 0x00200000L;
    //protected static final long MAC_ATTACH_ENCODING_APPLESINGLE = 0x00400000L;
    //protected static final long MAC_ATTACH_ENCODING_APPLEDOUBLE = 0x00600000L;
    //protected static final long OOP_DONT_LOOKUP = 0x10000000L;

    @Override
    public void sendMessage(MimeMessage mimeMessage) throws IOException {
        try {
            // need to create draft first
            String itemName = UUID.randomUUID().toString() + "".EML"";
            HashMap<String, String> properties = new HashMap<String, String>();
            properties.put(""draft"", ""9"");
            String contentType = mimeMessage.getContentType();
            if (contentType != null && contentType.startsWith(""text/plain"")) {
                properties.put(""messageFormat"", ""1"");
            } else {
                properties.put(""mailOverrideFormat"", String.valueOf(ENCODING_PREFERENCE | ENCODING_MIME | BODY_ENCODING_TEXT_AND_HTML));
                properties.put(""messageFormat"", ""2"");
            }
            createMessage(DRAFTS, itemName, properties, mimeMessage);
            MoveMethod method = new MoveMethod(URIUtil.encodePath(getFolderPath(DRAFTS + '/' + itemName)),
                    URIUtil.encodePath(getFolderPath(SENDMSG)), false);
            // set header if saveInSent is disabled 
            if (!Settings.getBooleanProperty(""davmail.smtpSaveInSent"", true)) {
                method.setRequestHeader(""Saveinsent"", ""f"");
            }
            moveItem(method);
        } catch (MessagingException e) {
            throw new IOException(e.getMessage());
        }
    }"
davmail-4.5.1,davmail.exchange.dav.DavExchangeSession,encodeAndFixUrl,,8,11,1,3,0.2857,0.2125,0,3,3,0,1,"protected String encodeAndFixUrl(String url) throws URIException {
        String originalUrl = URIUtil.encodePath(url);
        if (restoreHostName && originalUrl.startsWith(""http"")) {
            String targetPath = new URI(originalUrl, true).getEscapedPath();
            originalUrl = getEscapedUrlFromPath(targetPath);
        }
        return originalUrl;
    }"
davmail-4.5.1,davmail.exchange.dav.ExchangeDavMethod,processResponseBody,,42,494,492,30,0.0417,0.0078,0.5,13,9,0,1,"@Override
    protected void processResponseBody(HttpState httpState, HttpConnection httpConnection) {
        Header contentTypeHeader = getResponseHeader(""Content-Type"");
        if (contentTypeHeader != null && ""text/xml"".equals(contentTypeHeader.getValue())) {
            responses = new ArrayList<MultiStatusResponse>();
            XMLStreamReader reader;
            try {
                reader = XMLStreamUtil.createXMLStreamReader(new FilterInputStream(getResponseBodyAsStream()) {
                    final byte[] lastbytes = new byte[3];

                    @Override
                    public int read(byte[] bytes, int off, int len) throws IOException {
                        int count = in.read(bytes, off, len);
                        // patch invalid element name
                        for (int i = 0; i < count; i++) {
                            byte currentByte = bytes[off + i];
                            if ((lastbytes[0] == '<') && (currentByte >= '0' && currentByte <= '9')) {
                                // move invalid first tag char to valid range
                                bytes[off + i] = (byte) (currentByte + 49);
                            }
                            lastbytes[0] = lastbytes[1];
                            lastbytes[1] = lastbytes[2];
                            lastbytes[2] = currentByte;
                        }
                        return count;
                    }

                });
                while (reader.hasNext()) {
                    reader.next();
                    if (XMLStreamUtil.isStartTag(reader, ""response"")) {
                        handleResponse(reader);
                    }
                }

            } catch (IOException e) {
                LOGGER.error(""Error while parsing soap response: "" + e, e);
            } catch (XMLStreamException e) {
                LOGGER.error(""Error while parsing soap response: "" + e, e);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.dav.ExchangeDavMethod,handleResponse,,24,112,53,3,0.2039,0.1431,0.5,5,9,0,1,"protected void handleResponse(XMLStreamReader reader) throws XMLStreamException {
        MultiStatusResponse multiStatusResponse = null;
        String href = null;
        String responseStatus = """";
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""response"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""href"".equals(tagLocalName)) {
                    href = reader.getElementText();
                } else if (""status"".equals(tagLocalName)) {
                    responseStatus = reader.getElementText();
                } else if (""propstat"".equals(tagLocalName)) {
                     if (multiStatusResponse == null) {
                         multiStatusResponse = new MultiStatusResponse(href, responseStatus);
                     }
                     handlePropstat(reader, multiStatusResponse);
                }
            }
        }
        if (multiStatusResponse != null) {
            responses.add(multiStatusResponse);
        }
    }"
davmail-4.5.1,davmail.exchange.dav.ExchangeDavMethod,handlePropstat,,19,36,6,2,0.3167,0.2247,0.5,4,8,0,1,"protected void handlePropstat(XMLStreamReader reader, MultiStatusResponse multiStatusResponse) throws XMLStreamException {
        int propstatStatus = 0;
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""propstat"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""status"".equals(tagLocalName)) {
                    if (""HTTP/1.1 200 OK"".equals(reader.getElementText())) {
                        propstatStatus = HttpStatus.SC_OK;
                    } else {
                        propstatStatus = 0;
                    }
                } else if (""prop"".equals(tagLocalName) && propstatStatus == HttpStatus.SC_OK) {
                    handleProperty(reader, multiStatusResponse);
                }
            }
        }

    }"
davmail-4.5.1,davmail.exchange.dav.ExchangeDavMethod,handleProperty,,17,25,0,3,0.25,0.2511,0.5,5,7,0,1,"protected void handleProperty(XMLStreamReader reader, MultiStatusResponse multiStatusResponse) throws XMLStreamException {
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""prop"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                Namespace namespace = Namespace.getNamespace(reader.getNamespaceURI());
                String tagLocalName = reader.getLocalName();
                if (reader.getAttributeCount() > 0 && ""mv.string"".equals(reader.getAttributeValue(0))) {
                     handleMultiValuedProperty(reader, multiStatusResponse);
                } else {
                    String tagContent = getTagContent(reader);
                    if (tagContent != null) {
                        multiStatusResponse.add(new DefaultDavProperty(tagLocalName, tagContent, namespace));
                    }
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.dav.ExchangeDavMethod,handleMultiValuedProperty,,15,40,14,3,0.213,0.1323,0.5,6,5,0,1,"protected void handleMultiValuedProperty(XMLStreamReader reader, MultiStatusResponse multiStatusResponse) throws XMLStreamException {
        String tagLocalName = reader.getLocalName();
        Namespace namespace = Namespace.getNamespace(reader.getNamespaceURI());
        ArrayList<String> values = new ArrayList<String>();
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, tagLocalName)) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagContent = getTagContent(reader);
                if (tagContent != null) {
                    values.add(tagContent);
                }
            }
        }
        multiStatusResponse.add(new DefaultDavProperty(tagLocalName, values, namespace));
    }"
davmail-4.5.1,davmail.exchange.dav.ExchangePropFindMethod,generateRequestContent,,55,582,384,3,0.0906,0.1695,0,12,9,1,1,"protected byte[] generateRequestContent() {
        try {
            // build namespace map
            int currentChar = 'e';
            final Map<String, Integer> nameSpaceMap = new HashMap<String, Integer>();
            nameSpaceMap.put(""DAV:"", (int) 'D');
            if (propertyNameSet != null) {
                DavPropertyNameIterator propertyNameIterator = propertyNameSet.iterator();
                while (propertyNameIterator.hasNext()) {
                    DavPropertyName davPropertyName = propertyNameIterator.nextPropertyName();

                    davPropertyName.getName();
                    // property namespace
                    String namespaceUri = davPropertyName.getNamespace().getURI();
                    if (!nameSpaceMap.containsKey(namespaceUri)) {
                        nameSpaceMap.put(namespaceUri, currentChar++);
                    }
                }
            }
            // <D:propfind xmlns:D=""DAV:""><D:prop><D:displayname/></D:prop></D:propfind>
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            OutputStreamWriter writer = new OutputStreamWriter(baos, ""UTF-8"");
            writer.write(""<D:propfind "");
            for (Map.Entry<String, Integer> mapEntry : nameSpaceMap.entrySet()) {
                writer.write("" xmlns:"");
                writer.write((char) mapEntry.getValue().intValue());
                writer.write(""=\"""");
                writer.write(mapEntry.getKey());
                writer.write(""\"""");
            }
            writer.write("">"");
            if (propertyNameSet == null || propertyNameSet.isEmpty()) {
                writer.write(""<D:allprop/>"");
            } else {
                writer.write(""<D:prop>"");
                DavPropertyNameIterator propertyNameIterator = propertyNameSet.iterator();
                while (propertyNameIterator.hasNext()) {
                    DavPropertyName davPropertyName = propertyNameIterator.nextPropertyName();
                    char nameSpaceChar = (char) nameSpaceMap.get(davPropertyName.getNamespace().getURI()).intValue();
                    writer.write('<');
                    writer.write(nameSpaceChar);
                    writer.write(':');
                    writer.write(davPropertyName.getName());
                    writer.write(""/>"");
                }
                writer.write(""</D:prop>"");
            }
            writer.write(""</D:propfind>"");
            writer.close();
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }"
davmail-4.5.1,davmail.exchange.dav.ExchangeSearchMethod,generateRequestContent,,18,46,14,3,0.2051,0.2895,1,3,2,0,1,"protected byte[] generateRequestContent() {
        try {

            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            OutputStreamWriter writer = new OutputStreamWriter(baos, ""UTF-8"");
            writer.write(""<?xml version=\""1.0\""?>\n"");
            writer.write(""<d:searchrequest xmlns:d=\""DAV:\"">\n"");
            writer.write(""        <d:sql>"");
            writer.write(StringUtil.xmlEncode(searchRequest));
            writer.write(""</d:sql>\n"");
            writer.write(""</d:searchrequest>"");
            writer.close();
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }"
davmail-4.5.1,davmail.exchange.dav.Field,createField,,10,18,8,3,0.2813,0.1048,0,5,2,0,1,"protected static void createField(String alias, int propertyTag, PropertyType propertyType) {
        String name = 'x' + toHexString(propertyTag) + propertyTypeMap.get(propertyType);
        Field field;
        if (propertyType == PropertyType.Binary) {
            field = new Field(alias, SCHEMAS_MAPI_PROPTAG, name, propertyType, null, ""bin.base64"", name);
        } else {
            field = new Field(alias, SCHEMAS_MAPI_PROPTAG, name, propertyType);
        }
        fieldMap.put(field.alias, field);
    }"
davmail-4.5.1,davmail.exchange.dav.Field,createField,,19,60,29,4,0.1726,0.1465,0,8,3,0,1,"protected static void createField(String alias, DistinguishedPropertySetType propertySetType, int propertyTag, String responseAlias, PropertyType propertyType) {
        String name;
        String updateAlias;
        if (propertySetType == DistinguishedPropertySetType.Address) {
            // Address namespace expects integer names
            name = String.valueOf(propertyTag);
            updateAlias = ""_x0030_x"" + toHexString(propertyTag);
        } else if (propertySetType == DistinguishedPropertySetType.Task) {
            name = ""0x"" + toHexString(propertyTag);
            updateAlias = ""0x0000"" + toHexString(propertyTag);
        } else {
            // Common namespace expects hex names
            name = ""0x"" + toHexString(propertyTag);
            updateAlias = ""_x0030_x"" + toHexString(propertyTag);
        }
        Field field = new Field(alias, Namespace.getNamespace(SCHEMAS_MAPI_ID.getURI() +
                '{' + distinguishedPropertySetMap.get(propertySetType) + ""}/""), name, propertyType, responseAlias, null, updateAlias);
        fieldMap.put(field.alias, field);
    }"
davmail-4.5.1,davmail.exchange.dav.Field,Field,,25,113,90,6,0.1036,0.0503,0,14,6,0,1,"/**
     * Create field for namespace and name of type propertyType.
     *
     * @param alias         logical name in DavMail
     * @param namespace     Exchange namespace
     * @param name          Exchange name
     * @param propertyType  property type
     * @param responseAlias property name in SEARCH response (as responsealias in request)
     * @param cast          response cast type (e.g. bin.base64)
     * @param updateAlias   some properties use a different alias in PROPPATCH requests
     */
    protected Field(String alias, Namespace namespace, String name, PropertyType propertyType, String responseAlias, String cast, String updateAlias) {
        this.alias = alias;

        // property name in PROPFIND requests
        davPropertyName = DavPropertyName.create(name, namespace);
        // property name in PROPPATCH requests
        updatePropertyName = DavPropertyName.create(updateAlias, namespace);

        // a few type based flags
        isMultivalued = propertyType != null && propertyType.toString().endsWith(""Array"");
        isIntValue = propertyType == PropertyType.Long || propertyType == PropertyType.Integer || propertyType == PropertyType.Short;
        isBooleanValue = propertyType == PropertyType.Boolean;
        isFloatValue = propertyType == PropertyType.Float || propertyType == PropertyType.Double;
        isDateValue = propertyType == PropertyType.SystemTime;

        this.uri = namespace.getURI() + name;
        if (responseAlias == null) {
            this.requestPropertyString = '""' + uri + '""';
            this.responsePropertyName = davPropertyName;
        } else {
            this.requestPropertyString = '""' + uri + ""\"" as "" + responseAlias;
            this.responsePropertyName = DavPropertyName.create(responseAlias, EMPTY);
        }
        this.cast = cast;
    }"
davmail-4.5.1,davmail.exchange.dav.Field,createDavProperty,,30,268,260,18,0.0694,0.02,0,7,8,0,1,"/**
     * Create DavProperty object for field alias and value.
     *
     * @param alias DavMail field alias
     * @param value field value
     * @return DavProperty with value or DavPropertyName for null values
     */
    public static PropEntry createDavProperty(String alias, String value) {
        Field field = Field.get(alias);
        if (value == null) {
            // return DavPropertyName to remove property
            return field.updatePropertyName;
        } else if (field.isMultivalued) {
            // multivalued field, split values separated by \n
            List<XmlSerializable> valueList = new ArrayList<XmlSerializable>();
            String[] values = value.split("","");
            for (final String singleValue : values) {
                valueList.add(new XmlSerializable() {
                    public Element toXml(Document document) {
                        return DomUtil.createElement(document, ""v"", XML, singleValue);
                    }
                });
            }

            return new DefaultDavProperty(field.updatePropertyName, valueList);
        } else if (field.isBooleanValue && !""haspicture"".equals(alias)) {
            if (""true"".equals(value)) {
                return new DefaultDavProperty(field.updatePropertyName, ""1"");
            } else if (""false"".equals(value)) {
                return new DefaultDavProperty(field.updatePropertyName, ""0"");
            } else {
                throw new RuntimeException(""Invalid value for "" + field.alias + "": "" + value);
            }
        } else {
            return new DefaultDavProperty(field.updatePropertyName, value);
        }
    }"
davmail-4.5.1,davmail.exchange.dav.Field,createPropertyValue,,34,204,83,3,0.1199,0.149,1,7,10,1,1,"/**
     * Create property value object for field and value.
     *
     * @param alias field alias
     * @param value field value
     * @return property value object
     * @see ExchangePropPatchMethod
     */
    public static PropertyValue createPropertyValue(String alias, String value) {
        Field field = Field.get(alias);
        DavPropertyName davPropertyName = field.davPropertyName;
        if (value == null) {
            // return DavPropertyName to remove property
            return new PropertyValue(davPropertyName.getNamespace().getURI(), davPropertyName.getName());
        } else if (field.isMultivalued) {
            StringBuilder buffer = new StringBuilder();
            // multivalued field, split values separated by \n
            String[] values = value.split(""\n"");
            for (final String singleValue : values) {
                buffer.append(""<v>"");
                buffer.append(StringUtil.xmlEncode(singleValue));
                buffer.append(""</v>"");
            }
            return new PropertyValue(davPropertyName.getNamespace().getURI(), davPropertyName.getName(), buffer.toString());
        } else if (field.isBooleanValue) {
            if (""true"".equals(value)) {
                return new PropertyValue(davPropertyName.getNamespace().getURI(), davPropertyName.getName(), ""1"", ""boolean"");
            } else if (""false"".equals(value)) {
                return new PropertyValue(davPropertyName.getNamespace().getURI(), davPropertyName.getName(), ""0"", ""boolean"");
            } else {
                throw new RuntimeException(""Invalid value for "" + field.alias + "": "" + value);
            }
        } else if (field.isFloatValue) {
            return new PropertyValue(davPropertyName.getNamespace().getURI(), davPropertyName.getName(), StringUtil.xmlEncode(value), ""float"");
        } else if (field.isIntValue) {
            return new PropertyValue(field.updatePropertyName.getNamespace().getURI(), field.updatePropertyName.getName(), StringUtil.xmlEncode(value), ""int"");
        } else if (field.isDateValue) {
            return new PropertyValue(field.updatePropertyName.getNamespace().getURI(), field.updatePropertyName.getName(), StringUtil.xmlEncode(value), ""dateTime.tz"");
        } else {
            return new PropertyValue(davPropertyName.getNamespace().getURI(), davPropertyName.getName(), StringUtil.xmlEncode(value));
        }
    }"
davmail-4.5.1,davmail.exchange.dav.ExchangePropPatchMethod,generateRequestContent,,80,1267,581,4,0.0829,0.2284,0.25,15,13,1,1,"@Override
    protected byte[] generateRequestContent() {
        try {
            // build namespace map
            int currentChar = 'e';
            final Map<String, Integer> nameSpaceMap = new HashMap<String, Integer>();
            final Set<PropertyValue> setPropertyValues = new HashSet<PropertyValue>();
            final Set<PropertyValue> deletePropertyValues = new HashSet<PropertyValue>();
            for (PropertyValue propertyValue : propertyValues) {
                // data type namespace
                if (!nameSpaceMap.containsKey(TYPE_NAMESPACE) && propertyValue.getTypeString() != null) {
                    nameSpaceMap.put(TYPE_NAMESPACE, currentChar++);
                }
                // property namespace
                String namespaceUri = propertyValue.getNamespaceUri();
                if (!nameSpaceMap.containsKey(namespaceUri)) {
                    nameSpaceMap.put(namespaceUri, currentChar++);
                }
                if (propertyValue.getXmlEncodedValue() == null) {
                    deletePropertyValues.add(propertyValue);
                } else {
                    setPropertyValues.add(propertyValue);
                }
            }
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            OutputStreamWriter writer = new OutputStreamWriter(baos, ""UTF-8"");
            writer.write(""<D:propertyupdate xmlns:D=\""DAV:\"""");
            for (Map.Entry<String, Integer> mapEntry : nameSpaceMap.entrySet()) {
                writer.write("" xmlns:"");
                writer.write((char) mapEntry.getValue().intValue());
                writer.write(""=\"""");
                writer.write(mapEntry.getKey());
                writer.write(""\"""");
            }
            writer.write("">"");
            if (!setPropertyValues.isEmpty()) {
                writer.write(""<D:set><D:prop>"");
                for (PropertyValue propertyValue : setPropertyValues) {
                    String typeString = propertyValue.getTypeString();
                    char nameSpaceChar = (char) nameSpaceMap.get(propertyValue.getNamespaceUri()).intValue();
                    writer.write('<');
                    writer.write(nameSpaceChar);
                    writer.write(':');
                    writer.write(propertyValue.getName());
                    if (typeString != null) {
                        writer.write(' ');
                        writer.write(nameSpaceMap.get(TYPE_NAMESPACE));
                        writer.write("":dt=\"""");
                        writer.write(typeString);
                        writer.write(""\"""");
                    }
                    writer.write('>');
                    writer.write(propertyValue.getXmlEncodedValue());
                    writer.write(""</"");
                    writer.write(nameSpaceChar);
                    writer.write(':');
                    writer.write(propertyValue.getName());
                    writer.write('>');
                }
                writer.write(""</D:prop></D:set>"");
            }
            if (!deletePropertyValues.isEmpty()) {
                writer.write(""<D:remove><D:prop>"");
                for (PropertyValue propertyValue : deletePropertyValues) {
                    char nameSpaceChar = (char) nameSpaceMap.get(propertyValue.getNamespaceUri()).intValue();
                    writer.write('<');
                    writer.write(nameSpaceChar);
                    writer.write(':');
                    writer.write(propertyValue.getName());
                    writer.write(""/>"");
                }
                writer.write(""</D:prop></D:remove>"");
            }
            writer.write(""</D:propertyupdate>"");
            writer.close();
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.FolderId,write,,20,52,0,3,0.2375,0.3655,0,1,3,0,1,"/**
     * @inheritDoc
     */
    @Override
    public void write(Writer writer) throws IOException {
        writer.write('<');
        writer.write(name);
        writer.write("" Id=\"""");
        writer.write(value);
        if (changeKey != null) {
            writer.write(""\"" ChangeKey=\"""");
            writer.write(changeKey);
        }
        if (mailbox == null) {
            writer.write(""\""/>"");
        } else {
            writer.write(""\""><t:Mailbox><t:EmailAddress>"");
            writer.write(mailbox);
            writer.write(""</t:EmailAddress></t:Mailbox></"");
            writer.write(name);
            writer.write('>');
        }
    }"
davmail-4.5.1,davmail.exchange.ews.IndexedFieldUpdate,write,,24,70,35,3,0.1833,0.1731,1,5,4,0,1,"/**
     * Write field to request writer.
     *
     * @param itemType item type
     * @param writer   request writer
     * @throws IOException on error
     */
    @Override
    public void write(String itemType, Writer writer) throws IOException {
        if (itemType == null) {
            // use collection name on create
            writer.write(""<t:"");
            writer.write(collectionName);
            writer.write("">"");

            StringBuilder buffer = new StringBuilder();
            for (FieldUpdate fieldUpdate : updates) {
                fieldUpdate.fieldURI.appendValue(buffer, null, fieldUpdate.value);
            }
            writer.write(buffer.toString());

            writer.write(""</t:"");
            writer.write(collectionName);
            writer.write("">"");
        } else {
            // on update, write each fieldupdate
            for (FieldUpdate fieldUpdate : updates) {
                fieldUpdate.write(itemType, writer);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,formLogin,,13,20,12,3,0.25,0.1228,0.5,5,2,0,1,"@Override
    protected HttpMethod formLogin(HttpClient httpClient, HttpMethod initmethod, String userName, String password) throws IOException {
        LOGGER.debug(""Form based authentication detected"");

        HttpMethod logonMethod = buildLogonMethod(httpClient, initmethod);
        if (logonMethod == null) {
            LOGGER.debug(""Authentication form not found at "" + initmethod.getURI() + "", will try direct EWS access"");
        } else {
            logonMethod = postLogonMethod(httpClient, logonMethod, userName, password);
        }

        return logonMethod;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,checkEndPointUrl,,25,83,13,5,0.2315,0.2431,1,3,5,0,1,"/**
     * Check endpoint url.
     *
     * @param endPointUrl endpoint url
     * @throws IOException on error
     */
    protected void checkEndPointUrl(String endPointUrl) throws IOException {
        HttpMethod checkMethod = new HeadMethod(endPointUrl);
        checkMethod.setPath(""/ews/services.wsdl"");
        checkMethod.setFollowRedirects(false);
        try {
            int status = DavGatewayHttpClientFacade.executeNoRedirect(httpClient, checkMethod);
            if (status == HttpStatus.SC_UNAUTHORIZED) {
                // retry with /ews/exchange.asmx
                checkMethod.releaseConnection();
                checkMethod = new HeadMethod(endPointUrl);
                checkMethod.setFollowRedirects(true);
                status = DavGatewayHttpClientFacade.executeNoRedirect(httpClient, checkMethod);
                if (status == HttpStatus.SC_UNAUTHORIZED) {
                    throw new DavMailAuthenticationException(""EXCEPTION_AUTHENTICATION_FAILED"");
                } else if (status != HttpStatus.SC_OK) {
                    throw new IOException(""Ews endpoint not available at "" + checkMethod.getURI().toString()+"" status ""+status);
                }

            } else if (status != HttpStatus.SC_OK) {
                throw new IOException(""Ews endpoint not available at "" + checkMethod.getURI().toString()+"" status ""+status);
            }
        } finally {
            checkMethod.releaseConnection();
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,buildSessionInfo,,104,1297,1163,9,0.0571,0.0447,0.625,25,18,1,1,"@Override
    protected void buildSessionInfo(HttpMethod method) throws DavMailException {
        // no need to check logon method body
        if (method != null) {
            method.releaseConnection();
        }
        directEws = method == null || ""/ews/services.wsdl"".equalsIgnoreCase(method.getPath());

        // options page is not available in direct EWS mode
        if (!directEws) {
            // retrieve email and alias from options page
            getEmailAndAliasFromOptions();
        }

        if (email == null || alias == null) {
            // OWA authentication failed, get email address from login
            if (userName.indexOf('@') >= 0) {
                // userName is email address
                email = userName;
                alias = userName.substring(0, userName.indexOf('@'));
            } else {
                // userName or domain\\username, rebuild email address
                alias = getAliasFromLogin();

                // try to get email address with ResolveNames
                resolveEmailAddress(userName);
                // failover, build from host name
                if (email == null) {
                    email = getAliasFromLogin() + getEmailSuffixFromHostname();
                }
            }
        }

        currentMailboxPath = ""/users/"" + email.toLowerCase();

        // check EWS access
        try {
            checkEndPointUrl(""/ews/exchange.asmx"");
            // workaround for Exchange bug: send fake request
            internalGetFolder("""");
        } catch (IOException e) {
            // first failover: retry with NTLM
            DavGatewayHttpClientFacade.addNTLM(httpClient);
            try {
                checkEndPointUrl(""/ews/exchange.asmx"");
                // workaround for Exchange bug: send fake request
                internalGetFolder("""");
            } catch (IOException e2) {
                LOGGER.debug(e2.getMessage());
                try {
                    // failover, try to retrieve EWS url from autodiscover
                    checkEndPointUrl(getEwsUrlFromAutoDiscover());
                    // workaround for Exchange bug: send fake request
                    internalGetFolder("""");
                } catch (IOException e3) {
                    // autodiscover failed and initial exception was authentication failure => throw original exception
                    if (e instanceof DavMailAuthenticationException) {
                        throw (DavMailAuthenticationException) e;
                    }
                    LOGGER.error(e2.getMessage());
                    throw new DavMailAuthenticationException(""EXCEPTION_EWS_NOT_AVAILABLE"");
                }
            }
        }

        // enable preemptive authentication on non NTLM endpoints
        if (!DavGatewayHttpClientFacade.hasNTLMorNegotiate(httpClient)) {
            httpClient.getParams().setParameter(HttpClientParams.PREEMPTIVE_AUTHENTICATION, true);
        }

        // direct EWS: get primary smtp email address with ResolveNames
        if (directEws) {
            try {
                ResolveNamesMethod resolveNamesMethod = new ResolveNamesMethod(alias);
                executeMethod(resolveNamesMethod);
                List<EWSMethod.Item> responses = resolveNamesMethod.getResponseItems();
                for (EWSMethod.Item response : responses) {
                    if (alias.equalsIgnoreCase(response.get(""Name""))) {
                        email = response.get(""EmailAddress"");
                        currentMailboxPath = ""/users/"" + email.toLowerCase();
                    }
                }
            } catch (IOException e) {
                LOGGER.warn(""Unable to get primary email address with ResolveNames"", e);
            }
        }

        try {
            folderIdMap = new HashMap<String, String>();
            // load actual well known folder ids
            folderIdMap.put(internalGetFolder(INBOX).folderId.value, INBOX);
            folderIdMap.put(internalGetFolder(CALENDAR).folderId.value, CALENDAR);
            folderIdMap.put(internalGetFolder(CONTACTS).folderId.value, CONTACTS);
            folderIdMap.put(internalGetFolder(SENT).folderId.value, SENT);
            folderIdMap.put(internalGetFolder(DRAFTS).folderId.value, DRAFTS);
            folderIdMap.put(internalGetFolder(TRASH).folderId.value, TRASH);
            folderIdMap.put(internalGetFolder(JUNK).folderId.value, JUNK);
            folderIdMap.put(internalGetFolder(UNSENT).folderId.value, UNSENT);
        } catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
            throw new DavMailAuthenticationException(""EXCEPTION_EWS_NOT_AVAILABLE"");
        }
        LOGGER.debug(""Current user email is "" + email + "", alias is "" + alias + "" on "" + serverVersion);
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,resolveEmailAddress,,20,64,50,5,0.1635,0.0756,1,6,4,0,1,"protected void resolveEmailAddress(String userName) {
        String searchValue = userName;
        int index = searchValue.indexOf('\\');
        if (index >= 0) {
            searchValue = searchValue.substring(index+1);
        }
        ResolveNamesMethod resolveNamesMethod = new ResolveNamesMethod(searchValue);
        try {
            // send a fake request to get server version
            internalGetFolder("""");
            executeMethod(resolveNamesMethod);
            List<EWSMethod.Item> responses = resolveNamesMethod.getResponseItems();
            if (responses.size() == 1) {
                email = responses.get(0).get(""EmailAddress"");
            }

        } catch (IOException e) {
            // ignore
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,buildProperties,,32,63,0,3,0.3905,0.4057,1,3,13,0,1,"/**
     * Message create/update properties
     *
     * @param properties flag values map
     * @return field values
     */
    protected List<FieldUpdate> buildProperties(Map<String, String> properties) {
        ArrayList<FieldUpdate> list = new ArrayList<FieldUpdate>();
        for (Map.Entry<String, String> entry : properties.entrySet()) {
            if (""read"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""read"", Boolean.toString(""1"".equals(entry.getValue()))));
            } else if (""junk"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""junk"", entry.getValue()));
            } else if (""flagged"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""flagStatus"", entry.getValue()));
            } else if (""answered"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""lastVerbExecuted"", entry.getValue()));
                if (""102"".equals(entry.getValue())) {
                    list.add(Field.createFieldUpdate(""iconIndex"", ""261""));
                }
            } else if (""forwarded"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""lastVerbExecuted"", entry.getValue()));
                if (""104"".equals(entry.getValue())) {
                    list.add(Field.createFieldUpdate(""iconIndex"", ""262""));
                }
            } else if (""draft"".equals(entry.getKey())) {
                // note: draft is readonly after create
                list.add(Field.createFieldUpdate(""messageFlags"", entry.getValue()));
            } else if (""deleted"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""deleted"", entry.getValue()));
            } else if (""datereceived"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""datereceived"", entry.getValue()));
            } else if (""keywords"".equals(entry.getKey())) {
                list.add(Field.createFieldUpdate(""keywords"", entry.getValue()));
            }
        }
        return list;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,createMessage,,27,140,109,4,0.134,0.087,0.8,9,4,0,1,"@Override
    public void createMessage(String folderPath, String messageName, HashMap<String, String> properties, MimeMessage mimeMessage) throws IOException {
        EWSMethod.Item item = new EWSMethod.Item();
        item.type = ""Message"";
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            mimeMessage.writeTo(baos);
        } catch (MessagingException e) {
            throw new IOException(e.getMessage());
        }
        baos.close();
        item.mimeContent = IOUtil.encodeBase64(baos.toByteArray());

        List<FieldUpdate> fieldUpdates = buildProperties(properties);
        if (!properties.containsKey(""draft"")) {
            // need to force draft flag to false
            if (properties.containsKey(""read"")) {
                fieldUpdates.add(Field.createFieldUpdate(""messageFlags"", ""1""));
            } else {
                fieldUpdates.add(Field.createFieldUpdate(""messageFlags"", ""0""));
            }
        }
        fieldUpdates.add(Field.createFieldUpdate(""urlcompname"", messageName));
        item.setFieldUpdates(fieldUpdates);
        CreateItemMethod createItemMethod = new CreateItemMethod(MessageDisposition.SaveOnly, getFolderId(folderPath), item);
        executeMethod(createItemMethod);
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,updateMessage,,13,17,13,4,0.2286,0.1167,1,4,4,0,1,"@Override
    public void updateMessage(ExchangeSession.Message message, Map<String, String> properties) throws IOException {
        if (properties.containsKey(""read"") && ""urn:content-classes:appointment"".equals(message.contentClass)) {
            properties.remove(""read"");
        }
        if (!properties.isEmpty()) {
            UpdateItemMethod updateItemMethod = new UpdateItemMethod(MessageDisposition.SaveOnly,
                    ConflictResolution.AlwaysOverwrite,
                    SendMeetingInvitationsOrCancellations.SendToNone,
                    ((EwsExchangeSession.Message) message).itemId, buildProperties(properties));
            executeMethod(updateItemMethod);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,sendMessage,,18,60,42,4,0.1538,0.1029,0.8,5,3,0,1,"protected void sendMessage(String itemClass, byte[] messageBody) throws IOException {
        EWSMethod.Item item = new EWSMethod.Item();
        item.type = ""Message"";
        item.mimeContent = IOUtil.encodeBase64(messageBody);
        if (itemClass != null) {
            item.put(""ItemClass"", itemClass);
        }

        MessageDisposition messageDisposition;
        if (Settings.getBooleanProperty(""davmail.smtpSaveInSent"", true)) {
            messageDisposition = MessageDisposition.SendAndSaveCopy;
        } else {
            messageDisposition = MessageDisposition.SendOnly;
        }

        CreateItemMethod createItemMethod = new CreateItemMethod(messageDisposition, getFolderId(SENT), item);
        executeMethod(createItemMethod);
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,sendMessage,,15,37,29,4,0.22,0.1023,0,4,3,0,1,"@Override
    public void sendMessage(MimeMessage mimeMessage) throws IOException, MessagingException {
        String itemClass = null;
        if (mimeMessage.getContentType().startsWith(""multipart/report"")) {
            itemClass = ""REPORT.IPM.Note.IPNRN"";
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            mimeMessage.writeTo(baos);
        } catch (MessagingException e) {
            throw new IOException(e.getMessage());
        }
        sendMessage(itemClass, baos.toByteArray());
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,buildMessage,,42,170,0,3,0.2312,0.3086,0.714285714,5,7,0,1,"protected Message buildMessage(EWSMethod.Item response) throws DavMailException {
        Message message = new Message();

        // get item id
        message.itemId = new ItemId(response);

        message.permanentUrl = response.get(Field.get(""permanenturl"").getResponseName());

        message.size = response.getInt(Field.get(""messageSize"").getResponseName());
        message.uid = response.get(Field.get(""uid"").getResponseName());
        message.contentClass = response.get(Field.get(""contentclass"").getResponseName());
        message.imapUid = response.getLong(Field.get(""imapUid"").getResponseName());
        message.read = response.getBoolean(Field.get(""read"").getResponseName());
        message.junk = response.getBoolean(Field.get(""junk"").getResponseName());
        message.flagged = ""2"".equals(response.get(Field.get(""flagStatus"").getResponseName()));
        message.draft = (response.getInt(Field.get(""messageFlags"").getResponseName()) & 8) != 0;
        String lastVerbExecuted = response.get(Field.get(""lastVerbExecuted"").getResponseName());
        message.answered = ""102"".equals(lastVerbExecuted) || ""103"".equals(lastVerbExecuted);
        message.forwarded = ""104"".equals(lastVerbExecuted);
        message.date = convertDateFromExchange(response.get(Field.get(""date"").getResponseName()));
        message.deleted = ""1"".equals(response.get(Field.get(""deleted"").getResponseName()));

        String lastmodified = convertDateFromExchange(response.get(Field.get(""lastmodified"").getResponseName()));
        message.recent = !message.read && lastmodified != null && lastmodified.equals(message.date);

        message.keywords = response.get(Field.get(""keywords"").getResponseName());

        if (LOGGER.isDebugEnabled()) {
            StringBuilder buffer = new StringBuilder();
            buffer.append(""Message"");
            if (message.imapUid != 0) {
                buffer.append("" IMAP uid: "").append(message.imapUid);
            }
            if (message.uid != null) {
                buffer.append("" uid: "").append(message.uid);
            }
            buffer.append("" ItemId: "").append(message.itemId.id);
            buffer.append("" ChangeKey: "").append(message.itemId.changeKey);
            LOGGER.debug(buffer.toString());
        }
        return message;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,searchMessages,,16,49,32,3,0.1667,0.1385,1,8,3,0,1,"@Override
    public MessageList searchMessages(String folderPath, Set<String> attributes, Condition condition) throws IOException {
        MessageList messages = new MessageList();
        int maxCount = Settings.getIntProperty(""davmail.folderSizeLimit"", 0);
        List<EWSMethod.Item> responses = searchItems(folderPath, attributes, condition, FolderQueryTraversal.SHALLOW, maxCount);

        for (EWSMethod.Item response : responses) {
            if (MESSAGE_TYPES.contains(response.type)) {
                Message message = buildMessage(response);
                message.messageList = messages;
                messages.add(message);
            }
        }
        Collections.sort(messages);
        return messages;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,searchItems,,38,152,94,2,0.1429,0.0937,0.666666667,9,8,0,1,"protected List<EWSMethod.Item> searchItems(String folderPath, Set<String> attributes, Condition condition, FolderQueryTraversal folderQueryTraversal, int maxCount) throws IOException {
        if (maxCount == 0) {
            // unlimited search
            return searchItems(folderPath, attributes, condition, folderQueryTraversal);
        }
        // limited search, do not use paged search, limit with maxCount, sort by imapUid descending to get latest items
        int resultCount;
        List<EWSMethod.Item> results = new ArrayList<EWSMethod.Item>();
        FindItemMethod findItemMethod;

        // search items in folder, do not retrieve all properties
        findItemMethod = new FindItemMethod(folderQueryTraversal, BaseShape.ID_ONLY, getFolderId(folderPath), 0, maxCount);
        for (String attribute : attributes) {
            findItemMethod.addAdditionalProperty(Field.get(attribute));
        }
        // make sure imapUid is available
        if (!attributes.contains(""imapUid"")) {
            findItemMethod.addAdditionalProperty(Field.get(""imapUid""));
        }

        // always sort items by imapUid descending to retrieve recent messages first
        findItemMethod.setFieldOrder(new FieldOrder(Field.get(""imapUid""), FieldOrder.Order.Descending));

        if (condition != null && !condition.isEmpty()) {
            findItemMethod.setSearchExpression((SearchExpression) condition);
        }
        executeMethod(findItemMethod);
        results.addAll(findItemMethod.getResponseItems());
        resultCount = results.size();
        if (resultCount > 0 && LOGGER.isDebugEnabled()) {
            LOGGER.debug(""Folder "" + folderPath + "" - Search items count: "" + resultCount + "" maxCount: "" + maxCount
                    + "" highest uid: "" + results.get(0).get(Field.get(""imapUid"").getResponseName())
                    + "" lowest uid: "" + results.get(resultCount - 1).get(Field.get(""imapUid"").getResponseName()));
        }


        return results;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,searchItems,,50,431,334,6,0.088,0.061,0.666666667,13,12,0,1,"/**
     * Paged search, retrieve all items.
     *
     * @param folderPath folder path
     * @param attributes attributes
     * @param condition search condition
     * @param folderQueryTraversal search mode
     * @return items
     * @throws IOException on error
     */
    protected List<EWSMethod.Item> searchItems(String folderPath, Set<String> attributes, Condition condition, FolderQueryTraversal folderQueryTraversal) throws IOException {
        int resultCount = 0;
        List<EWSMethod.Item> results = new ArrayList<EWSMethod.Item>();
        FolderId folderId = getFolderId(folderPath);
        FindItemMethod findItemMethod;
        do {
            int fetchCount = PAGE_SIZE;

            // search items in folder, do not retrieve all properties
            findItemMethod = new FindItemMethod(folderQueryTraversal, BaseShape.ID_ONLY, folderId, resultCount, fetchCount);
            for (String attribute : attributes) {
                findItemMethod.addAdditionalProperty(Field.get(attribute));
            }
            // make sure imapUid is available
            if (!attributes.contains(""imapUid"")) {
                findItemMethod.addAdditionalProperty(Field.get(""imapUid""));
            }

            // always sort items by imapUid ascending to retrieve pages in creation order
            findItemMethod.setFieldOrder(new FieldOrder(Field.get(""imapUid""), FieldOrder.Order.Ascending));

            if (condition != null && !condition.isEmpty()) {
                findItemMethod.setSearchExpression((SearchExpression) condition);
            }
            executeMethod(findItemMethod);

            long highestUid = 0;
            if (resultCount > 0) {
                highestUid = Long.parseLong(results.get(resultCount-1).get(Field.get(""imapUid"").getResponseName()));
            }
            // Only add new result if not already available (concurrent folder changes issue)
            for (EWSMethod.Item item:findItemMethod.getResponseItems()) {
                long imapUid = Long.parseLong(item.get(Field.get(""imapUid"").getResponseName()));
                if (imapUid > highestUid) {
                    results.add(item);
                }
            }
            resultCount = results.size();
            if (resultCount > 0 && LOGGER.isDebugEnabled()) {
                LOGGER.debug(""Folder "" + folderPath + "" - Search items current count: ""+resultCount+"" fetchCount: ""+fetchCount
                        +"" highest uid: ""+results.get(resultCount-1).get(Field.get(""imapUid"").getResponseName())
                        +"" lowest uid: ""+results.get(0).get(Field.get(""imapUid"").getResponseName()));
            }
            if (Thread.interrupted()) {
                LOGGER.debug(""Folder "" + folderPath + "" - Search items failed: Interrupted by client"");
                throw new IOException(""Search items failed: Interrupted by client"");
            }
        } while (!(findItemMethod.includesLastItemInRange));
        return results;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,headerIsEqualTo,,18,19,2,3,0.3889,0.2714,1,2,7,0,1,"@Override
    public Condition headerIsEqualTo(String headerName, String value) {
        if (serverVersion.startsWith(""Exchange201"")) {
            if (""from"".equals(headerName)
                    || ""to"".equals(headerName)
                    || ""cc"".equals(headerName)) {
                return new AttributeCondition(""msg""+headerName, Operator.Contains, value, ContainmentMode.Substring, ContainmentComparison.IgnoreCase);
            } else if (""message-id"".equals(headerName)
                    || ""bcc"".equals(headerName)) {
                return new AttributeCondition(headerName, Operator.Contains, value, ContainmentMode.Substring, ContainmentComparison.IgnoreCase);
            } else {
                // Exchange 2010 does not support header search, use PR_TRANSPORT_MESSAGE_HEADERS instead
                return new AttributeCondition(""messageheaders"", Operator.Contains, headerName + "": "" + value, ContainmentMode.Substring, ContainmentComparison.IgnoreCase);
            }
        } else {
            return new HeaderCondition(headerName, value);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,buildFolder,,16,25,0,3,0.4429,0.4772,0.833333333,2,1,0,1,"protected Folder buildFolder(EWSMethod.Item item) {
        Folder folder = new Folder();
        folder.folderId = new FolderId(item);
        folder.displayName = item.get(Field.get(""folderDisplayName"").getResponseName());
        folder.folderClass = item.get(Field.get(""folderclass"").getResponseName());
        folder.etag = item.get(Field.get(""lastmodified"").getResponseName());
        folder.ctag = item.get(Field.get(""ctag"").getResponseName());
        folder.count = item.getInt(Field.get(""count"").getResponseName());
        folder.unreadCount = item.getInt(Field.get(""unread"").getResponseName());
        // fake recent value
        folder.recent = folder.unreadCount;
        folder.hasChildren = item.getBoolean(Field.get(""hassubs"").getResponseName());
        // noInferiors not implemented
        folder.uidNext = item.getInt(Field.get(""uidNext"").getResponseName());
        return folder;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,appendSubFolders,,25,59,13,2,0.1911,0.1353,1,8,7,0,1,"protected void appendSubFolders(List<ExchangeSession.Folder> folders,
                                    String parentFolderPath, FolderId parentFolderId,
                                    Condition condition, boolean recursive) throws IOException {
        FindFolderMethod findFolderMethod = new FindFolderMethod(FolderQueryTraversal.SHALLOW,
                BaseShape.ID_ONLY, parentFolderId, FOLDER_PROPERTIES, (SearchExpression) condition);
        executeMethod(findFolderMethod);
        for (EWSMethod.Item item : findFolderMethod.getResponseItems()) {
            Folder folder = buildFolder(item);
            if (parentFolderPath.length() > 0) {
                if (parentFolderPath.endsWith(""/"")) {
                    folder.folderPath = parentFolderPath + item.get(Field.get(""folderDisplayName"").getResponseName());
                } else {
                    folder.folderPath = parentFolderPath + '/' + item.get(Field.get(""folderDisplayName"").getResponseName());
                }
            } else if (folderIdMap.get(folder.folderId.value) != null) {
                folder.folderPath = folderIdMap.get(folder.folderId.value);
            } else {
                folder.folderPath = item.get(Field.get(""folderDisplayName"").getResponseName());
            }
            folders.add(folder);
            if (recursive && folder.hasChildren) {
                appendSubFolders(folders, folder.folderPath, folder.folderId, condition, recursive);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,internalGetFolder,,15,50,34,3,0.2222,0.1128,1,5,2,0,1,"/**
     * Get folder by path.
     *
     * @param folderPath folder path
     * @return folder object
     * @throws IOException on error
     */
    @Override
    protected EwsExchangeSession.Folder internalGetFolder(String folderPath) throws IOException {
        FolderId folderId = getFolderId(folderPath);
        GetFolderMethod getFolderMethod = new GetFolderMethod(BaseShape.ID_ONLY, folderId, FOLDER_PROPERTIES);
        executeMethod(getFolderMethod);
        EWSMethod.Item item = getFolderMethod.getResponseItem();
        Folder folder;
        if (item != null) {
            folder = buildFolder(item);
            folder.folderPath = folderPath;
        } else {
            throw new HttpNotFoundException(""Folder "" + folderPath + "" not found"");
        }
        return folder;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,createFolder,,12,33,21,4,0.175,0.102,0.75,6,1,0,1,"/**
     * @inheritDoc
     */
    @Override
    public int createFolder(String folderPath, String folderClass, Map<String, String> properties) throws IOException {
        FolderPath path = new FolderPath(folderPath);
        EWSMethod.Item folder = new EWSMethod.Item();
        folder.type = ""Folder"";
        folder.put(""FolderClass"", folderClass);
        folder.put(""DisplayName"", path.folderName);
        // TODO: handle properties
        CreateFolderMethod createFolderMethod = new CreateFolderMethod(getFolderId(path.parentPath), folder);
        executeMethod(createFolderMethod);
        return HttpStatus.SC_CREATED;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,updateFolder,,11,23,18,4,0.2083,0.066,1,6,2,0,1,"/**
     * @inheritDoc
     */
    @Override
    public int updateFolder(String folderPath, Map<String, String> properties) throws IOException {
        ArrayList<FieldUpdate> updates = new ArrayList<FieldUpdate>();
        for (Map.Entry<String, String> entry : properties.entrySet()) {
            updates.add(new FieldUpdate(Field.get(entry.getKey()), entry.getValue()));
        }
        UpdateFolderMethod updateFolderMethod = new UpdateFolderMethod(internalGetFolder(folderPath).folderId, updates);

        executeMethod(updateFolderMethod);
        return HttpStatus.SC_CREATED;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,deleteFolder,,10,16,11,3,0.2857,0.1083,1,3,2,0,1,"/**
     * @inheritDoc
     */
    @Override
    public void deleteFolder(String folderPath) throws IOException {
        FolderId folderId = getFolderIdIfExists(folderPath);
        if (folderId != null) {
            DeleteFolderMethod deleteFolderMethod = new DeleteFolderMethod(folderId);
            executeMethod(deleteFolderMethod);
        } else {
            LOGGER.debug(""Folder "" + folderPath + "" not found"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,moveFolder,,20,85,65,3,0.1515,0.0678,1,9,3,0,1,"/**
     * @inheritDoc
     */
    @Override
    public void moveFolder(String folderPath, String targetFolderPath) throws IOException {
        FolderPath path = new FolderPath(folderPath);
        FolderPath targetPath = new FolderPath(targetFolderPath);
        FolderId folderId = getFolderId(folderPath);
        FolderId toFolderId = getFolderId(targetPath.parentPath);
        toFolderId.changeKey = null;
        // move folder
        if (!path.parentPath.equals(targetPath.parentPath)) {
            MoveFolderMethod moveFolderMethod = new MoveFolderMethod(folderId, toFolderId);
            executeMethod(moveFolderMethod);
        }
        // rename folder
        if (!path.folderName.equals(targetPath.folderName)) {
            ArrayList<FieldUpdate> updates = new ArrayList<FieldUpdate>();
            updates.add(new FieldUpdate(Field.get(""folderDisplayName""), targetPath.folderName));
            UpdateFolderMethod updateFolderMethod = new UpdateFolderMethod(folderId, updates);
            executeMethod(updateFolderMethod);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,searchContacts,,11,16,11,2,0.2143,0.1042,1,7,2,0,1,"@Override
    public List<ExchangeSession.Contact> searchContacts(String folderPath, Set<String> attributes, Condition condition, int maxCount) throws IOException {
        List<ExchangeSession.Contact> contacts = new ArrayList<ExchangeSession.Contact>();
        List<EWSMethod.Item> responses = searchItems(folderPath, attributes, condition,
                FolderQueryTraversal.SHALLOW, maxCount);

        for (EWSMethod.Item response : responses) {
            contacts.add(new Contact(response));
        }
        return contacts;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,searchEvents,,28,399,333,9,0.0968,0.1027,0.666666667,8,5,0,1,"@Override
    public List<ExchangeSession.Event> searchEvents(String folderPath, Set<String> attributes, Condition condition) throws IOException {
        List<ExchangeSession.Event> events = new ArrayList<ExchangeSession.Event>();
        List<EWSMethod.Item> responses = searchItems(folderPath, attributes,
                condition,
                FolderQueryTraversal.SHALLOW, 0);
        for (EWSMethod.Item response : responses) {
            Event event = new Event(folderPath, response);
            if (""Message"".equals(event.type)) {
                // TODO: just exclude
                // need to check body
                try {
                    event.getEventContent();
                    events.add(event);
                } catch (HttpException e) {
                    LOGGER.warn(""Ignore invalid event "" + event.getHref());
                }
                // exclude exceptions
            } else if (event.isException) {
                LOGGER.debug(""Exclude recurrence exception "" + event.getHref());
            } else {
                events.add(event);
            }

        }

        return events;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,deleteItem,,12,21,14,4,0.25,0.1142,1,4,4,0,1,"@Override
    public void deleteItem(String folderPath, String itemName) throws IOException {
        EWSMethod.Item item = getEwsItem(folderPath, itemName);
        if (item == null && isMainCalendar(folderPath)) {
            // look for item in task folder
            item = getEwsItem(TASKS, itemName);
        }
        if (item != null) {
            DeleteItemMethod deleteItemMethod = new DeleteItemMethod(new ItemId(item), DeleteType.HardDelete, SendMeetingCancellations.SendToNone);
            executeMethod(deleteItemMethod);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,processItem,,14,31,26,5,0.1667,0.1024,1,5,2,0,1,"@Override
    public void processItem(String folderPath, String itemName) throws IOException {
        EWSMethod.Item item = getEwsItem(folderPath, itemName);
        if (item != null) {
            HashMap<String, String> localProperties = new HashMap<String, String>();
            localProperties.put(""processed"", ""1"");
            localProperties.put(""read"", ""1"");
            UpdateItemMethod updateItemMethod = new UpdateItemMethod(MessageDisposition.SaveOnly,
                    ConflictResolution.AlwaysOverwrite,
                    SendMeetingInvitationsOrCancellations.SendToNone,
                    new ItemId(item), buildProperties(localProperties));
            executeMethod(updateItemMethod);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,sendEvent,,12,24,20,5,0.2,0.0773,1,3,2,0,1,"@Override
    public int sendEvent(String icsBody) throws IOException {
        String itemName = UUID.randomUUID().toString() + "".EML"";
        byte[] mimeContent = new Event(DRAFTS, itemName, ""urn:content-classes:calendarmessage"", icsBody, null, null).createMimeContent();
        if (mimeContent == null) {
            // no recipients, cancel
            return HttpStatus.SC_NO_CONTENT;
        } else {
            sendMessage(null, mimeContent);
            return HttpStatus.SC_OK;
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,loadVtimezone,,51,510,425,8,0.0729,0.0714,0.8,10,8,0,1,"@Override
    protected void loadVtimezone() {

        try {
            String timezoneId = null;
            if (!""Exchange2007_SP1"".equals(serverVersion)) {
                // On Exchange 2010, get user timezone from server
                GetUserConfigurationMethod getUserConfigurationMethod = new GetUserConfigurationMethod();
                executeMethod(getUserConfigurationMethod);
                EWSMethod.Item item = getUserConfigurationMethod.getResponseItem();
                if (item != null) {
                    timezoneId = item.get(""timezone"");
                }
            } else if (!directEws) {
                timezoneId = getTimezoneidFromOptions();
            }
            // failover: use timezone id from settings file
            if (timezoneId == null) {
                timezoneId = Settings.getProperty(""davmail.timezoneId"");
            }
            // last failover: use GMT
            if (timezoneId == null) {
                LOGGER.warn(""Unable to get user timezone, using GMT Standard Time. Set davmail.timezoneId setting to override this."");
                timezoneId = ""GMT Standard Time"";
            }

            createCalendarFolder(""davmailtemp"", null);
            EWSMethod.Item item = new EWSMethod.Item();
            item.type = ""CalendarItem"";
            if (!""Exchange2007_SP1"".equals(serverVersion)) {
                SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss"", Locale.ENGLISH);
                dateFormatter.setTimeZone(GMT_TIMEZONE);
                Calendar cal = Calendar.getInstance();
                item.put(""Start"", dateFormatter.format(cal.getTime()));
                cal.add(Calendar.DAY_OF_MONTH, 1);
                item.put(""End"", dateFormatter.format(cal.getTime()));
                item.put(""StartTimeZone"", timezoneId);
            } else {
                item.put(""MeetingTimeZone"", timezoneId);
            }
            CreateItemMethod createItemMethod = new CreateItemMethod(MessageDisposition.SaveOnly, SendMeetingInvitations.SendToNone, getFolderId(""davmailtemp""), item);
            executeMethod(createItemMethod);
            item = createItemMethod.getResponseItem();
            VCalendar vCalendar = new VCalendar(getContent(new ItemId(item)), email, null);
            this.vTimezone = vCalendar.getVTimezone();
            // delete temporary folder
            deleteFolder(""davmailtemp"");
        } catch (IOException e) {
            LOGGER.warn(""Unable to get VTIMEZONE info: "" + e, e);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,executeMethod,,12,456,209,10,0.1789,0.3558,0.333333333,1,2,0,1,"protected void executeMethod(EWSMethod ewsMethod) throws IOException {
        try {
            ewsMethod.setServerVersion(serverVersion);
            httpClient.executeMethod(ewsMethod);
            if (serverVersion == null) {
                serverVersion = ewsMethod.getServerVersion();
            }
            ewsMethod.checkSuccess();
        } finally {
            ewsMethod.releaseConnection();
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,buildGalfindContact,,21,79,38,3,0.2083,0.1312,0.666666667,6,7,0,1,"protected Contact buildGalfindContact(EWSMethod.Item response) {
        Contact contact = new Contact();
        contact.setName(response.get(""Name""));
        contact.put(""imapUid"", response.get(""Name""));
        contact.put(""uid"", response.get(""Name""));
        if (LOGGER.isDebugEnabled()) {
            for (Map.Entry<String, String> entry : response.entrySet()) {
                String key = entry.getKey();
                if (!IGNORE_ATTRIBUTE_SET.contains(key) && !GALFIND_ATTRIBUTE_MAP.containsValue(key)) {
                    LOGGER.debug(""Unsupported ResolveNames "" + contact.getName() + "" response attribute: "" + key + "" value: "" + entry.getValue());
                }
            }
        }
        for (Map.Entry<String, String> entry : GALFIND_ATTRIBUTE_MAP.entrySet()) {
            String attributeValue = response.get(entry.getValue());
            if (attributeValue != null) {
                contact.put(entry.getKey(), attributeValue);
            }
        }
        return contact;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,galFind,,46,394,260,2,0.1061,0.0909,0.777777778,17,15,0,1,"@Override
    public Map<String, ExchangeSession.Contact> galFind(Condition condition, Set<String> returningAttributes, int sizeLimit) throws IOException {
        Map<String, ExchangeSession.Contact> contacts = new HashMap<String, ExchangeSession.Contact>();
        if (condition instanceof MultiCondition) {
            List<Condition> conditions = ((ExchangeSession.MultiCondition) condition).getConditions();
            Operator operator = ((ExchangeSession.MultiCondition) condition).getOperator();
            if (operator == Operator.Or) {
                for (Condition innerCondition : conditions) {
                    contacts.putAll(galFind(innerCondition, returningAttributes, sizeLimit));
                }
            } else if (operator == Operator.And && !conditions.isEmpty()) {
                Map<String, ExchangeSession.Contact> innerContacts = galFind(conditions.get(0), returningAttributes, sizeLimit);
                for (ExchangeSession.Contact contact : innerContacts.values()) {
                    if (condition.isMatch(contact)) {
                        contacts.put(contact.getName().toLowerCase(), contact);
                    }
                }
            }
        } else if (condition instanceof AttributeCondition) {
            String mappedAttributeName = GALFIND_ATTRIBUTE_MAP.get(((ExchangeSession.AttributeCondition) condition).getAttributeName());
            if (mappedAttributeName != null) {
                String value = ((ExchangeSession.AttributeCondition) condition).getValue().toLowerCase();
                Operator operator = ((AttributeCondition) condition).getOperator();
                String searchValue = value;
                if (mappedAttributeName.startsWith(""EmailAddress"")) {
                    searchValue = ""smtp:"" + searchValue;
                }
                if (operator == Operator.IsEqualTo) {
                    searchValue = '=' + searchValue;
                }
                ResolveNamesMethod resolveNamesMethod = new ResolveNamesMethod(searchValue);
                executeMethod(resolveNamesMethod);
                List<EWSMethod.Item> responses = resolveNamesMethod.getResponseItems();
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug(""ResolveNames("" + searchValue + "") returned "" + responses.size() + "" results"");
                }
                for (EWSMethod.Item response : responses) {
                    Contact contact = buildGalfindContact(response);
                    if (condition.isMatch(contact)) {
                        contacts.put(contact.getName().toLowerCase(), contact);
                    }
                }
            }
        }
        return contacts;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,parseDateFromExchange,,11,22,16,4,0.2917,0.1481,1,3,3,0,1,"protected Date parseDateFromExchange(String exchangeDateValue) throws DavMailException {
        Date dateValue = null;
        if (exchangeDateValue != null) {
            try {
                dateValue = getExchangeZuluDateFormat().parse(exchangeDateValue);
            } catch (ParseException e) {
                throw new DavMailException(""EXCEPTION_INVALID_DATE"", exchangeDateValue);
            }
        }
        return dateValue;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,convertDateFromExchange,,11,22,16,4,0.2917,0.1481,0.666666667,3,3,0,1,"protected String convertDateFromExchange(String exchangeDateValue) throws DavMailException {
        String zuluDateValue = null;
        if (exchangeDateValue != null) {
            try {
                zuluDateValue = getZuluDateFormat().format(getExchangeZuluDateFormat().parse(exchangeDateValue));
            } catch (ParseException e) {
                throw new DavMailException(""EXCEPTION_INVALID_DATE"", exchangeDateValue);
            }
        }
        return zuluDateValue;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,convertCalendarDateToExchange,,20,82,59,4,0.2,0.1152,1,5,4,0,1,"protected String convertCalendarDateToExchange(String vcalendarDateValue) throws DavMailException {
        String zuluDateValue = null;
        if (vcalendarDateValue != null) {
            try {
                SimpleDateFormat dateParser;
                if (vcalendarDateValue.length() == 8) {
                    dateParser = new SimpleDateFormat(""yyyyMMdd"", Locale.ENGLISH);
                } else {
                    dateParser = new SimpleDateFormat(""yyyyMMdd'T'HHmmss"", Locale.ENGLISH);
                }
                dateParser.setTimeZone(GMT_TIMEZONE);
                SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss"", Locale.ENGLISH);
                dateFormatter.setTimeZone(GMT_TIMEZONE);
                zuluDateValue = dateFormatter.format(dateParser.parse(vcalendarDateValue));
            } catch (ParseException e) {
                throw new DavMailException(""EXCEPTION_INVALID_DATE"", vcalendarDateValue);
            }
        }
        return zuluDateValue;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,convertDateFromExchangeToTaskDate,,13,36,27,4,0.22,0.1004,1,4,3,0,1,"protected String convertDateFromExchangeToTaskDate(String exchangeDateValue) throws DavMailException {
        String zuluDateValue = null;
        if (exchangeDateValue != null) {
            try {
                SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyyMMdd"", Locale.ENGLISH);
                dateFormat.setTimeZone(GMT_TIMEZONE);
                zuluDateValue = dateFormat.format(getExchangeZuluDateFormat().parse(exchangeDateValue));
            } catch (ParseException e) {
                throw new DavMailException(""EXCEPTION_INVALID_DATE"", exchangeDateValue);
            }
        }
        return zuluDateValue;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,convertTaskDateToZulu,,34,202,128,4,0.1528,0.1431,1,5,8,0,1,"protected String convertTaskDateToZulu(String value) {
        String result = null;
        if (value != null && value.length() > 0) {
            try {
                SimpleDateFormat parser;
                if (value.length() == 8) {
                    parser = new SimpleDateFormat(""yyyyMMdd"", Locale.ENGLISH);
                    parser.setTimeZone(GMT_TIMEZONE);
                } else if (value.length() == 15) {
                    parser = new SimpleDateFormat(""yyyyMMdd'T'HHmmss"", Locale.ENGLISH);
                    parser.setTimeZone(GMT_TIMEZONE);
                } else if (value.length() == 16) {
                    parser = new SimpleDateFormat(""yyyyMMdd'T'HHmmss'Z'"", Locale.ENGLISH);
                    parser.setTimeZone(GMT_TIMEZONE);
                } else {
                    parser = ExchangeSession.getExchangeZuluDateFormat();
                }
                Calendar calendarValue = Calendar.getInstance(GMT_TIMEZONE);
                calendarValue.setTime(parser.parse(value));
                // zulu time: add 12 hours
                if (value.length() == 16) {
                    calendarValue.add(Calendar.HOUR, 12);
                }
                calendarValue.set(Calendar.HOUR, 0);
                calendarValue.set(Calendar.MINUTE, 0);
                calendarValue.set(Calendar.SECOND, 0);
                result = ExchangeSession.getExchangeZuluDateFormat().format(calendarValue.getTime());
            } catch (ParseException e) {
                LOGGER.warn(""Invalid date: "" + value);
            }
        }

        return result;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,isItemId,,6,92,79,8,0.2222,0.1368,0,1,1,0,1,"/**
     * Check if itemName is long and base64 encoded.
     * User generated item names are usually short
     * @param itemName item name
     * @return true if itemName is an EWS item id
     */
    protected static boolean isItemId(String itemName) {
        return itemName.length() >= 152
                // item name is base64url
                //&& itemName.matches(""^([A-Za-z0-9-_]{4})*([A-Za-z0-9-_]{4}|[A-Za-z0-9-_]{3}=|[A-Za-z0-9-_]{2}==)$"")
                && itemName.indexOf(' ') < 0;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,convertPriorityFromExchange,,7,11,7,3,0.3333,0.1429,0,2,2,0,1,"protected String convertPriorityFromExchange(String exchangeImportanceValue) {
        String value = null;
        if (exchangeImportanceValue != null) {
            value = importanceToPriorityMap.get(exchangeImportanceValue);
        }
        return value;
    }"
davmail-4.5.1,davmail.exchange.ews.EwsExchangeSession,convertPriorityToExchange,,7,11,7,3,0.3333,0.1429,0,2,2,0,1,"protected String convertPriorityToExchange(String vTodoPriorityValue) {
        String value = null;
        if (vTodoPriorityValue != null) {
            value = priorityToImportanceMap.get(vTodoPriorityValue);
        }
        return value;
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeShape,,23,105,39,3,0.188,0.248,1,3,5,0,1,"protected void writeShape(Writer writer) throws IOException {
        if (baseShape != null) {
            writer.write(""<m:"");
            writer.write(itemType);
            writer.write(""Shape>"");
            baseShape.write(writer);
            if (includeMimeContent) {
                writer.write(""<t:IncludeMimeContent>true</t:IncludeMimeContent>"");
            }
            if (additionalProperties != null) {
                writer.write(""<t:AdditionalProperties>"");
                StringBuilder buffer = new StringBuilder();
                for (FieldURI fieldURI : additionalProperties) {
                    fieldURI.appendTo(buffer);
                }
                writer.write(buffer.toString());
                writer.write(""</t:AdditionalProperties>"");
            }
            writer.write(""</m:"");
            writer.write(itemType);
            writer.write(""Shape>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeItemId,,11,19,10,3,0.375,0.1914,1,1,4,0,1,"protected void writeItemId(Writer writer) throws IOException {
        if (itemId != null) {
            if (updates == null) {
                writer.write(""<m:ItemIds>"");
            }
            itemId.write(writer);
            if (updates == null) {
                writer.write(""</m:ItemIds>"");
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeParentItemId,,11,21,6,3,0.5,0.2857,0,1,3,0,1,"protected void writeParentItemId(Writer writer) throws IOException {
        if (parentItemId != null) {
            writer.write(""<m:ParentItemId Id=\"""");
            writer.write(parentItemId.id);
            if (parentItemId.changeKey != null) {
                writer.write(""\"" ChangeKey=\"""");
                writer.write(parentItemId.changeKey);
            }
            writer.write(""\""/>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeFolderId,,11,19,10,3,0.375,0.1914,1,1,4,0,1,"protected void writeFolderId(Writer writer) throws IOException {
        if (folderId != null) {
            if (updates == null) {
                writer.write(""<m:FolderIds>"");
            }
            folderId.write(writer);
            if (updates == null) {
                writer.write(""</m:FolderIds>"");
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeSavedItemFolderId,,7,11,7,3,0.4167,0.1786,1,1,2,0,1,"protected void writeSavedItemFolderId(Writer writer) throws IOException {
        if (savedItemFolderId != null) {
            writer.write(""<m:SavedItemFolderId>"");
            savedItemFolderId.write(writer);
            writer.write(""</m:SavedItemFolderId>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeToFolderId,,7,11,7,3,0.4167,0.1786,1,1,2,0,1,"protected void writeToFolderId(Writer writer) throws IOException {
        if (toFolderId != null) {
            writer.write(""<m:ToFolderId>"");
            toFolderId.write(writer);
            writer.write(""</m:ToFolderId>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeParentFolderId,,15,39,12,3,0.3611,0.3256,1,1,4,0,1,"protected void writeParentFolderId(Writer writer) throws IOException {
        if (parentFolderId != null) {
            writer.write(""<m:ParentFolderId"");
            if (item == null) {
                writer.write(""s"");
            }
            writer.write("">"");
            parentFolderId.write(writer);
            writer.write(""</m:ParentFolderId"");
            if (item == null) {
                writer.write(""s"");
            }
            writer.write("">"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeItem,,11,23,1,3,0.3667,0.322,1,1,2,0,1,"protected void writeItem(Writer writer) throws IOException {
        if (item != null) {
            writer.write(""<m:"");
            writer.write(itemType);
            writer.write(""s>"");
            item.write(writer);
            writer.write(""</m:"");
            writer.write(itemType);
            writer.write(""s>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeRestriction,,9,21,14,3,0.3333,0.142,1,2,2,0,1,"protected void writeRestriction(Writer writer) throws IOException {
        if (searchExpression != null) {
            writer.write(""<m:Restriction>"");
            StringBuilder buffer = new StringBuilder();
            searchExpression.appendTo(buffer);
            writer.write(buffer.toString());
            writer.write(""</m:Restriction>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeSortOrder,,9,21,14,3,0.3333,0.142,1,2,2,0,1,"protected void writeSortOrder(Writer writer) throws IOException {
        if (fieldOrder != null) {
            writer.write(""<m:SortOrder>"");
            StringBuilder buffer = new StringBuilder();
            fieldOrder.appendTo(buffer);
            writer.write(buffer.toString());
            writer.write(""</m:SortOrder>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,startChanges,,11,13,0,3,0.375,0.3929,0,1,2,0,1,"protected void startChanges(Writer writer) throws IOException {
        //noinspection VariableNotUsedInsideIf
        if (updates != null) {
            writer.write(""<m:"");
            writer.write(itemType);
            writer.write(""Changes>"");
            writer.write(""<t:"");
            writer.write(itemType);
            writer.write(""Change>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeUpdates,,9,16,11,3,0.2857,0.1208,1,2,3,0,1,"protected void writeUpdates(Writer writer) throws IOException {
        if (updates != null) {
            writer.write(""<t:Updates>"");
            for (FieldUpdate fieldUpdate : updates) {
                fieldUpdate.write(itemType, writer);
            }
            writer.write(""</t:Updates>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,endChanges,,11,13,0,3,0.375,0.3929,0,1,2,0,1,"protected void endChanges(Writer writer) throws IOException {
        //noinspection VariableNotUsedInsideIf
        if (updates != null) {
            writer.write(""</t:"");
            writer.write(itemType);
            writer.write(""Change>"");
            writer.write(""</m:"");
            writer.write(itemType);
            writer.write(""Changes>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,generateSoapEnvelope,,48,332,69,4,0.12,0.3044,1,4,8,0,1,"protected byte[] generateSoapEnvelope() {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            OutputStreamWriter writer = new OutputStreamWriter(baos, ""UTF-8"");
            writer.write(""<soap:Envelope xmlns:soap=\""http://schemas.xmlsoap.org/soap/envelope/\"" "" +
                    ""xmlns:t=\""http://schemas.microsoft.com/exchange/services/2006/types\"" "" +
                    ""xmlns:m=\""http://schemas.microsoft.com/exchange/services/2006/messages\"">"" +
                    """");
            writer.write(""<soap:Header>"");
            if (serverVersion != null) {
                writer.write(""<t:RequestServerVersion Version=\"""");
                writer.write(serverVersion);
                writer.write(""\""/>"");
            }
            if (timezoneContext != null) {
                writer.write(""<t:TimeZoneContext><t:TimeZoneDefinition Id=\"""");
                writer.write(timezoneContext);
                writer.write(""\""/></t:TimeZoneContext>"");
            }
            writer.write(""</soap:Header>"");

            writer.write(""<soap:Body>"");
            writer.write(""<m:"");
            writer.write(methodName);
            if (traversal != null) {
                traversal.write(writer);
            }
            if (deleteType != null) {
                deleteType.write(writer);
            }
            if (methodOptions != null) {
                for (AttributeOption attributeOption : methodOptions) {
                    attributeOption.write(writer);
                }
            }
            writer.write("">"");
            writeSoapBody(writer);
            writer.write(""</m:"");
            writer.write(methodName);
            writer.write("">"");
            writer.write(""</soap:Body>"" +
                    ""</soap:Envelope>"");
            writer.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return baos.toByteArray();
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeIndexedPageItemView,,10,17,6,3,0.3125,0.216,0,1,2,0,1,0
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeAttachmentId,,14,35,4,3,0.3333,0.3974,0,1,3,0,1,"protected void writeAttachmentId(Writer writer) throws IOException {
        if (attachmentId != null) {
            if (""CreateAttachment"".equals(methodName)) {
                writer.write(""<m:AttachmentShape>"");
                writer.write(""<t:IncludeMimeContent>true</t:IncludeMimeContent>"");
                writer.write(""</m:AttachmentShape>"");
            }
            writer.write(""<m:AttachmentIds>"");
            writer.write(""<t:AttachmentId Id=\"""");
            writer.write(attachmentId);
            writer.write(""\""/>"");
            writer.write(""</m:AttachmentIds>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,writeAttachments,,7,11,7,3,0.4167,0.1786,1,1,2,0,1,"protected void writeAttachments(Writer writer) throws IOException {
        if (attachment != null) {
            writer.write(""<m:Attachments>"");
            attachment.write(writer);
            writer.write(""</m:Attachments>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,checkSuccess,,17,32,28,6,0.2222,0.1,1,1,9,0,1,"/**
     * Check method success.
     *
     * @throws EWSException on error
     */
    public void checkSuccess() throws EWSException {
        if (errorDetail != null) {
            if (!""ErrorAccessDenied"".equals(errorDetail)
                    && !""ErrorMailRecipientNotFound"".equals(errorDetail)
                    && !""ErrorItemNotFound"".equals(errorDetail)
                    ) {
                try {
                    throw new EWSException(errorDetail + ' ' +((errorDescription!=null)?errorDescription:"""")+ ""\n request: "" + new String(generateSoapEnvelope(), ""UTF-8""));
                } catch (UnsupportedEncodingException e) {
                    throw new EWSException(e.getMessage());
                }
            }
        }
        if (getStatusCode() == HttpStatus.SC_BAD_REQUEST || getStatusCode() == HttpStatus.SC_INSUFFICIENT_STORAGE ) {
             throw new EWSException(getStatusText());
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleTag,,14,28,11,3,0.4,0.2235,0,4,7,0,1,"protected String handleTag(XMLStreamReader reader, String localName) throws XMLStreamException {
        String result = null;
        int event = reader.getEventType();
        if (event == XMLStreamConstants.START_ELEMENT && localName.equals(reader.getLocalName())) {
            while (reader.hasNext() &&
                    !((event == XMLStreamConstants.END_ELEMENT && localName.equals(reader.getLocalName())))) {
                event = reader.next();
                if (event == XMLStreamConstants.CHARACTERS) {
                    result = reader.getText();
                }
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleErrors,,19,41,27,4,0.2424,0.109,0.5,3,9,0,1,"protected void handleErrors(XMLStreamReader reader) throws XMLStreamException {
        String result = handleTag(reader, ""ResponseCode"");
        // store error description;
        String messageText = handleTag(reader, ""MessageText"");
        if (messageText != null) {
            errorDescription = messageText;
        }
        if (errorDetail == null && result != null
                && !""NoError"".equals(result)
                && !""ErrorNameResolutionMultipleResults"".equals(result)
                && !""ErrorNameResolutionNoResults"".equals(result)
                && !""ErrorFolderExists"".equals(result)
                ) {
            errorDetail = result;
        }
        if (XMLStreamUtil.isStartTag(reader, ""faultstring"")) {
            errorDetail = XMLStreamUtil.getElementText(reader);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleItem,,37,147,0,3,0.2857,0.2497,0.5,4,14,0,1,"protected Item handleItem(XMLStreamReader reader) throws XMLStreamException {
        Item responseItem = new Item();
        responseItem.type = reader.getLocalName();
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, responseItem.type)) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                String value = null;
                if (""ExtendedProperty"".equals(tagLocalName)) {
                    addExtendedPropertyValue(reader, responseItem);
                } else if (tagLocalName.endsWith(""MimeContent"")) {
                    handleMimeContent(reader, responseItem);
                } else if (""Attachments"".equals(tagLocalName)) {
                    responseItem.attachments = handleAttachments(reader);
                } else if (""EmailAddresses"".equals(tagLocalName)) {
                    handleEmailAddresses(reader, responseItem);
                } else if (""RequiredAttendees"".equals(tagLocalName) || ""OptionalAttendees"".equals(tagLocalName)) {
                    handleAttendees(reader, responseItem, tagLocalName);
                } else if (""ModifiedOccurrences"".equals(tagLocalName)) {
                    handleModifiedOccurrences(reader, responseItem);
                } else {
                    if (tagLocalName.endsWith(""Id"")) {
                        value = getAttributeValue(reader, ""Id"");
                        // get change key
                        responseItem.put(""ChangeKey"", getAttributeValue(reader, ""ChangeKey""));
                    }
                    if (value == null) {
                        value = getTagContent(reader);
                    }
                    if (value != null) {
                        responseItem.put(tagLocalName, value);
                    }
                }
            }
        }
        return responseItem;
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleEmailAddresses,,11,14,0,3,0.375,0.2346,0.5,3,5,0,1,"protected void handleEmailAddresses(XMLStreamReader reader, Item item) throws XMLStreamException {
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""EmailAddresses""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Entry"".equals(tagLocalName)) {
                    item.put(reader.getAttributeValue(null, ""Key""), XMLStreamUtil.getElementText(reader));
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleAttendees,,11,15,2,3,0.325,0.179,0.5,4,5,0,1,"protected void handleAttendees(XMLStreamReader reader, Item item, String attendeeType) throws XMLStreamException {
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, attendeeType))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Attendee"".equals(tagLocalName)) {
                    handleAttendee(reader, item, attendeeType);
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleModifiedOccurrences,,11,15,2,3,0.3438,0.2099,0.5,3,5,0,1,"protected void handleModifiedOccurrences(XMLStreamReader reader, Item item) throws XMLStreamException {
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""ModifiedOccurrences""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Occurrence"".equals(tagLocalName)) {
                    handleOccurrence(reader, item);
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleOccurrence,,16,37,8,3,0.25,0.1697,0.666666667,4,6,0,1,"protected void handleOccurrence(XMLStreamReader reader, Item item) throws XMLStreamException {
        Occurrence occurrence = new Occurrence();
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""Occurrence""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""ItemId"".equals(tagLocalName)) {
                    occurrence.itemId = new ItemId(""ItemId"", getAttributeValue(reader, ""Id""), getAttributeValue(reader, ""ChangeKey""));
                }
                if (""OriginalStart"".equals(tagLocalName)) {
                    occurrence.originalStart = XMLStreamUtil.getElementText(reader);
                }
            }
        }
        item.addOccurrence(occurrence);
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,responseTypeToPartstat,,11,7,4,3,0.6,0.3333,0,1,5,0,1,"/**
     * Convert response type to partstat value
     * @param responseType response type
     * @return partstat value
     */
    public static String responseTypeToPartstat(String responseType) {
        if (""Accept"".equals(responseType) || ""Organizer"".equals(responseType)) {
            return ""ACCEPTED"";
        } else if (""Tentative"".equals(responseType)) {
            return ""TENTATIVE"";
        } else if (""Decline"".equals(responseType)) {
            return ""DECLINED"";
        } else {
            return ""NEEDS-ACTION"";
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleAttendee,,23,93,33,4,0.1717,0.1495,0.6,6,8,0,1,"protected void handleAttendee(XMLStreamReader reader, Item item, String attendeeType) throws XMLStreamException {
        Attendee attendee = new Attendee();
        if (""RequiredAttendees"".equals(attendeeType)) {
            attendee.role = ""REQ-PARTICIPANT"";
        } else {
            attendee.role = ""OPT-PARTICIPANT"";
        }
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""Attendee""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""EmailAddress"".equals(tagLocalName)) {
                    attendee.email = reader.getElementText();
                } else if (""Name"".equals(tagLocalName)) {
                    attendee.name = XMLStreamUtil.getElementText(reader);
                } else if (""ResponseType"".equals(tagLocalName)) {
                    String responseType = XMLStreamUtil.getElementText(reader);
                    attendee.partstat = responseTypeToPartstat(responseType);
                }
            }
        }
        item.addAttendee(attendee);
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleAttachments,,13,29,13,3,0.325,0.1742,0.5,3,5,0,1,"protected List<FileAttachment> handleAttachments(XMLStreamReader reader) throws XMLStreamException {
        List<FileAttachment> attachments = new ArrayList<FileAttachment>();
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""Attachments""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""FileAttachment"".equals(tagLocalName)) {
                    attachments.add(handleFileAttachment(reader));
                }
            }
        }
        return attachments;
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleFileAttachment,,17,51,11,3,0.2738,0.2,0.666666667,3,7,0,1,"protected FileAttachment handleFileAttachment(XMLStreamReader reader) throws XMLStreamException {
        FileAttachment fileAttachment = new FileAttachment();
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""FileAttachment""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""AttachmentId"".equals(tagLocalName)) {
                    fileAttachment.attachmentId = getAttributeValue(reader, ""Id"");
                } else if (""Name"".equals(tagLocalName)) {
                    fileAttachment.name = getTagContent(reader);
                } else if (""ContentType"".equals(tagLocalName)) {
                    fileAttachment.contentType = getTagContent(reader);
                }
            }
        }
        return fileAttachment;
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,handleMimeContent,,13,17,13,4,0.2857,0.1167,0,3,3,0,1,"protected void handleMimeContent(XMLStreamReader reader, Item responseItem) throws XMLStreamException {
        if (reader instanceof TypedXMLStreamReader) {
            // Stax2 parser: use enhanced base64 conversion
            responseItem.mimeContent = ((TypedXMLStreamReader) reader).getElementAsBinary();
        } else {
            // failover: slow and memory consuming conversion
            try {
                responseItem.mimeContent = Base64.decodeBase64(reader.getElementText().getBytes(""ASCII""));
            } catch (UnsupportedEncodingException e) {
                throw new XMLStreamException(e);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,addExtendedPropertyValue,,41,229,52,3,0.2198,0.1849,0.5,7,16,0,1,"protected void addExtendedPropertyValue(XMLStreamReader reader, Item item) throws XMLStreamException {
        String propertyTag = null;
        String propertyValue = null;
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""ExtendedProperty""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""ExtendedFieldURI"".equals(tagLocalName)) {
                    propertyTag = getAttributeValue(reader, ""PropertyTag"");
                    // property name is in PropertyId or PropertyName with DistinguishedPropertySetId
                    if (propertyTag == null) {
                        propertyTag = getAttributeValue(reader, ""PropertyId"");
                    }
                    if (propertyTag == null) {
                        propertyTag = getAttributeValue(reader, ""PropertyName"");
                    }
                } else if (""Value"".equals(tagLocalName)) {
                    propertyValue = XMLStreamUtil.getElementText(reader);
                } else if (""Values"".equals(tagLocalName)) {
                    StringBuilder buffer = new StringBuilder();
                    while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""Values""))) {
                        reader.next();
                        if (XMLStreamUtil.isStartTag(reader)) {

                            if (buffer.length() > 0) {
                                buffer.append(',');
                            }
                            String singleValue = XMLStreamUtil.getElementText(reader);
                            if (singleValue != null) {
                                buffer.append(singleValue);
                            }
                        }
                    }
                    propertyValue = buffer.toString();
                }
            }
        }
        if ((propertyTag != null) && (propertyValue != null)) {
            item.put(propertyTag, propertyValue);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.EWSMethod,processResponseBody,,15,32,28,5,0.1667,0.0657,1,4,5,0,1,"@Override
    protected void processResponseBody(HttpState httpState, HttpConnection httpConnection) {
        Header contentTypeHeader = getResponseHeader(""Content-Type"");
        if (contentTypeHeader != null && ""text/xml; charset=utf-8"".equals(contentTypeHeader.getValue())) {
            try {
                if (DavGatewayHttpClientFacade.isGzipEncoded(this)) {
                    processResponseStream(new GZIPInputStream(getResponseBodyAsStream()));
                } else {
                    processResponseStream(getResponseBodyAsStream());
                }
            } catch (IOException e) {
                LOGGER.error(""Error while parsing soap response: "" + e, e);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ExtendedFieldURI,appendTo,,19,65,39,3,0.1837,0.1222,0,1,6,0,1,"public void appendTo(StringBuilder buffer) {
        buffer.append(""<t:ExtendedFieldURI"");
        if (propertyTag != null) {
            buffer.append("" PropertyTag=\"""").append(propertyTag).append('""');
        }
        if (distinguishedPropertySetId != null) {
            buffer.append("" DistinguishedPropertySetId=\"""").append(distinguishedPropertySetId).append('""');
        }
        if (propertyName != null) {
            buffer.append("" PropertyName=\"""").append(propertyName).append('""');
        }
        if (propertyId != 0) {
            buffer.append("" PropertyId=\"""").append(String.valueOf(propertyId)).append('""');
        }
        if (propertyType != null) {
            buffer.append("" PropertyType=\"""").append(propertyType.toString()).append('""');
        }
        buffer.append(""/>"");
    }"
davmail-4.5.1,davmail.exchange.ews.ExtendedFieldURI,appendValue,,35,171,0,4,0.137,0.3648,0.5,5,6,0,1,"public void appendValue(StringBuilder buffer, String itemType, String value) {
        if (itemType != null) {
            appendTo(buffer);
            buffer.append(""<t:"");
            buffer.append(itemType);
            buffer.append('>');
        }
        buffer.append(""<t:ExtendedProperty>"");
        appendTo(buffer);
        if (propertyType == PropertyType.StringArray) {
            buffer.append(""<t:Values>"");
            String[] values = value.split("","");
            for (final String singleValue : values) {
                buffer.append(""<t:Value>"");
                buffer.append(StringUtil.xmlEncode(singleValue));
                buffer.append(""</t:Value>"");

            }
            buffer.append(""</t:Values>"");
        } else {
            buffer.append(""<t:Value>"");
            if (""0x10f3"".equals(propertyTag)) {
                buffer.append(StringUtil.xmlEncode(StringUtil.encodeUrlcompname(value)));
            } else {
                buffer.append(StringUtil.xmlEncode(value));
            }
            buffer.append(""</t:Value>"");
        }
        buffer.append(""</t:ExtendedProperty>"");
        if (itemType != null) {
            buffer.append(""</t:"");
            buffer.append(itemType);
            buffer.append('>');
        }
    }"
davmail-4.5.1,davmail.exchange.ews.GetUserAvailabilityMethod,handleCustom,,6,5,4,3,0.4167,0.1333,0.5,2,2,0,1,"@Override
    protected void handleCustom(XMLStreamReader reader) throws XMLStreamException {
        if (XMLStreamUtil.isStartTag(reader, ""MergedFreeBusy"")) {
            this.mergedFreeBusy = XMLStreamUtil.getElementText(reader);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.FileAttachment,write,,22,84,15,4,0.2111,0.3421,0,1,5,0,1,"/**
     * Write XML content to writer.
     *
     * @param writer writer
     * @throws IOException on error
     */
    public void write(Writer writer) throws IOException {
        writer.write(""<t:FileAttachment>"");
        if (name != null) {
            writer.write(""<t:Name>"");
            writer.write(name);
            writer.write(""</t:Name>"");
        }
        if (contentType != null) {
            writer.write(""<t:ContentType>"");
            writer.write(contentType);
            writer.write(""</t:ContentType>"");
        }
        if (isContactPhoto) {
            writer.write(""<t:IsContactPhoto>true</t:IsContactPhoto>"");
        }
        if (content != null) {
            writer.write(""<t:Content>"");
            writer.write(content);
            writer.write(""</t:Content>"");
        }
        writer.write(""</t:FileAttachment>"");
    }"
davmail-4.5.1,davmail.exchange.ews.GetUserConfigurationMethod,handleUserConfiguration,,13,29,13,3,0.325,0.1742,0.666666667,3,5,0,1,"private Item handleUserConfiguration(XMLStreamReader reader) throws XMLStreamException {
        Item responseItem = new Item();
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""UserConfiguration""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""DictionaryEntry"".equals(tagLocalName)) {
                    handleDictionaryEntry(reader, responseItem);
                }
            }
        }
        return responseItem;
    }"
davmail-4.5.1,davmail.exchange.ews.GetUserConfigurationMethod,handleDictionaryEntry,,16,28,1,3,0.3273,0.2019,0.5,4,6,0,1,"private void handleDictionaryEntry(XMLStreamReader reader, Item responseItem) throws XMLStreamException {
        String key = null;
        while (reader.hasNext() && !(XMLStreamUtil.isEndTag(reader, ""DictionaryEntry""))) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Value"".equals(tagLocalName)) {
                    if (key == null) {
                        key = reader.getElementText();
                    } else {
                        responseItem.put(key, XMLStreamUtil.getElementText(reader));
                    }
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.FieldUpdate,write,,33,157,83,3,0.2348,0.1714,0.5,4,7,0,1,"/**
     * Write field to request writer.
     *
     * @param itemType item type
     * @param writer   request writer
     * @throws IOException on error
     */
    public void write(String itemType, Writer writer) throws IOException {
        String action;
        //noinspection VariableNotUsedInsideIf
        if (value == null) {
            action = ""Delete"";
        } else {
            action = ""Set"";
        }
        if (itemType != null) {
            writer.write(""<t:"");
            writer.write(action);
            writer.write(itemType);
            writer.write(""Field>"");
        }

        // do not try to set empty value on create
        if (itemType != null || value != null) {
            StringBuilder buffer = new StringBuilder();
            if (value == null) {
                fieldURI.appendTo(buffer);
            } else {
                fieldURI.appendValue(buffer, itemType, value);
            }
            writer.write(buffer.toString());
        }

        if (itemType != null) {
            writer.write(""</t:"");
            writer.write(action);
            writer.write(itemType);
            writer.write(""Field>"");
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,ResolveNamesMethod,,6,6,6,3,0.25,0,1,1,1,0,1,"/**
     * Build Resolve Names method
     *
     * @param value search value
     */
    public ResolveNamesMethod(String value) {
        super(""Contact"", ""ResolveNames"", ""ResolutionSet"");
        addMethodOption(SearchScope.ActiveDirectory);
        addMethodOption(RETURN_FULL_CONTACT_DATA);
        unresolvedEntry = new ElementOption(""m:UnresolvedEntry"", value);
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,handleItem,,21,59,13,3,0.35,0.234,0.666666667,3,8,0,1,"@Override
    protected Item handleItem(XMLStreamReader reader) throws XMLStreamException {
        Item responseItem = new Item();
        responseItem.type = ""Contact"";
        // skip to Contact
        while (reader.hasNext() && !XMLStreamUtil.isStartTag(reader, ""Resolution"")) {
            reader.next();
        }
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""Resolution"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Mailbox"".equals(tagLocalName)) {
                    handleMailbox(reader, responseItem);
                } else if (""Contact"".equals(tagLocalName)) {
                    handleContact(reader, responseItem);
                }
            }
        }
        return responseItem;
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,handleMailbox,,13,19,0,3,0.475,0.2879,0.5,3,6,0,1,"protected void handleMailbox(XMLStreamReader reader, Item responseItem) throws XMLStreamException {
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""Mailbox"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Name"".equals(tagLocalName)) {
                    responseItem.put(tagLocalName, XMLStreamUtil.getElementText(reader));
                } else if (""EmailAddress"".equals(tagLocalName)) {
                    responseItem.put(tagLocalName, XMLStreamUtil.getElementText(reader));
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,handleContact,,17,35,0,3,0.4423,0.2781,0.5,3,7,0,1,"protected void handleContact(XMLStreamReader reader, Item responseItem) throws XMLStreamException {
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""Contact"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""EmailAddresses"".equals(tagLocalName)) {
                    handleEmailAddresses(reader, responseItem);
                } else if (""PhysicalAddresses"".equals(tagLocalName)) {
                    handlePhysicalAddresses(reader, responseItem);
                } else if (""PhoneNumbers"".equals(tagLocalName)) {
                    handlePhoneNumbers(reader, responseItem);
                } else {
                    responseItem.put(tagLocalName, XMLStreamUtil.getElementText(reader));
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,handlePhysicalAddress,,10,16,4,3,0.2679,0.1997,0.5,5,4,0,1,"protected void handlePhysicalAddress(XMLStreamReader reader, Item responseItem, String addressType) throws XMLStreamException {
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""Entry"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                String value = XMLStreamUtil.getElementText(reader);
                responseItem.put(addressType + tagLocalName, value);
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,handlePhysicalAddresses,,12,18,0,3,0.3111,0.2119,0.666666667,4,5,0,1,"protected void handlePhysicalAddresses(XMLStreamReader reader, Item responseItem) throws XMLStreamException {
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""PhysicalAddresses"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Entry"".equals(tagLocalName)) {
                    String key = getAttributeValue(reader, ""Key"");
                    handlePhysicalAddress(reader, responseItem, key);
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,handlePhoneNumbers,,13,24,3,3,0.2833,0.1939,0.6,5,5,0,1,"protected void handlePhoneNumbers(XMLStreamReader reader, Item responseItem) throws XMLStreamException {
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""PhoneNumbers"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Entry"".equals(tagLocalName)) {
                    String key = getAttributeValue(reader, ""Key"");
                    String value = XMLStreamUtil.getElementText(reader);
                    responseItem.put(key, value);
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ResolveNamesMethod,handleEmailAddresses,,21,40,2,3,0.3385,0.2208,0.5,4,9,0,1,"@Override
    protected void handleEmailAddresses(XMLStreamReader reader, Item responseItem) throws XMLStreamException {
        while (reader.hasNext() && !XMLStreamUtil.isEndTag(reader, ""EmailAddresses"")) {
            reader.next();
            if (XMLStreamUtil.isStartTag(reader)) {
                String tagLocalName = reader.getLocalName();
                if (""Entry"".equals(tagLocalName)) {
                    String value = XMLStreamUtil.getElementText(reader);
                    if (value != null) {
                        if (value.startsWith(""smtp:"") || value.startsWith(""SMTP:"")) {
                            value = value.substring(5);
                            // get smtp address only if not already available through Mailbox info
                            if (responseItem.get(""EmailAddress"") == null) {
                                responseItem.put(""EmailAddress"", value);
                            }
                        }
                    }
                }
            }
        }
    }"
davmail-4.5.1,davmail.exchange.ews.IndexedFieldURI,appendValue,,15,37,8,4,0.2024,0.209,1,3,3,0,1,"public void appendValue(StringBuilder buffer, String itemType, String value) {
        if (itemType != null) {
            // append IndexedFieldURI
            appendTo(buffer);
            buffer.append(""<t:"").append(fieldItemType).append('>');
            buffer.append(""<t:"").append(collectionName).append('>');
        }
        buffer.append(""<t:Entry Key=\"""").append(fieldIndex).append(""\"">"");
        buffer.append(StringUtil.xmlEncodeAttribute(value));
        buffer.append(""</t:Entry>"");
        if (itemType != null) {
            buffer.append(""</t:"").append(collectionName).append('>');
            buffer.append(""</t:"").append(fieldItemType).append('>');
        }
    }"
davmail-4.5.1,davmail.exchange.ews.UnindexedFieldURI,UnindexedFieldURI,,9,13,5,3,0.3143,0.1475,0,3,2,0,1,"/**
     * Create unindexed field URI.
     *
     * @param fieldURI field name
     */
    public UnindexedFieldURI(String fieldURI) {
        this.fieldURI = fieldURI;
        int colonIndex = fieldURI.indexOf(':');
        if (colonIndex < 0) {
            fieldName = fieldURI;
        } else {
            fieldName = fieldURI.substring(colonIndex + 1);
        }
    }"
davmail-4.5.1,davmail.exchange.ews.UnindexedFieldURI,appendValue,,39,235,5,3,0.2151,0.3319,1,3,13,1,1,"public void appendValue(StringBuilder buffer, String itemType, String value) {
        if (fieldURI.startsWith(""message"") && itemType != null) {
            itemType = ""Message"";
        } else if (fieldURI.startsWith(""calendar"") && itemType != null) {
            itemType = ""CalendarItem"";
        } else if (fieldURI.startsWith(""task"") && itemType != null) {
            itemType = ""Task"";
        } else if (fieldURI.startsWith(""contacts"") && itemType != null) {
            itemType = ""Contact"";
        }
        if (itemType != null) {
            appendTo(buffer);
            buffer.append(""<t:"");
            buffer.append(itemType);
            buffer.append('>');
        }
        if (""MeetingTimeZone"".equals(fieldName)) {
            buffer.append(""<t:MeetingTimeZone TimeZoneName=\"""");
            buffer.append(StringUtil.xmlEncodeAttribute(value));
            buffer.append(""\""></t:MeetingTimeZone>"");
        } else if (""StartTimeZone"".equals(fieldName)) {
            buffer.append(""<t:StartTimeZone Id=\"""");
            buffer.append(StringUtil.xmlEncodeAttribute(value));
            buffer.append(""\""></t:StartTimeZone>"");
        } else {
            buffer.append(""<t:"");
            buffer.append(fieldName);
            buffer.append('>');
            buffer.append(StringUtil.xmlEncodeAttribute(value));
            buffer.append(""</t:"");
            buffer.append(fieldName);
            buffer.append('>');
        }
        if (itemType != null) {
            buffer.append(""</t:"");
            buffer.append(itemType);
            buffer.append('>');
        }
    }"
davmail-4.5.1,davmail.exchange.ews.ItemId,write,,11,23,1,3,0.275,0.3068,0,1,2,0,1,"/**
     * Write item id as XML.
     *
     * @param writer request writer
     * @throws IOException on error
     */
    public void write(Writer writer) throws IOException {
        writer.write(""<t:"");
        writer.write(name);
        writer.write("" Id=\"""");
        writer.write(id);
        if (changeKey != null) {
            writer.write(""\"" ChangeKey=\"""");
            writer.write(changeKey);
        }
        writer.write(""\""/>"");
    }"
davmail-4.5.1,davmail.exchange.ews.TwoOperandExpression,appendTo,,15,23,1,3,0.3,0.2273,0.666666667,2,3,0,1,"public void appendTo(StringBuilder buffer) {
        buffer.append(""<t:"").append(operator.toString()).append('>');
        fieldURI.appendTo(buffer);

        buffer.append(""<t:FieldURIOrConstant><t:Constant Value=\"""");
        // encode urlcompname
        if (fieldURI instanceof ExtendedFieldURI && ""0x10f3"".equals(((ExtendedFieldURI) fieldURI).propertyTag)) {
            buffer.append(StringUtil.xmlEncodeAttribute(StringUtil.encodeUrlcompname(value)));
        } else {
            buffer.append(StringUtil.xmlEncodeAttribute(value));
        }
        buffer.append(""\""/></t:FieldURIOrConstant>"");

        buffer.append(""</t:"").append(operator.toString()).append('>');
    }"
davmail-4.5.1,davmail.http.DavMailCookieSpec,validate,,33,99,45,2,0.1944,0.1593,0,9,8,0,1,"@Override
    public void validate(String host, int port, String path,
                         boolean secure, final Cookie cookie) throws MalformedCookieException {
        // workaround for space in cookie name
        String cookieName = cookie.getName();
        if (cookieName != null && cookieName.indexOf(' ') >= 0) {
            cookie.setName(cookieName.replaceAll("" "", """"));
        } else {
            cookieName = null;
        }
        // workaround for invalid cookie path
        String cookiePath = cookie.getPath();
        if (cookiePath != null && !path.startsWith(cookiePath)) {
            cookie.setPath(path);
        } else {
            cookiePath = null;
        }
        String hostWithoutDomain = host.substring(0, host.length()
                - cookie.getDomain().length());
        int dotIndex = hostWithoutDomain.indexOf('.');
        if (dotIndex != -1) {
            // discard additional host name part
            super.validate(host.substring(dotIndex + 1), port, path, secure, cookie);
        } else {
            super.validate(host, port, path, secure, cookie);
        }
        if (cookieName != null) {
            cookie.setName(cookieName);
        }
        if (cookiePath != null) {
            cookie.setPath(cookiePath);
        }
    }"
davmail-4.5.1,davmail.http.KerberosHelper,initSecurityContext,,47,329,252,5,0.0948,0.0934,0,12,11,1,1,"/**
     * Get response Kerberos token for host with provided token, use client provided delegation credentials.
     * Used to authenticate with target host on a gateway server with client credentials,
     * gateway must have its own principal authorized for delegation
     *
     * @param protocol             target protocol
     * @param host                 target host
     * @param delegatedCredentials client delegated credentials
     * @param token                input token
     * @return response token
     * @throws GSSException   on error
     * @throws LoginException on error
     */
    public static byte[] initSecurityContext(final String protocol, final String host, final GSSCredential delegatedCredentials, final byte[] token) throws GSSException, LoginException {
        LOGGER.debug(""KerberosHelper.initSecurityContext "" + protocol + '/' + host + ' ' + token.length + "" bytes token"");

        synchronized (LOCK) {
            // check cached TGT
            if (clientLoginContext != null) {
                for (Object ticket : clientLoginContext.getSubject().getPrivateCredentials(KerberosTicket.class)) {
                    KerberosTicket kerberosTicket = (KerberosTicket) ticket;
                    if (kerberosTicket.getServer().getName().startsWith(""krbtgt"") && !kerberosTicket.isCurrent()) {
                        LOGGER.debug(""KerberosHelper.clientLogin cached TGT expired, try to relogin"");
                        clientLoginContext = null;
                    }
                }
            }
            // create client login context
            if (clientLoginContext == null) {
                final LoginContext localLoginContext = new LoginContext(""spnego-client"", KERBEROS_CALLBACK_HANDLER);
                localLoginContext.login();
                clientLoginContext = localLoginContext;
            }
            // try to renew almost expired tickets
            for (Object ticket : clientLoginContext.getSubject().getPrivateCredentials(KerberosTicket.class)) {
                KerberosTicket kerberosTicket = (KerberosTicket) ticket;
                LOGGER.debug(""KerberosHelper.clientLogin ticket for "" + kerberosTicket.getServer().getName() + "" expires at "" + kerberosTicket.getEndTime());
                if (kerberosTicket.getEndTime().getTime() < System.currentTimeMillis() + 10000) {
                    if (kerberosTicket.isRenewable()) {
                        try {
                            kerberosTicket.refresh();
                        } catch (RefreshFailedException e) {
                            LOGGER.debug(""KerberosHelper.clientLogin failed to renew ticket "" + kerberosTicket.toString());
                        }
                    } else {
                        LOGGER.debug(""KerberosHelper.clientLogin ticket is not renewable"");
                    }
                }
            }

            Object result = internalInitSecContext(protocol, host, delegatedCredentials, token);
            if (result instanceof GSSException) {
                LOGGER.info(""KerberosHelper.initSecurityContext exception code "" + ((GSSException) result).getMajor() + "" minor code "" + ((GSSException) result).getMinor() + "" message "" + ((Throwable) result).getMessage());
                throw (GSSException) result;
            }

            LOGGER.debug(""KerberosHelper.initSecurityContext return "" + ((byte[]) result).length + "" bytes token"");
            return (byte[]) result;
        }
    }"
davmail-4.5.1,davmail.http.KerberosHelper,serverLogin,,21,273,270,22,0.0556,0.0244,0,7,1,0,1,"/**
     * Create server side Kerberos login context for provided credentials.
     *
     * @param serverPrincipal server principal
     * @param serverPassword  server passsword
     * @return LoginContext server login context
     * @throws LoginException on error
     */
    public static LoginContext serverLogin(final String serverPrincipal, final String serverPassword) throws LoginException {
        LoginContext serverLoginContext = new LoginContext(""spnego-server"", new CallbackHandler() {

            public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
                for (Callback callback : callbacks) {
                    if (callback instanceof NameCallback) {
                        final NameCallback nameCallback = (NameCallback) callback;
                        nameCallback.setName(serverPrincipal);
                    } else if (callback instanceof PasswordCallback) {
                        final PasswordCallback passCallback = (PasswordCallback) callback;
                        passCallback.setPassword(serverPassword.toCharArray());
                    } else {
                        throw new UnsupportedCallbackException(callback);
                    }
                }

            }
        });
        serverLoginContext.login();
        return serverLoginContext;
    }"
davmail-4.5.1,davmail.http.KerberosHelper,acceptSecurityContext,,50,810,800,37,0.0488,0.0303,1,11,2,0,1,"/**
     * Check client provided Kerberos token in server login context
     *
     * @param serverLoginContext server login context
     * @param token              Kerberos client token
     * @return result with client principal and optional returned Kerberos token
     * @throws GSSException on error
     */
    public static SecurityContext acceptSecurityContext(LoginContext serverLoginContext, final byte[] token) throws GSSException {
        Object result = Subject.doAs(serverLoginContext.getSubject(), new PrivilegedAction() {

            public Object run() {
                Object innerResult;
                SecurityContext securityContext = new SecurityContext();
                GSSContext context = null;
                try {
                    GSSManager manager = GSSManager.getInstance();

                    // get server credentials from context
                    Oid krb5oid = new Oid(""1.2.840.113554.1.2.2"");
                    GSSCredential serverCreds = manager.createCredential(null/* use name from login context*/,
                            GSSCredential.DEFAULT_LIFETIME,
                            krb5oid,
                            GSSCredential.ACCEPT_ONLY/* server mode */);
                    context = manager.createContext(serverCreds);

                    securityContext.token = context.acceptSecContext(token, 0, token.length);
                    if (context.isEstablished()) {
                        securityContext.principal = context.getSrcName().toString();
                        LOGGER.debug(""Authenticated user: "" + securityContext.principal);
                        if (!context.getCredDelegState()) {
                            LOGGER.debug(""Credentials can not be delegated"");
                        } else {
                            // Get client delegated credentials from context (gateway mode)
                            securityContext.clientCredential = context.getDelegCred();
                        }
                    }
                    innerResult = securityContext;
                } catch (GSSException e) {
                    innerResult = e;
                } finally {
                    if (context != null) {
                        try {
                            context.dispose();
                        } catch (GSSException e) {
                            LOGGER.debug(""KerberosHelper.acceptSecurityContext "" + e + ' ' + e.getMessage());
                        }
                    }
                }
                return innerResult;
            }
        });
        if (result instanceof GSSException) {
            LOGGER.info(""KerberosHelper.acceptSecurityContext exception code "" + ((GSSException) result).getMajor() + "" minor code "" + ((GSSException) result).getMinor() + "" message "" + ((Throwable) result).getMessage());
            throw (GSSException) result;
        }
        return (SecurityContext) result;
    }"
davmail-4.5.1,davmail.http.SpNegoScheme,processChallenge,,20,62,46,4,0.1361,0.058,0,8,4,0,1,"/**
     * Processes the Negotiate challenge.
     *
     * @param challenge the challenge string
     * @throws MalformedChallengeException is thrown if the authentication challenge is malformed
     */
    public void processChallenge(final String challenge) throws MalformedChallengeException {
        String authScheme = AuthChallengeParser.extractScheme(challenge);
        if (!authScheme.equalsIgnoreCase(getSchemeName())) {
            throw new MalformedChallengeException(""Invalid Negotiate challenge: "" + challenge);
        }
        int spaceIndex = challenge.indexOf(' ');
        if (spaceIndex != -1) {
            // step 2: received server challenge
            serverToken = Base64.decodeBase64(EncodingUtil.getBytes(
                    challenge.substring(spaceIndex, challenge.length()).trim(), ""ASCII""));
            this.state = TYPE2_MSG_RECEIVED;
        } else {
            this.serverToken = null;
            if (this.state == UNINITIATED) {
                this.state = INITIATED;
            } else {
                this.state = FAILED;
            }
        }
    }"
davmail-4.5.1,davmail.http.SpNegoScheme,authenticate,,54,382,299,8,0.0883,0.0884,1,13,17,1,1,"/**
     * Produces Negotiate authorization string for the given set of
     * {@link Credentials}.
     *
     * @param credentials The set of credentials to be used for authentication
     * @param httpMethod  The method being authenticated
     * @return an Negotiate authorization string
     * @throws org.apache.commons.httpclient.auth.InvalidCredentialsException
     *                                 if authentication credentials
     *                                 are not valid or not applicable for this authentication scheme
     * @throws AuthenticationException if authorization string cannot
     *                                 be generated due to an authentication failure
     */
    public String authenticate(Credentials credentials, HttpMethod httpMethod) throws AuthenticationException {
        if (this.state == UNINITIATED) {
            throw new IllegalStateException(""Negotiate authentication process has not been initiated"");
        }
        String host = null;
        try {
            host = httpMethod.getURI().getHost();
        } catch (URIException e) {
            // ignore
        }
        if (host == null) {
            Header header = httpMethod.getRequestHeader(""Host"");
            if (header != null) {
                host = header.getValue();
                if (host.indexOf(':') >= 0) {
                    host = host.substring(0, host.indexOf(':'));
                }
            }
        }
        if (host == null) {
            throw new IllegalStateException(""Negotiate authentication failed: empty host"");
        }

        // no credentials needed
        String response;
        try {
            if (this.state == INITIATED || this.state == FAILED) {
                // send initial token to server
                response = EncodingUtil.getAsciiString(Base64.encodeBase64(KerberosHelper.initSecurityContext(""HTTP"", host, new byte[0])));
                this.state = TYPE1_MSG_GENERATED;
            } else {
                // send challenge response
                response = EncodingUtil.getAsciiString(Base64.encodeBase64(KerberosHelper.initSecurityContext(""HTTP"", host, serverToken)));
                this.state = TYPE3_MSG_GENERATED;
            }
        } catch (GSSException gsse) {
            state = FAILED;
            if (gsse.getMajor() == GSSException.DEFECTIVE_CREDENTIAL
                    || gsse.getMajor() == GSSException.CREDENTIALS_EXPIRED)
                throw new InvalidCredentialsException(gsse.getMessage(), gsse);
            if (gsse.getMajor() == GSSException.NO_CRED)
                throw new CredentialsNotAvailableException(gsse.getMessage(), gsse);
            if (gsse.getMajor() == GSSException.DEFECTIVE_TOKEN
                    || gsse.getMajor() == GSSException.DUPLICATE_TOKEN
                    || gsse.getMajor() == GSSException.OLD_TOKEN)
                throw new AuthChallengeException(gsse.getMessage(), gsse);
            // other error
            throw new AuthenticationException(gsse.getMessage(), gsse);
        } catch (LoginException e) {
            state = FAILED;
            throw new InvalidCredentialsException(e.getMessage(), e);
        }
        return ""Negotiate "" + response;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,isNoProxyFor,,13,19,10,3,0.25,0.1111,1,5,4,0,1,"protected static boolean isNoProxyFor(java.net.URI uri) {
        final String noProxyFor = Settings.getProperty(""davmail.noProxyFor"");
        if (noProxyFor != null) {
            final String urihost = uri.getHost().toLowerCase();
            final String[] domains = noProxyFor.toLowerCase().split("",\\s*"");
            for (String domain : domains) {
                if (urihost.endsWith(domain)) {
                    return true; //break;
                }
            }
        }
        return false;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,configureClient,,72,787,628,5,0.0767,0.0604,0.5,16,14,1,1,"/**
     * Update http client configuration (proxy)
     *
     * @param httpClient current Http client
     * @param url        target url
     * @throws DavMailException on error
     */
    public static void configureClient(HttpClient httpClient, String url) throws DavMailException {
        setClientHost(httpClient, url);

        if (Settings.getBooleanProperty(""davmail.enableKerberos"", false)) {
            AuthPolicy.registerAuthScheme(""Negotiate"", SpNegoScheme.class);
            ArrayList<String> authPrefs = new ArrayList<String>();
            authPrefs.add(""Negotiate"");
            httpClient.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY, authPrefs);
        } else if (!needNTLM) {
            ArrayList<String> authPrefs = new ArrayList<String>();
            authPrefs.add(AuthPolicy.DIGEST);
            authPrefs.add(AuthPolicy.BASIC);
            // exclude NTLM authentication scheme
            httpClient.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY, authPrefs);
        }

        boolean enableProxy = Settings.getBooleanProperty(""davmail.enableProxy"");
        boolean useSystemProxies = Settings.getBooleanProperty(""davmail.useSystemProxies"", Boolean.FALSE);
        String proxyHost = null;
        int proxyPort = 0;
        String proxyUser = null;
        String proxyPassword = null;

        try {
            java.net.URI uri = new java.net.URI(url);
            if (isNoProxyFor(uri)) {
                LOGGER.debug(""no proxy for "" + uri.getHost());
            } else if (useSystemProxies) {
                // get proxy for url from system settings
                System.setProperty(""java.net.useSystemProxies"", ""true"");
                List<Proxy> proxyList = getProxyForURI(uri);
                if (!proxyList.isEmpty() && proxyList.get(0).address() != null) {
                    InetSocketAddress inetSocketAddress = (InetSocketAddress) proxyList.get(0).address();
                    proxyHost = inetSocketAddress.getHostName();
                    proxyPort = inetSocketAddress.getPort();

                    // we may still need authentication credentials
                    proxyUser = Settings.getProperty(""davmail.proxyUser"");
                    proxyPassword = Settings.getProperty(""davmail.proxyPassword"");
                }
            } else if (enableProxy) {
                proxyHost = Settings.getProperty(""davmail.proxyHost"");
                proxyPort = Settings.getIntProperty(""davmail.proxyPort"");
                proxyUser = Settings.getProperty(""davmail.proxyUser"");
                proxyPassword = Settings.getProperty(""davmail.proxyPassword"");
            }
        } catch (URISyntaxException e) {
            throw new DavMailException(""LOG_INVALID_URL"", url);
        }

        // configure proxy
        if (proxyHost != null && proxyHost.length() > 0) {
            httpClient.getHostConfiguration().setProxy(proxyHost, proxyPort);
            if (proxyUser != null && proxyUser.length() > 0) {

                AuthScope authScope = new AuthScope(proxyHost, proxyPort, AuthScope.ANY_REALM);

                // detect ntlm authentication (windows domain name in user name)
                int backslashindex = proxyUser.indexOf('\\');
                if (backslashindex > 0) {
                    httpClient.getState().setProxyCredentials(authScope,
                            new NTCredentials(proxyUser.substring(backslashindex + 1),
                                    proxyPassword, ""UNKNOWN"",
                                    proxyUser.substring(0, backslashindex)));
                } else {
                    httpClient.getState().setProxyCredentials(authScope,
                            new NTCredentials(proxyUser, proxyPassword, ""UNKNOWN"", """"));
                }
            }
        }

    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,checkNTLM,,11,20,4,3,0.3889,0.219,0,3,5,0,1,"private static int checkNTLM(HttpClient httpClient, HttpMethod currentMethod) throws IOException {
        int status = currentMethod.getStatusCode();
        if ((status == HttpStatus.SC_UNAUTHORIZED || status == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED)
                && acceptsNTLMOnly(currentMethod) && !hasNTLMorNegotiate(httpClient)) {
            LOGGER.debug(""Received "" + status + "" unauthorized at "" + currentMethod.getURI() + "", retrying with NTLM"");
            resetMethod(currentMethod);
            addNTLM(httpClient);
            status = httpClient.executeMethod(currentMethod);
        }
        return status;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeFollowRedirects,,35,161,22,5,0.18,0.233,1,6,6,0,1,"/**
     * Execute method with httpClient, follow 30x redirects.
     *
     * @param httpClient Http client instance
     * @param method     Http method
     * @return last http method after redirects
     * @throws IOException on error
     */
    public static HttpMethod executeFollowRedirects(HttpClient httpClient, HttpMethod method) throws IOException {
        HttpMethod currentMethod = method;
        try {
            DavGatewayTray.debug(new BundleMessage(""LOG_EXECUTE_FOLLOW_REDIRECTS"", currentMethod.getURI()));
            httpClient.executeMethod(currentMethod);
            checkNTLM(httpClient, currentMethod);

            String locationValue = getLocationValue(currentMethod);
            // check javascript redirect (multiple authentication pages)
            if (locationValue == null) {
                locationValue = getJavascriptRedirectUrl(currentMethod);
            }

            int redirectCount = 0;
            while (redirectCount++ < 10
                    && locationValue != null) {
                currentMethod.releaseConnection();
                currentMethod = new GetMethod(locationValue);
                currentMethod.setFollowRedirects(false);
                DavGatewayTray.debug(new BundleMessage(""LOG_EXECUTE_FOLLOW_REDIRECTS_COUNT"", currentMethod.getURI(), redirectCount));
                httpClient.executeMethod(currentMethod);
                checkNTLM(httpClient, currentMethod);
                locationValue = getLocationValue(currentMethod);
            }
            if (locationValue != null) {
                currentMethod.releaseConnection();
                throw new HttpException(""Maximum redirections reached"");
            }
        } catch (IOException e) {
            currentMethod.releaseConnection();
            throw e;
        }
        // caller will need to release connection
        return currentMethod;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeNoRedirect,,18,39,12,4,0.3542,0.2037,0,3,5,0,1,"/**
     * Execute method with httpClient, do not follow 30x redirects.
     *
     * @param httpClient Http client instance
     * @param method     Http method
     * @return status
     * @throws IOException on error
     */
    public static int executeNoRedirect(HttpClient httpClient, HttpMethod method) throws IOException {
        int status;
        try {
            status = httpClient.executeMethod(method);
            // check NTLM
            if ((status == HttpStatus.SC_UNAUTHORIZED || status == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED)
                    && acceptsNTLMOnly(method) && !hasNTLMorNegotiate(httpClient)) {
                LOGGER.debug(""Received "" + status + "" unauthorized at "" + method.getURI() + "", retrying with NTLM"");
                resetMethod(method);
                addNTLM(httpClient);
                status = httpClient.executeMethod(method);
            }
        } finally {
            method.releaseConnection();
        }
        // caller will need to release connection
        return status;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeSearchMethod,,8,9,3,2,0.3,0.1889,1,5,2,0,1,"/**
     * Execute webdav search method.
     *
     * @param httpClient    http client instance
     * @param path          <i>encoded</i> searched folder path
     * @param searchRequest (SQL like) search request
     * @param maxCount      max item count
     * @return Responses enumeration
     * @throws IOException on error
     */
    public static MultiStatusResponse[] executeSearchMethod(HttpClient httpClient, String path, String searchRequest,
                                                            int maxCount) throws IOException {
        ExchangeSearchMethod searchMethod = new ExchangeSearchMethod(path, searchRequest);
        if (maxCount > 0) {
            searchMethod.addRequestHeader(""Range"", ""rows=0-"" + (maxCount - 1));
        }
        return executeMethod(httpClient, searchMethod);
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeDeleteMethod,,11,19,10,3,0.2813,0.1698,0,4,3,0,1,"/**
     * Execute a delete method on the given path with httpClient.
     *
     * @param httpClient Http client instance
     * @param path       Path to be deleted
     * @return http status
     * @throws IOException on error
     */
    public static int executeDeleteMethod(HttpClient httpClient, String path) throws IOException {
        DeleteMethod deleteMethod = new DeleteMethod(path);
        deleteMethod.setFollowRedirects(false);

        int status = executeHttpMethod(httpClient, deleteMethod);
        // do not throw error if already deleted
        if (status != HttpStatus.SC_OK && status != HttpStatus.SC_NOT_FOUND) {
            throw DavGatewayHttpClientFacade.buildHttpException(deleteMethod);
        }
        return status;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeMethod,,26,103,70,4,0.2059,0.1309,0,6,4,0,1,"/**
     * Execute webdav request.
     *
     * @param httpClient http client instance
     * @param method     webdav method
     * @return Responses enumeration
     * @throws IOException on error
     */
    public static MultiStatusResponse[] executeMethod(HttpClient httpClient, DavMethodBase method) throws IOException {
        MultiStatusResponse[] responses = null;
        try {
            int status = httpClient.executeMethod(method);

            // need to follow redirects (once) on public folders
            if (isRedirect(status)) {
                method.releaseConnection();
                URI targetUri = new URI(method.getResponseHeader(""Location"").getValue(), true);
                checkExpiredSession(targetUri.getQuery());
                method.setURI(targetUri);
                status = httpClient.executeMethod(method);
            }

            if (status != HttpStatus.SC_MULTI_STATUS) {
                throw buildHttpException(method);
            }
            responses = method.getResponseBodyAsMultiStatus().getResponses();

        } catch (DavException e) {
            throw new IOException(e.getMessage());
        } finally {
            method.releaseConnection();
        }
        return responses;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeMethod,,24,88,56,4,0.2375,0.1425,1,5,3,0,1,"/**
     * Execute webdav request.
     *
     * @param httpClient http client instance
     * @param method     webdav method
     * @return Responses enumeration
     * @throws IOException on error
     */
    public static MultiStatusResponse[] executeMethod(HttpClient httpClient, ExchangeDavMethod method) throws IOException {
        MultiStatusResponse[] responses = null;
        try {
            int status = httpClient.executeMethod(method);

            // need to follow redirects (once) on public folders
            if (isRedirect(status)) {
                method.releaseConnection();
                URI targetUri = new URI(method.getResponseHeader(""Location"").getValue(), true);
                checkExpiredSession(targetUri.getQuery());
                method.setURI(targetUri);
                status = httpClient.executeMethod(method);
            }

            if (status != HttpStatus.SC_MULTI_STATUS) {
                throw buildHttpException(method);
            }
            responses = method.getResponses();

        } finally {
            method.releaseConnection();
        }
        return responses;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,addNTLM,,21,31,17,3,0.2333,0.2111,0,4,1,0,1,"/**
     * Enable NTLM authentication on http client
     *
     * @param httpClient HttpClient instance
     */
    public static void addNTLM(HttpClient httpClient) {
        // disable preemptive authentication
        httpClient.getParams().setParameter(HttpClientParams.PREEMPTIVE_AUTHENTICATION, false);

        // register the jcifs based NTLMv2 implementation
        AuthPolicy.registerAuthScheme(AuthPolicy.NTLM, NTLMv2Scheme.class);

        ArrayList<String> authPrefs = new ArrayList<String>();
        authPrefs.add(AuthPolicy.NTLM);
        authPrefs.add(AuthPolicy.DIGEST);
        authPrefs.add(AuthPolicy.BASIC);
        httpClient.getParams().setParameter(AuthPolicy.AUTH_SCHEME_PRIORITY, authPrefs);

        // make sure NTLM is always active
        needNTLM = true;

        // separate domain from username in credentials
        AuthScope authScope = new AuthScope(null, -1);
        NTCredentials credentials = (NTCredentials) httpClient.getState().getCredentials(authScope);
        setCredentials(httpClient, credentials.getUserName(), credentials.getPassword());
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,acceptsNTLMOnly,,25,101,66,4,0.2157,0.1383,0,6,7,0,1,"/**
     * Test method header for supported authentication mode,
     * return true if Basic authentication is not available
     *
     * @param getMethod http method
     * @return true if only NTLM is enabled
     */
    public static boolean acceptsNTLMOnly(HttpMethod getMethod) {
        Header authenticateHeader = null;
        if (getMethod.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
            authenticateHeader = getMethod.getResponseHeader(""WWW-Authenticate"");
        } else if (getMethod.getStatusCode() == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED) {
            authenticateHeader = getMethod.getResponseHeader(""Proxy-Authenticate"");
        }
        if (authenticateHeader == null) {
            return false;
        } else {
            boolean acceptBasic = false;
            boolean acceptNTLM = false;
            HeaderElement[] headerElements = authenticateHeader.getElements();
            for (HeaderElement headerElement : headerElements) {
                if (""NTLM"".equalsIgnoreCase(headerElement.getName())) {
                    acceptNTLM = true;
                }
                if (""Basic realm"".equalsIgnoreCase(headerElement.getName())) {
                    acceptBasic = true;
                }
            }
            return acceptNTLM && !acceptBasic;

        }
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeTestMethod,,14,14,0,2,0.4444,0.2917,0,3,4,0,1,"/**
     * Execute test method from checkConfig, with proxy credentials, but without Exchange credentials.
     *
     * @param httpClient Http client instance
     * @param method     Http method
     * @return Http status
     * @throws IOException on error
     */
    public static int executeTestMethod(HttpClient httpClient, GetMethod method) throws IOException {
        // do not follow redirects in expired sessions
        method.setFollowRedirects(false);
        int status = httpClient.executeMethod(method);
        if (status == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED
                && acceptsNTLMOnly(method) && !hasNTLMorNegotiate(httpClient)) {
            resetMethod(method);
            LOGGER.debug(""Received "" + status + "" unauthorized at "" + method.getURI() + "", retrying with NTLM"");
            addNTLM(httpClient);
            status = httpClient.executeMethod(method);
        }

        return status;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,executeGetMethod,,24,55,0,2,0.3125,0.2257,0,5,11,0,1,"/**
     * Execute Get method, do not follow redirects.
     *
     * @param httpClient      Http client instance
     * @param method          Http method
     * @param followRedirects Follow redirects flag
     * @throws IOException on error
     */
    public static void executeGetMethod(HttpClient httpClient, GetMethod method, boolean followRedirects) throws IOException {
        // do not follow redirects in expired sessions
        method.setFollowRedirects(followRedirects);
        int status = httpClient.executeMethod(method);
        if ((status == HttpStatus.SC_UNAUTHORIZED || status == HttpStatus.SC_PROXY_AUTHENTICATION_REQUIRED)
                && acceptsNTLMOnly(method) && !hasNTLMorNegotiate(httpClient)) {
            resetMethod(method);
            LOGGER.debug(""Received "" + status + "" unauthorized at "" + method.getURI() + "", retrying with NTLM"");
            addNTLM(httpClient);
            status = httpClient.executeMethod(method);
        }
        if (status != HttpStatus.SC_OK && (followRedirects || !isRedirect(status))) {
            LOGGER.warn(""GET failed with status "" + status + "" at "" + method.getURI());
            if (status != HttpStatus.SC_NOT_FOUND && status != HttpStatus.SC_FORBIDDEN) {
                LOGGER.warn(method.getResponseBodyAsString());
            }
            throw DavGatewayHttpClientFacade.buildHttpException(method);
        }
        // check for expired session
        if (followRedirects) {
            String queryString = method.getQueryString();
            checkExpiredSession(queryString);
        }
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,checkExpiredSession,,6,10,10,5,0.2,0,1,1,4,0,1,"private static void checkExpiredSession(String queryString) throws DavMailAuthenticationException {
        if (queryString != null && (queryString.contains(""reason=2"") || queryString.contains(""reason=0""))) {
            LOGGER.warn(""Request failed, session expired"");
            throw new DavMailAuthenticationException(""EXCEPTION_SESSION_EXPIRED"");
        }
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,buildHttpException,,27,84,15,4,0.3056,0.2993,1,4,9,0,1,"/**
     * Build Http Exception from methode status
     *
     * @param method Http Method
     * @return Http Exception
     */
    public static HttpException buildHttpException(HttpMethod method) {
        int status = method.getStatusCode();
        StringBuilder message = new StringBuilder();
        message.append(status).append(' ').append(method.getStatusText());
        try {
            message.append("" at "").append(method.getURI().getURI());
            if (method instanceof CopyMethod || method instanceof MoveMethod) {
                message.append("" to "").append(method.getRequestHeader(""Destination""));
            }
        } catch (URIException e) {
            message.append(method.getPath());
        }
        // 440 means forbidden on Exchange
        if (status == 440) {
            return new LoginTimeoutException(message.toString());
        } else if (status == HttpStatus.SC_FORBIDDEN) {
            return new HttpForbiddenException(message.toString());
        } else if (status == HttpStatus.SC_NOT_FOUND) {
            return new HttpNotFoundException(message.toString());
        } else if (status == HttpStatus.SC_PRECONDITION_FAILED) {
            return new HttpPreconditionFailedException(message.toString());
        } else if (status == HttpStatus.SC_INTERNAL_SERVER_ERROR) {
            return new HttpServerErrorException(message.toString());
        } else {
            return new HttpException(message.toString());
        }
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,isGzipEncoded,,11,9,3,3,0.3889,0.2262,0,3,4,0,1,"/**
     * Test if the method response is gzip encoded
     *
     * @param method http method
     * @return true if response is gzip encoded
     */
    public static boolean isGzipEncoded(HttpMethod method) {
        Header[] contentEncodingHeaders = method.getResponseHeaders(""Content-Encoding"");
        if (contentEncodingHeaders != null) {
            for (Header header : contentEncodingHeaders) {
                if (""gzip"".equals(header.getValue())) {
                    return true;
                }
            }
        }
        return false;
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,stop,,9,18,15,5,0.2381,0.15,0,0,2,0,1,"/**
     * Stop HttpConnectionManager.
     */
    public static void stop() {
        synchronized (LOCK) {
            if (httpConnectionManagerThread != null) {
                httpConnectionManagerThread.interrupt();
                httpConnectionManagerThread = null;
            }
            MultiThreadedHttpConnectionManager.shutdownAll();
        }
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,createMultiThreadedHttpConnectionManager,,10,30,15,5,0.2,0.2024,1,2,1,0,1,"/**
     * Create and set connection pool.
     *
     * @param httpClient httpClient instance
     */
    public static void createMultiThreadedHttpConnectionManager(HttpClient httpClient) {
        MultiThreadedHttpConnectionManager connectionManager = new MultiThreadedHttpConnectionManager();
        connectionManager.getParams().setDefaultMaxConnectionsPerHost(Settings.getIntProperty(""davmail.exchange.maxConnections"",100));
        connectionManager.getParams().setConnectionTimeout(10000);
        connectionManager.getParams().setSoTimeout(120000);
        synchronized (LOCK) {
            httpConnectionManagerThread.addConnectionManager(connectionManager);
        }
        httpClient.setHttpConnectionManager(connectionManager);
    }"
davmail-4.5.1,davmail.http.DavGatewayHttpClientFacade,start,,11,21,6,4,0.2444,0.219,0,0,2,0,1,"/**
     * Create and start a new HttpConnectionManager, close idle connections every minute.
     */
    public static void start() {
        synchronized (LOCK) {
            if (httpConnectionManagerThread == null) {
                httpConnectionManagerThread = new IdleConnectionTimeoutThread();
                httpConnectionManagerThread.setName(IdleConnectionTimeoutThread.class.getSimpleName());
                httpConnectionManagerThread.setConnectionTimeout(ONE_MINUTE);
                httpConnectionManagerThread.setTimeoutInterval(ONE_MINUTE);
                httpConnectionManagerThread.start();
            }
        }
    }"
davmail-4.5.1,davmail.http.DavGatewayX509TrustManager,DavGatewayX509TrustManager,,9,22,16,4,0.25,0.1067,0,3,2,0,1,"/**
     * Create a new custom X509 trust manager.
     *
     * @throws NoSuchAlgorithmException on error
     * @throws KeyStoreException        on error
     */
    public DavGatewayX509TrustManager() throws NoSuchAlgorithmException, KeyStoreException {
        TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        factory.init((KeyStore) null);
        TrustManager[] trustManagers = factory.getTrustManagers();
        if (trustManagers.length == 0) {
            throw new NoSuchAlgorithmException(""No trust manager found"");
        }
        this.standardTrustManager = (X509TrustManager) trustManagers[0];
    }"
davmail-4.5.1,davmail.http.DavGatewayX509TrustManager,checkServerTrusted,,13,17,13,4,0.2286,0.125,0,4,4,0,1,"public void checkServerTrusted(X509Certificate[] x509Certificates, String authType) throws CertificateException {
        try {
            // first try standard Trust Manager
            this.standardTrustManager.checkServerTrusted(x509Certificates, authType);
        } catch (CertificateException e) {
            if ((x509Certificates != null) && (x509Certificates.length > 0)) {
                userCheckServerTrusted(x509Certificates);
            } else {
                throw e;
            }

        }
    }"
davmail-4.5.1,davmail.http.DavGatewayX509TrustManager,userCheckServerTrusted,,22,60,42,4,0.1868,0.0961,0.666666667,4,7,0,1,"protected void userCheckServerTrusted(final X509Certificate[] x509Certificates) throws CertificateException {
        String acceptedCertificateHash = Settings.getProperty(""davmail.server.certificate.hash"");
        String certificateHash = getFormattedHash(x509Certificates[0]);
        // if user already accepted a certificate,
        if (acceptedCertificateHash != null && acceptedCertificateHash.length() > 0
                && acceptedCertificateHash.equals(certificateHash)) {
            DavGatewayTray.debug(new BundleMessage(""LOG_FOUND_ACCEPTED_CERTIFICATE"", acceptedCertificateHash));
        } else {
            boolean isCertificateTrusted;
            if (Settings.getBooleanProperty(""davmail.server"") || GraphicsEnvironment.isHeadless()) {
                // headless or server mode
                isCertificateTrusted = isCertificateTrusted(x509Certificates[0]);
            } else {
                isCertificateTrusted = AcceptCertificateDialog.isCertificateTrusted(x509Certificates[0]);
            }
            if (!isCertificateTrusted) {
                throw new CertificateException(""User rejected certificate"");
            }
            // certificate accepted, store in settings
            Settings.saveProperty(""davmail.server.certificate.hash"", certificateHash);
        }
    }"
davmail-4.5.1,davmail.http.DavGatewayX509TrustManager,isCertificateTrusted,,36,290,174,4,0.1379,0.1256,1,11,5,1,1,"@SuppressWarnings({""UseOfSystemOutOrSystemErr""})
    protected boolean isCertificateTrusted(X509Certificate certificate) {
        BufferedReader inReader = new BufferedReader(new InputStreamReader(System.in));
        String answer = null;
        String yes = BundleMessage.format(""UI_ANSWER_YES"");
        String no = BundleMessage.format(""UI_ANSWER_NO"");
        StringBuilder buffer = new StringBuilder();
        buffer.append(BundleMessage.format(""UI_SERVER_CERTIFICATE"")).append("":\n"");
        buffer.append(BundleMessage.format(""UI_ISSUED_TO"")).append("": "")
                .append(DavGatewayX509TrustManager.getRDN(certificate.getSubjectDN())).append('\n');
        buffer.append(BundleMessage.format(""UI_ISSUED_BY"")).append("": "")
                .append(getRDN(certificate.getIssuerDN())).append('\n');
        SimpleDateFormat formatter = new SimpleDateFormat(""MM/dd/yyyy"");
        String notBefore = formatter.format(certificate.getNotBefore());
        buffer.append(BundleMessage.format(""UI_VALID_FROM"")).append("": "").append(notBefore).append('\n');
        String notAfter = formatter.format(certificate.getNotAfter());
        buffer.append(BundleMessage.format(""UI_VALID_UNTIL"")).append("": "").append(notAfter).append('\n');
        buffer.append(BundleMessage.format(""UI_SERIAL"")).append("": "").append(getFormattedSerial(certificate)).append('\n');
        String sha1Hash = DavGatewayX509TrustManager.getFormattedHash(certificate);
        buffer.append(BundleMessage.format(""UI_FINGERPRINT"")).append("": "").append(sha1Hash).append('\n');
        buffer.append('\n');
        buffer.append(BundleMessage.format(""UI_UNTRUSTED_CERTIFICATE"")).append('\n');
        try {
            while (!yes.equals(answer) && !no.equals(answer)) {
                System.out.println(buffer.toString());
                answer = inReader.readLine();
                if (answer == null) {
                    answer = no;
                }
                answer = answer.toLowerCase();
            }
        } catch (IOException e) {
            System.err.println(e);
        }
        return yes.equals(answer);
    }"
davmail-4.5.1,davmail.http.DavGatewayX509TrustManager,formatHash,,10,20,12,3,0.25,0.1648,0,3,3,0,1,"/**
     * Format byte buffer to a hexadecimal hash string.
     *
     * @param buffer byte array
     * @return hexadecimal hash string
     */
    protected static String formatHash(byte[] buffer) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < buffer.length; i++) {
            if (i > 0) {
                builder.append(':');
            }
            builder.append(Integer.toHexString(buffer[i] & 0xFF));
        }
        return builder.toString().toUpperCase();
    }"
davmail-4.5.1,davmail.http.NTLMv2Scheme,processChallenge,,23,88,71,5,0.1156,0.0508,0,9,5,0,1,"/**
     * Processes the NTLM challenge.
     *
     * @param challenge the challenge string
     * @throws MalformedChallengeException is thrown if the authentication challenge
     *                                     is malformed
     */
    public void processChallenge(final String challenge) throws MalformedChallengeException {
        String authScheme = AuthChallengeParser.extractScheme(challenge);
        if (!authScheme.equalsIgnoreCase(getSchemeName())) {
            throw new MalformedChallengeException(""Invalid NTLM challenge: "" + challenge);
        }
        int spaceIndex = challenge.indexOf(' ');
        if (spaceIndex != -1) {
            try {
                type2Message = new Type2Message(Base64.decodeBase64(EncodingUtil.getBytes(
                        challenge.substring(spaceIndex, challenge.length()).trim(), ""ASCII"")));
            } catch (IOException e) {
                throw new MalformedChallengeException(""Invalid NTLM challenge: "" + challenge, e);
            }
            this.state = TYPE2_MSG_RECEIVED;
        } else {
            this.type2Message = null;
            if (this.state == UNINITIATED) {
                this.state = INITIATED;
            } else {
                this.state = FAILED;
            }
        }
    }"
davmail-4.5.1,davmail.http.NTLMv2Scheme,authenticate,,33,153,135,7,0.0914,0.0348,0,14,5,0,1,"/**
     * Produces NTLM authorization string for the given set of
     * {@link Credentials}.
     *
     * @param credentials The set of credentials to be used for authentication
     * @param httpMethod  The method being authenticated
     * @return an NTLM authorization string
     * @throws InvalidCredentialsException if authentication credentials
     *                                     are not valid or not applicable for this authentication scheme
     * @throws AuthenticationException     if authorization string cannot
     *                                     be generated due to an authentication failure
     */
    public String authenticate(Credentials credentials, HttpMethod httpMethod) throws AuthenticationException {
        if (this.state == UNINITIATED) {
            throw new IllegalStateException(""NTLM authentication process has not been initiated"");
        }

        NTCredentials ntcredentials;
        try {
            ntcredentials = (NTCredentials) credentials;
        } catch (ClassCastException e) {
            throw new InvalidCredentialsException(
                    ""Credentials cannot be used for NTLM authentication: ""
                            + credentials.getClass().getName());
        }
        String response;
        if (this.state == INITIATED || this.state == FAILED) {
            int flags = NtlmFlags.NTLMSSP_NEGOTIATE_NTLM2 | NtlmFlags.NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                    NtlmFlags.NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED | NtlmFlags.NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED |
                    NtlmFlags.NTLMSSP_NEGOTIATE_NTLM | NtlmFlags.NTLMSSP_REQUEST_TARGET |
                    NtlmFlags.NTLMSSP_NEGOTIATE_OEM | NtlmFlags.NTLMSSP_NEGOTIATE_UNICODE |
                    NtlmFlags.NTLMSSP_NEGOTIATE_56 | NtlmFlags.NTLMSSP_NEGOTIATE_128;
            Type1Message type1Message = new Type1Message(flags, ntcredentials.getDomain(), ntcredentials.getHost());
            response = EncodingUtil.getAsciiString(Base64.encodeBase64(type1Message.toByteArray()));
            this.state = TYPE1_MSG_GENERATED;
        } else {
            int flags = NtlmFlags.NTLMSSP_NEGOTIATE_NTLM2 | NtlmFlags.NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                    NtlmFlags.NTLMSSP_NEGOTIATE_NTLM | NtlmFlags.NTLMSSP_NEGOTIATE_UNICODE;
            Type3Message type3Message = new Type3Message(type2Message, ntcredentials.getPassword(),
                    ntcredentials.getDomain(), ntcredentials.getUserName(), ntcredentials.getHost(), flags);
            response = EncodingUtil.getAsciiString(Base64.encodeBase64(type3Message.toByteArray()));
            this.state = TYPE3_MSG_GENERATED;
        }
        return ""NTLM "" + response;
    }"
davmail-4.5.1,davmail.http.DavGatewaySSLProtocolSocketFactory,register,,17,50,34,4,0.1591,0.0865,1,5,4,0,1,"/**
     * Register custom Socket Factory to let user accept or reject certificate
     */
    public static void register() {
        String urlString = Settings.getProperty(""davmail.url"");
        try {
            URL url = new URL(urlString);
            String protocol = url.getProtocol();
            if (""https"".equals(protocol)) {
                int port = url.getPort();
                if (port < 0) {
                    port = HttpsURL.DEFAULT_PORT;
                }
                Protocol.registerProtocol(url.getProtocol(),
                        new Protocol(protocol, (ProtocolSocketFactory) new DavGatewaySSLProtocolSocketFactory(), port));
            }
        } catch (MalformedURLException e) {
            DavGatewayTray.error(new BundleMessage(""LOG_INVALID_URL"", urlString));
        }
    }"
davmail-4.5.1,davmail.http.DavGatewaySSLProtocolSocketFactory,createSSLContext,,62,524,453,2,0.0731,0.0517,1,16,16,1,1,"private SSLContext createSSLContext() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, KeyManagementException, KeyStoreException {
        // PKCS11 client certificate settings
        String pkcs11Library = Settings.getProperty(""davmail.ssl.pkcs11Library"");

        String clientKeystoreType = Settings.getProperty(""davmail.ssl.clientKeystoreType"");
        // set default keystore type
        if (clientKeystoreType == null || clientKeystoreType.length() == 0) {
            clientKeystoreType = ""PKCS11"";
        }

        if (pkcs11Library != null && pkcs11Library.length() > 0 && ""PKCS11"".equals(clientKeystoreType)) {
            StringBuilder pkcs11Buffer = new StringBuilder();
            pkcs11Buffer.append(""name=DavMail\n"");
            pkcs11Buffer.append(""library="").append(pkcs11Library).append('\n');
            String pkcs11Config = Settings.getProperty(""davmail.ssl.pkcs11Config"");
            if (pkcs11Config != null && pkcs11Config.length() > 0) {
                pkcs11Buffer.append(pkcs11Config).append('\n');
            }
            SunPKCS11ProviderHandler.registerProvider(pkcs11Buffer.toString());
        }
        String algorithm = KeyManagerFactory.getDefaultAlgorithm();
        if (""SunX509"".equals(algorithm)) {
            algorithm = ""NewSunX509"";
        } else if (""IbmX509"".equals(algorithm)) {
            algorithm = ""NewIbmX509"";
        }
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(algorithm);

        ArrayList<KeyStore.Builder> keyStoreBuilders = new ArrayList<KeyStore.Builder>();
        // PKCS11 (smartcard) keystore with password callback
        KeyStore.Builder scBuilder = KeyStore.Builder.newInstance(""PKCS11"", null, getProtectionParameter(null));
        keyStoreBuilders.add(scBuilder);

        String clientKeystoreFile = Settings.getProperty(""davmail.ssl.clientKeystoreFile"");
        String clientKeystorePass = Settings.getProperty(""davmail.ssl.clientKeystorePass"");
        if (clientKeystoreFile != null && clientKeystoreFile.length() > 0
                && (""PKCS12"".equals(clientKeystoreType) || ""JKS"".equals(clientKeystoreType))) {
            // PKCS12 file based keystore
            KeyStore.Builder fsBuilder = KeyStore.Builder.newInstance(clientKeystoreType, null,
                    new File(clientKeystoreFile), getProtectionParameter(clientKeystorePass));
            keyStoreBuilders.add(fsBuilder);
        }

        ManagerFactoryParameters keyStoreBuilderParameters = new KeyStoreBuilderParameters(keyStoreBuilders);
        keyManagerFactory.init(keyStoreBuilderParameters);

        // Get a list of key managers
        KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();

        // Walk through the key managers and replace all X509 Key Managers with
        // a specialized wrapped DavMail X509 Key Manager
        for (int i = 0; i < keyManagers.length; i++) {
            KeyManager keyManager = keyManagers[i];
            if (keyManager instanceof X509KeyManager) {
                keyManagers[i] = new DavMailX509KeyManager((X509KeyManager) keyManager);
            }
        }

        SSLContext context = SSLContext.getInstance(""SSL"");
        context.init(keyManagers, new TrustManager[]{new DavGatewayX509TrustManager()}, null);
        return context;
    }"
davmail-4.5.1,davmail.http.DavGatewaySSLProtocolSocketFactory,createSocket,,13,27,0,4,0.2182,0.5185,0,8,5,0,1,"public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException {
        try {
            return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);
        } catch (NoSuchAlgorithmException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyManagementException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyStoreException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (InvalidAlgorithmParameterException e) {
            throw new IOException(e + "" "" + e.getMessage());
        }
    }"
davmail-4.5.1,davmail.http.DavGatewaySSLProtocolSocketFactory,createSocket,,13,27,0,4,0.2182,0.5185,0,9,5,0,1,"public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort, HttpConnectionParams params) throws IOException {
        try {
            return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);
        } catch (NoSuchAlgorithmException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyManagementException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyStoreException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (InvalidAlgorithmParameterException e) {
            throw new IOException(e + "" "" + e.getMessage());
        }
    }"
davmail-4.5.1,davmail.http.DavGatewaySSLProtocolSocketFactory,createSocket,,13,27,0,4,0.303,0.5185,0,6,5,0,1,"public Socket createSocket(String host, int port) throws IOException {
        try {
            return getSSLContext().getSocketFactory().createSocket(host, port);
        } catch (NoSuchAlgorithmException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyManagementException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyStoreException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (InvalidAlgorithmParameterException e) {
            throw new IOException(e + "" "" + e.getMessage());
        }
    }"
davmail-4.5.1,davmail.http.DavGatewaySSLProtocolSocketFactory,createSocket,,13,27,0,4,0.2182,0.5185,0,8,5,0,1,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        try {
            return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
        } catch (NoSuchAlgorithmException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyManagementException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (KeyStoreException e) {
            throw new IOException(e + "" "" + e.getMessage());
        } catch (InvalidAlgorithmParameterException e) {
            throw new IOException(e + "" "" + e.getMessage());
        }
    }"
davmail-4.5.1,davmail.http.LenientBasicScheme,processChallenge,,8,9,8,4,0.4,0.1429,0,1,2,0,1,"public void processChallenge(String challenge)
            throws MalformedChallengeException {
        if (""Basic"".equalsIgnoreCase(challenge)) {
            super.processChallenge(""Basic \""default\"""");
        } else {
            super.processChallenge(challenge);
        }
    }"
davmail-4.5.1,davmail.http.DavMailX509KeyManager,chooseClientAlias,,48,165,99,2,0.1529,0.1217,0.5,9,8,1,1,"/**
     * Select a client alias. Some servers are misconfigured and claim to accept
     * any client certificate during the SSL handshake, however OWA only authenticates
     * using a single certificate.
     * <p/>
     * This method allows the user to select the right client certificate
     */
    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {
        // Build a list of all aliases
        ArrayList<String> aliases = new ArrayList<String>();
        for (String keyTypeValue : keyType) {
            String[] keyAliases = keyManager.getClientAliases(keyTypeValue, null);

            if (keyAliases != null) {
                aliases.addAll(Arrays.asList(keyAliases));
            }
        }

        // If there are more than one show a dialog and return the selected alias
        if (aliases.size() > 1) {

            //If there's a saved pattern try to match it
            if (cachedAlias != null) {
                for (String alias : aliases) {
                    if (cachedAlias.equals(stripAlias(alias))) {
                        LOGGER.debug(alias + "" matched cached alias: "" + cachedAlias);
                        return alias;
                    }
                }

                // pattern didn't match, clear the pattern and ask user to select an alias
                cachedAlias = null;
            }

            String[] aliasesArray = aliases.toArray(new String[aliases.size()]);
            SelectCertificateDialog selectCertificateDialog = new SelectCertificateDialog(aliasesArray);

            LOGGER.debug(""User selected Key Alias: "" + selectCertificateDialog.getSelectedAlias());

            cachedAlias = stripAlias(selectCertificateDialog.getSelectedAlias());
            LOGGER.debug(""Stored Key Alias Pattern: "" + cachedAlias);

            return selectCertificateDialog.getSelectedAlias();

            // exactly one, simply return that and don't bother the user
        } else if (aliases.size() == 1) {
            LOGGER.debug(""One Private Key found, returning that"");
            return aliases.get(0);

            // none, return null
        } else {
            LOGGER.debug(""No Private Keys found"");
            return null;
        }
    }"
davmail-4.5.1,davmail.http.DavMailX509KeyManager,stripAlias,,11,15,0,3,0.3111,0.2738,0,4,6,0,1,"/**
     * PKCS11 aliases are in the format: dd.0, dd is incremented
     * every time the SSL connection is re-negotiated
     *
     * @param alias original alias
     * @return alias without prefix
     */
    protected String stripAlias(String alias) {
        String value = alias;
        if (value != null && value.length() > 1) {
            char firstChar = value.charAt(0);
            int dotIndex = value.indexOf('.'); 
            if (firstChar >= '0' && firstChar <= '9' && dotIndex >= 0) {
                value = value.substring(dotIndex+1);
            }
        }
        return value;
    }"
davmail-4.5.1,davmail.imap.ImapConnection,checkInfiniteLoop,,21,52,26,3,0.2692,0.1468,0,3,6,0,1,"/**
     * Detect infinite loop on the client side.
     *
     * @param line IMAP command line
     * @throws IOException on infinite loop
     */
    protected void checkInfiniteLoop(String line) throws IOException {
        int spaceIndex = line.indexOf(' ');
        if (spaceIndex < 0) {
            // invalid command line, reset
            lastCommand = null;
            lastCommandCount = 0;
        } else {
            String command = line.substring(spaceIndex + 1);
            if (command.equals(lastCommand)) {
                lastCommandCount++;
                if (lastCommandCount > 100 && !""NOOP"".equalsIgnoreCase(lastCommand) && !""IDLE"".equalsIgnoreCase(lastCommand)) {
                    // more than a hundred times the same command => this is a client infinite loop, close connection
                    throw new IOException(""Infinite loop on command "" + command + "" detected"");
                }
            } else {
                // new command, reset
                lastCommand = command;
                lastCommandCount = 0;
            }
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,splitUserName,,13,18,0,3,0.4074,0.3,0,1,5,0,1,"/**
     * Detect shared mailbox access.
     * see http://msexchangeteam.com/archive/2004/03/31/105275.aspx
     */
    protected void splitUserName() {
        String[] tokens = null;
        if (userName.indexOf('/') >= 0) {
            tokens = userName.split(""/"");
        } else if (userName.indexOf('\\') >= 0) {
            tokens = userName.split(""\\\\"");
        }

        if (tokens != null && tokens.length == 3) {
            userName = tokens[0] + '\\' + tokens[1];
            baseMailboxPath = ""/users/"" + tokens[2] + '/';
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,handleRefresh,,18,78,65,6,0.1607,0.0898,1,4,4,0,1,"/**
     * Send expunge untagged response for removed IMAP message uids.
     *
     * @param previousImapFlagMap uid map before refresh
     * @param imapFlagMap         uid map after refresh
     * @throws IOException on error
     */
    private void handleRefresh(TreeMap<Long, String> previousImapFlagMap, TreeMap<Long, String> imapFlagMap) throws IOException {
        // send deleted message expunge notification
        int index = 1;
        for (long previousImapUid : previousImapFlagMap.keySet()) {
            if (!imapFlagMap.keySet().contains(previousImapUid)) {
                sendClient(""* "" + index + "" EXPUNGE"");
            } else {
                // send updated flags
                if (!previousImapFlagMap.get(previousImapUid).equals(imapFlagMap.get(previousImapUid))) {
                    sendClient(""* "" + index + "" FETCH (UID "" + previousImapUid + "" FLAGS ("" + imapFlagMap.get(previousImapUid) + ""))"");
                }
                index++;
            }
        }

        sendClient(""* "" + currentFolder.count() + "" EXISTS"");
        sendClient(""* "" + currentFolder.recent + "" RECENT"");
    }"
davmail-4.5.1,davmail.imap.ImapConnection,handleFetch,,164,4275,3194,4,0.0529,0.0692,0.6,30,50,0,1,"private void handleFetch(ExchangeSession.Message message, int currentIndex, String parameters) throws IOException, MessagingException {
        StringBuilder buffer = new StringBuilder();
        MessageWrapper messageWrapper = new MessageWrapper(os, buffer, message);
        buffer.append(""* "").append(currentIndex).append("" FETCH (UID "").append(message.getImapUid());
        if (parameters != null) {
            StringTokenizer paramTokens = new StringTokenizer(parameters);
            while (paramTokens.hasMoreTokens()) {
                @SuppressWarnings({""NonConstantStringShouldBeStringBuffer""})
                String param = paramTokens.nextToken().toUpperCase();
                if (""FLAGS"".equals(param)) {
                    buffer.append("" FLAGS ("").append(message.getImapFlags()).append(')');
                } else if (""RFC822.SIZE"".equals(param)) {
                    int size;
                    if (parameters.contains(""BODY.PEEK[HEADER.FIELDS ("")
                            // exclude mutt header request
                            && !parameters.contains(""X-LABEL"")) {
                        // Header request, send approximate size
                        size = message.size;
                    } else {
                        size = messageWrapper.getMimeMessageSize();
                    }
                    buffer.append("" RFC822.SIZE "").append(size);
                } else if (""ENVELOPE"".equals(param)) {
                    appendEnvelope(buffer, messageWrapper);
                } else if (""BODYSTRUCTURE"".equals(param)) {
                    appendBodyStructure(buffer, messageWrapper);
                } else if (""INTERNALDATE"".equals(param) && message.date != null && message.date.length() > 0) {
                    try {
                        SimpleDateFormat dateParser = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"");
                        dateParser.setTimeZone(ExchangeSession.GMT_TIMEZONE);
                        Date date = ExchangeSession.getZuluDateFormat().parse(message.date);
                        SimpleDateFormat dateFormatter = new SimpleDateFormat(""dd-MMM-yyyy HH:mm:ss Z"", Locale.ENGLISH);
                        buffer.append("" INTERNALDATE \"""").append(dateFormatter.format(date)).append('\""');
                    } catch (ParseException e) {
                        throw new DavMailException(""EXCEPTION_INVALID_DATE"", message.date);
                    }
                } else if (""RFC822"".equals(param) || param.startsWith(""BODY["") || param.startsWith(""BODY.PEEK["") || ""RFC822.HEADER"".equals(param)) {
                    // get full param
                    if (param.indexOf('[') >= 0) {
                        StringBuilder paramBuffer = new StringBuilder(param);
                        while (paramTokens.hasMoreTokens() && paramBuffer.indexOf(""]"") < 0) {
                            paramBuffer.append(' ').append(paramTokens.nextToken());
                        }
                        param = paramBuffer.toString();
                    }
                    // parse buffer size
                    int startIndex = 0;
                    int maxSize = Integer.MAX_VALUE;
                    int ltIndex = param.indexOf('<');
                    if (ltIndex >= 0) {
                        int dotIndex = param.indexOf('.', ltIndex);
                        if (dotIndex >= 0) {
                            startIndex = Integer.parseInt(param.substring(ltIndex + 1, dotIndex));
                            maxSize = Integer.parseInt(param.substring(dotIndex + 1, param.indexOf('>')));
                        }
                    }

                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    InputStream partInputStream = null;
                    OutputStream partOutputStream = null;

                    // try to parse message part index
                    String partIndexString = StringUtil.getToken(param, ""["", ""]"");
                    if ((partIndexString == null || partIndexString.length() == 0) && !""RFC822.HEADER"".equals(param)) {
                        // write message with headers
                        partOutputStream = new PartialOutputStream(baos, startIndex, maxSize);
                        partInputStream = messageWrapper.getRawInputStream();
                    } else if (""TEXT"".equals(partIndexString)) {
                        // write message without headers
                        partOutputStream = new PartOutputStream(baos, false, true, startIndex, maxSize);
                        partInputStream = messageWrapper.getRawInputStream();
                    } else if (""RFC822.HEADER"".equals(param) || (partIndexString != null && partIndexString.startsWith(""HEADER""))) {
                        // Header requested fetch  headers
                        String[] requestedHeaders = getRequestedHeaders(partIndexString);
                        // OSX Lion special flags request
                        if (requestedHeaders != null && requestedHeaders.length == 1 && ""content-class"".equals(requestedHeaders[0]) && message.contentClass != null) {
                            baos.write(""Content-class: "".getBytes(""UTF-8""));
                            baos.write(message.contentClass.getBytes(""UTF-8""));
                            baos.write(13);
                            baos.write(10);
                        } else if (requestedHeaders == null) {
                            // load message and write all headers
                            partOutputStream = new PartOutputStream(baos, true, false, startIndex, maxSize);
                            partInputStream = messageWrapper.getRawInputStream();
                        } else {
                            Enumeration headerEnumeration = messageWrapper.getMatchingHeaderLines(requestedHeaders);
                            while (headerEnumeration.hasMoreElements()) {
                                baos.write(((String) headerEnumeration.nextElement()).getBytes(""UTF-8""));
                                baos.write(13);
                                baos.write(10);
                            }
                        }
                    } else if (partIndexString != null) {
                        MimePart bodyPart = messageWrapper.getMimeMessage();
                        String[] partIndexStrings = partIndexString.split(""\\."");
                        for (String subPartIndexString : partIndexStrings) {
                            // ignore MIME subpart index, will return full part
                            if (""MIME"".equals(subPartIndexString)) {
                                break;
                            }
                            int subPartIndex;
                            // try to parse part index
                            try {
                                subPartIndex = Integer.parseInt(subPartIndexString);
                            } catch (NumberFormatException e) {
                                throw new DavMailException(""EXCEPTION_INVALID_PARAMETER"", param);
                            }

                            Object mimeBody = bodyPart.getContent();
                            if (mimeBody instanceof MimeMultipart) {
                                MimeMultipart multiPart = (MimeMultipart) mimeBody;
                                if (subPartIndex - 1 < multiPart.getCount()) {
                                    bodyPart = (MimePart) multiPart.getBodyPart(subPartIndex - 1);
                                } else {
                                    throw new DavMailException(""EXCEPTION_INVALID_PARAMETER"", param);
                                }
                            } else if (subPartIndex != 1) {
                                throw new DavMailException(""EXCEPTION_INVALID_PARAMETER"", param);
                            }
                        }

                        // write selected part, without headers
                        partOutputStream = new PartialOutputStream(baos, startIndex, maxSize);
                        if (bodyPart instanceof MimeMessage) {
                            partInputStream = ((MimeMessage) bodyPart).getRawInputStream();
                        } else {
                            partInputStream = ((MimeBodyPart) bodyPart).getRawInputStream();
                        }
                    }

                    // copy selected content to baos
                    if (partInputStream != null && partOutputStream != null) {
                        IOUtil.write(partInputStream, partOutputStream);
                        partInputStream.close();
                        partOutputStream.close();
                    }
                    baos.close();

                    if (""RFC822.HEADER"".equals(param)) {
                        buffer.append("" RFC822.HEADER "");
                    } else {
                        buffer.append("" BODY["").append(partIndexString).append(']');
                    }
                    // partial
                    if (startIndex > 0 || maxSize != Integer.MAX_VALUE) {
                        buffer.append('<').append(startIndex).append('>');
                    }
                    buffer.append("" {"").append(baos.size()).append('}');
                    sendClient(buffer.toString());
                    // log content if less than 2K
                    if (LOGGER.isDebugEnabled() && baos.size() < 2048) {
                        LOGGER.debug(new String(baos.toByteArray(), ""UTF-8""));
                    }
                    os.write(baos.toByteArray());
                    os.flush();
                    buffer.setLength(0);
                }
            }
        }
        buffer.append(')');
        sendClient(buffer.toString());
        // do not keep message content in memory
        message.dropMimeMessage();
    }"
davmail-4.5.1,davmail.imap.ImapConnection,handleStore,,15,49,43,6,0.1414,0.0648,0.857142857,5,4,0,1,"protected void handleStore(String commandId, AbstractRangeIterator rangeIterator, String action, String flags) throws IOException {
        while (rangeIterator.hasNext()) {
            DavGatewayTray.switchIcon();
            ExchangeSession.Message message = rangeIterator.next();
            updateFlags(message, action, flags);
            sendClient(""* "" + (rangeIterator.getCurrentIndex()) + "" FETCH (UID "" + message.getImapUid() + "" FLAGS ("" + (message.getImapFlags()) + ""))"");
        }
        // auto expunge
        if (Settings.getBooleanProperty(""davmail.imapAutoExpunge"")) {
            if (expunge(false)) {
                session.refreshFolder(currentFolder);
            }
        }
        sendClient(commandId + "" OK STORE completed"");
    }"
davmail-4.5.1,davmail.imap.ImapConnection,buildConditions,,28,82,11,3,0.287,0.2072,0.6,5,11,0,1,"protected ExchangeSession.Condition buildConditions(SearchConditions conditions, IMAPTokenizer tokens) throws IOException {
        ExchangeSession.MultiCondition condition = null;
        while (tokens.hasMoreTokens()) {
            String token = tokens.nextQuotedToken().toUpperCase();
            if (token.startsWith(""("") && token.endsWith("")"")) {
                // quoted search param
                if (condition == null) {
                    condition = session.and();
                }
                condition.add(buildConditions(conditions, new IMAPTokenizer(token.substring(1, token.length() - 1))));
            } else if (""OR"".equals(token)) {
                condition = session.or();
            } else if (token.startsWith(""OR "")) {
                condition = appendOrSearchParams(token, conditions);
            } else if (""CHARSET"".equals(token)) {
                String charset = tokens.nextQuotedToken().toUpperCase();
                if (!(""ASCII"".equals(charset) || ""UTF-8"".equals(charset))) {
                    throw new IOException(""Unsupported charset "" + charset);
                }
            } else {
                if (condition == null) {
                    condition = session.and();
                }
                condition.add(appendSearchParam(tokens, token, conditions));
            }
        }
        return condition;
    }"
davmail-4.5.1,davmail.imap.ImapConnection,handleSearch,,33,174,117,3,0.1266,0.0903,1,9,13,0,1,"protected List<Long> handleSearch(IMAPTokenizer tokens) throws IOException {
        List<Long> uidList = new ArrayList<Long>();
        List<Long> localMessagesUidList = null;
        SearchConditions conditions = new SearchConditions();
        ExchangeSession.Condition condition = buildConditions(conditions, tokens);
        session.refreshFolder(currentFolder);
        ExchangeSession.MessageList localMessages = currentFolder.searchMessages(condition);
        Iterator<ExchangeSession.Message> iterator;
        if (conditions.uidRange != null) {
            iterator = new UIDRangeIterator(localMessages, conditions.uidRange);
        } else if (conditions.indexRange != null) {
            // range iterator is on folder messages, not messages returned from search
            iterator = new RangeIterator(currentFolder.messages, conditions.indexRange);
            localMessagesUidList = new ArrayList<Long>();
            // build search result uid list
            for (ExchangeSession.Message message : localMessages) {
                localMessagesUidList.add(message.getImapUid());
            }
        } else {
            iterator = localMessages.iterator();
        }
        while (iterator.hasNext()) {
            ExchangeSession.Message message = iterator.next();
            if ((conditions.flagged == null || message.flagged == conditions.flagged)
                    && (conditions.answered == null || message.answered == conditions.answered)
                    && (conditions.draft == null || message.draft == conditions.draft)
                    // range iterator: include messages available in search result
                    && (localMessagesUidList == null || localMessagesUidList.contains(message.getImapUid()))) {
                uidList.add(message.getImapUid());
            }
        }
        return uidList;
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendEnvelope,,24,47,0,3,0.3294,0.4914,1,4,2,0,1,"protected void appendEnvelope(StringBuilder buffer, MessageWrapper message) throws IOException {

        try {
            MimeMessage mimeMessage = message.getMimeMessage();
            buffer.append("" ENVELOPE ("");
            // Envelope for date, subject, from, sender, reply-to, to, cc, bcc,in-reply-to, message-id
            appendEnvelopeHeader(buffer, mimeMessage.getHeader(""Date""));
            appendEnvelopeHeader(buffer, mimeMessage.getHeader(""Subject""));
            appendMailEnvelopeHeader(buffer, mimeMessage.getHeader(""From""));
            appendMailEnvelopeHeader(buffer, mimeMessage.getHeader(""Sender""));
            appendMailEnvelopeHeader(buffer, mimeMessage.getHeader(""Reply-To""));
            appendMailEnvelopeHeader(buffer, mimeMessage.getHeader(""To""));
            appendMailEnvelopeHeader(buffer, mimeMessage.getHeader(""CC""));
            appendMailEnvelopeHeader(buffer, mimeMessage.getHeader(""BCC""));
            appendEnvelopeHeader(buffer, mimeMessage.getHeader(""In-Reply-To""));
            appendEnvelopeHeader(buffer, mimeMessage.getHeader(""Message-Id""));
            buffer.append(')');

        } catch (MessagingException me) {
            DavGatewayTray.warn(me);
            // send fake envelope
            buffer.append("" ENVELOPE (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)"");
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendEnvelopeHeader,,10,14,7,3,0.3333,0.2167,0,2,4,0,1,"protected void appendEnvelopeHeader(StringBuilder buffer, String[] value) throws UnsupportedEncodingException {
        if (buffer.charAt(buffer.length() - 1) != '(') {
            buffer.append(' ');
        }
        if (value != null && value.length > 0) {
            appendEnvelopeHeaderValue(buffer, MimeUtility.unfold(value[0]));
        } else {
            buffer.append(""NIL"");
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendMailEnvelopeHeader,,43,338,180,4,0.1226,0.2174,1,10,10,0,1,"protected void appendMailEnvelopeHeader(StringBuilder buffer, String[] value) {
        buffer.append(' ');
        if (value != null && value.length > 0) {
            try {
                String unfoldedValue = MimeUtility.unfold(value[0]);
                InternetAddress[] addresses = InternetAddress.parseHeader(unfoldedValue, false);
                if (addresses != null && addresses.length > 0) {
                    buffer.append('(');
                    for (InternetAddress address : addresses) {
                        buffer.append('(');
                        String personal = address.getPersonal();
                        if (personal != null) {
                            appendEnvelopeHeaderValue(buffer, personal);
                        } else {
                            buffer.append(""NIL"");
                        }
                        buffer.append("" NIL "");
                        String mail = address.getAddress();
                        int atIndex = mail.indexOf('@');
                        if (atIndex >= 0) {
                            buffer.append('""').append(mail.substring(0, atIndex)).append('""');
                            buffer.append(' ');
                            buffer.append('""').append(mail.substring(atIndex + 1)).append('""');
                        } else {
                            buffer.append(""NIL NIL"");
                        }
                        buffer.append(')');
                    }
                    buffer.append(')');
                } else {
                    buffer.append(""NIL"");
                }
            } catch (AddressException e) {
                DavGatewayTray.warn(e);
                buffer.append(""NIL"");
            } catch (UnsupportedEncodingException e) {
                DavGatewayTray.warn(e);
                buffer.append(""NIL"");
            }
        } else {
            buffer.append(""NIL"");
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendEnvelopeHeaderValue,,13,12,0,2,0.4444,0.4167,0,2,3,0,1,"protected void appendEnvelopeHeaderValue(StringBuilder buffer, String value) throws UnsupportedEncodingException {
        if (value.indexOf('""') >= 0 || value.indexOf('\\') >= 0) {
            buffer.append('{');
            buffer.append(value.length());
            buffer.append(""}\r\n"");
            buffer.append(value);
        } else {
            buffer.append('""');
            buffer.append(MimeUtility.encodeText(value, ""UTF-8"", null));
            buffer.append('""');
        }

    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendBodyStructure,,22,59,40,3,0.1978,0.1282,1,6,4,0,1,"protected void appendBodyStructure(StringBuilder buffer, MessageWrapper message) throws IOException {

        buffer.append("" BODYSTRUCTURE "");
        try {
            MimeMessage mimeMessage = message.getMimeMessage();
            Object mimeBody = mimeMessage.getContent();
            if (mimeBody instanceof MimeMultipart) {
                appendBodyStructure(buffer, (MimeMultipart) mimeBody);
            } else {
                // no multipart, single body
                appendBodyStructure(buffer, mimeMessage);
            }
        } catch (UnsupportedEncodingException e) {
            DavGatewayTray.warn(e);
            // failover: send default bodystructure
            buffer.append(""(\""TEXT\"" \""PLAIN\"" (\""CHARSET\"" \""US-ASCII\"") NIL NIL NIL NIL NIL)"");
        } catch (MessagingException me) {
            DavGatewayTray.warn(me);
            // failover: send default bodystructure
            buffer.append(""(\""TEXT\"" \""PLAIN\"" (\""CHARSET\"" \""US-ASCII\"") NIL NIL NIL NIL NIL)"");
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendBodyStructure,,34,177,123,5,0.1402,0.0898,1,9,7,0,1,"protected void appendBodyStructure(StringBuilder buffer, MimeMultipart multiPart) throws IOException, MessagingException {
        buffer.append('(');

        for (int i = 0; i < multiPart.getCount(); i++) {
            MimeBodyPart bodyPart = (MimeBodyPart) multiPart.getBodyPart(i);
            try {
                Object mimeBody = bodyPart.getContent();
                if (mimeBody instanceof MimeMultipart) {
                    appendBodyStructure(buffer, (MimeMultipart) mimeBody);
                } else {
                    // no multipart, single body
                    appendBodyStructure(buffer, bodyPart);
                }
            } catch (UnsupportedEncodingException e) {
                LOGGER.warn(e);
                // failover: send default bodystructure
                buffer.append(""(\""TEXT\"" \""PLAIN\"" (\""CHARSET\"" \""US-ASCII\"") NIL NIL NIL NIL NIL)"");
            } catch (MessagingException me) {
                DavGatewayTray.warn(me);
                // failover: send default bodystructure
                buffer.append(""(\""TEXT\"" \""PLAIN\"" (\""CHARSET\"" \""US-ASCII\"") NIL NIL NIL NIL NIL)"");
            }
        }
        int slashIndex = multiPart.getContentType().indexOf('/');
        if (slashIndex < 0) {
            throw new DavMailException(""EXCEPTION_INVALID_CONTENT_TYPE"", multiPart.getContentType());
        }
        int semiColonIndex = multiPart.getContentType().indexOf(';');
        if (semiColonIndex < 0) {
            buffer.append("" \"""").append(multiPart.getContentType().substring(slashIndex + 1).toUpperCase()).append(""\"")"");
        } else {
            buffer.append("" \"""").append(multiPart.getContentType().substring(slashIndex + 1, semiColonIndex).trim().toUpperCase()).append(""\"")"");
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendBodyStructure,,78,927,423,3,0.1253,0.1613,1,14,16,0,1,"protected void appendBodyStructure(StringBuilder buffer, MimePart bodyPart) throws IOException, MessagingException {
        String contentType = MimeUtility.unfold(bodyPart.getContentType());
        int slashIndex = contentType.indexOf('/');
        if (slashIndex < 0) {
            throw new DavMailException(""EXCEPTION_INVALID_CONTENT_TYPE"", contentType);
        }
        String type = contentType.substring(0, slashIndex).toUpperCase();
        buffer.append(""(\"""").append(type).append(""\"" \"""");
        int semiColonIndex = contentType.indexOf(';');
        if (semiColonIndex < 0) {
            buffer.append(contentType.substring(slashIndex + 1).toUpperCase()).append(""\"" NIL"");
        } else {
            // extended content type
            buffer.append(contentType.substring(slashIndex + 1, semiColonIndex).trim().toUpperCase()).append('\""');
            int charsetindex = contentType.indexOf(""charset="");
            int nameindex = contentType.indexOf(""name="");
            if (charsetindex >= 0 || nameindex >= 0) {
                buffer.append("" ("");

                if (charsetindex >= 0) {
                    buffer.append(""\""CHARSET\"" "");
                    int charsetSemiColonIndex = contentType.indexOf(';', charsetindex);
                    int charsetEndIndex;
                    if (charsetSemiColonIndex > 0) {
                        charsetEndIndex = charsetSemiColonIndex;
                    } else {
                        charsetEndIndex = contentType.length();
                    }
                    String charSet = contentType.substring(charsetindex + ""charset="".length(), charsetEndIndex);
                    if (!charSet.startsWith(""\"""")) {
                        buffer.append('""');
                    }
                    buffer.append(charSet.trim().toUpperCase());
                    if (!charSet.endsWith(""\"""")) {
                        buffer.append('""');
                    }
                }

                if (nameindex >= 0) {
                    if (charsetindex >= 0) {
                        buffer.append(' ');
                    }

                    buffer.append(""\""NAME\"" "");
                    int nameSemiColonIndex = contentType.indexOf(';', nameindex);
                    int nameEndIndex;
                    if (nameSemiColonIndex > 0) {
                        nameEndIndex = nameSemiColonIndex;
                    } else {
                        nameEndIndex = contentType.length();
                    }
                    String name = contentType.substring(nameindex + ""name="".length(), nameEndIndex).trim();
                    if (!name.startsWith(""\"""")) {
                        buffer.append('""');
                    }
                    buffer.append(name.trim());
                    if (!name.endsWith(""\"""")) {
                        buffer.append('""');
                    }
                }
                buffer.append(')');
            } else {
                buffer.append("" NIL"");
            }
        }
        appendBodyStructureValue(buffer, bodyPart.getContentID());
        appendBodyStructureValue(buffer, bodyPart.getDescription());
        appendBodyStructureValue(buffer, bodyPart.getEncoding());
        appendBodyStructureValue(buffer, bodyPart.getSize());
        if (""MESSAGE"".equals(type) || ""TEXT"".equals(type)) {
            // line count not implemented in JavaMail, return fake line count
            appendBodyStructureValue(buffer, bodyPart.getSize() / 80);
        } else {
            // do not send line count for non text bodyparts
            appendBodyStructureValue(buffer, -1);
        }
        buffer.append(')');
    }"
davmail-4.5.1,davmail.imap.ImapConnection,sendSubFolders,,17,135,117,10,0.1037,0.0527,1,8,5,0,1,"protected void sendSubFolders(String command, String folderPath, boolean recursive) throws IOException {
        try {
            List<ExchangeSession.Folder> folders = session.getSubFolders(folderPath, recursive);
            for (ExchangeSession.Folder folder : folders) {
                sendClient(""* "" + command + "" ("" + folder.getFlags() + "") \""/\"" \"""" + BASE64MailboxEncoder.encode(folder.folderPath) + '\""');
            }
        } catch (HttpForbiddenException e) {
            // access forbidden, ignore
            DavGatewayTray.debug(new BundleMessage(""LOG_SUBFOLDER_ACCESS_FORBIDDEN"", folderPath));
        } catch (HttpNotFoundException e) {
            // not found, ignore
            DavGatewayTray.debug(new BundleMessage(""LOG_FOLDER_NOT_FOUND"", folderPath));
        } catch (HttpException e) {
            // other errors, ignore
            DavGatewayTray.debug(new BundleMessage(""LOG_FOLDER_ACCESS_ERROR"", folderPath, e.getMessage()));
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendOrSearchParams,,10,23,10,2,0.2407,0.1567,0.75,5,2,0,1,"protected ExchangeSession.MultiCondition appendOrSearchParams(String token, SearchConditions conditions) throws IOException {
        ExchangeSession.MultiCondition orCondition = session.or();
        IMAPTokenizer innerTokens = new IMAPTokenizer(token);
        innerTokens.nextToken();
        while (innerTokens.hasMoreTokens()) {
            String innerToken = innerTokens.nextToken();
            orCondition.add(appendSearchParam(innerTokens, innerToken, conditions));
        }
        return orCondition;
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendSearchParam,,83,663,380,6,0.1185,0.1408,0.166666667,8,39,0,1,"protected ExchangeSession.Condition appendSearchParam(StringTokenizer tokens, String token, SearchConditions conditions) throws IOException {
        if (""NOT"".equals(token)) {
            String nextToken = tokens.nextToken();
            if (""DELETED"".equals(nextToken)) {
                // conditions.deleted = Boolean.FALSE;
                return session.isNull(""deleted"");
            } else {
                return session.not(appendSearchParam(tokens, nextToken, conditions));
            }
        } else if (token.startsWith(""OR "")) {
            return appendOrSearchParams(token, conditions);
        } else if (""SUBJECT"".equals(token)) {
            return session.contains(""subject"", tokens.nextToken());
        } else if (""BODY"".equals(token)) {
            return session.contains(""body"", tokens.nextToken());
        } else if (""TEXT"".equals(token)) {
            String value = tokens.nextToken();
            return session.or(session.contains(""body"", value),
                    session.contains(""subject"", value),
                    session.contains(""from"", value),
                    session.contains(""to"", value),
                    session.contains(""cc"", value));
        } else if (""KEYWORD"".equals(token)) {
            return session.isEqualTo(""keywords"", session.convertFlagToKeyword(tokens.nextToken()));
        } else if (""FROM"".equals(token)) {
            return session.contains(""from"", tokens.nextToken());
        } else if (""TO"".equals(token)) {
            return session.contains(""to"", tokens.nextToken());
        } else if (""CC"".equals(token)) {
            return session.contains(""cc"", tokens.nextToken());
        } else if (""LARGER"".equals(token)) {
            return session.gte(""messageSize"", tokens.nextToken());
        } else if (""SMALLER"".equals(token)) {
            return session.lt(""messageSize"", tokens.nextToken());
        } else if (token.startsWith(""SENT"") || ""SINCE"".equals(token) || ""BEFORE"".equals(token)) {
            return appendDateSearchParam(tokens, token);
        } else if (""SEEN"".equals(token)) {
            return session.isTrue(""read"");
        } else if (""UNSEEN"".equals(token) || ""NEW"".equals(token)) {
            return session.isFalse(""read"");
        } else if (""DRAFT"".equals(token)) {
            conditions.draft = Boolean.TRUE;
        } else if (""UNDRAFT"".equals(token)) {
            conditions.draft = Boolean.FALSE;
        } else if (""DELETED"".equals(token)) {
            // conditions.deleted = Boolean.TRUE;
            return session.isEqualTo(""deleted"", ""1"");
        } else if (""UNDELETED"".equals(token) || ""NOT DELETED"".equals(token)) {
            // conditions.deleted = Boolean.FALSE;
            return session.isNull(""deleted"");
        } else if (""FLAGGED"".equals(token)) {
            conditions.flagged = Boolean.TRUE;
        } else if (""UNFLAGGED"".equals(token) || ""NEW"".equals(token)) {
            conditions.flagged = Boolean.FALSE;
        } else if (""ANSWERED"".equals(token)) {
            conditions.answered = Boolean.TRUE;
        } else if (""UNANSWERED"".equals(token)) {
            conditions.answered = Boolean.FALSE;
        } else if (""HEADER"".equals(token)) {
            String headerName = tokens.nextToken().toLowerCase();
            String value = tokens.nextToken();
            if (""message-id"".equals(headerName) && !value.startsWith(""<"")) {
                value = '<' + value + '>';
            }
            return session.headerIsEqualTo(headerName, value);
        } else if (""UID"".equals(token)) {
            String range = tokens.nextToken();
            if (""1:*"".equals(range)) {
                // ignore: this is a noop filter
            } else {
                conditions.uidRange = range;
            }
        } else if (""OLD"".equals(token) || ""RECENT"".equals(token) || ""ALL"".equals(token)) {
            // ignore
        } else if (token.indexOf(':') >= 0 || token.matches(""\\d+"")) {
            // range search
            conditions.indexRange = token;
        } else {
            throw new DavMailException(""EXCEPTION_INVALID_SEARCH_PARAMETERS"", token);
        }
        // client side search token
        return null;
    }"
davmail-4.5.1,davmail.imap.ImapConnection,appendDateSearchParam,,33,228,180,5,0.1326,0.082,0.333333333,9,6,0,1,"protected ExchangeSession.Condition appendDateSearchParam(StringTokenizer tokens, String token) throws IOException {
        Date startDate;
        Date endDate;
        SimpleDateFormat parser = new SimpleDateFormat(""dd-MMM-yyyy"", Locale.ENGLISH);
        parser.setTimeZone(ExchangeSession.GMT_TIMEZONE);
        String dateToken = tokens.nextToken();
        try {
            startDate = parser.parse(dateToken);
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(startDate);
            calendar.add(Calendar.DAY_OF_MONTH, 1);
            endDate = calendar.getTime();
        } catch (ParseException e) {
            throw new DavMailException(""EXCEPTION_INVALID_SEARCH_PARAMETERS"", dateToken);
        }
        String searchAttribute;
        if (token.startsWith(""SENT"")) {
            searchAttribute = ""date"";
        } else {
            searchAttribute = ""lastmodified"";
        }

        if (token.endsWith(""ON"")) {
            return session.and(session.gt(searchAttribute, session.formatSearchDate(startDate)),
                    session.lt(searchAttribute, session.formatSearchDate(endDate)));
        } else if (token.endsWith(""BEFORE"")) {
            return session.lt(searchAttribute, session.formatSearchDate(startDate));
        } else if (token.endsWith(""SINCE"")) {
            return session.gte(searchAttribute, session.formatSearchDate(startDate));
        } else {
            throw new DavMailException(""EXCEPTION_INVALID_SEARCH_PARAMETERS"", dateToken);
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,expunge,,18,68,58,5,0.1846,0.1104,1,4,5,0,1,"protected boolean expunge(boolean silent) throws IOException {
        boolean hasDeleted = false;
        if (currentFolder.messages != null) {
            int index = 1;
            for (ExchangeSession.Message message : currentFolder.messages) {
                if (message.deleted) {
                    message.delete();
                    hasDeleted = true;
                    if (!silent) {
                        sendClient(""* "" + index + "" EXPUNGE"");
                    }
                } else {
                    index++;
                }
            }
        }
        return hasDeleted;
    }"
davmail-4.5.1,davmail.imap.ImapConnection,updateFlags,,170,5790,4077,4,0.0631,0.1374,0.5,17,58,0,1,"protected void updateFlags(ExchangeSession.Message message, String action, String flags) throws IOException {
        HashMap<String, String> properties = new HashMap<String, String>();
        if (""-Flags"".equalsIgnoreCase(action) || ""-FLAGS.SILENT"".equalsIgnoreCase(action)) {
            StringTokenizer flagtokenizer = new StringTokenizer(flags);
            while (flagtokenizer.hasMoreTokens()) {
                String flag = flagtokenizer.nextToken();
                if (""\\Seen"".equalsIgnoreCase(flag)) {
                    if (message.read) {
                        properties.put(""read"", ""0"");
                        message.read = false;
                    }
                } else if (""\\Flagged"".equalsIgnoreCase(flag)) {
                    if (message.flagged) {
                        properties.put(""flagged"", ""0"");
                        message.flagged = false;
                    }
                } else if (""\\Deleted"".equalsIgnoreCase(flag)) {
                    if (message.deleted) {
                        properties.put(""deleted"", null);
                        message.deleted = false;
                    }
                } else if (""Junk"".equalsIgnoreCase(flag)) {
                    if (message.junk) {
                        properties.put(""junk"", ""0"");
                        message.junk = false;
                    }
                } else if (""$Forwarded"".equalsIgnoreCase(flag)) {
                    if (message.forwarded) {
                        properties.put(""forwarded"", null);
                        message.forwarded = false;
                    }
                } else if (""\\Answered"".equalsIgnoreCase(flag)) {
                    if (message.answered) {
                        properties.put(""answered"", null);
                        message.answered = false;
                    }
                } else if (message.keywords != null) {
                    properties.put(""keywords"", message.removeFlag(flag));
                }
            }
        } else if (""+Flags"".equalsIgnoreCase(action) || ""+FLAGS.SILENT"".equalsIgnoreCase(action)) {
            StringTokenizer flagtokenizer = new StringTokenizer(flags);
            while (flagtokenizer.hasMoreTokens()) {
                String flag = flagtokenizer.nextToken();
                if (""\\Seen"".equalsIgnoreCase(flag)) {
                    if (!message.read) {
                        properties.put(""read"", ""1"");
                        message.read = true;
                    }
                } else if (""\\Deleted"".equalsIgnoreCase(flag)) {
                    if (!message.deleted) {
                        message.deleted = true;
                        properties.put(""deleted"", ""1"");
                    }
                } else if (""\\Flagged"".equalsIgnoreCase(flag)) {
                    if (!message.flagged) {
                        properties.put(""flagged"", ""2"");
                        message.flagged = true;
                    }
                } else if (""\\Answered"".equalsIgnoreCase(flag)) {
                    if (!message.answered) {
                        properties.put(""answered"", ""102"");
                        message.answered = true;
                    }
                } else if (""$Forwarded"".equalsIgnoreCase(flag)) {
                    if (!message.forwarded) {
                        properties.put(""forwarded"", ""104"");
                        message.forwarded = true;
                    }
                } else if (""Junk"".equalsIgnoreCase(flag)) {
                    if (!message.junk) {
                        properties.put(""junk"", ""1"");
                        message.junk = true;
                    }
                } else {
                    properties.put(""keywords"", message.addFlag(flag));
                }
            }
        } else if (""FLAGS"".equalsIgnoreCase(action) || ""FLAGS.SILENT"".equalsIgnoreCase(action)) {
            // flag list with default values
            boolean read = false;
            boolean deleted = false;
            boolean junk = false;
            boolean flagged = false;
            boolean answered = false;
            boolean forwarded = false;
            HashSet<String> keywords = null;
            // set flags from new flag list
            StringTokenizer flagtokenizer = new StringTokenizer(flags);
            while (flagtokenizer.hasMoreTokens()) {
                String flag = flagtokenizer.nextToken();
                if (""\\Seen"".equalsIgnoreCase(flag)) {
                    read = true;
                } else if (""\\Deleted"".equalsIgnoreCase(flag)) {
                    deleted = true;
                } else if (""\\Flagged"".equalsIgnoreCase(flag)) {
                    flagged = true;
                } else if (""\\Answered"".equalsIgnoreCase(flag)) {
                    answered = true;
                } else if (""$Forwarded"".equalsIgnoreCase(flag)) {
                    forwarded = true;
                } else if (""Junk"".equalsIgnoreCase(flag)) {
                    junk = true;
                } else {
                    if (keywords == null) {
                        keywords = new HashSet<String>();
                    }
                    keywords.add(flag);
                }
            }
            if (keywords != null) {
                properties.put(""keywords"", message.setFlags(keywords));
            }
            if (read != message.read) {
                message.read = read;
                if (message.read) {
                    properties.put(""read"", ""1"");
                } else {
                    properties.put(""read"", ""0"");
                }
            }
            if (deleted != message.deleted) {
                message.deleted = deleted;
                if (message.deleted) {
                    properties.put(""deleted"", ""1"");
                } else {
                    properties.put(""deleted"", null);
                }
            }
            if (flagged != message.flagged) {
                message.flagged = flagged;
                if (message.flagged) {
                    properties.put(""flagged"", ""2"");
                } else {
                    properties.put(""flagged"", ""0"");
                }
            }
            if (answered != message.answered) {
                message.answered = answered;
                if (message.answered) {
                    properties.put(""answered"", ""102"");
                } else if (!forwarded) {
                    // remove property only if not forwarded
                    properties.put(""answered"", null);
                }
            }
            if (forwarded != message.forwarded) {
                message.forwarded = forwarded;
                if (message.forwarded) {
                    properties.put(""forwarded"", ""104"");
                } else if (!answered) {
                    // remove property only if not answered
                    properties.put(""forwarded"", null);
                }
            }
            if (junk != message.junk) {
                message.junk = junk;
                if (message.junk) {
                    properties.put(""junk"", ""1"");
                } else {
                    properties.put(""junk"", ""0"");
                }
            }
        }
        if (!properties.isEmpty()) {
            session.updateMessage(message, properties);
            // message is no longer recent
            message.recent = false;
        }
    }"
davmail-4.5.1,davmail.imap.ImapConnection,parseCredentials,,17,198,186,14,0.0769,0.0303,1,2,4,0,1,"/**
     * Decode IMAP credentials
     *
     * @param tokens tokens
     * @throws IOException on error
     */
    protected void parseCredentials(StringTokenizer tokens) throws IOException {
        if (tokens.hasMoreTokens()) {
            userName = tokens.nextToken();
        } else {
            throw new DavMailException(""EXCEPTION_INVALID_CREDENTIALS"");
        }

        if (tokens.hasMoreTokens()) {
            password = tokens.nextToken();
        } else {
            throw new DavMailException(""EXCEPTION_INVALID_CREDENTIALS"");
        }
        int backslashindex = userName.indexOf('\\');
        if (backslashindex > 0) {
            userName = userName.substring(0, backslashindex) + userName.substring(backslashindex + 1);
        }
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,LdapConnection,,10,26,24,6,0.1528,0.028,1,2,2,0,1,"/**
     * Initialize the streams and start the thread.
     *
     * @param clientSocket LDAP client socket
     */
    public LdapConnection(Socket clientSocket) {
        super(LdapConnection.class.getSimpleName(), clientSocket);
        try {
            is = new BufferedInputStream(client.getInputStream());
            os = new BufferedOutputStream(client.getOutputStream());
        } catch (IOException e) {
            close();
            DavGatewayTray.error(new BundleMessage(""LOG_EXCEPTION_GETTING_SOCKET_STREAMS""), e);
        }
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,run,,107,1392,1131,9,0.078,0.0696,0.555555556,15,18,0,1,"@Override
    public void run() {
        byte[] inbuf = new byte[2048];   // Buffer for reading incoming bytes
        int bytesread;  // Number of bytes in inbuf
        int bytesleft;  // Number of bytes that need to read for completing resp
        int br;         // Temp; number of bytes read from stream
        int offset;     // Offset of where to store bytes in inbuf
        boolean eos;    // End of stream

        try {
            ExchangeSessionFactory.checkConfig();
            while (true) {
                offset = 0;

                // check that it is the beginning of a sequence
                bytesread = is.read(inbuf, offset, 1);
                if (bytesread < 0) {
                    break; // EOF
                }

                if (inbuf[offset++] != (Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR)) {
                    continue;
                }

                // get length of sequence
                bytesread = is.read(inbuf, offset, 1);
                if (bytesread < 0) {
                    break; // EOF
                }
                int seqlen = inbuf[offset++]; // Length of ASN sequence

                // if high bit is on, length is encoded in the
                // subsequent length bytes and the number of length bytes
                // is equal to & 0x80 (i.e. length byte with high bit off).
                if ((seqlen & 0x80) == 0x80) {
                    int seqlenlen = seqlen & 0x7f;  // number of length bytes

                    bytesread = 0;
                    eos = false;

                    // Read all length bytes
                    while (bytesread < seqlenlen) {
                        br = is.read(inbuf, offset + bytesread,
                                seqlenlen - bytesread);
                        if (br < 0) {
                            eos = true;
                            break; // EOF
                        }
                        bytesread += br;
                    }

                    // end-of-stream reached before length bytes are read
                    if (eos) {
                        break;  // EOF
                    }

                    // Add contents of length bytes to determine length
                    seqlen = 0;
                    for (int i = 0; i < seqlenlen; i++) {
                        seqlen = (seqlen << 8) + (inbuf[offset + i] & 0xff);
                    }
                    offset += bytesread;
                }

                // read in seqlen bytes
                bytesleft = seqlen;
                if ((offset + bytesleft) > inbuf.length) {
                    byte[] nbuf = new byte[offset + bytesleft];
                    System.arraycopy(inbuf, 0, nbuf, 0, offset);
                    inbuf = nbuf;
                }
                while (bytesleft > 0) {
                    bytesread = is.read(inbuf, offset, bytesleft);
                    if (bytesread < 0) {
                        break; // EOF
                    }
                    offset += bytesread;
                    bytesleft -= bytesread;
                }

                DavGatewayTray.switchIcon();

                handleRequest(inbuf, offset);
            }

        } catch (SocketException e) {
            DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
        } catch (SocketTimeoutException e) {
            DavGatewayTray.debug(new BundleMessage(""LOG_CLOSE_CONNECTION_ON_TIMEOUT""));
        } catch (Exception e) {
            DavGatewayTray.log(e);
            try {
                sendErr(0, LDAP_REP_BIND, e);
            } catch (IOException e2) {
                DavGatewayTray.warn(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
            }
        } finally {
            // cancel all search threads
            synchronized (searchThreadMap) {
                for (SearchRunnable searchRunnable : searchThreadMap.values()) {
                    searchRunnable.abandon();
                }
            }
            close();
        }
        DavGatewayTray.resetIcon();
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,handleRequest,,169,6252,5483,23,0.0346,0.0418,0.5,30,25,0,1,"protected void handleRequest(byte[] inbuf, int offset) throws IOException {
        //dumpBer(inbuf, offset);
        BerDecoder reqBer = new BerDecoder(inbuf, 0, offset);
        int currentMessageId = 0;
        try {
            reqBer.parseSeq(null);
            currentMessageId = reqBer.parseInt();
            int requestOperation = reqBer.peekByte();

            if (requestOperation == LDAP_REQ_BIND) {
                reqBer.parseSeq(null);
                ldapVersion = reqBer.parseInt();
                userName = reqBer.parseString(isLdapV3());
                if (reqBer.peekByte() == (Ber.ASN_CONTEXT | Ber.ASN_CONSTRUCTOR | 3)) {
                    // SASL authentication
                    reqBer.parseSeq(null);
                    // Get mechanism, usually DIGEST-MD5
                    String mechanism = reqBer.parseString(isLdapV3());

                    byte[] serverResponse;
                    CallbackHandler callbackHandler = new CallbackHandler() {
                        public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
                            // look for username in callbacks
                            for (Callback callback : callbacks) {
                                if (callback instanceof NameCallback) {
                                    userName = ((NameCallback) callback).getDefaultName();
                                    // get password from session pool
                                    password = ExchangeSessionFactory.getUserPassword(userName);
                                }
                            }
                            // handle other callbacks
                            for (Callback callback : callbacks) {
                                if (callback instanceof AuthorizeCallback) {
                                    ((AuthorizeCallback) callback).setAuthorized(true);
                                } else if (callback instanceof PasswordCallback) {
                                    if (password != null) {
                                        ((PasswordCallback) callback).setPassword(password.toCharArray());
                                    }
                                }
                            }
                        }
                    };
                    int status;
                    if (reqBer.bytesLeft() > 0 && saslServer != null) {
                        byte[] clientResponse = reqBer.parseOctetString(Ber.ASN_OCTET_STR, null);
                        serverResponse = saslServer.evaluateResponse(clientResponse);
                        status = LDAP_SUCCESS;

                        DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_USER"", currentMessageId, userName));
                        try {
                            session = ExchangeSessionFactory.getInstance(userName, password);
                            DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_SUCCESS""));
                        } catch (IOException e) {
                            serverResponse = EMPTY_BYTE_ARRAY;
                            status = LDAP_INVALID_CREDENTIALS;
                            DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_INVALID_CREDENTIALS""));
                        }

                    } else {
                        Map<String, String> properties = new HashMap<String, String>();
                        properties.put(""javax.security.sasl.qop"", ""auth,auth-int"");
                        saslServer = Sasl.createSaslServer(mechanism, ""ldap"", client.getLocalAddress().getHostAddress(), properties, callbackHandler);
                        if (saslServer == null) {
                            throw new IOException(""Unable to create SASL server for mechanism ""+mechanism);
                        }
                        serverResponse = saslServer.evaluateResponse(EMPTY_BYTE_ARRAY);
                        status = LDAP_SASL_BIND_IN_PROGRESS;
                    }

                    responseBer.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
                    responseBer.encodeInt(currentMessageId);
                    responseBer.beginSeq(LDAP_REP_BIND);
                    responseBer.encodeInt(status, LBER_ENUMERATED);
                    // server credentials
                    responseBer.encodeString("""", isLdapV3());
                    responseBer.encodeString("""", isLdapV3());
                    // challenge or response
                    if (serverResponse != null) {
                        responseBer.encodeOctetString(serverResponse, 0x87);
                    }
                    responseBer.endSeq();
                    responseBer.endSeq();
                    sendResponse();

                } else {
                    password = reqBer.parseStringWithTag(Ber.ASN_CONTEXT, isLdapV3(), null);

                    if (userName.length() > 0 && password.length() > 0) {
                        DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_USER"", currentMessageId, userName));
                        try {
                            session = ExchangeSessionFactory.getInstance(userName, password);
                            DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_SUCCESS""));
                            sendClient(currentMessageId, LDAP_REP_BIND, LDAP_SUCCESS, """");
                        } catch (IOException e) {
                            DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_INVALID_CREDENTIALS""));
                            sendClient(currentMessageId, LDAP_REP_BIND, LDAP_INVALID_CREDENTIALS, """");
                        }
                    } else {
                        DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_ANONYMOUS"", currentMessageId));
                        // anonymous bind
                        sendClient(currentMessageId, LDAP_REP_BIND, LDAP_SUCCESS, """");
                    }
                }

            } else if (requestOperation == LDAP_REQ_UNBIND) {
                DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_UNBIND"", currentMessageId));
                if (session != null) {
                    session = null;
                }
            } else if (requestOperation == LDAP_REQ_SEARCH) {
                reqBer.parseSeq(null);
                String dn = reqBer.parseString(isLdapV3());
                int scope = reqBer.parseEnumeration();
                /*int derefAliases =*/
                reqBer.parseEnumeration();
                int sizeLimit = reqBer.parseInt();
                if (sizeLimit > 100 || sizeLimit == 0) {
                    sizeLimit = 100;
                }
                int timelimit = reqBer.parseInt();
                /*boolean typesOnly =*/
                reqBer.parseBoolean();
                LdapFilter ldapFilter = parseFilter(reqBer);
                Set<String> returningAttributes = parseReturningAttributes(reqBer);
                SearchRunnable searchRunnable = new SearchRunnable(currentMessageId, dn, scope, sizeLimit, timelimit, ldapFilter, returningAttributes);
                if (BASE_CONTEXT.equalsIgnoreCase(dn) || OD_USER_CONTEXT.equalsIgnoreCase(dn) || OD_USER_CONTEXT_LION.equalsIgnoreCase(dn)) {
                    // launch search in a separate thread
                    synchronized (searchThreadMap) {
                        searchThreadMap.put(currentMessageId, searchRunnable);
                    }
                    Thread searchThread = new Thread(searchRunnable);
                    searchThread.setName(getName() + ""-Search-"" + currentMessageId);
                    searchThread.start();
                } else {
                    // no need to create a separate thread, just run
                    searchRunnable.run();
                }

            } else if (requestOperation == LDAP_REQ_ABANDON) {
                int abandonMessageId = 0;
                try {
                    abandonMessageId = (Integer) PARSE_INT_WITH_TAG_METHOD.invoke(reqBer, LDAP_REQ_ABANDON);
                    synchronized (searchThreadMap) {
                        SearchRunnable searchRunnable = searchThreadMap.get(abandonMessageId);
                        if (searchRunnable != null) {
                            searchRunnable.abandon();
                            searchThreadMap.remove(currentMessageId);
                        }
                    }
                } catch (IllegalAccessException e) {
                    DavGatewayTray.error(e);
                } catch (InvocationTargetException e) {
                    DavGatewayTray.error(e);
                }
                DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_ABANDON_SEARCH"", currentMessageId, abandonMessageId));
            } else {
                DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_UNSUPPORTED_OPERATION"", requestOperation));
                sendClient(currentMessageId, LDAP_REP_RESULT, LDAP_OTHER, ""Unsupported operation"");
            }
        } catch (IOException e) {
            dumpBer(inbuf, offset);
            try {
                sendErr(currentMessageId, LDAP_REP_RESULT, e);
            } catch (IOException e2) {
                DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
            }
            throw e;
        }
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,dumpBer,,10,16,11,3,0.2381,0.0892,0,4,2,0,1,"protected void dumpBer(byte[] inbuf, int offset) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Ber.dumpBER(baos, ""LDAP request buffer\n"", inbuf, 0, offset);
        try {
            LOGGER.debug(new String(baos.toByteArray(), ""UTF-8""));
        } catch (UnsupportedEncodingException e) {
            // should not happen
            LOGGER.error(e);
        }
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,parseFilter,,15,37,19,3,0.2273,0.1127,1,6,2,0,1,"protected LdapFilter parseFilter(BerDecoder reqBer) throws IOException {
        LdapFilter ldapFilter;
        if (reqBer.peekByte() == LDAP_FILTER_PRESENT) {
            String attributeName = reqBer.parseStringWithTag(LDAP_FILTER_PRESENT, isLdapV3(), null).toLowerCase();
            ldapFilter = new SimpleFilter(attributeName);
        } else {
            int[] seqSize = new int[1];
            int ldapFilterType = reqBer.parseSeq(seqSize);
            int end = reqBer.getParsePosition() + seqSize[0];

            ldapFilter = parseNestedFilter(reqBer, ldapFilterType, end);
        }

        return ldapFilter;
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,parseNestedFilter,,25,64,23,3,0.1667,0.1116,1,8,7,0,1,"protected LdapFilter parseNestedFilter(BerDecoder reqBer, int ldapFilterType, int end) throws IOException {
        LdapFilter nestedFilter;

        if ((ldapFilterType == LDAP_FILTER_OR) || (ldapFilterType == LDAP_FILTER_AND)
                || ldapFilterType == LDAP_FILTER_NOT) {
            nestedFilter = new CompoundFilter(ldapFilterType);

            while (reqBer.getParsePosition() < end && reqBer.bytesLeft() > 0) {
                if (reqBer.peekByte() == LDAP_FILTER_PRESENT) {
                    String attributeName = reqBer.parseStringWithTag(LDAP_FILTER_PRESENT, isLdapV3(), null).toLowerCase();
                    nestedFilter.add(new SimpleFilter(attributeName));
                } else {
                    int[] seqSize = new int[1];
                    int ldapFilterOperator = reqBer.parseSeq(seqSize);
                    int subEnd = reqBer.getParsePosition() + seqSize[0];
                    nestedFilter.add(parseNestedFilter(reqBer, ldapFilterOperator, subEnd));
                }
            }
        } else {
            // simple filter
            nestedFilter = parseSimpleFilter(reqBer, ldapFilterType);
        }

        return nestedFilter;
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,parseSimpleFilter,,36,188,123,3,0.1333,0.0885,0.8,8,10,0,1,"protected LdapFilter parseSimpleFilter(BerDecoder reqBer, int ldapFilterOperator) throws IOException {
        String attributeName = reqBer.parseString(isLdapV3()).toLowerCase();
        int ldapFilterMode = 0;

        StringBuilder value = new StringBuilder();
        if (ldapFilterOperator == LDAP_FILTER_SUBSTRINGS) {
            // Thunderbird sends values with space as separate strings, rebuild value
            int[] seqSize = new int[1];
            /*LBER_SEQUENCE*/
            reqBer.parseSeq(seqSize);
            int end = reqBer.getParsePosition() + seqSize[0];
            while (reqBer.getParsePosition() < end && reqBer.bytesLeft() > 0) {
                ldapFilterMode = reqBer.peekByte();
                if (value.length() > 0) {
                    value.append(' ');
                }
                value.append(reqBer.parseStringWithTag(ldapFilterMode, isLdapV3(), null));
            }
        } else if (ldapFilterOperator == LDAP_FILTER_EQUALITY) {
            value.append(reqBer.parseString(isLdapV3()));
        } else {
            DavGatewayTray.warn(new BundleMessage(""LOG_LDAP_UNSUPPORTED_FILTER_VALUE""));
        }

        String sValue = value.toString();

        if (""uid"".equalsIgnoreCase(attributeName) && sValue.equals(userName)) {
            // replace with actual alias instead of login name search, only in Dav mode
            if (sValue.equals(userName) && session instanceof DavExchangeSession) {
                sValue = session.getAlias();
                DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REPLACED_UID_FILTER"", userName, sValue));
            }
        }

        return new SimpleFilter(attributeName, sValue, ldapFilterOperator, ldapFilterMode);
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,parseReturningAttributes,,10,26,16,3,0.3056,0.1476,0,4,3,0,1,"protected Set<String> parseReturningAttributes(BerDecoder reqBer) throws IOException {
        Set<String> returningAttributes = new HashSet<String>();
        int[] seqSize = new int[1];
        reqBer.parseSeq(seqSize);
        int end = reqBer.getParsePosition() + seqSize[0];
        while (reqBer.getParsePosition() < end && reqBer.bytesLeft() > 0) {
            returningAttributes.add(reqBer.parseString(isLdapV3()).toLowerCase());
        }
        return returningAttributes;
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,sendRootDSE,,10,22,16,5,0.2188,0.1333,1,2,1,0,1,"/**
     * Send Root DSE
     *
     * @param currentMessageId current message id
     * @throws IOException on error
     */
    protected void sendRootDSE(int currentMessageId) throws IOException {
        DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_SEND_ROOT_DSE""));

        Map<String, Object> attributes = new HashMap<String, Object>();
        attributes.put(""objectClass"", ""top"");
        attributes.put(""namingContexts"", NAMING_CONTEXTS);
        //attributes.put(""supportedsaslmechanisms"", ""PLAIN"");

        sendEntry(currentMessageId, ""Root DSE"", attributes);
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,sendComputerContext,,18,61,17,3,0.2381,0.2224,1,5,1,0,1,"/**
     * Send ComputerContext
     *
     * @param currentMessageId    current message id
     * @param returningAttributes attributes to return
     * @throws IOException on error
     */
    protected void sendComputerContext(int currentMessageId, Set<String> returningAttributes) throws IOException {
        List<String> objectClasses = new ArrayList<String>();
        objectClasses.add(""top"");
        objectClasses.add(""apple-computer"");
        Map<String, Object> attributes = new HashMap<String, Object>();
        addIf(attributes, returningAttributes, ""objectClass"", objectClasses);
        addIf(attributes, returningAttributes, ""apple-generateduid"", COMPUTER_GUID);
        addIf(attributes, returningAttributes, ""apple-serviceinfo"", getServiceInfo());
        // TODO: remove ?
        addIf(attributes, returningAttributes, ""apple-xmlplist"", getServiceInfo());
        addIf(attributes, returningAttributes, ""apple-serviceslocator"", ""::anyService"");
        addIf(attributes, returningAttributes, ""cn"", getCurrentHostName());

        String dn = ""cn="" + getCurrentHostName() + "", "" + COMPUTER_CONTEXT;
        DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_SEND_COMPUTER_CONTEXT"", dn, attributes));

        sendEntry(currentMessageId, dn, attributes);
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,sendBaseContext,,9,24,12,3,0.2444,0.1905,1,3,1,0,1,"/**
     * Send Base Context
     *
     * @param currentMessageId current message id
     * @throws IOException on error
     */
    protected void sendBaseContext(int currentMessageId) throws IOException {
        List<String> objectClasses = new ArrayList<String>();
        objectClasses.add(""top"");
        objectClasses.add(""organizationalUnit"");
        Map<String, Object> attributes = new HashMap<String, Object>();
        attributes.put(""objectClass"", objectClasses);
        attributes.put(""description"", ""DavMail Gateway LDAP for "" + Settings.getProperty(""davmail.url""));
        sendEntry(currentMessageId, BASE_CONTEXT, attributes);
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,sendEntry,,32,126,0,3,0.1417,0.3018,1,6,5,0,1,"protected void sendEntry(int currentMessageId, String dn, Map<String, Object> attributes) throws IOException {
        // synchronize on responseBer
        synchronized (responseBer) {
            responseBer.reset();
            responseBer.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
            responseBer.encodeInt(currentMessageId);
            responseBer.beginSeq(LDAP_REP_SEARCH);
            responseBer.encodeString(dn, isLdapV3());
            responseBer.beginSeq(LBER_SEQUENCE);
            for (Map.Entry<String, Object> entry : attributes.entrySet()) {
                responseBer.beginSeq(LBER_SEQUENCE);
                responseBer.encodeString(entry.getKey(), isLdapV3());
                responseBer.beginSeq(LBER_SET);
                Object values = entry.getValue();
                if (values instanceof String) {
                    responseBer.encodeString((String) values, isLdapV3());
                } else if (values instanceof List) {
                    for (Object value : (Iterable) values) {
                        responseBer.encodeString((String) value, isLdapV3());
                    }
                } else {
                    throw new DavMailException(""EXCEPTION_UNSUPPORTED_VALUE"", values);
                }
                responseBer.endSeq();
                responseBer.endSeq();
            }
            responseBer.endSeq();
            responseBer.endSeq();
            responseBer.endSeq();
            sendResponse();
        }
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,sendErr,,7,9,3,3,0.3,0.1893,0,4,2,0,1,"protected void sendErr(int currentMessageId, int responseOperation, Exception e) throws IOException {
        String message = e.getMessage();
        if (message == null) {
            message = e.toString();
        }
        sendClient(currentMessageId, responseOperation, LDAP_OTHER, message);
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,sendClient,,15,30,0,4,0.1944,0.332,0,4,1,0,1,"protected void sendClient(int currentMessageId, int responseOperation, int status, String message) throws IOException {
        responseBer.reset();

        responseBer.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
        responseBer.encodeInt(currentMessageId);
        responseBer.beginSeq(responseOperation);
        responseBer.encodeInt(status, LBER_ENUMERATED);
        // dn
        responseBer.encodeString("""", isLdapV3());
        // error message
        responseBer.encodeString(message, isLdapV3());
        responseBer.endSeq();
        responseBer.endSeq();
        sendResponse();
    }"
davmail-4.5.1,davmail.ldap.LdapConnection,convertLdapToContactReturningAttributes,,17,188,166,12,0.0873,0.0733,0,4,5,0,1,"protected Set<String> convertLdapToContactReturningAttributes(Set<String> returningAttributes) {
        Set<String> contactReturningAttributes;
        if (returningAttributes != null && !returningAttributes.isEmpty()) {
            contactReturningAttributes = new HashSet<String>();
            // always return uid
            contactReturningAttributes.add(""imapUid"");
            for (String attribute : returningAttributes) {
                String contactAttributeName = getContactAttributeName(attribute);
                if (contactAttributeName != null) {
                    contactReturningAttributes.add(contactAttributeName);
                }
            }
        } else {
            contactReturningAttributes = ExchangeSession.CONTACT_ATTRIBUTES;
        }
        return contactReturningAttributes;
    }"
davmail-4.5.1,davmail.pop.PopConnection,printList,,7,14,13,4,0.2083,0.0278,1,2,2,0,1,"protected void printList() throws IOException {
        int i = 1;
        for (ExchangeSession.Message message : messages) {
            sendClient(i++ + "" "" + message.size);
        }
        sendClient(""."");
    }"
davmail-4.5.1,davmail.pop.PopConnection,printUidList,,7,14,13,4,0.2083,0.0278,1,2,2,0,1,"protected void printUidList() throws IOException {
        int i = 1;
        for (ExchangeSession.Message message : messages) {
            sendClient(i++ + "" "" + message.getUid());
        }
        sendClient(""."");
    }"
davmail-4.5.1,davmail.pop.PopConnection,run,,200,7963,7015,9,0.0369,0.0601,0.5,33,43,0,1,"@Override
    public void run() {
        String line;
        StringTokenizer tokens;

        try {
            ExchangeSessionFactory.checkConfig();
            sendOK(""DavMail "" + DavGateway.getCurrentVersion() + "" POP ready at "" + new Date());

            for (; ;) {
                line = readClient();
                // unable to read line, connection closed ?
                if (line == null) {
                    break;
                }

                tokens = new StringTokenizer(line);
                if (tokens.hasMoreTokens()) {
                    String command = tokens.nextToken();

                    if (""QUIT"".equalsIgnoreCase(command)) {
                        // delete messages before quit
                        if (session != null) {
                            session.purgeOldestTrashAndSentMessages();
                        }
                        sendOK(""Bye"");
                        break;
                    } else if (""USER"".equalsIgnoreCase(command)) {
                        userName = null;
                        password = null;
                        session = null;
                        if (tokens.hasMoreTokens()) {
                            userName = line.substring(""USER "".length());
                            sendOK(""USER : "" + userName);
                            state = State.USER;
                        } else {
                            sendERR(""invalid syntax"");
                            state = State.INITIAL;
                        }
                    } else if (""PASS"".equalsIgnoreCase(command)) {
                        if (state != State.USER) {
                            sendERR(""invalid state"");
                            state = State.INITIAL;
                        } else if (!tokens.hasMoreTokens()) {
                            sendERR(""invalid syntax"");
                        } else {
                            // bug 2194492 : allow space in password
                            password = line.substring(""PASS"".length() + 1);
                            try {
                                session = ExchangeSessionFactory.getInstance(userName, password);
                                sendOK(""PASS"");
                                state = State.AUTHENTICATED;
                            } catch (SocketException e) {
                                // can not send error to client after a socket exception
                                LOGGER.warn(BundleMessage.formatLog(""LOG_CLIENT_CLOSED_CONNECTION""));
                            } catch (Exception e) {
                                DavGatewayTray.error(e);
                                sendERR(e);
                            }
                        }
                    } else if (""CAPA"".equalsIgnoreCase(command)) {
                        sendOK(""Capability list follows"");
                        printCapabilities();
                    } else if (state != State.AUTHENTICATED) {
                        sendERR(""Invalid state not authenticated"");
                    } else {
                        // load messages (once)
                        if (messages == null) {
                            messages = session.getAllMessageUidAndSize(""INBOX"");
                        }
                        if (""STAT"".equalsIgnoreCase(command)) {
                            sendOK(messages.size() + "" "" +
                                    getTotalMessagesLength());
                        } else if (""NOOP"".equalsIgnoreCase(command)) {
                            sendOK("""");
                        } else if (""LIST"".equalsIgnoreCase(command)) {
                            if (tokens.hasMoreTokens()) {
                                String token = tokens.nextToken();
                                try {
                                    int messageNumber = Integer.valueOf(token);
                                    ExchangeSession.Message message = messages.get(messageNumber - 1);
                                    sendOK("""" + messageNumber + ' ' + message.size);
                                } catch (NumberFormatException e) {
                                    sendERR(""Invalid message index: "" + token);
                                } catch (IndexOutOfBoundsException e) {
                                    sendERR(""Invalid message index: "" + token);
                                }
                            } else {
                                sendOK(messages.size() +
                                        "" messages ("" + getTotalMessagesLength() +
                                        "" octets)"");
                                printList();
                            }
                        } else if (""UIDL"".equalsIgnoreCase(command)) {
                            if (tokens.hasMoreTokens()) {
                                String token = tokens.nextToken();
                                try {
                                    int messageNumber = Integer.valueOf(token);
                                    sendOK(messageNumber + "" "" + messages.get(messageNumber - 1).getUid());
                                } catch (NumberFormatException e) {
                                    sendERR(""Invalid message index: "" + token);
                                } catch (IndexOutOfBoundsException e) {
                                    sendERR(""Invalid message index: "" + token);
                                }
                            } else {
                                sendOK(messages.size() +
                                        "" messages ("" + getTotalMessagesLength() +
                                        "" octets)"");
                                printUidList();
                            }
                        } else if (""RETR"".equalsIgnoreCase(command)) {
                            if (tokens.hasMoreTokens()) {
                                try {
                                    int messageNumber = Integer.valueOf(tokens.nextToken()) - 1;
                                    ExchangeSession.Message message = messages.get(messageNumber);

                                    // load big messages in a separate thread
                                    os.write(""+OK "".getBytes(""ASCII""));
                                    os.flush();
                                    MessageLoadThread.loadMimeMessage(message, os);
                                    sendClient("""");

                                    DoubleDotOutputStream doubleDotOutputStream = new DoubleDotOutputStream(os);
                                    IOUtil.write(message.getRawInputStream(), doubleDotOutputStream);
                                    doubleDotOutputStream.close();
                                    if (Settings.getBooleanProperty(""davmail.popMarkReadOnRetr"")) {
                                        message.markRead();
                                    }
                                } catch (SocketException e) {
                                    // can not send error to client after a socket exception
                                    LOGGER.warn(BundleMessage.formatLog(""LOG_CLIENT_CLOSED_CONNECTION""));
                                } catch (Exception e) {
                                    DavGatewayTray.error(new BundleMessage(""LOG_ERROR_RETRIEVING_MESSAGE""), e);
                                    sendERR(""error retrieving message "" + e + ' ' + e.getMessage());
                                }
                            } else {
                                sendERR(""invalid message index"");
                            }
                        } else if (""DELE"".equalsIgnoreCase(command)) {
                            if (tokens.hasMoreTokens()) {
                                ExchangeSession.Message message;
                                try {
                                    int messageNumber = Integer.valueOf(tokens.
                                            nextToken()) - 1;
                                    message = messages.get(messageNumber);
                                    message.moveToTrash();
                                    sendOK(""DELETE"");
                                } catch (NumberFormatException e) {
                                    sendERR(""invalid message index"");
                                } catch (IndexOutOfBoundsException e) {
                                    sendERR(""invalid message index"");
                                }
                            } else {
                                sendERR(""invalid message index"");
                            }
                        } else if (""TOP"".equalsIgnoreCase(command)) {
                            int message = 0;
                            try {
                                message = Integer.valueOf(tokens.nextToken());
                                int lines = Integer.valueOf(tokens.nextToken());
                                ExchangeSession.Message m = messages.get(message - 1);
                                sendOK("""");
                                DoubleDotOutputStream doubleDotOutputStream = new DoubleDotOutputStream(os);
                                IOUtil.write(m.getRawInputStream(), new TopOutputStream(doubleDotOutputStream, lines));
                                doubleDotOutputStream.close();
                            } catch (NumberFormatException e) {
                                sendERR(""invalid command"");
                            } catch (IndexOutOfBoundsException e) {
                                sendERR(""invalid message index: "" + message);
                            } catch (Exception e) {
                                sendERR(""error retreiving top of messages"");
                                DavGatewayTray.error(e);
                            }
                        } else if (""RSET"".equalsIgnoreCase(command)) {
                            sendOK(""RSET"");
                        } else {
                            sendERR(""unknown command"");
                        }
                    }

                } else {
                    sendERR(""unknown command"");
                }

                os.flush();
            }
        } catch (SocketException e) {
            DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
        } catch (Exception e) {
            DavGatewayTray.log(e);
            try {
                sendERR(e.getMessage());
            } catch (IOException e2) {
                DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
            }
        } finally {
            close();
        }
        DavGatewayTray.resetIcon();
    }"
davmail-4.5.1,davmail.pop.PopConnection,sendERR,,7,9,3,3,0.5,0.2857,0,2,2,0,1,"protected void sendERR(Exception e) throws IOException {
        String message = e.getMessage();
        if (message == null) {
            message = e.toString();
        }
        sendERR(message);
    }"
davmail-4.5.1,davmail.service.DavService,serviceRequest,,11,15,15,6,0.1667,0,1,1,3,0,1,"/**
     * Perform a service request.
     *
     * @param control service control.
     * @return return code.
     * @throws ServiceException on error.
     */
    @Override
    public int serviceRequest(int control) throws ServiceException {
        switch (control) {
            case SERVICE_CONTROL_STOP:
            case SERVICE_CONTROL_SHUTDOWN:
                DavGatewayTray.debug(new BundleMessage(""LOG_STOPPING_DAVMAIL""));
                DavGateway.stop();
                stopped = true;
        }
        return 0;
    }"
davmail-4.5.1,davmail.service.DavService,serviceMain,,31,264,252,18,0.0917,0.0514,0.444444444,3,3,0,1,"/**
     * Run the service.
     *
     * @param args command line arguments
     * @return return code
     * @throws ServiceException on error
     */
    public int serviceMain(String[] args) throws ServiceException {
        if (args.length >= 1) {
            Settings.setConfigFilePath(args[0]);
        }

        Settings.load();
        if (!Settings.getBooleanProperty(""davmail.server"")) {
            Settings.setProperty(""davmail.server"", ""true"");
            Settings.updateLoggingConfig();
        }

        DavGateway.start();
        DavGatewayTray.debug(new BundleMessage(""LOG_DAVMAIL_STARTED""));

        // launch a non daemon thread
        Thread shutdownListenerThread = new Thread(""ShutDownListener"") {
            public void run() {
                try {
                    while (!stopped) {
                        Thread.sleep(1000);
                    }
                } catch (InterruptedException e) {
                    DavGatewayTray.debug(new BundleMessage(""LOG_GATEWAY_INTERRUPTED""));
                    DavGateway.stop();
                    DavGatewayTray.debug(new BundleMessage(""LOG_GATEWAY_STOP""));
                }
            }
        };
        shutdownListenerThread.start();
        return 0;
    }"
davmail-4.5.1,davmail.smtp.SmtpConnection,run,,158,3742,3298,9,0.0418,0.069,0.5625,15,37,0,1,"@Override
    public void run() {
        String line;
        StringTokenizer tokens;
        List<String> recipients = new ArrayList<String>();

        try {
            ExchangeSessionFactory.checkConfig();
            sendClient(""220 DavMail "" + DavGateway.getCurrentVersion() + "" SMTP ready at "" + new Date());
            for (; ;) {
                line = readClient();
                // unable to read line, connection closed ?
                if (line == null) {
                    break;
                }

                tokens = new StringTokenizer(line);
                if (tokens.hasMoreTokens()) {
                    String command = tokens.nextToken();

                    if (state == State.LOGIN) {
                        // AUTH LOGIN, read userName
                        userName = IOUtil.decodeBase64AsString(line);
                        sendClient(""334 "" + IOUtil.encodeBase64AsString(""Password:""));
                        state = State.PASSWORD;
                    } else if (state == State.PASSWORD) {
                        // AUTH LOGIN, read password
                        password = IOUtil.decodeBase64AsString(line);
                        authenticate();
                    } else if (""QUIT"".equalsIgnoreCase(command)) {
                        sendClient(""221 Closing connection"");
                        break;
                    } else if (""NOOP"".equalsIgnoreCase(command)) {
                        sendClient(""250 OK"");
                    } else if (""EHLO"".equalsIgnoreCase(command)) {
                        sendClient(""250-"" + tokens.nextToken());
                        // inform server that AUTH is supported
                        // actually it is mandatory (only way to get credentials)
                        sendClient(""250-AUTH LOGIN PLAIN"");
                        sendClient(""250-8BITMIME"");
                        sendClient(""250 Hello"");
                    } else if (""HELO"".equalsIgnoreCase(command)) {
                        sendClient(""250 Hello"");
                    } else if (""AUTH"".equalsIgnoreCase(command)) {
                        if (tokens.hasMoreElements()) {
                            String authType = tokens.nextToken();
                            if (""PLAIN"".equalsIgnoreCase(authType) && tokens.hasMoreElements()) {
                                decodeCredentials(tokens.nextToken());
                                authenticate();
                            } else if (""LOGIN"".equalsIgnoreCase(authType)) {
                                if (tokens.hasMoreTokens()) {
                                    // user name sent on auth line
                                    userName = IOUtil.decodeBase64AsString(tokens.nextToken());
                                    sendClient(""334 "" + IOUtil.encodeBase64AsString(""Password:""));
                                    state = State.PASSWORD;
                                } else {
                                    sendClient(""334 "" + IOUtil.encodeBase64AsString(""Username:""));
                                    state = State.LOGIN;
                                }
                            } else {
                                sendClient(""451 Error : unknown authentication type"");
                            }
                        } else {
                            sendClient(""451 Error : authentication type not specified"");
                        }
                    } else if (""MAIL"".equalsIgnoreCase(command)) {
                        if (state == State.AUTHENTICATED) {
                            state = State.STARTMAIL;
                            recipients.clear();
                            sendClient(""250 Sender OK"");
                        } else if (state == State.INITIAL) {
                            sendClient(""503 Authentication required"");
                        } else {
                            state = State.INITIAL;
                            sendClient(""503 Bad sequence of commands"");
                        }
                    } else if (""RCPT"".equalsIgnoreCase(command)) {
                        if (state == State.STARTMAIL || state == State.RECIPIENT) {
                            if (line.toUpperCase().startsWith(""RCPT TO:"")) {
                                state = State.RECIPIENT;
                                try {
                                    InternetAddress internetAddress = new InternetAddress(line.substring(""RCPT TO:"".length()));
                                    recipients.add(internetAddress.getAddress());
                                } catch (AddressException e) {
                                    throw new DavMailException(""EXCEPTION_INVALID_RECIPIENT"", line);
                                }
                                sendClient(""250 Recipient OK"");
                            } else {
                                sendClient(""500 Unrecognized command"");
                            }

                        } else {
                            state = State.AUTHENTICATED;
                            sendClient(""503 Bad sequence of commands"");
                        }
                    } else if (""DATA"".equalsIgnoreCase(command)) {
                        if (state == State.RECIPIENT) {
                            state = State.MAILDATA;
                            sendClient(""354 Start mail input; end with <CRLF>.<CRLF>"");

                            try {
                                // read message in buffer
                                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                                DoubleDotInputStream doubleDotInputStream = new DoubleDotInputStream(in);
                                int b;
                                while ((b = doubleDotInputStream.read()) >= 0) {
                                    baos.write(b);
                                }
                                MimeMessage mimeMessage = new MimeMessage(null, new SharedByteArrayInputStream(baos.toByteArray()));
                                session.sendMessage(recipients, mimeMessage);
                                state = State.AUTHENTICATED;
                                sendClient(""250 Queued mail for delivery"");
                            } catch (Exception e) {
                                DavGatewayTray.error(e);
                                state = State.AUTHENTICATED;
                                sendClient(""451 Error : "" + e + ' ' + e.getMessage());
                            }

                        } else {
                            state = State.AUTHENTICATED;
                            sendClient(""503 Bad sequence of commands"");
                        }
                    } else if (""RSET"".equalsIgnoreCase(command)) {
                        recipients.clear();

                        if (state == State.STARTMAIL ||
                                state == State.RECIPIENT ||
                                state == State.MAILDATA ||
                                state == State.AUTHENTICATED) {
                            state = State.AUTHENTICATED;
                        } else {
                            state = State.INITIAL;
                        }
                        sendClient(""250 OK Reset"");
                    } else {
                        sendClient(""500 Unrecognized command"");
                    }
                } else {
                    sendClient(""500 Unrecognized command"");
                }

                os.flush();
            }

        } catch (SocketException e) {
            DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
        } catch (Exception e) {
            DavGatewayTray.log(e);
            try {
                sendClient(""500 "" + ((e.getMessage() == null) ? e : e.getMessage()));
            } catch (IOException e2) {
                DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
            }
        } finally {
            close();
        }
        DavGatewayTray.resetIcon();
    }"
davmail-4.5.1,davmail.smtp.SmtpConnection,authenticate,,17,50,34,4,0.1667,0.1564,1,2,3,0,1,"/**
     * Create authenticated session with Exchange server
     *
     * @throws IOException on error
     */
    protected void authenticate() throws IOException {
        try {
            session = ExchangeSessionFactory.getInstance(userName, password);
            sendClient(""235 OK Authenticated"");
            state = State.AUTHENTICATED;
        } catch (Exception e) {
            DavGatewayTray.error(e);
            String message = e.getMessage();
            if (message == null) {
                message = e.toString();
            }
            message = message.replaceAll(""\\n"", "" "");
            sendClient(""554 Authenticated failed "" + message);
            state = State.INITIAL;
        }

    }"
davmail-4.5.1,davmail.smtp.SmtpConnection,decodeCredentials,,15,37,19,5,0.2091,0.1117,1,4,3,0,1,"/**
     * Decode SMTP credentials
     *
     * @param encodedCredentials smtp encoded credentials
     * @throws IOException if invalid credentials
     */
    protected void decodeCredentials(String encodedCredentials) throws IOException {
        String decodedCredentials = IOUtil.decodeBase64AsString(encodedCredentials);
        int startIndex = decodedCredentials.indexOf((char) 0);
        if (startIndex >=0) {
            int endIndex = decodedCredentials.indexOf((char) 0, startIndex+1);
            if (endIndex >=0) {
                userName = decodedCredentials.substring(startIndex+1, endIndex);
                password = decodedCredentials.substring(endIndex + 1);
            } else {
                throw new DavMailException(""EXCEPTION_INVALID_CREDENTIALS"");
            }
        } else {
            throw new DavMailException(""EXCEPTION_INVALID_CREDENTIALS"");
        }
    }"
davmail-4.5.1,davmail.ui.NotificationDialog,addRecipientComponent,,16,74,43,3,0.1905,0.141,0,6,2,0,1,"protected void addRecipientComponent(JPanel panel, String label, JTextField textField, String toolTipText) {
        JLabel fieldLabel = new JLabel(label);
        fieldLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        fieldLabel.setVerticalAlignment(SwingConstants.CENTER);
        textField.setMaximumSize(textField.getPreferredSize());
        JPanel innerPanel = new JPanel();
        innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.X_AXIS));
        innerPanel.setAlignmentX(Component.RIGHT_ALIGNMENT);
        innerPanel.add(fieldLabel);
        innerPanel.add(textField);
        panel.add(innerPanel);
        if (toolTipText != null) {
            fieldLabel.setToolTipText(toolTipText);
            textField.setToolTipText(toolTipText);
        }
    }"
davmail-4.5.1,davmail.ui.NotificationDialog,NotificationDialog,,72,51,47,8,0.1364,0.0476,0.6,18,5,0,1,"/**
     * Notification dialog to let user edit message body or cancel notification.
     *
     * @param to      main recipients
     * @param cc      copy recipients
     * @param subject notification subject
     * @param description notification description
     */
    public NotificationDialog(String to, String cc, String subject, String description) {
        setModal(true);
        setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
        setTitle(BundleMessage.format(""UI_CALDAV_NOTIFICATION""));
        try {
            setIconImage(DavGatewayTray.getFrameIcon());
        } catch (NoSuchMethodError error) {
            DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
        }

        JPanel mainPanel = new JPanel();
        // add help (F1 handler)
        mainPanel.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(""F1""),
                ""help"");
        mainPanel.getActionMap().put(""help"", new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                DesktopBrowser.browse(""http://davmail.sourceforge.net"");
            }
        });

        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.add(getRecipientsPanel());
        mainPanel.add(getBodyPanel(description));

        JPanel recipientsPanel = getRecipientsPanel();
        if (to != null) {
            toField.setText(to);
        }
        if (cc != null) {
            ccField.setText(cc);
        }
        if (subject != null) {
            subjectField.setText(subject);
        }
        add(BorderLayout.NORTH, recipientsPanel);
        JPanel bodyPanel = getBodyPanel(description);
        add(BorderLayout.CENTER, bodyPanel);
        bodyField.setPreferredSize(recipientsPanel.getPreferredSize());

        JPanel buttonPanel = new JPanel();
        JButton cancel = new JButton(BundleMessage.format(""UI_BUTTON_CANCEL""));
        JButton send = new JButton(BundleMessage.format(""UI_BUTTON_SEND""));

        send.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                sendNotification = true;
                setVisible(false);
            }
        });

        cancel.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                // nothing to do, just hide
                setVisible(false);
            }
        });

        buttonPanel.add(send);
        buttonPanel.add(cancel);

        add(BorderLayout.SOUTH, buttonPanel);

        pack();
        setResizable(true);
        // center frame
        setLocation(getToolkit().getScreenSize().width / 2 -
                getSize().width / 2,
                getToolkit().getScreenSize().height / 2 -
                        getSize().height / 2);
	setAlwaysOnTop(true);
        setVisible(true);
    }"
davmail-4.5.1,davmail.ui.OSXInfoPlist,isHideFromDock,,9,17,13,4,0.2857,0.175,0,2,3,0,1,"/**
     * Test current LSUIElement (hide from dock) value
     *
     * @return true if application is hidden from dock
     */
    public static boolean isHideFromDock() {
        boolean result = false;
        try {
            result = isOSX() && getInfoPlistContent().contains(""<key>LSUIElement</key><string>1</string>"");
        } catch (IOException e) {
            LOGGER.warn(""Unable to update Info.plist"", e);
        }
        return result;
    }"
davmail-4.5.1,davmail.ui.CredentialPromptDialog,CredentialPromptDialog,,60,83,75,8,0.119,0.0492,0.5,12,2,0,1,"/**
     * Get credentials.
     *
     * @param prompt Kerberos prompt from callback handler
     */
    public CredentialPromptDialog(String prompt) {
        setAlwaysOnTop(true);

        setTitle(BundleMessage.format(""UI_KERBEROS_CREDENTIAL_PROMPT""));

        try {
            //noinspection Since15
            setIconImage(DavGatewayTray.getFrameIcon());
        } catch (NoSuchMethodError error) {
            DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
        }


        JPanel questionPanel = new JPanel();
        questionPanel.setLayout(new BoxLayout(questionPanel, BoxLayout.Y_AXIS));
        JLabel imageLabel = new JLabel();
        imageLabel.setIcon(UIManager.getIcon(""OptionPane.questionIcon""));
        questionPanel.add(imageLabel);

        passwordField.setMaximumSize(passwordField.getPreferredSize());
        passwordField.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                principal = principalField.getText();
                password = passwordField.getPassword();
                setVisible(false);
            }
        });
        JPanel credentialPanel = new JPanel(new GridLayout(2, 2));

        JLabel promptLabel = new JLabel(' ' +prompt.trim());
        promptLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        promptLabel.setVerticalAlignment(SwingConstants.CENTER);

        credentialPanel.add(promptLabel);

        principalField.setMaximumSize(principalField.getPreferredSize());
        credentialPanel.add(principalField);

        JLabel passwordLabel = new JLabel(BundleMessage.format(""UI_KERBEROS_PASSWORD_PROMPT""));
        passwordLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        passwordLabel.setVerticalAlignment(SwingConstants.CENTER);
        credentialPanel.add(passwordLabel);

        passwordField.setMaximumSize(passwordField.getPreferredSize());
        credentialPanel.add(passwordField);

        add(questionPanel, BorderLayout.WEST);
        add(credentialPanel, BorderLayout.CENTER);
        add(getButtonPanel(), BorderLayout.SOUTH);
        setModal(true);

        pack();
        // center frame
        setLocation(getToolkit().getScreenSize().width / 2 -
                getSize().width / 2,
                getToolkit().getScreenSize().height / 2 -
                        getSize().height / 2);
        setAlwaysOnTop(true);
        setVisible(true);
    }"
davmail-4.5.1,davmail.ui.PasswordPromptDialog,PasswordPromptDialog,,50,94,83,8,0.1133,0.0539,0.5,12,3,0,1,"/**
     * Get smartcard password.
     *
     * @param prompt password prompt from PKCS11 module
     * @param captchaImage ISA filter pinsafe image
     */
    public PasswordPromptDialog(String prompt, Image captchaImage) {
        setAlwaysOnTop(true);

        setTitle(BundleMessage.format(""UI_PASSWORD_PROMPT""));
        try {
            //noinspection Since15
            setIconImage(DavGatewayTray.getFrameIcon());
        } catch (NoSuchMethodError error) {
            DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
        }


        JPanel questionPanel = new JPanel();
        questionPanel.setLayout(new BoxLayout(questionPanel, BoxLayout.Y_AXIS));
        JLabel imageLabel = new JLabel();
        imageLabel.setIcon(UIManager.getIcon(""OptionPane.questionIcon""));
        imageLabel.setText(prompt);
        questionPanel.add(imageLabel);

        passwordField.setMaximumSize(passwordField.getPreferredSize());
        passwordField.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                password = passwordField.getPassword();
                setVisible(false);
            }
        });
        JPanel passwordPanel = new JPanel();
        passwordPanel.setLayout(new BoxLayout(passwordPanel, BoxLayout.Y_AXIS));
        if (captchaImage != null) {
            JLabel captchaLabel = new JLabel(new ImageIcon(captchaImage));
            captchaLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            captchaLabel.setBorder(new EmptyBorder(10,10,10,10));
            passwordPanel.add(captchaLabel);
        }
        passwordPanel.add(passwordField);

        add(questionPanel, BorderLayout.NORTH);
        add(passwordPanel, BorderLayout.CENTER);
        add(getButtonPanel(), BorderLayout.SOUTH);
        setModal(true);

        pack();
        // center frame
        setLocation(getToolkit().getScreenSize().width / 2 -
                getSize().width / 2,
                getToolkit().getScreenSize().height / 2 -
                        getSize().height / 2);
	setAlwaysOnTop(true);
        setVisible(true);
    }"
davmail-4.5.1,davmail.ui.SelectCertificateDialog,SelectCertificateDialog,,38,300,275,10,0.0828,0.0367,0.5,9,2,0,1,"/**
     * Select a client certificate
     *
     * @param aliases An array of certificate aliases for the user to pick from
     */
    public SelectCertificateDialog(String[] aliases) {
        setAlwaysOnTop(true);

        setTitle(BundleMessage.format(""UI_CERTIFICATE_ALIAS_PROMPT""));
        try {
            setIconImage(DavGatewayTray.getFrameIcon());
        } catch (NoSuchMethodError error) {
            DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
        }

        JPanel questionPanel = new JPanel();
        questionPanel.setLayout(new BoxLayout(questionPanel, BoxLayout.Y_AXIS));
        JLabel imageLabel = new JLabel();
        imageLabel.setIcon(UIManager.getIcon(""OptionPane.questionIcon""));
        imageLabel.setText(BundleMessage.format(""UI_CERTIFICATE_ALIAS_PROMPT""));
        questionPanel.add(imageLabel);

        aliasListBox = new JList(aliases);
        aliasListBox.setMaximumSize(aliasListBox.getPreferredSize());

        JPanel aliasPanel = new JPanel();
        aliasPanel.setLayout(new BoxLayout(aliasPanel, BoxLayout.Y_AXIS));
        aliasPanel.add(aliasListBox);

        add(questionPanel, BorderLayout.NORTH);
        add(aliasPanel, BorderLayout.CENTER);
        add(getButtonPanel(), BorderLayout.SOUTH);
        setModal(true);

        pack();
        // center frame
        setLocation(getToolkit().getScreenSize().width / 2 -
                getSize().width / 2,
                getToolkit().getScreenSize().height / 2 -
                        getSize().height / 2);
	setAlwaysOnTop(true);
        setVisible(true);
    }"
davmail-4.5.1,davmail.ui.SettingsFrame,addSettingComponent,,15,68,45,3,0.1939,0.1167,0,6,2,0,1,"protected void addSettingComponent(JPanel panel, String label, JComponent component, String toolTipText) {
        JLabel fieldLabel = new JLabel(label);
        fieldLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        fieldLabel.setVerticalAlignment(SwingConstants.CENTER);
        panel.add(fieldLabel);
        component.setMaximumSize(component.getPreferredSize());
        JPanel innerPanel = new JPanel();
        innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.X_AXIS));
        innerPanel.add(component);
        panel.add(innerPanel);
        if (toolTipText != null) {
            fieldLabel.setToolTipText(toolTipText);
            component.setToolTipText(toolTipText);
        }
    }"
davmail-4.5.1,davmail.ui.SettingsFrame,addPortSettingComponent,,17,88,56,3,0.1597,0.1162,0,8,2,0,1,"protected void addPortSettingComponent(JPanel panel, String label, JComponent component, JComponent checkboxComponent, JComponent checkboxSSLComponent, String toolTipText) {
        JLabel fieldLabel = new JLabel(label);
        fieldLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        fieldLabel.setVerticalAlignment(SwingConstants.CENTER);
        panel.add(fieldLabel);
        component.setMaximumSize(component.getPreferredSize());
        JPanel innerPanel = new JPanel();
        innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.X_AXIS));
        innerPanel.add(checkboxComponent);
        innerPanel.add(component);
        innerPanel.add(checkboxSSLComponent);
        panel.add(innerPanel);
        if (toolTipText != null) {
            fieldLabel.setToolTipText(toolTipText);
            component.setToolTipText(toolTipText);
        }
    }"
davmail-4.5.1,davmail.ui.SettingsFrame,reload,,78,647,0,3,0.0325,0.2452,0.5,2,12,0,1,"/**
     * Reload settings from properties.
     */
    public void reload() {
        // reload settings in form
        urlField.setText(Settings.getProperty(""davmail.url""));
        popPortField.setText(Settings.getProperty(""davmail.popPort""));
        popPortCheckBox.setSelected(Settings.getProperty(""davmail.popPort"") != null && Settings.getProperty(""davmail.popPort"").length() > 0);
        popNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecurepop""));
        imapPortField.setText(Settings.getProperty(""davmail.imapPort""));
        imapPortCheckBox.setSelected(Settings.getProperty(""davmail.imapPort"") != null && Settings.getProperty(""davmail.imapPort"").length() > 0);
        imapNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecureimap""));
        smtpPortField.setText(Settings.getProperty(""davmail.smtpPort""));
        smtpPortCheckBox.setSelected(Settings.getProperty(""davmail.smtpPort"") != null && Settings.getProperty(""davmail.smtpPort"").length() > 0);
        smtpNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecuresmtp""));
        caldavPortField.setText(Settings.getProperty(""davmail.caldavPort""));
        caldavPortCheckBox.setSelected(Settings.getProperty(""davmail.caldavPort"") != null && Settings.getProperty(""davmail.caldavPort"").length() > 0);
        caldavNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecurecaldav""));
        ldapPortField.setText(Settings.getProperty(""davmail.ldapPort""));
        ldapPortCheckBox.setSelected(Settings.getProperty(""davmail.ldapPort"") != null && Settings.getProperty(""davmail.ldapPort"").length() > 0);
        ldapNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecureldap""));
        keepDelayField.setText(Settings.getProperty(""davmail.keepDelay""));
        sentKeepDelayField.setText(Settings.getProperty(""davmail.sentKeepDelay""));
        caldavPastDelayField.setText(Settings.getProperty(""davmail.caldavPastDelay""));
        imapIdleDelayField.setText(Settings.getProperty(""davmail.imapIdleDelay""));
        boolean useSystemProxies = Settings.getBooleanProperty(""davmail.useSystemProxies"", Boolean.FALSE);
        useSystemProxiesField.setSelected(useSystemProxies);
        boolean enableProxy = Settings.getBooleanProperty(""davmail.enableProxy"");
        enableProxyField.setSelected(enableProxy);
        enableProxyField.setEnabled(!useSystemProxies);
        httpProxyField.setEnabled(!useSystemProxies && enableProxy);
        httpProxyPortField.setEnabled(!useSystemProxies && enableProxy);
        httpProxyUserField.setEnabled(useSystemProxies || enableProxy);
        httpProxyPasswordField.setEnabled(useSystemProxies || enableProxy);
        noProxyForField.setEnabled(useSystemProxies || enableProxy);
        httpProxyField.setText(Settings.getProperty(""davmail.proxyHost""));
        httpProxyPortField.setText(Settings.getProperty(""davmail.proxyPort""));
        httpProxyUserField.setText(Settings.getProperty(""davmail.proxyUser""));
        httpProxyPasswordField.setText(Settings.getProperty(""davmail.proxyPassword""));
        noProxyForField.setText(Settings.getProperty(""davmail.noProxyFor""));

        bindAddressField.setText(Settings.getProperty(""davmail.bindAddress""));
        allowRemoteField.setSelected(Settings.getBooleanProperty((""davmail.allowRemote"")));
        certHashField.setText(Settings.getProperty(""davmail.server.certificate.hash""));
        disableUpdateCheck.setSelected(Settings.getBooleanProperty((""davmail.disableUpdateCheck"")));

        caldavEditNotificationsField.setSelected(Settings.getBooleanProperty(""davmail.caldavEditNotifications""));
        clientSoTimeoutField.setText(Settings.getProperty(""davmail.clientSoTimeout""));
        caldavAlarmSoundField.setText(Settings.getProperty(""davmail.caldavAlarmSound""));
        forceActiveSyncUpdateCheckBox.setSelected(Settings.getBooleanProperty(""davmail.forceActiveSyncUpdate""));
        defaultDomainField.setText(Settings.getProperty(""davmail.defaultDomain""));
        showStartupBannerCheckBox.setSelected(Settings.getBooleanProperty(""davmail.showStartupBanner"", true));
        disableGuiNotificationsCheckBox.setSelected(Settings.getBooleanProperty(""davmail.disableGuiNotifications"", false));
        imapAutoExpungeCheckBox.setSelected(Settings.getBooleanProperty(""davmail.imapAutoExpunge"", true));
        enableKeepAliveCheckBox.setSelected(Settings.getBooleanProperty(""davmail.enableKeepAlive"", false));
        popMarkReadOnRetrCheckBox.setSelected(Settings.getBooleanProperty(""davmail.popMarkReadOnRetrCheckBox"", false));
        setEwsModeSelectedItem(Settings.getProperty(""davmail.enableEws"", ""auto""));
        smtpSaveInSentCheckBox.setSelected(Settings.getBooleanProperty(""davmail.smtpSaveInSent"", true));
        enableKerberosCheckBox.setSelected(Settings.getBooleanProperty(""davmail.enableKerberos"", false));
        folderSizeLimitField.setText(Settings.getProperty(""davmail.folderSizeLimit""));

        keystoreTypeCombo.setSelectedItem(Settings.getProperty(""davmail.ssl.keystoreType""));
        keystoreFileField.setText(Settings.getProperty(""davmail.ssl.keystoreFile""));
        keystorePassField.setText(Settings.getProperty(""davmail.ssl.keystorePass""));
        keyPassField.setText(Settings.getProperty(""davmail.ssl.keyPass""));

        clientKeystoreTypeCombo.setSelectedItem(Settings.getProperty(""davmail.ssl.clientKeystoreType""));
        pkcs11LibraryField.setText(Settings.getProperty(""davmail.ssl.pkcs11Library""));
        pkcs11ConfigField.setText(Settings.getProperty(""davmail.ssl.pkcs11Config""));

        rootLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""rootLogger""));
        davmailLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""davmail""));
        httpclientLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""org.apache.commons.httpclient""));
        wireLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""httpclient.wire""));
        logFilePathField.setText(Settings.getProperty(""davmail.logFilePath""));
        logFileSizeField.setText(Settings.getProperty(""davmail.logFileSize""));

        if (osxHideFromDockCheckBox != null) {
            osxHideFromDockCheckBox.setSelected(OSXInfoPlist.isHideFromDock());
        }
    }"
davmail-4.5.1,davmail.ui.SettingsFrame,isSslEnabled,,8,9,8,4,0.3,0.1111,1,0,2,0,1,"protected boolean isSslEnabled() {
        if (keystoreFileField != null) {
            return keystoreFileField.getText().length() > 0;
        } else {
            return Settings.getProperty(""davmail.ssl.keystoreFile"") != null &&
                    (Settings.getProperty(""davmail.ssl.keystoreFile"").length() > 0);
        }
    }"
davmail-4.5.1,davmail.ui.SettingsFrame,SettingsFrame,,198,41,37,7,0.15,0.0556,0.5,25,8,0,1,"/**
     * DavMail settings frame.
     */
    public SettingsFrame() {
        setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
        setTitle(BundleMessage.format(""UI_DAVMAIL_SETTINGS""));
        try {
            setIconImage(DavGatewayTray.getFrameIcon());
        } catch (NoSuchMethodError error) {
            DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
        }

        JTabbedPane tabbedPane = new JTabbedPane();
        // add help (F1 handler)
        tabbedPane.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(""F1""),
                ""help"");
        tabbedPane.getActionMap().put(""help"", new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                DesktopBrowser.browse(""http://davmail.sourceforge.net"");
            }
        });
        tabbedPane.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                boolean isSslEnabled = isSslEnabled();
                popNoSSLCheckBox.setEnabled(Settings.getProperty(""davmail.popPort"") != null && isSslEnabled);
                imapNoSSLCheckBox.setEnabled(imapPortCheckBox.isSelected() && isSslEnabled);
                smtpNoSSLCheckBox.setEnabled(smtpPortCheckBox.isSelected() && isSslEnabled);
                caldavNoSSLCheckBox.setEnabled(caldavPortCheckBox.isSelected() && isSslEnabled);
                ldapNoSSLCheckBox.setEnabled(ldapPortCheckBox.isSelected() && isSslEnabled);
            }
        });

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.add(getSettingsPanel());
        mainPanel.add(getDelaysPanel());
        mainPanel.add(Box.createVerticalGlue());

        tabbedPane.add(BundleMessage.format(""UI_TAB_MAIN""), mainPanel);

        JPanel proxyPanel = new JPanel();
        proxyPanel.setLayout(new BoxLayout(proxyPanel, BoxLayout.Y_AXIS));
        proxyPanel.add(getProxyPanel());
        proxyPanel.add(getNetworkSettingsPanel());
        tabbedPane.add(BundleMessage.format(""UI_TAB_NETWORK""), proxyPanel);

        JPanel encryptionPanel = new JPanel();
        encryptionPanel.setLayout(new BoxLayout(encryptionPanel, BoxLayout.Y_AXIS));
        encryptionPanel.add(getKeystorePanel());
        encryptionPanel.add(getSmartCardPanel());
        // empty panel
        encryptionPanel.add(new JPanel());
        tabbedPane.add(BundleMessage.format(""UI_TAB_ENCRYPTION""), encryptionPanel);

        JPanel loggingPanel = new JPanel();
        loggingPanel.setLayout(new BoxLayout(loggingPanel, BoxLayout.Y_AXIS));
        loggingPanel.add(getLoggingSettingsPanel());
        // empty panel
        loggingPanel.add(new JPanel());

        tabbedPane.add(BundleMessage.format(""UI_TAB_LOGGING""), loggingPanel);

        JPanel advancedPanel = new JPanel();
        advancedPanel.setLayout(new BoxLayout(advancedPanel, BoxLayout.Y_AXIS));

        advancedPanel.add(getOtherSettingsPanel());
        // empty panel
        advancedPanel.add(new JPanel());

        tabbedPane.add(BundleMessage.format(""UI_TAB_ADVANCED""), advancedPanel);

        if (OSXInfoPlist.isOSX()) {
            JPanel osxPanel = new JPanel();
            osxPanel.setLayout(new BoxLayout(osxPanel, BoxLayout.Y_AXIS));
            osxPanel.add(getOSXPanel());
            // empty panel
            osxPanel.add(new JPanel());

            tabbedPane.add(BundleMessage.format(""UI_TAB_OSX""), osxPanel);
        }

        add(BorderLayout.CENTER, tabbedPane);

        JPanel buttonPanel = new JPanel();
        JButton cancel = new JButton(BundleMessage.format(""UI_BUTTON_CANCEL""));
        JButton ok = new JButton(BundleMessage.format(""UI_BUTTON_SAVE""));
        JButton help = new JButton(BundleMessage.format(""UI_BUTTON_HELP""));
        ActionListener save = new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                // save options
                Settings.setProperty(""davmail.url"", urlField.getText());
                Settings.setProperty(""davmail.popPort"", popPortCheckBox.isSelected() ? popPortField.getText() : """");
                Settings.setProperty(""davmail.ssl.nosecurepop"", String.valueOf(popNoSSLCheckBox.isSelected()));
                Settings.setProperty(""davmail.imapPort"", imapPortCheckBox.isSelected() ? imapPortField.getText() : """");
                Settings.setProperty(""davmail.ssl.nosecureimap"", String.valueOf(imapNoSSLCheckBox.isSelected()));
                Settings.setProperty(""davmail.smtpPort"", smtpPortCheckBox.isSelected() ? smtpPortField.getText() : """");
                Settings.setProperty(""davmail.ssl.nosecuresmtp"", String.valueOf(smtpNoSSLCheckBox.isSelected()));
                Settings.setProperty(""davmail.caldavPort"", caldavPortCheckBox.isSelected() ? caldavPortField.getText() : """");
                Settings.setProperty(""davmail.ssl.nosecurecaldav"", String.valueOf(caldavNoSSLCheckBox.isSelected()));
                Settings.setProperty(""davmail.ldapPort"", ldapPortCheckBox.isSelected() ? ldapPortField.getText() : """");
                Settings.setProperty(""davmail.ssl.nosecureldap"", String.valueOf(ldapNoSSLCheckBox.isSelected()));
                Settings.setProperty(""davmail.keepDelay"", keepDelayField.getText());
                Settings.setProperty(""davmail.sentKeepDelay"", sentKeepDelayField.getText());
                Settings.setProperty(""davmail.caldavPastDelay"", caldavPastDelayField.getText());
                Settings.setProperty(""davmail.imapIdleDelay"", imapIdleDelayField.getText());
                Settings.setProperty(""davmail.useSystemProxies"", String.valueOf(useSystemProxiesField.isSelected()));
                Settings.setProperty(""davmail.enableProxy"", String.valueOf(enableProxyField.isSelected()));
                Settings.setProperty(""davmail.proxyHost"", httpProxyField.getText());
                Settings.setProperty(""davmail.proxyPort"", httpProxyPortField.getText());
                Settings.setProperty(""davmail.proxyUser"", httpProxyUserField.getText());
                Settings.setProperty(""davmail.proxyPassword"", httpProxyPasswordField.getText());
                Settings.setProperty(""davmail.noProxyFor"", noProxyForField.getText());

                Settings.setProperty(""davmail.bindAddress"", bindAddressField.getText());
                Settings.setProperty(""davmail.clientSoTimeout"", String.valueOf(clientSoTimeoutField.getText()));
                Settings.setProperty(""davmail.allowRemote"", String.valueOf(allowRemoteField.isSelected()));
                Settings.setProperty(""davmail.server.certificate.hash"", certHashField.getText());
                Settings.setProperty(""davmail.disableUpdateCheck"", String.valueOf(disableUpdateCheck.isSelected()));

                Settings.setProperty(""davmail.caldavEditNotifications"", String.valueOf(caldavEditNotificationsField.isSelected()));
                Settings.setProperty(""davmail.caldavAlarmSound"", String.valueOf(caldavAlarmSoundField.getText()));
                Settings.setProperty(""davmail.forceActiveSyncUpdate"", String.valueOf(forceActiveSyncUpdateCheckBox.isSelected()));
                Settings.setProperty(""davmail.defaultDomain"", String.valueOf(defaultDomainField.getText()));
                Settings.setProperty(""davmail.showStartupBanner"", String.valueOf(showStartupBannerCheckBox.isSelected()));
                Settings.setProperty(""davmail.disableGuiNotifications"", String.valueOf(disableGuiNotificationsCheckBox.isSelected()));
                Settings.setProperty(""davmail.imapAutoExpunge"", String.valueOf(imapAutoExpungeCheckBox.isSelected()));
                Settings.setProperty(""davmail.enableKeepAlive"", String.valueOf(enableKeepAliveCheckBox.isSelected()));
                Settings.setProperty(""davmail.popMarkReadOnRetr"", String.valueOf(popMarkReadOnRetrCheckBox.isSelected()));
                String selectedEwsMode = (String) enableEwsComboBox.getSelectedItem();
                String enableEws;
                if (EWS.equals(selectedEwsMode)) {
                    enableEws = ""true"";
                } else if (WEBDAV.equals(selectedEwsMode)) {
                    enableEws = ""false"";
                } else {
                    enableEws = ""auto"";
                }
                Settings.setProperty(""davmail.enableEws"", enableEws);
                Settings.setProperty(""davmail.enableKerberos"", String.valueOf(enableKerberosCheckBox.isSelected()));
                Settings.setProperty(""davmail.folderSizeLimit"", folderSizeLimitField.getText());
                Settings.setProperty(""davmail.smtpSaveInSent"", String.valueOf(smtpSaveInSentCheckBox.isSelected()));

                Settings.setProperty(""davmail.ssl.keystoreType"", (String) keystoreTypeCombo.getSelectedItem());
                Settings.setProperty(""davmail.ssl.keystoreFile"", keystoreFileField.getText());
                Settings.setProperty(""davmail.ssl.keystorePass"", String.valueOf(keystorePassField.getPassword()));
                Settings.setProperty(""davmail.ssl.keyPass"", String.valueOf(keyPassField.getPassword()));

                Settings.setProperty(""davmail.ssl.clientKeystoreType"", (String) clientKeystoreTypeCombo.getSelectedItem());
                Settings.setProperty(""davmail.ssl.clientKeystoreFile"", clientKeystoreFileField.getText());
                Settings.setProperty(""davmail.ssl.clientKeystorePass"", String.valueOf(clientKeystorePassField.getPassword()));
                Settings.setProperty(""davmail.ssl.pkcs11Library"", pkcs11LibraryField.getText());
                Settings.setProperty(""davmail.ssl.pkcs11Config"", pkcs11ConfigField.getText());

                Settings.setLoggingLevel(""rootLogger"", (Level) rootLoggingLevelField.getSelectedItem());
                Settings.setLoggingLevel(""davmail"", (Level) davmailLoggingLevelField.getSelectedItem());
                Settings.setLoggingLevel(""org.apache.commons.httpclient"", (Level) httpclientLoggingLevelField.getSelectedItem());
                Settings.setLoggingLevel(""httpclient.wire"", (Level) wireLoggingLevelField.getSelectedItem());
                Settings.setProperty(""davmail.logFilePath"", logFilePathField.getText());
                Settings.setProperty(""davmail.logFileSize"", logFileSizeField.getText());

                setVisible(false);
                Settings.save();

                if (osxHideFromDockCheckBox != null) {
                    OSXInfoPlist.setOSXHideFromDock(osxHideFromDockCheckBox.isSelected());
                }

                // restart listeners with new config
                DavGateway.restart();
            }
        };
        ok.addActionListener(save);

        cancel.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                reload();
                setVisible(false);
            }
        });

        help.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                DesktopBrowser.browse(""http://davmail.sourceforge.net"");
            }
        });

        buttonPanel.add(ok);
        buttonPanel.add(cancel);
        buttonPanel.add(help);

        add(BorderLayout.SOUTH, buttonPanel);

        pack();
        //setResizable(false);
        // center frame
        setLocation(getToolkit().getScreenSize().width / 2 -
                getSize().width / 2,
                getToolkit().getScreenSize().height / 2 -
                        getSize().height / 2);
        urlField.requestFocus();
    }"
davmail-4.5.1,davmail.ui.AboutFrame,AboutFrame,,74,386,337,8,0.0759,0.0633,0.5,22,5,0,1,"/**
     * About frame.
     */
    public AboutFrame() {
        setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
        setTitle(BundleMessage.format(""UI_ABOUT_DAVMAIL""));
        try {
            setIconImage(DavGatewayTray.getFrameIcon());
        } catch (NoSuchMethodError error) {
            DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
        }
        try {
            JLabel imageLabel = new JLabel();
            ClassLoader classloader = this.getClass().getClassLoader();
            URL imageUrl = classloader.getResource(""tray32.png"");
            Image iconImage = ImageIO.read(imageUrl);
            if (iconImage != null) {
                ImageIcon icon = new ImageIcon(iconImage);
                imageLabel.setIcon(icon);
            }
            JPanel imagePanel = new JPanel();
            imagePanel.add(imageLabel);
            add(BorderLayout.WEST, imagePanel);
        } catch (IOException e) {
            DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_CREATE_ICON""), e);
        }

        jEditorPane = new JEditorPane();
        HTMLEditorKit htmlEditorKit = new HTMLEditorKit();
        StyleSheet stylesheet = htmlEditorKit.getStyleSheet();
        Font font = jEditorPane.getFont();
        stylesheet.addRule(""body { font-size:small;font-family: "" + ((font==null)?""Arial"":font.getFamily()) + '}');
        jEditorPane.setEditorKit(htmlEditorKit);
        jEditorPane.setContentType(""text/html"");
        jEditorPane.setText(getContent(null));

        jEditorPane.setEditable(false);
        jEditorPane.setOpaque(false);
        jEditorPane.addHyperlinkListener(new HyperlinkListener() {
            public void hyperlinkUpdate(HyperlinkEvent hle) {
                if (HyperlinkEvent.EventType.ACTIVATED.equals(hle.getEventType())) {
                    try {
                        DesktopBrowser.browse(hle.getURL().toURI());
                    } catch (URISyntaxException e) {
                        DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_OPEN_LINK""), e);
                    }
                    setVisible(false);
                }
            }
        });


        JPanel mainPanel = new JPanel();
        mainPanel.add(jEditorPane);
        add(BorderLayout.CENTER, mainPanel);

        JPanel buttonPanel = new JPanel();
        JButton ok = new JButton(BundleMessage.format(""UI_BUTTON_OK""));
        ActionListener close = new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                setVisible(false);
            }
        };
        ok.addActionListener(close);

        buttonPanel.add(ok);

        add(BorderLayout.SOUTH, buttonPanel);

        pack();
        setResizable(false);
        // center frame
        setLocation(getToolkit().getScreenSize().width / 2 -
                getSize().width / 2,
                getToolkit().getScreenSize().height / 2 -
                        getSize().height / 2);
    }"
davmail-4.5.1,davmail.ui.AcceptCertificateDialog,AcceptCertificateDialog,,50,596,489,10,0.0859,0.055,0.428571429,14,4,0,1,"/**
     * Accept certificate dialog.
     *
     * @param certificate certificate sent by server
     */
    public AcceptCertificateDialog(X509Certificate certificate) {
        setAlwaysOnTop(true);
        String sha1Hash = DavGatewayX509TrustManager.getFormattedHash(certificate);
        DateFormat formatter = DateFormat.getDateInstance(DateFormat.MEDIUM);

        setTitle(BundleMessage.format(""UI_ACCEPT_CERTIFICATE""));
        try {
            setIconImage(DavGatewayTray.getFrameIcon());
        } catch (NoSuchMethodError error) {
            DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
        }

        JPanel subjectPanel = new JPanel();
        subjectPanel.setLayout(new BoxLayout(subjectPanel, BoxLayout.Y_AXIS));
        subjectPanel.setBorder(BorderFactory.createTitledBorder(BundleMessage.format(""UI_SERVER_CERTIFICATE"")));
        addFieldValue(subjectPanel, BundleMessage.format(""UI_ISSUED_TO""), DavGatewayX509TrustManager.getRDN(certificate.getSubjectDN()));
        addFieldValue(subjectPanel, BundleMessage.format(""UI_ISSUED_BY""), DavGatewayX509TrustManager.getRDN(certificate.getIssuerDN()));
        Date now = new Date();
        String notBefore = formatter.format(certificate.getNotBefore());
        if (now.before(certificate.getNotBefore())) {
            notBefore = ""<html><font color=\""#FF0000\"">"" + notBefore + ""</font></html>"";
        }
        addFieldValue(subjectPanel, BundleMessage.format(""UI_VALID_FROM""), notBefore);
        String notAfter = formatter.format(certificate.getNotAfter());
        if (now.after(certificate.getNotAfter())) {
            notAfter = ""<html><font color=\""#FF0000\"">"" + notAfter + ""</font></html>"";
        }
        addFieldValue(subjectPanel, BundleMessage.format(""UI_VALID_UNTIL""), notAfter);
        addFieldValue(subjectPanel, BundleMessage.format(""UI_SERIAL""), DavGatewayX509TrustManager.getFormattedSerial(certificate));
        addFieldValue(subjectPanel, BundleMessage.format(""UI_FINGERPRINT""), sha1Hash);

        JPanel warningPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel imageLabel = new JLabel();
        imageLabel.setIcon(UIManager.getIcon(""OptionPane.warningIcon""));
        imageLabel.setText(BundleMessage.format(""UI_UNTRUSTED_CERTIFICATE_HTML""));
        warningPanel.add(imageLabel);
        add(warningPanel, BorderLayout.NORTH);
        add(subjectPanel, BorderLayout.CENTER);
        add(getButtonPanel(), BorderLayout.SOUTH);
        setModal(true);

        pack();
        // center frame
        setLocation(getToolkit().getScreenSize().width / 2 -
                getSize().width / 2,
                getToolkit().getScreenSize().height / 2 -
                        getSize().height / 2);
	setAlwaysOnTop(true);
        setVisible(true);
    }"
davmail-4.5.1,davmail.ui.AcceptCertificateDialog,isCertificateTrusted,,17,66,66,12,0.0833,0,1,5,3,0,1,"/**
     * Display certificate accept dialog and get user answer.
     *
     * @param certificate certificate sent by server
     * @return true if user accepted certificate
     */
    public static boolean isCertificateTrusted(final X509Certificate certificate) {
        final boolean[] answer = new boolean[1];
        try {
            SwingUtilities.invokeAndWait(new Runnable() {
                public void run() {
                    AcceptCertificateDialog certificateDialog = new AcceptCertificateDialog(certificate);
                    answer[0] = certificateDialog.isAccepted();
                }
            });
        } catch (InterruptedException ie) {
            DavGatewayTray.error(new BundleMessage(""UI_ERROR_WAITING_FOR_CERTIFICATE_CHECK""), ie);
        } catch (InvocationTargetException ite) {
            DavGatewayTray.error(new BundleMessage(""UI_ERROR_WAITING_FOR_CERTIFICATE_CHECK""), ite);
        }

        return answer[0];
    }"
davmail-4.5.1,davmail.ui.browser.DesktopBrowser,browse,,34,143,115,5,0.1316,0.0941,0.833333333,8,7,0,1,"/**
     * Open default browser at location URI.
     * User Java 6 Desktop class, OSX open command or SWT program launch
     *
     * @param location location URI
     */
    public static void browse(URI location) {
        try {
            // trigger ClassNotFoundException
            ClassLoader classloader = AboutFrame.class.getClassLoader();
            classloader.loadClass(""java.awt.Desktop"");

            // Open link in default browser
            AwtDesktopBrowser.browse(location);
        } catch (ClassNotFoundException e) {
            DavGatewayTray.debug(new BundleMessage(""LOG_JAVA6_DESKTOP_UNAVAILABLE""));
            // failover for MacOSX
            if (System.getProperty(""os.name"").toLowerCase().startsWith(""mac os x"")) {
                try {
                    OSXDesktopBrowser.browse(location);
                } catch (Exception e2) {
                    DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_OPEN_LINK""), e2);
                }
            } else {
                // failover : try SWT
                try {
                    // trigger ClassNotFoundException
                    ClassLoader classloader = AboutFrame.class.getClassLoader();
                    classloader.loadClass(""org.eclipse.swt.program.Program"");
                    SwtDesktopBrowser.browse(location);
                } catch (ClassNotFoundException e2) {
                    DavGatewayTray.error(new BundleMessage(""LOG_OPEN_LINK_NOT_SUPPORTED""));
                } catch (Exception e2) {
                    DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_OPEN_LINK""), e2);
                }
            }
        } catch (Exception e) {
            DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_OPEN_LINK""), e);
        }
    }"
davmail-4.5.1,davmail.ui.browser.DesktopBrowser,browse,,7,9,8,4,0.24,0.0556,1,2,2,0,1,"/**
     * Open default browser at location.
     * User Java 6 Desktop class, OSX open command or SWT program launch
     *
     * @param location target location
     */
    public static void browse(String location) {
        try {
            DesktopBrowser.browse(new URI(location));
        } catch (URISyntaxException e) {
            DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_OPEN_LINK""), e);
        }
    }"
davmail-4.5.1,davmail.ui.tray.FrameGatewayTray,switchIcon,,13,6,6,4,0.25,0,0,1,2,0,1,"/**
     * Switch tray icon between active and standby icon.
     */
    public void switchIcon() {
        isActive = true;
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                Image currentImage = mainFrame.getIconImage();
                if (currentImage != null && currentImage.equals(image)) {
                    mainFrame.setIconImage(image2);
                } else {
                    mainFrame.setIconImage(image);
                }
            }
        });
    }"
davmail-4.5.1,davmail.ui.tray.FrameGatewayTray,showLogs,,16,76,74,11,0.1026,0.0198,0,2,2,0,1,"/**
     * Open logging window.
     */
    public void showLogs() {
        Logger rootLogger = Logger.getRootLogger();
        LF5Appender lf5Appender = (LF5Appender) rootLogger.getAppender(""LF5Appender"");
        if (lf5Appender == null) {
            logBrokerMonitor = new LogBrokerMonitor(LogLevel.getLog4JLevels()) {
                @Override
                protected void closeAfterConfirm() {
                    hide();
                }
            };
            lf5Appender = new LF5Appender(logBrokerMonitor);
            lf5Appender.setName(""LF5Appender"");
            rootLogger.addAppender(lf5Appender);
        }
        lf5Appender.getLogBrokerMonitor().show();
    }"
davmail-4.5.1,davmail.ui.tray.FrameGatewayTray,dispose,,8,9,8,4,0.2667,0.1,0,0,2,0,1,"public void dispose() {
        // dispose frames
        settingsFrame.dispose();
        aboutFrame.dispose();
        if (logBrokerMonitor != null) {
            logBrokerMonitor.dispose();
        }
    }"
davmail-4.5.1,davmail.ui.tray.FrameGatewayTray,buildMenu,,55,232,211,10,0.0988,0.0353,1,14,1,0,1,"protected void buildMenu() {
        // create a popup menu
        JMenu menu = new JMenu(BundleMessage.format(""UI_DAVMAIL_GATEWAY""));
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(menu);
        mainFrame.setJMenuBar(menuBar);

        // create an action settingsListener to listen for settings action executed on the tray icon
        ActionListener aboutListener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                about();
            }
        };
        // create menu item for the default action
        JMenuItem aboutItem = new JMenuItem(BundleMessage.format(""UI_ABOUT""));
        aboutItem.addActionListener(aboutListener);
        menu.add(aboutItem);


        // create an action settingsListener to listen for settings action executed on the tray icon
        ActionListener settingsListener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                preferences();
            }
        };
        // create menu item for the default action
        JMenuItem defaultItem = new JMenuItem(BundleMessage.format(""UI_SETTINGS""));
        defaultItem.addActionListener(settingsListener);
        menu.add(defaultItem);

        JMenuItem logItem = new JMenuItem(BundleMessage.format(""UI_SHOW_LOGS""));
        logItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                showLogs();
            }
        });
        menu.add(logItem);

        // create an action exitListener to listen for exit action executed on the tray icon
        ActionListener exitListener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                try {
                    DavGateway.stop();
                } catch (Exception exc) {
                    DavGatewayTray.error(exc);
                }
                // make sure we do exit
                System.exit(0);
            }
        };
        // create menu item for the exit action
        JMenuItem exitItem = new JMenuItem(BundleMessage.format(""UI_EXIT""));
        exitItem.addActionListener(exitListener);
        menu.add(exitItem);
    }"
davmail-4.5.1,davmail.ui.tray.FrameGatewayTray,createAndShowGUI,,64,878,721,8,0.0572,0.0652,1,11,4,1,1,"protected void createAndShowGUI() {
        System.setProperty(""swing.defaultlaf"", UIManager.getSystemLookAndFeelClassName());

        image = DavGatewayTray.loadImage(""tray.png"");
        image2 = DavGatewayTray.loadImage(AwtGatewayTray.TRAY_ACTIVE_PNG);
        inactiveImage = DavGatewayTray.loadImage(AwtGatewayTray.TRAY_INACTIVE_PNG);

        mainFrame = new JFrame();
        mainFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        mainFrame.setTitle(BundleMessage.format(""UI_DAVMAIL_GATEWAY""));
        mainFrame.setIconImage(image);

        JPanel errorPanel = new JPanel();
        errorPanel.setBorder(BorderFactory.createTitledBorder(BundleMessage.format(""UI_LAST_MESSAGE"")));
        errorPanel.setLayout(new BoxLayout(errorPanel, BoxLayout.X_AXIS));
        errorArea = new JTextPane();
        errorArea.setEditable(false);
        errorArea.setBackground(mainFrame.getBackground());
        errorLabel = new JLabel();
        errorPanel.add(errorLabel);
        errorPanel.add(errorArea);

        JPanel messagePanel = new JPanel();
        messagePanel.setBorder(BorderFactory.createTitledBorder(BundleMessage.format(""UI_LAST_LOG"")));
        messagePanel.setLayout(new BoxLayout(messagePanel, BoxLayout.X_AXIS));

        messageArea = new JTextPane();
        messageArea.setText(BundleMessage.format(""LOG_STARTING_DAVMAIL""));
        messageArea.setEditable(false);
        messageArea.setBackground(mainFrame.getBackground());
        messagePanel.add(messageArea);

        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.add(errorPanel);
        mainPanel.add(messagePanel);
        mainFrame.add(mainPanel);

        aboutFrame = new AboutFrame();
        settingsFrame = new SettingsFrame();
        buildMenu();

        mainFrame.setMinimumSize(new Dimension(400, 180));
        mainFrame.pack();
        // workaround MacOSX
        if (mainFrame.getSize().width < 400 || mainFrame.getSize().height < 180) {
            mainFrame.setSize(Math.max(mainFrame.getSize().width, 400),
                    Math.max(mainFrame.getSize().height, 180));
        }
        // center frame
        mainFrame.setLocation(mainFrame.getToolkit().getScreenSize().width / 2 -
                mainFrame.getSize().width / 2,
                mainFrame.getToolkit().getScreenSize().height / 2 -
                        mainFrame.getSize().height / 2);
        mainFrame.setVisible(true);

        // display settings frame on first start
        if (Settings.isFirstStart()) {
            settingsFrame.setVisible(true);
            settingsFrame.toFront();
            settingsFrame.repaint();
            settingsFrame.requestFocus();
        }
    }"
davmail-4.5.1,davmail.ui.tray.OSXAwtGatewayTray,quit,,11,15,15,6,0.1667,0,1,0,2,0,1,"/**
     * Exit DavMail Gateway.
     *
     * @return true
     */
    @SuppressWarnings({""SameReturnValue"", ""UnusedDeclaration""})
    public boolean quit() {
        DavGateway.stop();
        // dispose frames
        settingsFrame.dispose();
        aboutFrame.dispose();
        if (logBrokerMonitor != null) {
            logBrokerMonitor.dispose();
        }
        return true;
    }"
davmail-4.5.1,davmail.ui.tray.OSXAwtGatewayTray,createAndShowGUI,,13,17,13,4,0.2698,0.1286,0.6,1,2,0,1,"@Override
    protected void createAndShowGUI() {
        System.setProperty(""apple.laf.useScreenMenuBar"", ""true"");
        super.createAndShowGUI();
        trayIcon.removeActionListener(settingsListener);
        try {
            OSXAdapter.setAboutHandler(this, AwtGatewayTray.class.getDeclaredMethod(""about"", (Class[]) null));
            OSXAdapter.setPreferencesHandler(this, AwtGatewayTray.class.getDeclaredMethod(""preferences"", (Class[]) null));
            OSXAdapter.setQuitHandler(this, OSXAwtGatewayTray.class.getDeclaredMethod(""quit"", (Class[]) null));
        } catch (Exception e) {
            DavGatewayTray.error(new BundleMessage(""LOG_ERROR_LOADING_OSXADAPTER""), e);
        }
    }"
davmail-4.5.1,davmail.ui.tray.OSXAwtGatewayTray,displayMessage,,34,435,435,30,0.0333,0,1,6,4,0,1,"@Override
    public void displayMessage(final String message, final Level level) {
        if (!GrowlUtils.isGrowlLoaded()) {
            super.displayMessage(message, level);
        } else {
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    if (trayIcon != null) {
                        Icon icon = null;
                        if (level.equals(Level.INFO)) {
                            icon = UIManager.getIcon(""OptionPane.informationIcon"");
                        } else if (level.equals(Level.WARN)) {
                            icon = UIManager.getIcon(""OptionPane.warningIcon"");
                        } else if (level.equals(Level.ERROR)) {
                            icon = UIManager.getIcon(""OptionPane.errorIcon"");
                        }

                        if (icon != null && message != null && message.length() > 0) {
                            try {
                                String title = BundleMessage.format(""UI_DAVMAIL_GATEWAY"");
                                Growl growl = GrowlUtils.getGrowlInstance(""DavMail"");
                                growl.addNotification(title, true);
                                growl.register();
                                growl.sendNotification(title, title, message, (RenderedImage) getImageForIcon(icon));
                            } catch (GrowlException growlException) {
                                LOGGER.error(growlException);
                            }
                        }
                        trayIcon.setToolTip(BundleMessage.format(""UI_DAVMAIL_GATEWAY"") + '\n' + message);
                    }
                }
            });
        }
    }"
davmail-4.5.1,davmail.ui.tray.DavGatewayTray,switchIcon,,8,11,7,3,0.3333,0.1429,1,0,3,0,1,"/**
     * Switch tray icon between active and standby icon.
     */
    public static void switchIcon() {
        if (davGatewayTray != null) {
            if (System.currentTimeMillis() - lastIconSwitch > ICON_SWITCH_MINIMUM_DELAY) {
                davGatewayTray.switchIcon();
                lastIconSwitch = System.currentTimeMillis();
            }
        }
    }"
davmail-4.5.1,davmail.ui.tray.DavGatewayTray,displayMessage,,6,8,6,3,0.32,0.0833,0.75,2,3,0,1,"/**
     * Log and display balloon message according to log level.
     *
     * @param message text message
     * @param level   log level
     */
    private static void displayMessage(BundleMessage message, Level level) {
        LOGGER.log(level, message.formatLog());
        if (davGatewayTray != null && !Settings.getBooleanProperty(""davmail.disableGuiNotifications"")) {
            davGatewayTray.displayMessage(message.format(), level);
        }
    }"
davmail-4.5.1,davmail.ui.tray.DavGatewayTray,displayMessage,,14,18,0,3,0.3519,0.2048,0.6,3,7,0,1,"/**
     * Log and display balloon message and exception according to log level.
     *
     * @param message text message
     * @param e       exception
     * @param level   log level
     */
    private static void displayMessage(BundleMessage message, Exception e, Level level) {
        if (e instanceof NetworkDownException) {
            LOGGER.log(level, BundleMessage.getExceptionLogMessage(message, e));
        } else {
            LOGGER.log(level, BundleMessage.getExceptionLogMessage(message, e), e);
        }
        if (davGatewayTray != null && !Settings.getBooleanProperty(""davmail.disableGuiNotifications"")
                && (!(e instanceof NetworkDownException))) {
            davGatewayTray.displayMessage(BundleMessage.getExceptionMessage(message, e), level);
        }
        if (davGatewayTray != null && e instanceof NetworkDownException) {
            davGatewayTray.inactiveIcon();
        }
    }"
davmail-4.5.1,davmail.ui.tray.DavGatewayTray,init,,39,143,55,5,0.1224,0.1703,1,3,9,0,1,"/**
     * Create tray icon and register frame listeners.
     */
    public static void init() {
        if (!Settings.getBooleanProperty(""davmail.server"")) {
            // first try to load SWT before with Java
            ClassLoader classloader = DavGatewayTray.class.getClassLoader();
            try {
                // trigger ClassNotFoundException
                classloader.loadClass(""org.eclipse.swt.SWT"");
                // SWT available, create tray
                davGatewayTray = new SwtGatewayTray();
                davGatewayTray.init();
            } catch (ClassNotFoundException e) {
                DavGatewayTray.info(new BundleMessage(""LOG_SWT_NOT_AVAILABLE""));
            }
            // try java6 tray support
            if (davGatewayTray == null) {
                try {
                    if (SystemTray.isSupported()) {
                        if (isOSX()) {
                            davGatewayTray = new OSXAwtGatewayTray();
                        } else {
                            davGatewayTray = new AwtGatewayTray();
                        }
                        davGatewayTray.init();
                    }
                } catch (NoClassDefFoundError e) {
                    DavGatewayTray.info(new BundleMessage(""LOG_SYSTEM_TRAY_NOT_AVAILABLE""));
                }
            }
            if (davGatewayTray == null) {
                if (isOSX()) {
                    // MacOS
                    davGatewayTray = new OSXFrameGatewayTray();
                } else {
                    davGatewayTray = new FrameGatewayTray();
                }
                davGatewayTray.init();
            }
        }
    }"
davmail-4.5.1,davmail.ui.tray.DavGatewayTray,loadImage,,11,29,22,3,0.2063,0.0843,1,5,2,0,1,"/**
     * Load image with current class loader.
     *
     * @param fileName image resource file name
     * @return image
     */
    public static Image loadImage(String fileName) {
        Image result = null;
        try {
            ClassLoader classloader = DavGatewayTray.class.getClassLoader();
            URL imageUrl = classloader.getResource(fileName);
            result = ImageIO.read(imageUrl);
        } catch (IOException e) {
            DavGatewayTray.warn(new BundleMessage(""LOG_UNABLE_TO_LOAD_IMAGE""), e);
        }
        return result;
    }"
davmail-4.5.1,davmail.ui.tray.OSXFrameGatewayTray,quit,,11,15,15,6,0.1667,0,1,0,2,0,1,"/**
     * Exit DavMail Gateway.
     *
     * @return true
     */
    @SuppressWarnings({""SameReturnValue"", ""UnusedDeclaration""})
    public boolean quit() {
        DavGateway.stop();
        // dispose frames
        settingsFrame.dispose();
        aboutFrame.dispose();
        if (logBrokerMonitor != null) {
            logBrokerMonitor.dispose();
        }
        return true;
    }"
davmail-4.5.1,davmail.ui.tray.SwtGatewayTray,displayMessage,,24,253,253,23,0.0435,0,1,4,2,0,1,"/**
     * Log and display balloon message according to log level.
     *
     * @param message text message
     * @param level   log level
     */
    public void displayMessage(final String message, final Level level) {
        if (trayItem != null) {
            display.asyncExec(new Runnable() {
                public void run() {
                    int messageType = 0;
                    if (level.equals(Level.INFO)) {
                        messageType = SWT.ICON_INFORMATION;
                    } else if (level.equals(Level.WARN)) {
                        messageType = SWT.ICON_WARNING;
                    } else if (level.equals(Level.ERROR)) {
                        messageType = SWT.ICON_ERROR;
                    }
                    if (messageType != 0) {
                        final ToolTip toolTip = new ToolTip(shell, SWT.BALLOON | messageType);
                        toolTip.setText(BundleMessage.format(""UI_DAVMAIL_GATEWAY""));
                        toolTip.setMessage(message);
                        trayItem.setToolTip(toolTip);
                        toolTip.setVisible(true);
                    }
                    trayItem.setToolTipText(BundleMessage.format(""UI_DAVMAIL_GATEWAY"") + '\n' + message);
                }
            });
        }
    }"
davmail-4.5.1,davmail.ui.tray.SwtGatewayTray,loadSwtImage,,14,45,35,3,0.1818,0.0679,1,5,3,0,1,"/**
     * Load image with current class loader.
     *
     * @param fileName image resource file name
     * @return image
     */
    public static Image loadSwtImage(String fileName) {
        Image result = null;
        try {
            ClassLoader classloader = DavGatewayTray.class.getClassLoader();
            URL imageUrl = classloader.getResource(fileName);
            if (imageUrl == null) {
                throw new IOException(fileName);
            }
            result = new Image(display, imageUrl.openStream());
        } catch (IOException e) {
            DavGatewayTray.warn(new BundleMessage(""LOG_UNABLE_TO_LOAD_IMAGE""), e);
        }
        return result;
    }"
davmail-4.5.1,davmail.ui.tray.AwtGatewayTray,dispose,,10,20,19,6,0.1714,0.05,0,0,2,0,1,"public void dispose() {
        SystemTray.getSystemTray().remove(trayIcon);

        // dispose frames
        settingsFrame.dispose();
        aboutFrame.dispose();
        if (logBrokerMonitor != null) {
            logBrokerMonitor.dispose();
        }
    }"
davmail-4.5.1,davmail.ui.tray.AwtGatewayTray,createAndShowGUI,,95,163,155,12,0.0684,0.0182,0.666666667,16,3,1,1,"protected void createAndShowGUI() {
        System.setProperty(""swing.defaultlaf"", UIManager.getSystemLookAndFeelClassName());

        // get the SystemTray instance
        SystemTray tray = SystemTray.getSystemTray();
        image = DavGatewayTray.loadImage(getTrayIconPath());
        image2 = DavGatewayTray.loadImage(getTrayIconActivePath());
        inactiveImage = DavGatewayTray.loadImage(getTrayIconInactivePath());

        // create a popup menu
        PopupMenu popup = new PopupMenu();

        aboutFrame = new AboutFrame();
        // create an action settingsListener to listen for settings action executed on the tray icon
        ActionListener aboutListener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                about();
            }
        };
        // create menu item for the default action
        MenuItem aboutItem = new MenuItem(BundleMessage.format(""UI_ABOUT""));
        aboutItem.addActionListener(aboutListener);
        popup.add(aboutItem);

        settingsFrame = new SettingsFrame();
        // create an action settingsListener to listen for settings action executed on the tray icon
        settingsListener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                preferences();
            }
        };
        // create menu item for the default action
        MenuItem defaultItem = new MenuItem(BundleMessage.format(""UI_SETTINGS""));
        defaultItem.addActionListener(settingsListener);
        popup.add(defaultItem);

        MenuItem logItem = new MenuItem(BundleMessage.format(""UI_SHOW_LOGS""));
        logItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                Logger rootLogger = Logger.getRootLogger();
                LF5Appender lf5Appender = (LF5Appender) rootLogger.getAppender(""LF5Appender"");
                if (lf5Appender == null) {
                    logBrokerMonitor = new LogBrokerMonitor(LogLevel.getLog4JLevels()) {
                        @Override
                        protected void closeAfterConfirm() {
                            hide();
                        }
                    };
                    lf5Appender = new LF5Appender(logBrokerMonitor);
                    lf5Appender.setName(""LF5Appender"");
                    rootLogger.addAppender(lf5Appender);
                }
                lf5Appender.getLogBrokerMonitor().show();
            }
        });
        popup.add(logItem);

        // create an action exitListener to listen for exit action executed on the tray icon
        ActionListener exitListener = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                try {
                    DavGateway.stop();
                } catch (Exception exc) {
                    DavGatewayTray.error(exc);
                }
                // make sure we do exit
                System.exit(0);
            }
        };
        // create menu item for the exit action
        MenuItem exitItem = new MenuItem(BundleMessage.format(""UI_EXIT""));
        exitItem.addActionListener(exitListener);
        popup.add(exitItem);

        /// ... add other items
        // construct a TrayIcon
        trayIcon = new TrayIcon(image, BundleMessage.format(""UI_DAVMAIL_GATEWAY""), popup);
        // set the TrayIcon properties
        trayIcon.addActionListener(settingsListener);
        // ...
        // add the tray image
        try {
            tray.add(trayIcon);
        } catch (AWTException e) {
            DavGatewayTray.warn(new BundleMessage(""LOG_UNABLE_TO_CREATE_TRAY""), e);
        }

        // display settings frame on first start
        if (Settings.isFirstStart()) {
            settingsFrame.setVisible(true);
            settingsFrame.toFront();
            settingsFrame.repaint();
            settingsFrame.requestFocus();
        }
    }"
davmail-4.5.1,davmail.util.StringUtil,replaceToken,,14,32,9,3,0.2857,0.1843,0,7,4,0,1,"/**
     * Return the sub string between startDelimiter and endDelimiter with newToken.
     *
     * @param value          String value
     * @param startDelimiter start delimiter
     * @param endDelimiter   end delimiter
     * @param newToken       new token value
     * @return token value
     */
    public static String replaceToken(String value, String startDelimiter, String endDelimiter, String newToken) {
        String result = null;
        if (value != null) {
            int startIndex = value.indexOf(startDelimiter);
            if (startIndex >= 0) {
                startIndex += startDelimiter.length();
                int endIndex = value.indexOf(endDelimiter, startIndex);
                if (endIndex >= 0) {
                    result = value.substring(0, startIndex) + newToken + value.substring(endIndex);
                }
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,join,,14,64,50,7,0.1538,0.0889,0,4,5,0,1,"/**
     * Join values with given separator.
     *
     * @param values    value set
     * @param separator separator
     * @return joined values
     */
    public static String join(Set<String> values, String separator) {
        if (values != null && !values.isEmpty()) {
            StringBuilder result = new StringBuilder();
            for (String value : values) {
                if (result.length() > 0) {
                    result.append(separator);
                }
                result.append(value);
            }
            return result.toString();
        } else {
            return null;
        }
    }"
davmail-4.5.1,davmail.util.StringUtil,xmlEncode,,9,14,7,3,0.2857,0.1833,1,3,3,0,1,"/**
     * Xml encode content.
     *
     * @param name decoded name
     * @return name encoded name
     */
    public static String xmlEncode(String name) {
        String result = name;
        if (result != null) {
            for (PatternMap patternMap : XML_ENCODE_PATTERNS) {
                result = patternMap.replaceAll(result);
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,xmlEncodeAttribute,,15,19,0,3,0.2364,0.4074,0,2,5,0,1,"/**
     * Xml encode inside attribute.
     *
     * @param name decoded name
     * @return name encoded name
     */
    public static String xmlEncodeAttribute(String name) {
        String result = xmlEncode(name);
        if (result != null) {
            if (result.indexOf('""') >= 0) {
                result = QUOTE_PATTERN.matcher(result).replaceAll(""&#x22;"");
            }
            if (result.indexOf('\r') >= 0) {
                result = CR_PATTERN.matcher(result).replaceAll(""&#x0D;"");
            }
            if (result.indexOf('\n') >= 0) {
                result = LF_PATTERN.matcher(result).replaceAll(""&#x0A;"");
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,xmlDecode,,9,14,7,3,0.2857,0.1833,1,3,3,0,1,"/**
     * Need to decode xml for iCal
     *
     * @param name encoded name
     * @return name decoded name
     */
    public static String xmlDecode(String name) {
        String result = name;
        if (result != null) {
            for (PatternMap patternMap : XML_DECODE_PATTERNS) {
                result = patternMap.replaceAll(result);
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,base64ToHex,,7,11,7,3,0.2917,0.125,0,2,2,0,1,"/**
     * Convert base64 value to hex.
     *
     * @param value base64 value
     * @return hex value
     */
    public static String base64ToHex(String value) throws UnsupportedEncodingException {
        String hexValue = null;
        if (value != null) {
            hexValue = new String(Hex.encodeHex(Base64.decodeBase64(value.getBytes(""UTF-8""))));
        }
        return hexValue;
    }"
davmail-4.5.1,davmail.util.StringUtil,hexToBase64,,7,11,7,3,0.2917,0.125,0,2,2,0,1,"/**
     * Convert hex value to base64.
     *
     * @param value hex value
     * @return base64 value
     * @throws DecoderException on error
     */
    public static String hexToBase64(String value) throws DecoderException, UnsupportedEncodingException {
        String base64Value = null;
        if (value != null) {
            base64Value = new String(Base64.encodeBase64(Hex.decodeHex(value.toCharArray())), ""UTF-8"");
        }
        return base64Value;
    }"
davmail-4.5.1,davmail.util.StringUtil,encodeUrlcompname,,9,14,7,3,0.2857,0.1833,1,3,3,0,1,"/**
     * Encode item name to get actual value stored in urlcompname MAPI property.
     *
     * @param value decoded value
     * @return urlcompname encoded value
     */
    public static String encodeUrlcompname(String value) {
        String result = value;
        if (result != null) {
            for (PatternMap patternMap : URLENCODE_PATTERNS) {
                result = patternMap.replaceAll(result);
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,decodeUrlcompname,,9,14,7,3,0.2857,0.1833,1,3,3,0,1,"/**
     * Decode urlcompname to get item name.
     *
     * @param urlcompname encoded value
     * @return decoded value
     */
    public static String decodeUrlcompname(String urlcompname) {
        String result = urlcompname;
        if (result != null) {
            for (PatternMap patternMap : URLENCODED_PATTERNS) {
                result = patternMap.replaceAll(result);
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,encodePlusSign,,7,9,3,3,0.3333,0.2381,0,2,2,0,1,"/**
     * Urlencode plus sign in encoded href.
     * '+' is decoded as ' ' by URIUtil.decode, the workaround is to force urlencoding to '%2B' first
     *
     * @param value encoded href
     * @return encoded href
     */
    public static String encodePlusSign(String value) {
        String result = value;
        if (result.indexOf('+') >= 0) {
            result = PLUS_PATTERN.matcher(result).replaceAll(""%2B"");
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,base64ToUrl,,12,15,0,3,0.2778,0.3714,0,2,4,0,1,"/**
     * Encode EWS base64 itemId to url compatible value.
     *
     * @param value base64 value
     * @return url compatible value
     */
    public static String base64ToUrl(String value) {
        String result = value;
        if (result != null) {
            if (result.indexOf('+') >= 0) {
                result = PLUS_PATTERN.matcher(result).replaceAll(""-"");
            }
            if (result.indexOf('/') >= 0) {
                result = SLASH_PATTERN.matcher(result).replaceAll(""_"");
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,urlToBase64,,10,13,0,3,0.2813,0.3148,0,2,3,0,1,"/**
     * Encode EWS url compatible itemId back to base64 value.
     *
     * @param value url compatible value
     * @return base64 value
     */
    public static String urlToBase64(String value) {
        String result = value;
        if (result.indexOf('-') >= 0) {
            result = DASH_PATTERN.matcher(result).replaceAll(""+"");
        }
        if (result.indexOf('_') >= 0) {
            result = UNDERSCORE_PATTERN.matcher(result).replaceAll(""/"");
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,davSearchEncode,,7,9,3,3,0.3333,0.2381,0,2,2,0,1,"/**
     * Encode quotes in Dav search parameter.
     *
     * @param value search parameter
     * @return escaped value
     */
    public static String davSearchEncode(String value) {
        String result = value;
        if (result.indexOf('\'') >= 0) {
            result = APOS_PATTERN.matcher(result).replaceAll(""''"");
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,convertZuluDateTimeToAllDay,,17,52,38,4,0.1905,0.0723,0,6,4,0,1,"/**
     * Get allday date value from zulu timestamp.
     *
     * @param value zulu datetime
     * @return yyyyMMdd allday date value
     */
    public static String convertZuluDateTimeToAllDay(String value) {
        String result = value;
        if (value != null && value.length() != 8) {
            // try to convert datetime value to date value
            try {
                Calendar calendar = Calendar.getInstance();
                SimpleDateFormat dateParser = new SimpleDateFormat(""yyyyMMdd'T'HHmmss'Z'"");
                calendar.setTime(dateParser.parse(value));
                calendar.add(Calendar.HOUR_OF_DAY, 12);
                SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyyMMdd"");
                result = dateFormatter.format(calendar.getTime());
            } catch (ParseException e) {
                // ignore
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.StringUtil,removeQuotes,,12,15,0,3,0.4444,0.5143,0,2,8,0,1,"/**
     * Remove quotes if present on value.
     *
     * @param value input value
     * @return unquoted string
     */
    public static String removeQuotes(String value) {
        String result = value;
        if (result != null) {
            if (result.startsWith(""\"""") || result.startsWith(""{"") || result.startsWith(""("")) {
                result = result.substring(1);
            }
            if (result.endsWith(""\"""") || result.endsWith(""}"") || result.endsWith("")"")) {
                result = result.substring(0, result.length() - 1);
            }
        }
        return result;
    }"
davmail-4.5.1,davmail.util.IOUtil,write,,7,10,5,3,0.3333,0.131,0,4,2,0,1,"/**
     * Write all inputstream content to outputstream.
     *
     * @param inputStream  input stream
     * @param outputStream output stream
     * @throws IOException on error
     */
    public static void write(InputStream inputStream, OutputStream outputStream) throws IOException {
        byte[] bytes = new byte[8192];
        int length;
        while ((length = inputStream.read(bytes)) > 0) {
            outputStream.write(bytes, 0, length);
        }
    }"
davmail-4.5.1,davmail.util.IOUtil,resizeImage,,10,28,20,4,0.2222,0.0889,0,5,2,0,1,"/**
     * Resize image bytes to a max width or height image size.
     *
     * @param inputBytes input image bytes
     * @param max        max size
     * @return scaled image bytes
     * @throws IOException on error
     */
    public static byte[] resizeImage(byte[] inputBytes, int max) throws IOException {
        BufferedImage inputImage = ImageIO.read(new ByteArrayInputStream(inputBytes));
        if (inputImage == null) {
            throw new IOException(""Unable to decode image data"");
        }
        BufferedImage outputImage = resizeImage(inputImage, max);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(outputImage, ""jpg"", baos);
        return baos.toByteArray();
    }"
davmail-4.5.1,davmail.util.IOUtil,resizeImage,,19,75,30,3,0.25,0.1171,0,8,4,0,1,"/**
     * Resize image to a max width or height image size.
     *
     * @param inputImage input image
     * @param max        max size
     * @return scaled image
     */
    public static BufferedImage resizeImage(BufferedImage inputImage, int max) {
        int width = inputImage.getWidth();
        int height = inputImage.getHeight();
        int targetWidth;
        int targetHeight;
        if (width <= max && height <= max) {
            return inputImage;
        } else if (width > height) {
            targetWidth = max;
            targetHeight = targetWidth * height / width;
        } else {
            targetHeight = max;
            targetWidth = targetHeight * width / height;
        }
        Image scaledImage = inputImage.getScaledInstance(targetWidth, targetHeight, Image.SCALE_SMOOTH);
        BufferedImage targetImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB);
        targetImage.getGraphics().drawImage(scaledImage, 0, 0, null);
        return targetImage;
    }"
davmail-4.5.1,davmail.util.IOUtil,readFully,,9,20,12,3,0.3125,0.1296,0,4,2,0,1,"/**
     * Read all inputStream content to a byte array.
     *
     * @param inputStream input stream
     * @return content as byte array
     * @throws IOException on error
     */
    public static byte[] readFully(InputStream inputStream) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] bytes = new byte[8192];
        int length;
        while ((length = inputStream.read(bytes)) > 0) {
            baos.write(bytes, 0, length);
        }
        return baos.toByteArray();
    }"
davmail-4.5.1,davmail.web.DavGatewayServletContextListener,contextInitialized,,19,48,30,4,0.2083,0.1717,0.8,4,4,0,1,"public void contextInitialized(ServletContextEvent event) {
        InputStream settingInputStream = null;
        try {
            settingInputStream = DavGatewayServletContextListener.class.getClassLoader().getResourceAsStream(""davmail.properties"");
            Settings.load(settingInputStream);
            DavGateway.start();
        } catch (IOException e) {
            DavGatewayTray.error(new BundleMessage(""LOG_ERROR_LOADING_SETTINGS""), e);
        } finally {
            if (settingInputStream != null) {
                try {
                    settingInputStream.close();
                } catch (IOException e) {
                    DavGatewayTray.debug(new BundleMessage(""LOG_ERROR_CLOSING_CONFIG_FILE""), e);
                }
            }
        }
        DavGatewayTray.debug(new BundleMessage(""LOG_DAVMAIL_STARTED""));
    }"
fckeditor-2.6,net.fckeditor.FCKeditor,escapeXml,,40,54,30,2,0.25,0.2933,1,5,8,0,1,"/**
	 * Escapes base XML entities as specified <a
	 * href=""http://en.wikipedia.org/wiki/Xml#Entity_references"">here</a>.
	 * 
	 * @param str
	 *            string to escape, empty strings will be ignored
	 * @return escaped string
	 */
	private String escapeXml(String str) {

		if (Utils.isEmpty(str))
			return str;

		StringBuffer sb = new StringBuffer();

		int len = str.length();
		char c;

		for (int i = 0; i < len; i++) {

			c = str.charAt(i);
			switch (c) {
			case '&':
				sb.append(""&amp;"");
				break;
			case '<':
				sb.append(""&lt;"");
				break;
			case '>':
				sb.append(""&gt;"");
				break;
			case '""':
				sb.append(""&quot;"");
				break;
			// XML actually defines &apos; as entity for the apostrophe but we
			// user rather the numerical reference to avoid XHTML 1.0 validation
			// problems
			case '\'':
				sb.append(""&#39;"");
				break;
			default:
				sb.append(c);
				break;
			}
		}

		return sb.toString();
	}"
fckeditor-2.6,net.fckeditor.FCKeditor,toString,,54,340,245,2,0.0982,0.0872,0.8,6,4,1,1,"/**
	 * Creates the HTML representation of this editor instance. First of all,
	 * this method determines whether the request browser is supported.
	 * According to the result an appropriate HTML representation is assembled
	 * and returned.
	 * 
	 * @return HTML representation of this editor instance
	 */
	@Override
	public String toString() {
		StringBuffer strEditor = new StringBuffer();

		strEditor.append(""<div>"");
		String encodedValue = escapeXml(value);
		
		/*
		 * We have to reset inputName to make sure that a potentially reassigned
		 * instanceName has been propagated to empty field.
		 */
		setInputName(inputName);

		if (Compatibility.isCompatibleBrowser(request)) {
			strEditor.append(createInputForVariable(instanceName, inputName,
					encodedValue));

			// create config HTML
			String configStr = fckConfig.getUrlParams();
			if (Utils.isNotEmpty(configStr))
				strEditor.append(createInputForVariable(instanceName
						.concat(""___Config""), null, configStr));

			// create IFrame
			StringBuffer editorLink = new StringBuffer(request.getContextPath());
			editorLink.append(basePath);
			editorLink.append(""/editor/fckeditor.html?InstanceName="").append(
					instanceName);
			if (Utils.isNotEmpty(toolbarSet))
				editorLink.append(""&amp;Toolbar="").append(toolbarSet);

			XHtmlTagTool iframeTag = new XHtmlTagTool(""iframe"",
					XHtmlTagTool.SPACE);
			iframeTag.addAttribute(""id"", instanceName.concat(""___Frame""));
			iframeTag.addAttribute(""src"", editorLink.toString());
			iframeTag.addAttribute(""width"", width);
			iframeTag.addAttribute(""height"", height);
			iframeTag.addAttribute(""frameborder"", ""0"");
			iframeTag.addAttribute(""scrolling"", ""no"");
			strEditor.append(iframeTag);

		} else {
			XHtmlTagTool textareaTag = new XHtmlTagTool(""textarea"",
					encodedValue);
			textareaTag.addAttribute(""name"", inputName);
			textareaTag.addAttribute(""rows"", ""4"");
			textareaTag.addAttribute(""cols"", ""40"");
			textareaTag.addAttribute(""wrap"", ""virtual"");
			textareaTag.addAttribute(""style"", ""width: "".concat(width).concat(
					""; height: "").concat(height));
		}
		strEditor.append(""</div>"");
		return strEditor.toString();
	}"
fckeditor-2.6,net.fckeditor.FCKeditor,createInputForVariable,,9,12,0,2,0.275,0.3155,0.333333333,4,1,0,1,"/**
	 * Creates a hidden input element for the given attributes.
	 * @param id
	 *            id attribute of the input tag
	 * @param name
	 *            name attribute of the input tag
	 * @param value
	 *            value attribute of the input tag
	 * 
	 * @return the produced XHTML tag
	 */
	private String createInputForVariable(final String id, final String name,
			final String value) {
		XHtmlTagTool tag = new XHtmlTagTool(""input"");
		tag.addAttribute(""id"", id);
		tag.addAttribute(""name"", name);
		tag.addAttribute(""value"", value);
		tag.addAttribute(""type"", ""hidden"");
		return tag.toString();
	}"
fckeditor-2.6,net.fckeditor.connector.Dispatcher,Dispatcher,,17,23,10,2,0.254,0.169,1,4,3,0,1,"/**
	 * Initializes this dispatcher. It initializes the connector internally.
	 * Called at connector servlet {@link ConnectorServlet#init()
	 * initialization}.
	 * 
	 * @param servletContext
	 *            reference to the {@link ServletContext} in which the caller is
	 *            running
	 * @throws Exception
	 *             if the dispatcher initialization fails due to some reason
	 */
	Dispatcher(final ServletContext servletContext) throws Exception {	
		// try to instantiate the Connector object
		String className = PropertiesLoader.getConnectorImpl();
		if (Utils.isEmpty(className))
			logger.error(""Empty Connector implementation class name provided"");
		else {
			try {
				Class<?> clazz = Class.forName(className);
				connector = (Connector) clazz.newInstance();
				logger.info(""Connector initialized to {}"", className);
			} catch (Throwable e) {
				logger.error(""Connector implementation {} could not be instantiated"", className);
				throw new RuntimeException(""Connector implementation "" + className + "" could not be instantiated"", e); //$NON-NLS-1$
			}
		}
		connector.init(servletContext);
	}"
fckeditor-2.6,net.fckeditor.connector.Dispatcher,doGet,,75,431,232,4,0.1512,0.1279,0.357142857,13,18,0,1,"/**
	 * Called by the connector servlet to handle a {@code GET} request. In
	 * particular, it handles the {@link Command#GET_FOLDERS GetFolders},
	 * {@link Command#GET_FOLDERS_AND_FILES GetFoldersAndFiles} and
	 * {@link Command#CREATE_FOLDER CreateFolder} commands.
	 * 
	 * @param request
	 *            the current request instance
	 * @return the get response instance associated with this request
	 */
	GetResponse doGet(final HttpServletRequest request) {
		logger.debug(""Entering Dispatcher#doGet"");
		
		Context context = ThreadLocalData.getContext();
		context.logBaseParameters();
		
		GetResponse getResponse = null;
		// check parameters
		if (!Command.isValidForGet(context.getCommandStr()))
			getResponse = GetResponse.getInvalidCommandError();
		else if (!ResourceType.isValidType(context.getTypeStr()))
			getResponse = GetResponse.getInvalidResourceTypeError();
		else if (!UtilsFile.isValidPath(context.getCurrentFolderStr()))
			getResponse = GetResponse.getInvalidCurrentFolderError();
		else {
			
			// in contrast to doPost the referrer has to send an explicit type
			ResourceType type = context.getResourceType();
			Command command = context.getCommand();
			
			// check permissions for user action
			if ((command.equals(Command.GET_FOLDERS) || command.equals(Command.GET_FOLDERS_AND_FILES))
					&& !RequestCycleHandler.isGetResourcesEnabled(request))
				getResponse = GetResponse.getGetResourcesDisabledError();
			else if (command.equals(Command.CREATE_FOLDER) && !RequestCycleHandler.isCreateFolderEnabled(request))
				getResponse = GetResponse.getCreateFolderDisabledError();
			else {
				// make the connector calls, catch its exceptions and generate
				// the proper response object
				try {
					if (command.equals(Command.CREATE_FOLDER)) {
						String newFolderNameStr = request
								.getParameter(""NewFolderName"");
						logger.debug(""Parameter NewFolderName: {}"",
								newFolderNameStr);				
						String sanitizedNewFolderNameStr = UtilsFile
								.sanitizeFolderName(newFolderNameStr);
						if (Utils.isEmpty(sanitizedNewFolderNameStr))
							getResponse = GetResponse
									.getInvalidNewFolderNameError();
						else {
							logger.debug(
									""Parameter NewFolderName (sanitized): {}"",
									sanitizedNewFolderNameStr);
							connector.createFolder(type, context
									.getCurrentFolderStr(),
									sanitizedNewFolderNameStr);
							getResponse = GetResponse.getOK();
						}
					} else if (command.equals(Command.GET_FOLDERS)
							|| command
									.equals(Command.GET_FOLDERS_AND_FILES)) {
						String url = UtilsResponse.getUrl(RequestCycleHandler
								.getUserFilesPath(request), type, context
								.getCurrentFolderStr());
						getResponse = getFoldersAndOrFiles(command, type, context
								.getCurrentFolderStr(), url);
					}
				} catch (InvalidCurrentFolderException e) {
					getResponse = GetResponse.getInvalidCurrentFolderError();
				} catch (InvalidNewFolderNameException e) {
					getResponse = GetResponse.getInvalidNewFolderNameError();
				} catch (FolderAlreadyExistsException e) {
					getResponse = GetResponse.getFolderAlreadyExistsError();
				} catch (WriteException e) {
					getResponse = GetResponse.getCreateFolderWriteError();
				} catch (ReadException e) {
					getResponse = GetResponse.getGetResourcesReadError();
				}
			}
		}
		
		logger.debug(""Exiting Dispatcher#doGet"");
		return getResponse;
	}"
fckeditor-2.6,net.fckeditor.connector.Dispatcher,doPost,,75,520,337,4,0.1239,0.0944,0.384615385,16,14,1,1,"/**
	 * Called by the connector servlet to handle a {@code POST} request. In
	 * particular, it handles the {@link Command#FILE_UPLOAD FileUpload} and
	 * {@link Command#QUICK_UPLOAD QuickUpload} commands.
	 * 
	 * @param request
	 *            the current request instance
	 * @return the upload response instance associated with this request
	 */
	UploadResponse doPost(final HttpServletRequest request) {
		logger.debug(""Entering Dispatcher#doPost"");
		
		Context context = ThreadLocalData.getContext();
		context.logBaseParameters();
		
		UploadResponse uploadResponse = null;
		// check permissions for user actions
		if (!RequestCycleHandler.isFileUploadEnabled(request))
			uploadResponse = UploadResponse.getFileUploadDisabledError();
		// check parameters  
		else if (!Command.isValidForPost(context.getCommandStr()))
			uploadResponse = UploadResponse.getInvalidCommandError();
		else if (!ResourceType.isValidType(context.getTypeStr()))
			uploadResponse = UploadResponse.getInvalidResourceTypeError();
		else if (!UtilsFile.isValidPath(context.getCurrentFolderStr()))
			uploadResponse = UploadResponse.getInvalidCurrentFolderError();
		else {

			// call the Connector#fileUpload
			ResourceType type = context.getDefaultResourceType();
			FileItemFactory factory = new DiskFileItemFactory();
			ServletFileUpload upload = new ServletFileUpload(factory);
			try {
				List<FileItem> items = upload.parseRequest(request);
				// We upload just one file at the same time
				FileItem uplFile = items.get(0);
				// Some browsers transfer the entire source path not just the
				// filename
				String fileName = FilenameUtils.getName(uplFile.getName());
				logger.debug(""Parameter NewFile: {}"", fileName);
				// check the extension
				if (type.isDeniedExtension(FilenameUtils.getExtension(fileName)))
					uploadResponse = UploadResponse.getInvalidFileTypeError();
				// Secure image check (can't be done if QuickUpload)
				else if (type.equals(ResourceType.IMAGE)
						&& PropertiesLoader.isSecureImageUploads()
						&& !UtilsFile.isImage(uplFile.getInputStream())) {
					uploadResponse = UploadResponse.getInvalidFileTypeError();
				} else {
					String sanitizedFileName = UtilsFile
							.sanitizeFileName(fileName);
					logger.debug(""Parameter NewFile (sanitized): {}"",
							sanitizedFileName);
					String newFileName = connector.fileUpload(type, context
							.getCurrentFolderStr(), sanitizedFileName, uplFile
							.getInputStream());
					String fileUrl = UtilsResponse.fileUrl(RequestCycleHandler
							.getUserFilesPath(request), type, context
							.getCurrentFolderStr(), newFileName);

					if (sanitizedFileName.equals(newFileName))
						uploadResponse = UploadResponse.getOK(fileUrl);
					else {
						uploadResponse = UploadResponse.getFileRenamedWarning(fileUrl, newFileName);
						logger.debug(""Parameter NewFile (renamed): {}"",
								newFileName);
					}
				}
				
				uplFile.delete();
			} catch (InvalidCurrentFolderException e) {
				uploadResponse = UploadResponse.getInvalidCurrentFolderError();
			} catch (WriteException e) {
				uploadResponse = UploadResponse.getFileUploadWriteError();
			} catch (IOException e) {
				uploadResponse = UploadResponse.getFileUploadWriteError();
			} catch (FileUploadException e) {
				uploadResponse = UploadResponse.getFileUploadWriteError();
			}
		}
		
		logger.debug(""Exiting Dispatcher#doPost"");
		return uploadResponse;
	}"
fckeditor-2.6,net.fckeditor.connector.ConnectorServlet,doGet,,29,100,80,4,0.1563,0.0958,0.666666667,5,2,0,1,"/**
	 * Passes a GET request to the dispatcher.
	 * 
	 * @throws IOException
	 *             if an input or output error is detected when the servlet
	 *             handles the GET request
	 * @throws ServletException
	 *             if the request for the GET could not be handled
	 */
	@Override
	protected void doGet(final HttpServletRequest request,
			final HttpServletResponse response) throws ServletException,
			IOException {
		request.setCharacterEncoding(""UTF-8"");
		response.setCharacterEncoding(""UTF-8"");
		response.setContentType(""application/xml"");
		response.setHeader(""Cache-Control"", ""no-cache"");
		PrintWriter out = response.getWriter();
		GetResponse getResponse = null;

		try {
			ThreadLocalData.beginRequest(request);
			getResponse = dispatcher.doGet(request);
		} catch (Exception e) {
			throw new ServletException(e);
		} finally {
			/*
			 * call this method to prevent detached requests or else the request
			 * will probably never be garbage collected and will fill your
			 * memory
			 */
			ThreadLocalData.endRequest();
		}

		out.print(getResponse);
		out.flush();
		out.close();
	}"
fckeditor-2.6,net.fckeditor.connector.ConnectorServlet,doPost,,29,100,80,4,0.1563,0.0958,0.666666667,5,2,0,1,"/**
	 * Passes a POST request to the dispatcher.
	 * 
	 * @throws IOException
	 *             if an input or output error is detected when the servlet
	 *             handles the request
	 * @throws ServletException
	 *             if the request for the POST could not be handled
	 */
	@Override
	protected void doPost(final HttpServletRequest request,
			final HttpServletResponse response) throws ServletException,
			IOException {
		request.setCharacterEncoding(""UTF-8"");
		response.setCharacterEncoding(""UTF-8"");
		response.setContentType(""text/html"");
		response.setHeader(""Cache-Control"", ""no-cache"");
		PrintWriter out = response.getWriter();
		UploadResponse uploadResponse = null;

		try {
			ThreadLocalData.beginRequest(request);
			uploadResponse = dispatcher.doPost(request);
		} catch (Exception e) {
			throw new ServletException(e);
		} finally {
			/*
			 * call this method to prevent detached requests or else the request
			 * will probably never be garbage collected and will fill your
			 * memory
			 */
			ThreadLocalData.endRequest();
		}

		out.print(uploadResponse);
		out.flush();
		out.close();
	}"
fckeditor-2.6,net.fckeditor.connector.impl.AbstractLocalFileSystemConnector,fileUpload,,21,46,37,4,0.1307,0.0404,1,10,4,0,1,"public String fileUpload(final ResourceType type,
			final String currentFolder, final String fileName,
			final InputStream inputStream)
			throws InvalidCurrentFolderException, WriteException {
		String absolutePath = getRealUserFilesAbsolutePath(RequestCycleHandler
				.getUserFilesAbsolutePath(ThreadLocalData.getRequest()));
		File typeDir = getOrCreateResourceTypeDir(absolutePath, type);
		File currentDir = new File(typeDir, currentFolder);
		if (!currentDir.exists() || !currentDir.isDirectory())
			throw new InvalidCurrentFolderException();

		File newFile = new File(currentDir, fileName);
		File fileToSave = UtilsFile.getUniqueFile(newFile.getAbsoluteFile());

		try {
			IOUtils.copyLarge(inputStream, new FileOutputStream(fileToSave));
		} catch (IOException e) {
			throw new WriteException();
		}
		return fileToSave.getName();
	}"
fckeditor-2.6,net.fckeditor.connector.impl.AbstractLocalFileSystemConnector,createFolder,,17,20,12,2,0.2,0.1036,1,7,5,0,1,"public void createFolder(final ResourceType type,
			final String currentFolder, final String newFolder)
			throws InvalidCurrentFolderException,
			InvalidNewFolderNameException, FolderAlreadyExistsException {
		String absolutePath = getRealUserFilesAbsolutePath(RequestCycleHandler
				.getUserFilesAbsolutePath(ThreadLocalData.getRequest()));
		File typeDir = getOrCreateResourceTypeDir(absolutePath, type);
		File currentDir = new File(typeDir, currentFolder);
		if (!currentDir.exists() || !currentDir.isDirectory())
			throw new InvalidCurrentFolderException();

		File newDir = new File(currentDir, newFolder);
		if (newDir.exists())
			throw new FolderAlreadyExistsException();
		if (!newDir.mkdir())
			throw new InvalidNewFolderNameException();
	}"
fckeditor-2.6,net.fckeditor.connector.impl.ContextConnector,init,,13,32,28,6,0.1944,0.1061,1,3,2,0,1,"/**
	 * {@inheritDoc}
	 * This method will prepare the connector for further usage, additionally it
	 * will check if the aforementioned drawback exists. It will try to resolve
	 * the default {@link PropertiesLoader#getUserFilesPath() UserFilesPath}
	 * with
	 * <code><a href=""http://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/ServletContext.html#getRealPath(java.lang.String)""
	 * target=""_blank"">ServletContext.getRealPath(String)</a></code> against the
	 * local filesystem (real path). If it fails, it will emit helpful log
	 * messages and will throw an exception too.
	 */
	public void init(final ServletContext servletContext) throws Exception {
		this.servletContext = servletContext;
		String defaultAbsolutePath = getRealUserFilesAbsolutePath(PropertiesLoader
				.getUserFilesPath());

		if (defaultAbsolutePath == null) {
			logger.error(""The context root cannot be resolved against the local filesystem"");
			logger.info(""Your servlet container/application server does not expand deployed war files"");
			logger.debug(""Use another Connector implementation (e.g. LocalConnector) and consult http://www.fckeditor.net/forums/viewtopic.php?f=6&t=11568"");
			throw new NullPointerException(
					""The real context root cannot be resolved against the local filesystem"");
		}
	}"
fckeditor-2.6,net.fckeditor.handlers.ResourceType,ResourceType,,17,19,10,4,0.275,0.1786,0,8,5,0,1,"/**
	 * This constructor has been made intentionally made private to provide
	 * pre-defined types only.
	 * 
	 * @param name
	 *            the name of the new resource type
	 * @param path
	 *            the absolute path of the new resource type
	 * @param allowedEextensions
	 *            the allowed extensions set of the new resource type
	 * @param deniedExtensions
	 *            the denied extensions set of the new resource type
	 * @throws IllegalArgumentException
	 *             if both sets are empty
	 * @throws IllegalArgumentException
	 *             if both sets contain extensions
	 */
	private ResourceType(final String name, final String path,
			final Set<String> allowedEextensions,
			final Set<String> deniedExtensions) {
		this.name = name;
		this.path = path;

		if (allowedEextensions.isEmpty() && deniedExtensions.isEmpty())
			throw new IllegalArgumentException(
					""Both sets are empty, one has always to be filled"");

		if (!allowedEextensions.isEmpty() && !deniedExtensions.isEmpty())
			throw new IllegalArgumentException(
					""Both sets contain extensions, only one can be filled at the same time"");

		this.allowedEextensions = allowedEextensions;
		this.deniedExtensions = deniedExtensions;
	}"
fckeditor-2.6,net.fckeditor.handlers.ResourceType,isAllowedExtension,,10,6,2,2,0.4,0.1733,1,2,4,0,1,"/**
	 * Returns <code>true</code> if extension is allowed. Denied extensions set
	 * takes precedence over allowed extensions set, in other words a negative
	 * check is made against denied set and if this fails, allowed set is
	 * checked.
	 * 
	 * @param extension
	 *            the extension to check, empty will fail
	 * @return <code>true</code> if extension is allowed, else
	 *         <code>false</code>
	 */
	public boolean isAllowedExtension(final String extension) {
		if (Utils.isEmpty(extension))
			return false;
		String ext = extension.toLowerCase();
		if (allowedEextensions.isEmpty())
			return !deniedExtensions.contains(ext);
		if (deniedExtensions.isEmpty())
			return allowedEextensions.contains(ext);
		return false;
	}"
fckeditor-2.6,net.fckeditor.localization.LocalizedMessages,LocalizedMessages,,46,149,108,4,0.1393,0.0728,0,9,9,0,1,"/**
	 * Loads the localized messages for the given locale. This constructor loads
	 * the resource bundle for this locale and only for this, in other words it
	 * short-circuits the default resource bundle load mechanism in order to
	 * prevent the loading of the system default locale which may result in a
	 * completely different resource bundle.
	 * 
	 * @param locale
	 *            the locale of the new localized messages
	 */
	private LocalizedMessages(Locale locale) {

		properties = new Properties(defaultProperties);

		ResourceBundle localized = null;
		try {
			localized = ResourceBundle.getBundle(LOCAL_PROPERTIES, locale,
					Thread.currentThread().getContextClassLoader());
		} catch (Exception e) {
			; // do nothing
		}

		if (localized != null
				&& localized.getLocale().getLanguage().equals(
						locale.getLanguage())) {
			Enumeration<String> keys = localized.getKeys();

			while (keys.hasMoreElements()) {
				String key = keys.nextElement();
				properties.setProperty(key, localized.getString(key));
			}

			logger.debug(""Resource bundle for locale '{}' loaded"", locale); //$NON-NLS-1$
		} else {
			logger.debug(""No resource bundle for locale '{}' found, loading default bundle"", locale); //$NON-NLS-1$

			ResourceBundle base = null;
			try {
				base = ResourceBundle.getBundle(LOCAL_PROPERTIES, NEUTRAL,
						Thread.currentThread().getContextClassLoader());
			} catch (Exception e) {
				; // do nothing
			}

			if (base != null && base.getLocale().equals(NEUTRAL)) {
				Enumeration<String> keys = base.getKeys();

				while (keys.hasMoreElements()) {
					String key = keys.nextElement();
					properties.setProperty(key, base.getString(key));
				}
			}

		}

	}"
fckeditor-2.6,net.fckeditor.requestcycle.Context,Context,,18,24,12,3,0.3056,0.1619,1,1,6,0,1,"/**
	 * Sole class constructor. Takes in a request instance, processes parameters
	 * and populates private fields which can be accessed through getters.<br />
	 * This class will only be instantiated in {@link ThreadLocalData}.
	 * 
	 * @param request
	 *            current user request instance
	 */
	protected Context(final HttpServletRequest request) {
		commandStr = request.getParameter(""Command"");
		typeStr = request.getParameter(""Type"");
		currentFolderStr = request.getParameter(""CurrentFolder"");
		
		// if this is a QuickUpload request, 'commandStr', 'currentFolderStr'
		// are empty and 'typeStr' maybe empty too
		if (Utils.isEmpty(commandStr) && Utils.isEmpty(currentFolderStr)) {
			commandStr = ""QuickUpload"";
			currentFolderStr = ""/"";
			if (Utils.isEmpty(typeStr))
				typeStr = ""File"";
		}
		
		// checks to meet specs in http://docs.fckeditor.net/FCKeditor_2.x/Developers_Guide/Server_Side_Integration#File_Browser_Requests
		if (currentFolderStr != null && !currentFolderStr.startsWith(""/""))
			currentFolderStr = ""/"".concat(currentFolderStr);
	}"
fckeditor-2.6,net.fckeditor.response.GetResponse,GetResponse,,14,39,33,5,0.175,0.0758,0,6,2,0,1,"/**
	 * Constructs a response with a specific error number and message.
	 * 
	 * @param number
	 *            the error number of the new get response
	 * @param message
	 *            the specific message of the new get response
	 * @throws RuntimeException
	 *             if creation of the underlying DOM document failed
	 */
	public GetResponse(int number, String message) {
		try {
			DocumentBuilderFactory factory = DocumentBuilderFactory
					.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.newDocument();
		} catch (ParserConfigurationException e) {
			throw new RuntimeException(e);
		}

		Element root = document.createElement(""Connector"");
		document.appendChild(root);
		setError(number, message);
	}"
fckeditor-2.6,net.fckeditor.response.GetResponse,GetResponse,,24,54,30,2,0.1678,0.1197,1,9,2,0,1,"/**
	 * Constructs a successful response for a specific command and resource
	 * type.
	 * 
	 * @param command
	 *            the current command of the new get response
	 * @param type
	 *            the current resource type of the new get response
	 * @param currentFolder
	 *            the current folder of the new get response
	 * @param constructedUrl
	 *            the final URL of the new get response
	 * @throws RuntimeException
	 *             if creation of the underlying DOM document failed
	 */
	public GetResponse(Command command, ResourceType type,
			String currentFolder, String constructedUrl) {

		try {
			DocumentBuilderFactory factory = DocumentBuilderFactory
					.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			document = builder.newDocument();
		} catch (ParserConfigurationException e) {
			throw new RuntimeException(e);
		}

		Element root = document.createElement(""Connector"");
		document.appendChild(root);
		root.setAttribute(""command"", command.getName());
		root.setAttribute(""resourceType"", type.getName());

		Element currentFolderElement = document.createElement(""CurrentFolder"");
		currentFolderElement.setAttribute(""path"", currentFolder);

		currentFolderElement.setAttribute(""url"", constructedUrl);
		root.appendChild(currentFolderElement);

	}"
fckeditor-2.6,net.fckeditor.response.GetResponse,toString,,20,57,48,4,0.15,0.0569,0,6,2,0,1,"/**
	 * Creates the XML representation of this get response. The underlying DOM
	 * document will transformed to a string.
	 * 
	 * @throws RuntimeException
	 *             if creation failed
	 * @return XML representation of this get response
	 */
	@Override
	public String toString() {
		document.getDocumentElement().normalize();
		TransformerFactory factory = TransformerFactory.newInstance();

		StringWriter sw = new StringWriter();

		try {
			Transformer transformer = factory.newTransformer();

			DOMSource source = new DOMSource(document);
			StreamResult result = new StreamResult(sw);

			transformer.transform(source, result);
		} catch (TransformerException e) {
			throw new RuntimeException(e);
		}

		return sw.toString();
	}"
fckeditor-2.6,net.fckeditor.response.UploadResponse,toString,,28,53,0,3,0.2794,0.5086,0,2,4,1,1,"/**
	 * Creates the HTML/JS representation of this upload response.
	 * 
	 * @return HTML/JS representation of this upload response
	 */
	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer(400);
		sb.append(""<script type=\""text/javascript\"">\n"");
		// Compressed version of the document.domain automatic fix script.
		// The original script can be found at
		// [fckeditor_dir]/_dev/domain_fix_template.js
		sb.append(""(function(){var d=document.domain;while (true){try{var A=window.parent.document.domain;break;}catch(e) {};d=d.replace(/.*?(?:\\.|$)/,'');if (d.length==0) break;try{document.domain=d;}catch (e){break;}}})();\n"");
		sb.append(""window.parent.OnUploadCompleted("");

		for (Object parameter : parameters) {
			if (parameter instanceof Integer) {
				sb.append(parameter);
			} else {
				sb.append(""'"");
				if (parameter != null)
					sb.append(parameter);
				sb.append(""'"");
			}
			sb.append("","");
		}

		sb.deleteCharAt(sb.length() - 1);
		sb.append("");\n"");
		sb.append(""</script>"");

		return sb.toString();
	}"
fckeditor-2.6,net.fckeditor.tags.EditorTag,doStartTag,,24,2,1,2,0.6667,0.3333,0.285714286,1,7,1,0,"@Override
	public int doStartTag() throws JspException {

		try {
			setFckEditor(new FCKeditor((HttpServletRequest) pageContext
					.getRequest(), getInstanceName(), getInputName()));

			if (Utils.isNotEmpty(getWidth()))
				getFckEditor().setWidth(getWidth());
			if (Utils.isNotEmpty(getHeight()))
				getFckEditor().setHeight(getHeight());
			if (Utils.isNotEmpty(getToolbarSet()))
				getFckEditor().setToolbarSet(getToolbarSet());
			if (Utils.isNotEmpty(getValue()))
				getFckEditor().setValue(getValue());
			if (Utils.isNotEmpty(getBasePath()))
				getFckEditor().setBasePath(getBasePath());

		} catch (Exception e) {
			throw new JspException(e);
		}

		return EVAL_BODY_INCLUDE;
	}"
fckeditor-2.6,net.fckeditor.tags.CheckTag,doStartTag,,46,111,12,4,0.1905,0.1771,0.230769231,5,10,1,1,"@Override
	public int doStartTag() throws JspException {
		JspWriter out = pageContext.getOut();

		HttpServletRequest request = (HttpServletRequest) pageContext
				.getRequest();
		LocalizedMessages lm = LocalizedMessages.getInstance(request);
		String response = null;

		if (command.equals(FILE_UPLOAD)) {
			if (RequestCycleHandler.isFileUploadEnabled(request))
				response = lm.getFileUploadEnabled();
			else
				response = lm.getFileUploadDisabled();
		}

		if (command.equals(GET_RESOURCES)) {
			if (RequestCycleHandler.isGetResourcesEnabled(request))
				response = lm.getGetResourcesEnabled();
			else
				response = lm.getGetResourcesDisabled();
		}

		if (command.equals(CREATE_FOLDER)) {
			if (RequestCycleHandler.isCreateFolderEnabled(request))
				response = lm.getCreateFolderEnabled();
			else
				response = lm.getCreateFolderDisabled();
		}

		if (command.equals(COMPATIBLE_BROWSER)) {
			if (Compatibility.isCompatibleBrowser(request))
				response = lm.getCompatibleBrowserYes();
			else
				response = lm.getCompatibleBrowserNo();
		}

		try {
			out.print(response);
		} catch (IOException e) {
			throw new JspException(
					""Tag response could not be written to the user!"", e);
		}

		return SKIP_BODY;
	}"
fckeditor-2.6,net.fckeditor.tags.ConfigTag,doStartTag,,14,4,2,2,0.375,0.125,1,3,3,0,1,"@Override
	public int doStartTag() throws JspException {

		Tag ancestor = findAncestorWithClass(this, EditorTag.class);
		if (ancestor == null)
			throw new JspException(
					""the config tag can only be nested within an editor tag"");
		EditorTag editorTag = (EditorTag) ancestor;

		for (Map.Entry<String, String> option : params.entrySet())
			editorTag.setConfig(option.getKey(), option.getValue());

		return SKIP_BODY;
	}"
fckeditor-2.6,net.fckeditor.tool.XHtmlTagTool,toString,,22,34,13,2,0.2597,0.1797,1,3,3,1,1,"/**
	 * Creates the HTML representation of this tag. It follows the XHTML
	 * standard.
	 * 
	 * @return HTML representation of this tag
	 */
	@Override
	public String toString() {
		StringBuffer tag = new StringBuffer();

		// open tag
		tag.append(""<"").append(name);

		// add attributes
		for (String key : attributes.keySet()) {
			String val = attributes.get(key);
			tag.append(' ').append(key).append('=').append('\""').append(val)
					.append('\""');
		}

		// close the tag
		if (Utils.isNotEmpty(value)) {
			tag.append("">"").append(value).append(""</"").append(name).append('>');
		} else
			tag.append("" />"");

		return tag.toString();
	}"
fckeditor-2.6,net.fckeditor.tool.UtilsResponse,fileUrl,,13,5,0,2,0.3,0.2667,1,5,3,0,1,"/**
	 * 
	 * Assembles a file URL for the File Browser. Simply appends parameters to a
	 * string buffer with reasonable parameter checking.
	 * 
	 * @param userFilesPath
	 *            the current userfiles path (may be null)
	 * @param type
	 *            the current resource type
	 * @param currentFolder
	 *            the selected current folder
	 * @param filename
	 *            the current chosen file (may be null)
	 * @return assembled url for the File Browser
	 */
	public static String fileUrl(String userFilesPath, ResourceType type,
			String currentFolder, String filename) {

		StringBuffer sb = new StringBuffer();
		if (Utils.isNotEmpty(userFilesPath))
			sb.append(userFilesPath);
		sb.append(type.getPath());
		sb.append(currentFolder);
		if (Utils.isNotEmpty(filename))
			sb.append(filename);

		return sb.toString();
	}"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,compile,,93,1089,1002,8,0.0593,0.0336,0.4,18,10,0,1,"public boolean compile(File skelroot, SkeletonBean skel, File basedir ,JSmoothModelBean data, File out) throws Exception
    {
	try {
	    fireStepChange(0, ""Starting compilation"");
	    
	    File pattern = new File(skelroot, skel.getExecutableName());
	    if (pattern.exists() == false)
		{
		    m_errors.add(""Error: Can't find any skeleton at "" + skelroot);
		    fireFailedChange();
		    return false;
		}
			
	    fireStepChange(10, ""Scanning skeleton..."");
	    PEFile pe = new PEFile(pattern);
	    pe.open();
	    PEResourceDirectory resdir = pe.getResourceDirectory();

	    boolean resb = false;
		
	    //
	    // Adds the jar only if the user selected one
	    //
	    if (data.getEmbeddedJar() == true)
		{
		    if (data.getJarLocation() == null)
			{
			    m_errors.add(""Error: Jar is not specified!"");
			    fireFailedChange();
			    return false;
			}
			
		    fireStepChange(40, ""Loading Jar..."");
		    File jarloc = concFile(basedir, new File(data.getJarLocation()));
		    if (jarloc.exists() == false)
			{
			    m_errors.add(""Error: Can't find jar at "" + jarloc);
			    fireFailedChange();
			    return false;
			}

		    ByteBuffer jardata = load(jarloc);

		    fireStepChange(60, ""Adding Jar to Resources..."");
		    resb = resdir.replaceResource(skel.getResourceCategory(), skel.getResourceJarId(), 1033, jardata);
		    if (resb == false)
			{
			    m_errors.add(""Error: Can't replace jar resource! It is probably missing from the skeleton."");
			    fireFailedChange();
			    return false;
			}
		}
	    
	    fireStepChange(70, ""Adding Properties to Resources..."");
	    String props = PropertiesBuilder.makeProperties(basedir, data);
	    ByteBuffer propdata = convert(props);
	    resb = resdir.replaceResource(skel.getResourceCategory(), skel.getResourcePropsId(), 1033, propdata);

	    if (data.getIconLocation() != null)
		{
		    fireStepChange(80, ""Loading icon..."");
		    String iconpath;
		    if (new java.io.File(data.getIconLocation()).isAbsolute())
			iconpath = data.getIconLocation();
		    else
			iconpath = new java.io.File(basedir, data.getIconLocation()).getAbsolutePath();

		    Image img = getScaledImage(iconpath, 32, 32);
		    Hashtable set = calculateColorCount(img);
		    //		    System.out.println(""COLORS TOTAL 4: "" + set.size());

		    if (img != null)
			{
			    net.charabia.jsmoothgen.pe.res.ResIcon resicon = new net.charabia.jsmoothgen.pe.res.ResIcon(img);
			    pe.replaceDefaultIcon(resicon);
			}
		}

	    fireStepChange(90, ""Saving exe..."");
	    pe.dumpTo(out);
			
	    //		System.out.println(""PROPERTIES:\n"" + props);
			
	    fireCompleteChange();
	    return true;
	} catch (Exception exc)
	    {
		m_errors.add(""Error: "" + exc.getMessage());
		exc.printStackTrace();
		fireFailedChange();
		return false;
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,loadImages,,29,63,48,4,0.1731,0.0877,1,6,5,0,1,"public Image[] loadImages(String path)
    {
	File f = new File(path);

	if (path.toUpperCase().endsWith("".ICO""))
	    {
		//
		// Try to load with our ico codec...
		//
		try {
		    java.awt.Image[] images = net.charabia.util.codec.IcoCodec.loadImages(f);
		    if ((images != null) && (images.length>0))
			{
			    return images;
			}
		} catch (java.io.IOException exc)
		    {
			exc.printStackTrace();
		    }
	    }
	
	// 
	// defaults to the standard java loading process
	//
	javax.swing.ImageIcon icon = new javax.swing.ImageIcon(path, ""default icon"");
	java.awt.Image[] imgs = new java.awt.Image[1];
	imgs[0] = icon.getImage();
	return imgs;
    }"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,checkImageLoaded,,9,12,9,4,0.25,0.0952,0,3,2,0,1,"public void checkImageLoaded(Image img)
    {
	MediaTracker mtrack = new MediaTracker(new Canvas());
	mtrack.addImage(img, 1);
	try {
	    mtrack.waitForAll();
	} catch (InterruptedException e) {
	}
    }"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,calculateColorCount,,37,230,207,9,0.0897,0.0347,0,12,5,0,1,"private Hashtable calculateColorCount(Image img)
    {
	int width = img.getWidth(null);
	int height = img.getHeight(null);
	int[] pixels = new int[width*height];
	PixelGrabber grabber = new PixelGrabber(img, 0, 0, width, height, pixels, 0, width);
	try
	    {
		grabber.grabPixels();
	    } catch (InterruptedException e)
		{
		    System.err.println(""interrupted waiting for pixels!"");
		    //		    throw new Exception(""Can't load the image provided"",e);
		}
		


	Hashtable result = new Hashtable();
	int colorindex = 0;
	for (int i=0; i<pixels.length; i++)
	    {
		int pix = pixels[i];
		if (((pix>>24)&0xFF) > 0)
		    {
			pix &= 0x00FFFFFF;
			Integer pixi = new Integer(pix);
			Object o = result.get(pixi);
			if (o == null)
			    {
				result.put(pixi, new Integer(colorindex++));
			    }
			//			if (colorindex > 256)
			//			    return result;
		    }
	    }
	return result;
    }"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,load,,12,30,15,3,0.26,0.1742,0,4,1,0,1,"private ByteBuffer load(File in) throws Exception
    {
	FileInputStream fis = new FileInputStream(in);
	ByteBuffer data = ByteBuffer.allocate((int)in.length());
	data.order(ByteOrder.LITTLE_ENDIAN);
	FileChannel fischan = fis.getChannel();
	fischan.read(data);
	data.position(0);
	fis.close();
		
	return data;
    }"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,convert,,14,19,2,3,0.2889,0.2405,0,3,2,0,1,"private ByteBuffer convert(String data)
    {
	ByteBuffer result = ByteBuffer.allocate(data.length()+1);
	result.position(0);
		
	for (int i=0; i<data.length(); i++)
	    {
		result.put((byte)data.charAt(i));
	    }
	result.put((byte)0);
		
	result.position(0);
	return result;
    }"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,fireFailedChange,,8,4,2,2,0.4167,0.1389,1,2,2,0,1,"public void fireFailedChange()
    {
	for (Iterator i=m_listeners.iterator(); i.hasNext(); )
	    {
		ExeCompiler.StepListener l = (ExeCompiler.StepListener)i.next();
		l.failed();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.ExeCompiler,fireCompleteChange,,8,4,2,2,0.4167,0.1389,1,2,2,0,1,"public void fireCompleteChange()
    {
	for (Iterator i=m_listeners.iterator(); i.hasNext(); )
	    {
		ExeCompiler.StepListener l = (ExeCompiler.StepListener)i.next();
		l.complete();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.JSmoothModelPersistency,load,,48,363,320,9,0.1069,0.0673,0.2,10,8,0,1,"public static JSmoothModelBean load(File fin) throws IOException
    {
	FileReader fr = new FileReader(fin);
	try
	    {
		JSmoothModelBean jobj = new JSmoothModelBean();
		String INVALID = ""INVALID"";
		jobj.setSkeletonName(INVALID);
		JOXBeanReader jbr = new JOXBeanReader(fr);
		jbr.readObject(jobj);
		jbr.close();
		fr.close();

		if (jobj.getSkeletonName() == INVALID)
		    {
			throw new Exception(""Not a JOX File"");
		    }
		//		System.out.println(""Loaded jobj "" + jobj + "" = "" + jobj.getJarLocation());
		if ((jobj.getJarLocation() != null) && (jobj.getJarLocation().length()>0))
		    {
			jobj.setEmbeddedJar(true);
			//			System.out.println(""Set embeddedjar to "" + jobj.getEmbeddedJar());
		    }

		return jobj;

	    } catch (Exception exc)
		{
		    fr.close();

		    try {
			FileInputStream fis = new FileInputStream(fin);
			XMLDecoder dec = new XMLDecoder(fis);
			JSmoothModelBean xobj = (JSmoothModelBean)dec.readObject();
			fis.close();

			if ((xobj.getJarLocation() != null) && (xobj.getJarLocation().length()>0))
			    xobj.setEmbeddedJar(true);

			return xobj;

		    } catch (Exception exc2)
			{
			    exc2.printStackTrace();
			    throw new IOException(exc2.toString());
			}
		}
    }"
jsmooth,net.charabia.jsmoothgen.application.JSmoothModelPersistency,save,,30,47,39,5,0.1818,0.0769,0.333333333,6,3,0,1,"public static void save(File fout, JSmoothModelBean obj) throws IOException
    {
	//	FileOutputStream fos = new FileOutputStream(fout);
	try
	    {
		// 		XMLEncoder enc = new XMLEncoder(fos);
		// 		enc.writeObject(obj);
		// 		enc.close();
		
		String jarloc = obj.getJarLocation();
		if (obj.getEmbeddedJar() == false)
		    obj.setJarLocation(null);

		FileWriter fw = new FileWriter(fout);
		JOXBeanWriter jbw = new JOXBeanWriter(fw);
		jbw.writeObject(""jsmoothproject"", obj);
		jbw.close();
		fw.close();

		obj.setJarLocation(jarloc);

	    } catch (Exception ex)
		{
		    throw new IOException(ex.toString());
		}
	    finally
		{
		    //		    fos.close();
		}
    }"
jsmooth,net.charabia.jsmoothgen.application.JSmoothModelPersistency,makePathRelativeIfPossible,,76,597,453,4,0.106,0.0962,0,13,16,1,1,"// root : z:/a/b/c/d
    // t1:    z:/a/b/e/f
    // t2:    c:/t/r
    // t3:    z:/a/b/c/d/i/m
    // t4:    z:/a/b/c/d
    static public File makePathRelativeIfPossible(File root, File f)
    {
	if (f.toString().indexOf(""${"")>=0)
	    return f;

	File orgfile = f;
	try
	    {
		if (f.isAbsolute() == false)
		    {
			f = new File(root, f.toString());
		    }
		f = f.getCanonicalFile();
		f = f.getAbsoluteFile();
		root = root.getCanonicalFile();
		root = root.getAbsoluteFile();
	    } catch (IOException iox)
		{
		    iox.printStackTrace();
		    System.out.println(""Failed, returning "" + orgfile);

		    return orgfile;
		}
	Vector rootvec = new Vector();
	Vector targetvec = new Vector();
	File cur;
	cur = root;
	while (cur != null)
	    {
		String n = cur.getName();
		// lame hack, because getName() returns """" when the file is a drive (like c: or z:)
		if (n.equals(""""))
		    n = cur.getAbsolutePath();
		rootvec.add(0, n);
		cur = cur.getParentFile();
	    }
		
	cur = f;
	while (cur != null)
	    {
		String n = cur.getName();
		if (n.equals(""""))
		    n = cur.getAbsolutePath();
		targetvec.add(0, n);
		cur = cur.getParentFile();
	    }
		
	// find the lowest common path
	int cursor = 0;
	while ((cursor < rootvec.size()) && (cursor < targetvec.size()))
	    {
		if (rootvec.elementAt(cursor).equals(targetvec.elementAt(cursor)) == false)
		    break;
		cursor++;
	    }
		
	if (cursor == 0)
	    return f;
		
	if ((cursor == rootvec.size()) && (cursor == targetvec.size()))
	    return new File(""."");
		
	StringBuffer buffer = new StringBuffer();
	for (int i=cursor; i<rootvec.size(); i++)
	    {
		buffer.append(""../"");
	    }
		
	for (int i=cursor; i<targetvec.size(); i++)
	    {
		buffer.append(targetvec.elementAt(i).toString());
		buffer.append(""/"");
	    }
		
	return new File(buffer.toString());
    }"
jsmooth,net.charabia.jsmoothgen.application.JSmoothModelBean,fireChanged,,8,4,2,2,0.4167,0.1389,1,2,2,0,1,"private void fireChanged()
    {
	for (Iterator i=m_listeners.iterator(); i.hasNext(); )
	    {
		JSmoothModelBean.Listener l = (JSmoothModelBean.Listener)i.next();
		l.dataChanged();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.JSmoothModelBean,fireSkeletonChanged,,8,4,2,2,0.4167,0.1389,1,2,2,0,1,"private void fireSkeletonChanged()
    {
	for (Iterator i=m_skeletonChangedListener.iterator(); i.hasNext(); )
	    {
		JSmoothModelBean.SkeletonChangedListener l = (JSmoothModelBean.SkeletonChangedListener)i.next();
		l.skeletonChanged();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.JSmoothModelBean,normalizePaths,,37,98,43,3,0.1898,0.1327,0,6,8,0,1,"public String[] normalizePaths(java.io.File filebase, boolean toRelativePath)
    {
	//	System.out.println(""Normalize Path "" + filebase + "" / "" + toRelativePath);
	Vector result = new Vector();

	m_iconLocation = checkRelativePath(filebase, m_iconLocation, result, ""Icon location"", toRelativePath);
	m_jarLocation = checkRelativePath(filebase, m_jarLocation, result, ""Jar location"", toRelativePath);
	m_bundledJVM = checkRelativePath(filebase, m_bundledJVM, result, ""Bundle JVM location"", toRelativePath);
        m_executableName = checkRelativePath(filebase, m_executableName, result, ""Executable location"", toRelativePath);

	if (m_executableName != null)
	    {
		File exebase = new File(m_executableName);
		if (exebase.isAbsolute() == false)
		    exebase = new File(filebase, exebase.toString()).getParentFile();

		//		System.out.println(""EXE FILEBASE: "" + exebase.toString());
		if ((m_currentDirectory != null) && (m_currentDirectory.indexOf(""${"")>=0))
		    m_currentDirectory = checkRelativePath(exebase, m_currentDirectory, result, ""Current directory"", toRelativePath);
	    }

        if (m_classPath != null)
	    {
		for (int i=0; i<m_classPath.length; i++)
		    {
			m_classPath[i] = checkRelativePath(filebase, m_classPath[i], result, ""Classpath entry ("" + i + "")"", toRelativePath);
		    }
	    }
	
	if (result.size() == 0)
	    return null;
		
	String[] res = new String[result.size()];
	result.toArray(res);
		
	return res;
    }"
jsmooth,net.charabia.jsmoothgen.application.JSmoothModelBean,checkRelativePath,,32,63,35,4,0.1643,0.161,1,8,6,0,1,"private String checkRelativePath(java.io.File root, String value, java.util.Vector errors, String name, boolean toRelativePath)
    {
	if (value == null)
	    return value;

	if (toRelativePath)
	    {
		File nf = JSmoothModelPersistency.makePathRelativeIfPossible(root, new File(value));
		if (nf.isAbsolute())
		    {
			errors.add(name);
		    }
		return nf.toString();
	    } else
		{
		    File nf = new File(value);
		    if (nf.isAbsolute() == false)
			{
			    nf = new File(root, value);
			    nf = nf.getAbsoluteFile();

			    try {
				nf = nf.getCanonicalFile();
				nf = nf.getAbsoluteFile();
			    } catch (IOException iox)
				{
				    // do nothing
				}
			}
		    return nf.toString();
		}
    }"
jsmooth,net.charabia.jsmoothgen.application.PropertiesBuilder,makeProperties,,114,837,449,8,0.1169,0.1548,0.157894737,14,19,1,1,"/**
     * Creates a text containing all the relevant properties of a
     * JSmoothModelBean object. The properties are output in the form
     * ""key=value"".
     * <p>
     * 
     * Note that all the paths are converted to be made relative to
     * the basedir parameter provided. All the paths converted are
     * expected to be relative to the targetted executable binary
     * (before the conversion is applied, that is).
     *
     */
    static public String makeProperties(File basedir, JSmoothModelBean obj)
    {
	StringBuffer out = new StringBuffer();

	addPair(""arguments"", obj.getArguments(), out);
	addPair(""mainclassname"", obj.getMainClassName(), out);
	addPair(""jvmsearch"", makePathConc(obj.getJVMSearchPath()), out);
	addPair(""minversion"", obj.getMinimumVersion(), out);
	addPair(""maxversion"", obj.getMaximumVersion(), out);

	addPair(""currentdir"", obj.getCurrentDirectory(), out);

	if (obj.getEmbeddedJar() && (obj.getJarLocation().trim().length() > 0))
	    {
		addPair(""embedjar"", ""true"", out);
	    }
	else
	    {
		addPair(""embedjar"", ""false"", out);
	    }

	if (obj.getMaximumMemoryHeap() > 1)
	    {
		addPair(""maxheap"", Integer.toString(obj.getMaximumMemoryHeap()), out);
	    }

	if (obj.getInitialMemoryHeap() > 1)
	    {
		addPair(""initialheap"", Integer.toString(obj.getInitialMemoryHeap()), out);
	    }

	// BundledVM & classpaths are changed to be accessible
	// from the current directory
	File curdir = new File(obj.getExecutableName()).getParentFile();

	if (curdir == null)
	    curdir = basedir.getAbsoluteFile();

	if (curdir.isAbsolute() == false)
	    {
		curdir = new File(basedir, curdir.toString());
	    }


	//	System.out.println(""... curdir1 : "" + curdir.toString());

	if (obj.getCurrentDirectory() != null)
	    {
		File newcurdir = new File(obj.getCurrentDirectory());
		//		System.out.println(""... curdir1.5 : "" + obj.getCurrentDirectory());

		if ( ! ""${EXECUTABLEPATH}"".equalsIgnoreCase(obj.getCurrentDirectory()))
		    {
			if (newcurdir.isAbsolute() == false)
			    {
				curdir = new File(curdir, newcurdir.toString());
			    }
			else
			    curdir = newcurdir;
		    }
	    }
	//	System.out.println(""... curdir2 : "" + curdir.toString());

	if (obj.getBundledJVMPath() != null)
	    addPair(""bundledvm"", getRenormalizedPathIfNeeded(obj.getBundledJVMPath(), basedir, curdir), out);

        if (obj.getClassPath() != null)
        {
            String[] relcp = new String[obj.getClassPath().length];
            for (int i=0; i<relcp.length; i++)
                {
                    relcp[i] = getRenormalizedPathIfNeeded(obj.getClassPath()[i], basedir, curdir);
                }
            addPair(""classpath"", makePathConc(relcp), out);
        }

	//
	// Adds all the skeleton-specific properties
	//
	if (obj.getSkeletonProperties() != null)
	    {
		for (int i=0; i<obj.getSkeletonProperties().length; i++)
		    {
			JSmoothModelBean.Property prop = obj.getSkeletonProperties()[i];
			if (prop.getKey() != null)
			    {
				String val = prop.getValue();
				if (val == null)
				    val = """";
				addPair(""skel_"" + prop.getKey(), val, out);
			    }
		    }
	    }


	//
	// Adds all the java properties. Those properties are
	// typically passed as -Dname=value arguments for the sun's
	// JVM.
	//

	JavaPropertyPair[] javapairs = obj.getJavaProperties();
        if (javapairs != null)
        {
            addPair(""javapropertiescount"", new Integer(javapairs.length).toString(), out);
            for (int i=0; i<javapairs.length; i++)
                {
                    addPair(""javaproperty_name_"" + i, javapairs[i].getName(), out);
                    addPair(""javaproperty_value_"" + i, javapairs[i].getValue(), out);
                }
        }

	return out.toString();
    }"
jsmooth,net.charabia.jsmoothgen.application.PropertiesBuilder,escapeString,,29,29,13,2,0.3333,0.3636,0,4,7,0,1,"static public String escapeString(String str)
    {
	if (str == null)
	    return """";

	StringBuffer out = new StringBuffer();
	for (int i=0; i<str.length(); i++)
	    {
		char c = str.charAt(i);
		switch(c)
		    {
		    case '\n':
			out.append(""\\n"");
			break;
		    case '\t':
			out.append(""\\t"");
			break;
		    case '\r':
			out.append(""\\r"");
			break;
		    case '\\':
			out.append(""\\\\"");
			break;
		    default:
			out.append(c);
		    }
	    }
	return out.toString();
    }"
jsmooth,net.charabia.jsmoothgen.application.PropertiesBuilder,makePathConc,,12,13,5,3,0.4762,0.2333,0,3,4,0,1,"static public String makePathConc(String[] elements)
    {
	StringBuffer buf = new StringBuffer();
	if (elements != null)
	    for (int i=0; i<elements.length; i++)
		{
		    buf.append(elements[i]);
		    if ((i+1)<elements.length)
			buf.append("";"");
		}
	return buf.toString();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.AboutBox,initComponents,,105,136,136,7,0.0588,0,0,4,1,0,1,"/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	private void initComponents()//GEN-BEGIN:initComponents
	{
		java.awt.GridBagConstraints gridBagConstraints;
		
		jPanel1 = new javax.swing.JPanel();
		jLabel3 = new javax.swing.JLabel();
		m_labelVersion = new javax.swing.JLabel();
		jLabel5 = new javax.swing.JLabel();
		jLabel1 = new javax.swing.JLabel();
		jLabel2 = new javax.swing.JLabel();
		jScrollPane1 = new javax.swing.JScrollPane();
		m_licenceTextArea = new javax.swing.JTextArea();
		jPanel2 = new javax.swing.JPanel();
		m_buttonOk = new javax.swing.JButton();
		
		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
		setTitle(""About JSmooth"");
		setModal(true);
		setResizable(false);
		addWindowListener(new java.awt.event.WindowAdapter()
		{
			public void windowClosing(java.awt.event.WindowEvent evt)
			{
				closeDialog(evt);
			}
		});
		
		jPanel1.setLayout(new java.awt.GridBagLayout());
		
		jPanel1.setBorder(new javax.swing.border.CompoundBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(5, 5, 5, 5)), new javax.swing.border.EtchedBorder()));
		jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		jLabel3.setText(""<html><big>JSmooth</big></html>"");
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridx = 2;
		gridBagConstraints.gridy = 1;
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.weightx = 0.5;
		jPanel1.add(jLabel3, gridBagConstraints);
		
		m_labelVersion.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		m_labelVersion.setText(""Unknown Version"");
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridy = 2;
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.weightx = 0.5;
		jPanel1.add(m_labelVersion, gridBagConstraints);
		
		jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		jLabel5.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/gnome-application-x-jar.png"")));
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.weightx = 0.1;
		jPanel1.add(jLabel5, gridBagConstraints);
		
		jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		jLabel1.setText(""<html><b>Author</b></html>"");
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 0);
		jPanel1.add(jLabel1, gridBagConstraints);
		
		jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		jLabel2.setText(""Rodrigo Reyes <reyes@charabia.net>"");
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		jPanel1.add(jLabel2, gridBagConstraints);
		
		m_licenceTextArea.setEditable(false);
		m_licenceTextArea.setLineWrap(true);
		m_licenceTextArea.setText(""This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA."");
		m_licenceTextArea.setWrapStyleWord(true);
		jScrollPane1.setViewportView(m_licenceTextArea);
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.gridheight = 3;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.insets = new java.awt.Insets(10, 10, 10, 10);
		gridBagConstraints.weightx = 1.0;
		gridBagConstraints.weighty = 1.0;
		jPanel1.add(jScrollPane1, gridBagConstraints);
		
		getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);
		
		m_buttonOk.setText(""OK"");
		m_buttonOk.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				buttonOkActionPerformed(evt);
			}
		});
		
		jPanel2.add(m_buttonOk);
		
		getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);
		
		java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
		setBounds((screenSize.width-450)/2, (screenSize.height-350)/2, 450, 350);
	}//GEN-END:initComponents"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,MasterPanel,,20,113,106,6,0.0817,0.037,0,1,1,0,1,"public MasterPanel()
    {
	setLayout(new BorderLayout());
	add(BorderLayout.WEST, m_scrollpane = new JScrollPane(m_leftBar));
 	JScrollPane scp = new JScrollPane(m_mainpanel);
 	m_mainpanelVBar = scp.getVerticalScrollBar();
	add(BorderLayout.CENTER, scp);
	scp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
	//	add(BorderLayout.CENTER, m_mainpanel);


	addAction(""Welcome"", ""/icons/stock_form-properties.png"", m_jsInfo);
	addAction(""Skeleton"", ""/icons/stock_new-template.png"", m_skelElements);
	addAction(""Executable"", ""/icons/stock_autopilot-24.png"", m_execElements);
	addAction(""Application"", ""/icons/stock_form-image-control.png"", m_appElements);
	addAction(""JVM Selection"", ""/icons/stock_search.png"", m_jvmSelElements);
	addAction(""JVM Configuration"", ""/icons/stock_form-properties.png"", m_jvmCfgElements);
	
	setupPanel(m_jsInfo);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,addAction,,16,62,58,9,0.119,0.0272,0,6,1,0,1,"private void addAction(final String name, String iconloc, final Object[] els)
    {
	final Action a = new AbstractAction( name, new ImageIcon(getClass().getResource(iconloc))) {
		public void actionPerformed(ActionEvent e) 
		{
		    if (m_currentPanelName.equals(name))
			return;
		    setupPanel(els);
		    m_currentPanelName = name;
		}
	    };
	
	JToggleButton jtb = new JToggleButton(a);
	m_leftGroup.add(jtb);
	m_leftBar.add(jtb);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,fireUpdateModel,,8,4,2,2,0.4167,0.1389,1,2,2,0,1,"public void fireUpdateModel()
    {
	for (Iterator i=m_displayedElements.iterator(); i.hasNext(); )
	    {
		Editor ed = (Editor)i.next();
		ed.updateModel();
	    }	
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,fireModelChanged,,8,4,2,2,0.4167,0.1389,1,2,2,0,1,"public void fireModelChanged()
    {
	for (Iterator i=m_displayedElements.iterator(); i.hasNext(); )
	    {
		Editor ed = (Editor)i.next();
		ed.dataChanged();
	    }	
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,detachAll,,14,8,1,2,0.3667,0.2,0.666666667,2,4,0,1,"private void detachAll()
    {
	for (Iterator i=m_displayedElements.iterator(); i.hasNext(); )
	    {
		Editor ed = (Editor)i.next();

		if (ed instanceof JSmoothModelBean.Listener)
		    m_model.removeListener((JSmoothModelBean.Listener)ed);
		if (ed instanceof JSmoothModelBean.SkeletonChangedListener)
		    m_model.removeSkeletonChangedListener((JSmoothModelBean.SkeletonChangedListener)ed);

		ed.detach();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,attachAll,,20,22,8,2,0.2698,0.1574,0.5,3,5,0,1,"private void attachAll()
    {
	//	System.out.println(""Attaching all with "" + m_modelLocation + "": "" + m_model);
	for (Iterator i=m_displayedElements.iterator(); i.hasNext(); )
	    {
		Editor ed = (Editor)i.next();

		File basedir = null;
		if (m_modelLocation != null)
		    basedir = m_modelLocation.getParentFile();

		ed.attach(m_model, basedir);
		if (ed instanceof JSmoothModelBean.Listener)
		    m_model.addListener((JSmoothModelBean.Listener)ed);
		if (ed instanceof JSmoothModelBean.SkeletonChangedListener)
		    m_model.addSkeletonChangedListener((JSmoothModelBean.SkeletonChangedListener)ed);

		ed.dataChanged();
	    }	
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,openFile,,15,24,20,5,0.225,0.0733,1,3,2,0,1,"public boolean openFile(java.io.File f)
    {
	m_modelLocation = f;

	try
	    {
		JSmoothModelBean model = JSmoothModelPersistency.load(m_modelLocation);
		newModel(model, f);
		return true;
	    } catch (java.io.IOException iox)
		{
		    iox.printStackTrace();
		    return false;
		}
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,save,,17,41,37,7,0.1667,0.0641,1,1,3,0,1,"public boolean save()
    {
	if (m_modelLocation == null)
	    return false;
	try {
	    fireUpdateModel();
	    m_model.normalizePaths(m_modelLocation.getParentFile(), true);
	    JSmoothModelPersistency.save(m_modelLocation, m_model);
	    //	    System.out.println(""saving model "" + m_model);
	    //	    fireModelChanged();
	    return true;
	} catch (java.io.IOException iox)
	    {
		iox.printStackTrace();
	    }
	return false;
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.MasterPanel,runexe,,16,41,37,6,0.1571,0.047,1,4,2,0,1,"public void runexe()
    {
	fireUpdateModel();
		
	try {
	    File basedir = m_modelLocation.getParentFile();
	    File f = new File(basedir, m_model.getExecutableName());
	    String[] cmd = new String[]{ f.getAbsolutePath() };
	    
	    //	    System.out.println(""RUNNING "" + cmd[0] + "" @ "" + basedir);
	    CommandRunner.run(cmd, f.getParentFile());
	} catch (Exception exc)
	    {
		exc.printStackTrace();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.Main,Main,,26,51,47,7,0.1212,0.0374,0.5,2,1,0,1,"private Main()
    {
	Splash splash = new Splash(this, ""/icons/splash.png"", false);
	splash.setVersion(VERSION);
	splash.show();

	m_projectFileChooser.addChoosableFileFilter(new SimpleFileFilter(""jsmooth"", ""JSmooth Project Files""));

	getContentPane().setLayout(new BorderLayout());
	m_panel = new MasterPanel();
	getContentPane().add(BorderLayout.CENTER, m_panel);

	setupMenus();
	setupToolBar();

        addWindowListener(new java.awt.event.WindowAdapter() {
		public void windowClosing(java.awt.event.WindowEvent evt)
		{
		    EXIT.actionPerformed(null);
		}
	    });

	setTitle(""Untitled"");
	loadWindowSettings();
	splash.dispose();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.Splash,Splash,,18,47,39,5,0.1616,0.0586,1,6,3,0,1,"public Splash(Frame parent, String imagefilename, boolean dialog)
    {
	if (dialog)
	    {
                m_window = new MyDialog(parent);
	    }
	else
	    {
                m_window = new MyWindow(parent);
	    }
	javax.swing.ImageIcon icon = new javax.swing.ImageIcon(getClass().getResource(imagefilename));
	m_splashImage = icon.getImage();
	MediaTracker loader = new MediaTracker(m_window);
	loader.addImage(m_splashImage, 0);
	try { 
            loader.waitForAll(); 
	} catch (Exception e) {}
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.ClassPath,ClassPath,,14,52,38,4,0.1786,0.1154,0.75,1,1,0,1,"public ClassPath()
    {
	m_jarLocFileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
	m_jarLocFileChooser.setMultiSelectionEnabled(true);
	GenericFileFilter filter = new GenericFileFilter(""Zip, Jar, or directories"");
	filter.addSuffix(""jar"");
	filter.addSuffix(""zip"");
	m_jarLocFileChooser.addChoosableFileFilter(filter);
	m_fileeditor.setFileChooser(m_jarLocFileChooser);
	m_list.setEditor(m_fileeditor);

	setLayout(new BorderLayout());
	add(BorderLayout.CENTER, m_list);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.ClassPath,dataChanged,,13,12,9,3,0.25,0.0714,1,1,3,0,1,"public void dataChanged()
    {
	if (getBaseDir() != null)
	    {
		m_jarLocFileChooser.setCurrentDirectory(getBaseDir());
	    }

	String[] cp = m_model.getClassPath();
	if (cp == null)
	    m_list.setData(new Object[0]);
	else
	    m_list.setData((Object[])cp);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.ClassPath,updateModel,,10,15,9,3,0.2857,0.1583,1,3,2,0,1,"public void updateModel()
    {
	Object[] cpels = m_list.getData();
	String[] cp = new String[cpels.length];
	for (int i=0; i<cp.length; i++)
	    {
		cp[i] = cpels[i].toString();
	    }
	m_model.setClassPath(cp);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.ExecutableIcon,dataChanged,,17,17,13,3,0.3571,0.1389,0.6,0,3,0,1,"public void dataChanged()
    {
	if (getBaseDir() != null)
	    m_selector.setBaseDir(getBaseDir());

	if (m_model.getIconLocation() != null)
	    {
		m_selector.setFile(getAbsolutePath(new java.io.File(m_model.getIconLocation())));
		setIconLocation(getAbsolutePath(new java.io.File(m_model.getIconLocation())));
		
	    }
	else
	    {
		m_selector.setFile(null);
		setIconLocation(new File(""""));
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JavaProperties,updateModel,,10,15,9,3,0.2857,0.1167,1,3,2,0,1,"public void updateModel()
    {
	Object[] po = m_props.getData();
	JavaPropertyPair[] props = new JavaPropertyPair[po.length];
	for (int i=0; i<po.length; i++)
	    {
		props[i] = (JavaPropertyPair)po[i];
	    }
	m_model.setJavaProperties(props);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.CurrentDirectory,CurrentDirectory,,23,23,10,2,0.2407,0.1435,0.75,2,1,0,1,"public CurrentDirectory()
    {
	setLayout(new BorderLayout());
	add(BorderLayout.CENTER, m_selector);
	
	JPanel jpc = new JPanel();
	jpc.setLayout(new BorderLayout());
	jpc.add(BorderLayout.WEST, m_forceExePath);
	jpc.add(BorderLayout.CENTER, new HelpButton(Main.local(""CURRENTDIR_FORCEEXEPATH_HELP"")));
	add(BorderLayout.SOUTH, jpc);

	m_forceExePath.setAction(new AbstractAction(Main.local(""CURRENTDIR_FORCEEXEPATH"")) {
		public void actionPerformed(java.awt.event.ActionEvent e)
		{
		    if (m_forceExePath.isSelected())
			m_selector.setEnabled(false);
		    else
			m_selector.setEnabled(true);
		}
	    });

	m_selector.setFileChooser(new JDirectoryChooser());
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.CurrentDirectory,dataChanged,,27,74,57,6,0.2143,0.1451,0.6,1,4,0,1,"public void dataChanged()
    {
// 	System.out.println(""CurDir, basedir="" + getBaseDir());
	m_selector.setBaseDir(getBaseDir());
	String dir = m_model.getCurrentDirectory();
// 	System.out.println(""Cur Directory data changed: "" + dir);

	if (""${EXECUTABLEPATH}"".equals(dir))
	    {
		m_selector.setEnabled(false);
		m_forceExePath.setSelected(true);
	    }
	else
	    {
		m_forceExePath.setSelected(false);
		m_selector.setEnabled(true);

		if ((dir != null) && (dir.trim().length()>0))
		    {
			m_selector.setFile(new java.io.File(dir));
		    }
		else
		    {
			m_selector.setFile(null);
		    }
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.CurrentDirectory,updateModel,,16,8,6,3,0.3333,0.0741,1,0,3,0,1,"public void updateModel()
    {
// 	System.out.println(""UPDATE MODEL: "" + m_selector.getFile());

	if (m_forceExePath.isSelected())
	    {
		m_model.setCurrentDirectory(""${EXECUTABLEPATH}"");
	    }
	else
	    {
		if (m_selector.getFile() != null)
		    m_model.setCurrentDirectory(m_selector.getFile().toString());
		else
		    m_model.setCurrentDirectory(null);
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.InitialMemoryHeap,InitialMemoryHeap,,15,63,48,4,0.1868,0.119,1,2,1,0,1,"public InitialMemoryHeap()
    {
	setLayout(new BorderLayout());
	add(BorderLayout.CENTER, m_args);
	m_args.setDocument(new RegExDocument(""[0-9]+""));
	m_args.setHorizontalAlignment(JTextField.RIGHT);

	Vector u = new Vector();
	u.add(Main.local(""UNIT_MB""));
	u.add(Main.local(""UNIT_KB""));
	u.add(Main.local(""UNIT_BYTE""));
	DefaultComboBoxModel mod = new DefaultComboBoxModel(u);
	m_units.setModel(mod);
	add(BorderLayout.EAST, m_units);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.InitialMemoryHeap,updateModel,,33,42,29,6,0.197,0.1362,1,2,6,0,1,"public void updateModel()
    {
	int value;

// 	System.out.println(""Parsing "" + m_args.getText());

	try {
	    value = Integer.parseInt(m_args.getText());
	} catch (Exception exc)
	    {
		// nothing here
		m_model.setInitialMemoryHeap(-1);
		return;
	    }
// 	System.out.println(""sel index: "" + m_units.getSelectedIndex() + "" / "" + value + "" / "" + (value*1024*1024));

	switch(m_units.getSelectedIndex())
	    {
		case 0:
		    if (value>2047)
			value = 2047;
		    m_model.setInitialMemoryHeap(value * 1024 * 1024);
		    break;
		case 1:
		    m_model.setInitialMemoryHeap(value * 1024);
		    break;
		case 2:
		    m_model.setInitialMemoryHeap(value);
		    break;
	    }

// 	System.out.println(""Resulting initmem: "" + m_model.getInitialMemoryHeap());
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.MainClass,displayChooser,,45,254,208,5,0.104,0.0741,0.3,10,8,0,1,"protected void displayChooser()
    {
	ClassChooserDialog chooser = new ClassChooserDialog(Main.MAIN, true);

	Vector jars = new Vector();
	if (m_model.getEmbeddedJar() == true)
	    {
		String ejar = m_model.getJarLocation();
		if (ejar != null)
		    {
			File f = getAbsolutePath(new File(ejar));
			jars.add(f);
		    }
	    }

	String[] cp = m_model.getClassPath();
	if (cp != null)
	    {
		for (int i=0; i<cp.length; i++)
		    {
			jars.add(getAbsolutePath(new File(cp[i])));
		    }
	    }

	chooser.clear();
	for (Iterator i=jars.iterator(); i.hasNext(); )
	    {
		File f = (File)i.next();
// 		System.out.println(""Adding jar <"" + f + "">"");
		try {
		    chooser.addJar(new JarFile(f));
		} catch (Exception ex)
		    {
			ex.printStackTrace();
		    }
	    }

	chooser.setClassName(m_classname.getText());
	chooser.setVisible(true);
	if (chooser.validated())
	    {
		String classname = chooser.getClassName();
		m_classname.setText(classname);
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.SkeletonPropertiesEditor,rebuildProperties,,69,342,249,8,0.1061,0.1167,0.714285714,3,10,1,1,"public void rebuildProperties()
    {
// 	System.out.println(""============================================="");
// 	System.out.println(""============================================="");
// 	System.out.println(""===   REBUILD PROPERTIES !!!!     ==========="");
// 	System.out.println(""============================================="");
// 	System.out.println(""============================================="");

	m_skel = null;
	if (m_currentSkelName != null)
	    m_skel = Main.SKELETONS.getSkeleton(m_currentSkelName);

	SkeletonProperty[] sprops = null;
	if (m_skel != null)
	    sprops = m_skel.getSkeletonProperties();
	else
	    sprops = new SkeletonProperty[0];

	m_panel.removeAll();

	m_editors.clear();

	for (int i=0; i<sprops.length; i++)
	    {
		SkelPropEditor spe = null;
		if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_STRING))
		    {
			spe = new StringEditor();
		    }
		else if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_TEXTAREA))
		    {
			spe = new TextAreaEditor();
		    }
		else if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_BOOLEAN))
		    {
			spe = new CheckBoxEditor();
		    }
		else if (sprops[i].getType().equalsIgnoreCase(SkeletonProperty.TYPE_AUTODOWNLOADURL))
		    {
			spe = new AutoDownloadURLEditor();
		    }

		if (spe == null)
		    {
			spe = new StringEditor();
		    }

		m_editors.add(spe);
		spe.bind(sprops[i]);

		if (spe.labelAtLeft())
		    {
			m_panel.add(""br"", new JLabel(Main.local(sprops[i].getLabel())));
			m_panel.add(""tab"", new HelpButton(Main.local(sprops[i].getDescription())));
			m_panel.add(""tab hfill"", spe.getGUI());
		    }
		else
		    {
			m_panel.add(""br right"", spe.getGUI());
			m_panel.add(""tab"", new HelpButton(Main.local(sprops[i].getDescription())));
			m_panel.add(""tab hfill"", new JLabel(Main.local(sprops[i].getLabel())));
		    }
	    }

	revalidate();
	m_panel.revalidate();
	doLayout();
	m_panel.doLayout();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.SkeletonPropertiesEditor,dataChanged,,54,200,169,5,0.1136,0.0586,0.666666667,9,13,0,1,"public void dataChanged()
    {
// 	System.out.println(""========================================================"");
// 	System.out.println(""SkeletonPropertiesEditor: data changed, "" + m_model.getSkeletonName());
	if (m_model.getSkeletonName() == null)
	    {
// 		System.out.println(""SkeletonPropertiesEditor, no name"");
		m_currentSkelName = null;
		rebuildProperties();
	    }

	if ((m_model != null) && (m_model.getSkeletonName() != null) && (!m_model.getSkeletonName().equalsIgnoreCase(m_currentSkelName)))
	    {
// 		System.out.println(""SkeletonPropertiesEditor, different..."");
		m_currentSkelName = m_model.getSkeletonName();
		rebuildProperties();
	    }

	JSmoothModelBean.Property[] jsprop = m_model.getSkeletonProperties();
// 	System.out.println(""jsprop is null ? "" + jsprop + "" / "" + ((jsprop!=null)?jsprop.length:-1));
	if (jsprop != null)
	    {
		for (Enumeration e=m_editors.elements(); e.hasMoreElements(); )
		    {
			SkelPropEditor spe = (SkelPropEditor)e.nextElement();
			JSmoothModelBean.Property p = getPropertyInstance(spe.getIdName());
			if (p != null)
			    spe.valueChanged(p.getValue());
		    }
	    }
	else
	    { // if no properties are defined for this model, we use the default values
		
		SkeletonBean skel = Main.SKELETONS.getSkeleton( m_model.getSkeletonName() );
		SkeletonProperty[] sprops = null;
		if (skel != null)
		    sprops = skel.getSkeletonProperties();

		if (sprops != null)
		    {
			for (Enumeration e=m_editors.elements(); e.hasMoreElements(); )
			    {
				SkelPropEditor spe = (SkelPropEditor)e.nextElement();				
				for (int i=0; i<sprops.length; i++)
				    {
					if (sprops[i].getIdName().equals(spe.getIdName()))
					    spe.valueChanged(sprops[i].getValue());
				    }
			    }			
		    }
	    }

// 	System.out.println(""DONE NOTHING! "" +m_currentSkelName + ""/"" + m_model.getSkeletonName());
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.SkeletonPropertiesEditor,updateModel,,34,48,41,3,0.1667,0.0988,0.5,4,3,0,1,"public void updateModel()
    {
	if (m_skel != null)
	    {
		JSmoothModelBean.Property[] props = new JSmoothModelBean.Property[m_editors.size()];
		int index = 0;
		for (Enumeration e=m_editors.elements(); e.hasMoreElements(); )
		    {
			SkelPropEditor spe = (SkelPropEditor)e.nextElement();
// 			System.out.println(""IMODEL property "" + spe + ""/"" + spe.getIdName() + ""="" + spe.get());
			props[index] = new JSmoothModelBean.Property();
			props[index].setKey(spe.getIdName());
			props[index].setValue(spe.get());
			index++;
		    }
		m_model.setSkeletonProperties(props);
	    }

// 	if (m_skel != null)
// 	    {
// 		System.out.println(""UPDATE MODEL for skeletons..."");
// 		SkeletonProperty[] sp = m_skel.getSkeletonProperties();
// 		JSmoothModelBean.Property[] props = new JSmoothModelBean.Property[sp.length];
// 		for (int i=0; i<sp.length; i++)
// 		    {
// 			props[i] = new JSmoothModelBean.Property();
// 			props[i].setKey(sp[i].getIdName());
// 			props[i].setValue(sp[i].getValue());
// 			System.out.println(props[i]);
// 		    }
// 		m_model.setSkeletonProperties(props);
// 	    }

    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.MaxMemoryHeap,MaxMemoryHeap,,15,63,48,4,0.1868,0.119,1,2,1,0,1,"public MaxMemoryHeap()
    {
	setLayout(new BorderLayout());
	add(BorderLayout.CENTER, m_args);
	m_args.setDocument(new RegExDocument(""[0-9]+""));
	m_args.setHorizontalAlignment(JTextField.RIGHT);

	Vector u = new Vector();
	u.add(Main.local(""UNIT_MB""));
	u.add(Main.local(""UNIT_KB""));
	u.add(Main.local(""UNIT_BYTE""));
	DefaultComboBoxModel mod = new DefaultComboBoxModel(u);
	m_units.setModel(mod);
	add(BorderLayout.EAST, m_units);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.MaxMemoryHeap,updateModel,,28,32,19,5,0.2167,0.161,0.5,2,6,0,1,"public void updateModel()
    {
	int value;

	try {
	    value = Integer.parseInt(m_args.getText());
	} catch (Exception exc)
	    {
		// nothing here
		m_model.setInitialMemoryHeap(-1);
		return;
	    }

	switch(m_units.getSelectedIndex())
	    {
		case 0:
		    if (value>2047)
			value = 2047;
		    m_model.setMaximumMemoryHeap(value * 1024 * 1024);
		    break;
		case 1:
		    m_model.setMaximumMemoryHeap(value * 1024);
		    break;
		case 2:
		    m_model.setMaximumMemoryHeap(value);
		    break;
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.SkeletonProperties,dataChanged,,15,28,20,4,0.3889,0.1667,1,0,3,0,1,"public void dataChanged()
    {
	System.out.println(""SkeletonProperties: data changed, "" + m_model.getSkeletonName());
	if (m_model.getSkeletonName() == null)
	    {
		m_currentSkelName = null;
		setProperties();
		return;
	    }
	if ( ! m_model.getSkeletonName().equalsIgnoreCase(m_currentSkelName))
	    {
		m_currentSkelName = m_model.getSkeletonName();
		setProperties();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.SkeletonProperties,updateModel,,16,43,41,2,0.1667,0.0571,0.571428571,3,3,0,1,"public void updateModel()
    {
	if (m_skel != null)
	    {
		SkeletonProperty[] sp = m_skel.getSkeletonProperties();
		JSmoothModelBean.Property[] props = new JSmoothModelBean.Property[sp.length];
		for (int i=0; i<sp.length; i++)
		    {
			props[i] = new JSmoothModelBean.Property();
			props[i].setKey(sp[i].getIdName());
			props[i].setValue(sp[i].getValue());
			System.out.println(props[i]);
		    }
		m_model.setSkeletonProperties(props);
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JVMSearchSequence,dataChanged,,18,25,14,2,0.2381,0.1028,1,4,4,0,1,"public void dataChanged()
    {
	if (m_model.getJVMSearchPath() == null)
	    {
		m_vmSearch.setData(JVMSearchElement.Elements);
	    } else
		{
		    Vector v = new Vector();
		    String[] els = m_model.getJVMSearchPath();
		    for (int i=0; i<els.length; i++)
			{
			    JVMSearchElement el = JVMSearchElement.getStandardElement(els[i]);
			    if (el != null)
				v.add(el);
			}
		    m_vmSearch.setData(v.toArray());
		}
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JVMSearchSequence,updateModel,,10,15,9,3,0.2857,0.1583,0.75,3,2,0,1,"public void updateModel()
    {
	String[] ids = new String[m_vmSearch.dataSize()];
	Object[] data = m_vmSearch.getData();
	for (int i=0; i<ids.length; i++)
	    {
		ids[i] = ((JVMSearchElement)data[i]).getId();
	    }
	m_model.setJVMSearchPath(ids);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JSmoothInfo,JSmoothInfo,,8,19,17,5,0.2381,0.0556,1,1,1,0,1,"public JSmoothInfo()
    {
	setLayout(new java.awt.BorderLayout());
	add(java.awt.BorderLayout.CENTER, m_skeldesc);
	setBackground(java.awt.Color.red);
	String text = Main.MAIN.local(""JSMOOTH_WELCOME_SCREEN"");
	m_skeldesc.setText(text);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JSmoothInfo,readFile,,17,55,44,4,0.1944,0.0833,0,6,3,0,1,"public String readFile(java.io.File f)
    {
	StringBuffer buffer = new StringBuffer();
	try {
	    FileInputStream fis = new FileInputStream(f);
	    InputStreamReader isr = new InputStreamReader(fis);
	    int c;
	    while ((c=isr.read())!=-1)
		buffer.append((char)c);
	    isr.close();
	    fis.close();
	} catch (Exception ex)
	    {
		ex.printStackTrace();
	    }
	return buffer.toString();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JVMBundle,JVMBundle,,18,13,11,3,0.2222,0.0556,0.75,1,2,0,1,"public JVMBundle()
    {
	setLayout(new PanelLayout());
	add(m_checker);
	add(m_selector);

	m_selector.setFileChooser(new JDirectoryChooser());

	m_checker.setAction(new AbstractAction(Main.local(""JVMBUNDLE_CHECKBOX"")) {
		public void actionPerformed(java.awt.event.ActionEvent e)
		{
		    m_selector.setEnabled(m_checker.isSelected());
		}
	    });

	if (m_model != null)
	    dataChanged();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JVMBundle,dataChanged,,18,59,40,5,0.2308,0.1978,0.6,1,2,0,1,"public void dataChanged()
    {
	String bundle = m_model.getBundledJVMPath();
	if (bundle == null)
	    {
		m_checker.setSelected(false);
		m_selector.setBaseDir(getBaseDir());
		m_selector.setFile(null);
		m_selector.setEnabled(false);
	    }
	else
	    {
		m_checker.setSelected(true);
		m_selector.setBaseDir(getBaseDir());
		m_selector.setFile(new java.io.File(bundle));
		m_selector.setEnabled(true);
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.editors.JVMBundle,updateModel,,15,14,7,3,0.3571,0.1417,1,1,3,0,1,"public void updateModel()
    {
	if (m_checker.isSelected())
	    {
		File f = m_selector.getFile();
		if (f != null)
		    m_model.setBundledJVMPath(f.toString());
		else
		    m_model.setBundledJVMPath("""");
	    }
	else
	    {
		m_model.setBundledJVMPath(null);
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.SortedEditableList,initComponents,,106,187,143,3,0.1091,0.1558,0,6,1,1,1,"/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	private void initComponents()//GEN-BEGIN:initComponents
	{
		java.awt.GridBagConstraints gridBagConstraints;
		
		jScrollPane1 = new javax.swing.JScrollPane();
		m_itemList = new javax.swing.JList();
		m_buttonAdd = new javax.swing.JButton();
		m_buttonRemove = new javax.swing.JButton();
		m_buttonEdit = new javax.swing.JButton();
		jSeparator1 = new javax.swing.JSeparator();
		m_buttonUp = new javax.swing.JButton();
		m_buttonDown = new javax.swing.JButton();
		
		setLayout(new java.awt.GridBagLayout());
		
		jScrollPane1.setViewportView(m_itemList);
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridx = 1;
		gridBagConstraints.gridwidth = 4;
		gridBagConstraints.gridheight = 8;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.weightx = 1.0;
		gridBagConstraints.weighty = 1.0;
		add(jScrollPane1, gridBagConstraints);
		
		m_buttonAdd.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_insert-element.png"")));
		m_buttonAdd.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				buttonAddActionPerformed(evt);
			}
		});
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		add(m_buttonAdd, gridBagConstraints);
		
		m_buttonRemove.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_remove-element.png"")));
		m_buttonRemove.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				buttonRemoveActionPerformed(evt);
			}
		});
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		add(m_buttonRemove, gridBagConstraints);
		
		m_buttonEdit.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_edit.png"")));
		m_buttonEdit.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				buttonEditActionPerformed(evt);
			}
		});
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		add(m_buttonEdit, gridBagConstraints);
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.weighty = 1.0;
		gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
		add(jSeparator1, gridBagConstraints);
		
		m_buttonUp.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_up.png"")));
		m_buttonUp.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				buttonUpActionPerformed(evt);
			}
		});
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridy = 6;
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
		add(m_buttonUp, gridBagConstraints);
		
		m_buttonDown.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_down.png"")));
		m_buttonDown.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				buttonDownActionPerformed(evt);
			}
		});
		
		gridBagConstraints = new java.awt.GridBagConstraints();
		gridBagConstraints.gridy = 7;
		gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
		gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
		gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
		add(m_buttonDown, gridBagConstraints);
		
	}//GEN-END:initComponents"
jsmooth,net.charabia.jsmoothgen.application.gui.util.SortedEditableList,buttonDownActionPerformed,,13,8,0,2,0.381,0.204,0,4,2,0,1,"private void buttonDownActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_buttonDownActionPerformed
	{//GEN-HEADEREND:event_buttonDownActionPerformed
		// Add your handling code here:
		int max = m_model.size();
		int index = m_itemList.getSelectedIndex();
		if ((index+1) < max)
		{
			Object o = m_model.remove(index);
			m_model.add(index+1, o);
			m_itemList.setSelectedIndex(index+1);
		}
		modelChanged();
	}//GEN-LAST:event_buttonDownActionPerformed"
jsmooth,net.charabia.jsmoothgen.application.gui.util.SortedEditableList,buttonEditActionPerformed,,17,10,0,2,0.3036,0.2482,1,4,3,0,1,"private void buttonEditActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_buttonEditActionPerformed
	{//GEN-HEADEREND:event_buttonEditActionPerformed
		// Add your handling code here:
		int index = m_itemList.getSelectedIndex();
		if (index >= 0)
		{
			Object o = m_model.get(index);
			Object n = m_editor.editItem(this, o);
			if (n != null)
			{
				m_model.removeElementAt(index);
				m_model.add(index, n);
				m_itemList.setSelectedIndex(index);
			}
		}
		modelChanged();
	}//GEN-LAST:event_buttonEditActionPerformed"
jsmooth,net.charabia.jsmoothgen.application.gui.util.SortedEditableList,buttonRemoveActionPerformed,,16,7,4,3,0.2667,0.15,1,4,4,0,1,"private void buttonRemoveActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_buttonRemoveActionPerformed
	{//GEN-HEADEREND:event_buttonRemoveActionPerformed
		// Add your handling code here:

	    Object[] items = m_itemList.getSelectedValues();
	    for (int i=0; i<items.length; i++)
		{
		    Object o = items[i];
		    if (o != null)
			{
			    if (m_editor.removeItem(this, o))
				m_model.removeElement(o);
			}
		}
	    modelChanged();
	}//GEN-LAST:event_buttonRemoveActionPerformed"
jsmooth,net.charabia.jsmoothgen.application.gui.util.SortedEditableList,buttonAddActionPerformed,,24,15,0,3,0.3611,0.3048,1,4,6,0,1,"private void buttonAddActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_buttonAddActionPerformed
	{//GEN-HEADEREND:event_buttonAddActionPerformed
		// Add your handling code here:
		Object item = m_editor.createNewItem(this);
		if (item != null)
		{
		    System.out.println(""IsArray: "" + item.getClass() + "" == "" + item.getClass().isArray());
		    if (item.getClass().isArray())
			{
			    for (int i=0; i<java.lang.reflect.Array.getLength(item); i++)
				{
				    Object o = java.lang.reflect.Array.get(item, i);
				    if (m_model.contains(o) == false)
					m_model.addElement(o);
				}
			}
		    else
			{
			    if (m_model.contains(item) == false)
				m_model.addElement(item);
			}
		    modelChanged();
		}
	}//GEN-LAST:event_buttonAddActionPerformed"
jsmooth,net.charabia.jsmoothgen.application.gui.util.HelpButton,HelpButton,,41,46,26,4,0.1944,0.1744,0,8,1,0,1,"public HelpButton(String helptext)
    {
	setText("""");
	setIcon(ICON_HELP);
	m_helpWindow.getContentPane().setBackground(Color.yellow);
	m_helpWindow.getContentPane().setLayout(new BorderLayout());
	JEditorPane jep = new JEditorPane(""text/html"", wrap(helptext));
	jep.setBackground(Color.yellow);
	jep.setEditable(false);
	m_helpWindow.getContentPane().add(jep, BorderLayout.CENTER);
	jep.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.LOWERED));
	m_helpWindow.pack();
	
	m_helpWindow.addMouseListener( new MouseAdapter() {
		public void mouseEntered(MouseEvent e)
		{
		    HelpButton.this.m_helpWindow.dispose();
		}

		public void mouseExited(MouseEvent e)
		{
		    HelpButton.this.m_helpWindow.dispose();
		}

	    });

	addMouseListener(new MouseAdapter() {
		public void mouseEntered(MouseEvent e)
		{
		    HelpButton.this.requestFocus();
		    HelpButton.this.adjustLocation();
		    m_helpWindow.setVisible(true);
		}

		public void mouseExited(MouseEvent e)
		{
		    m_helpWindow.setVisible(false);
		}
	    });

    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.HelpButton,wrap,,30,107,61,4,0.2037,0.1853,0,6,9,0,1,"public String wrap(String str)
    {
	StringBuffer sb = new StringBuffer();
	StringBuffer line = new StringBuffer();
	StringTokenizer stok = new StringTokenizer(str, "" "", true);
	while (stok.hasMoreElements())
	    {
		boolean cut = false;
		String tok = stok.nextToken();
		line.append(tok);

		if (tok.indexOf(""<br"")>=0 || tok.indexOf(""<BR"")>=0
		    || tok.indexOf(""<p>"")>=0 || tok.indexOf(""<p/>"")>=0
		    || tok.indexOf(""<P/>"")>=0 || tok.indexOf(""<P/>"")>=0)
		    {
			sb.append(line);
			line.setLength(0);
		    }

		if (line.length() > 80)
		    {
			sb.append(line);
			sb.append(""<br>\n"");
			line.setLength(0);
		    }

	    }
	sb.append(line);
	return sb.toString();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.HelpButton,adjustLocation,,12,12,3,2,0.3143,0.1667,0,2,3,0,1,"public void adjustLocation()
    {
	// m_helpWindow.setLocationRelativeTo(this);
	Point p = this.getLocationOnScreen();
	p.y += getHeight();
	Rectangle bounds = GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds();
	if ((p.x + m_helpWindow.getWidth()) > bounds.width)
	    p.x = bounds.width - m_helpWindow.getWidth();
	if (p.x < bounds.x)
	    p.x = bounds.x;
	m_helpWindow.setLocation(p.x, p.y);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.ClassChooserDialog,addJar,,16,40,35,3,0.18,0.0913,1,5,4,0,1,"public void addJar(JarFile jf)
    {
        for (Enumeration e=jf.entries(); e.hasMoreElements(); )
        {
            JarEntry entry = (JarEntry)e.nextElement();
            String[] res = entry.toString().split(""/"");
	    //            System.out.println(""JarEntry: "" + entry);
            if ((res.length > 0) && (res[res.length-1].toLowerCase().endsWith("".class"")))
            {
                String rs = res[res.length-1];
                rs = rs.substring(0, rs.length()-6);
                res[res.length-1] = rs;
                m_root.add(res);
            }
        }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.ClassChooserDialog,initComponents,,74,66,66,4,0.0833,0,0,4,1,1,1,"/** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents()//GEN-BEGIN:initComponents
    {
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        m_tree = new javax.swing.JTree();
        jPanel2 = new javax.swing.JPanel();
        m_buttonSelect = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        m_buttonCancel = new javax.swing.JButton();

        setTitle(""Class Selector"");
        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent evt)
            {
                closeDialog(evt);
            }
        });

        jPanel1.setLayout(new java.awt.BorderLayout());

        jPanel1.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(10, 10, 10, 10)));
        jPanel1.setFocusable(false);
        jLabel1.setText(""Select a class..."");
        jLabel1.setFocusable(false);
        jPanel1.add(jLabel1, java.awt.BorderLayout.NORTH);

        jPanel3.setLayout(new java.awt.BorderLayout());

        jPanel3.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(1, 1, 1, 1)));
        jPanel3.setFocusable(false);
        jScrollPane1.setFocusable(false);
        jScrollPane1.setViewportView(m_tree);

        jPanel3.add(jScrollPane1, java.awt.BorderLayout.CENTER);

        jPanel1.add(jPanel3, java.awt.BorderLayout.CENTER);

        getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);

        jPanel2.setFocusable(false);
        m_buttonSelect.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_calc-accept-16.png"")));
        m_buttonSelect.setText(""Select"");
        m_buttonSelect.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                buttonSelectActionPerformed(evt);
            }
        });

        jPanel2.add(m_buttonSelect);

        jPanel2.add(jSeparator1);

        m_buttonCancel.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_calc-cancel-16.png"")));
        m_buttonCancel.setText(""Cancel"");
        m_buttonCancel.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                buttonCancelActionPerformed(evt);
            }
        });

        jPanel2.add(m_buttonCancel);

        getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-371)/2, (screenSize.height-260)/2, 371, 260);
    }//GEN-END:initComponents"
jsmooth,net.charabia.jsmoothgen.application.gui.util.HTMLPane,HTMLPane,,29,6,6,4,0.25,0,1,3,3,0,1,"public HTMLPane()
    {
	try {
	    m_baseurl = new File(""."").toURL();
	} catch (Exception ex) { ex.printStackTrace(); }
	m_html = new JEditorPane(""text/html"",""<html></html>"") {
		public boolean getScrollableTracksViewportWidth()
		{
		    return true;
		}
	    };
	HTMLEditorKit hek = new HTMLEditorKit();
	m_html.setEditorKit(hek);

	m_scroller = new JScrollPane(m_html);
	setLayout(new BorderLayout());
	m_html.setEditable(false);
	add(m_scroller, BorderLayout.CENTER);
	//add(m_html, BorderLayout.CENTER);
	m_html.addHyperlinkListener(new Hyperactive());

	try {
	    m_launcher = new edu.stanford.ejalbert.BrowserLauncher();
	}catch (Exception ex)
	    {
		ex.printStackTrace();
	    }

    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.LayoutLengthDescriptor,LayoutLengthDescriptor,,46,221,166,4,0.112,0.0988,0,9,9,0,1,"public LayoutLengthDescriptor(String s) 
    {
	try {
	    s = s.trim();

	    StringBuffer len = new StringBuffer();
	    StringBuffer unit = new StringBuffer();

	    int offset = 0;

	    for (; offset < s.length(); offset++)
		{
		    char c = s.charAt(offset);
		    if (Character.isDigit(c) == false)
			break;
		    len.append(c);
		}

	    for (; offset < s.length(); offset++)
		{
		    char c = s.charAt(offset);
		    if (Character.isWhitespace(c) == false)
			break;
		}

	    for (; offset < s.length(); offset++)
		{
		    char c = s.charAt(offset);
		    unit.append(c);
		}
	    System.out.println(""len: "" + len);
	    System.out.println(""unit: "" + unit);

	    m_length = Integer.parseInt(len.toString());

	    String sunit = unit.toString();
	    if (sunit.equals(""px""))
		m_unit = PIXEL;
	    else if (sunit.equals(""%""))
		m_unit = PERCENT;

	} catch (Exception exc)
	    {
		throw new RuntimeException(""Error parsing "" + s);
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.CompilationDialog,initComponents,,63,54,53,6,0.1039,0.0204,0,4,1,1,1,"/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
    private void initComponents() {//GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        jLabel1 = new javax.swing.JLabel();
        m_progress = new javax.swing.JProgressBar();
        jScrollPane1 = new javax.swing.JScrollPane();
        m_state = new javax.swing.JTextArea(10,60);
	m_state.setLineWrap(true);
        m_cancelbutton = new javax.swing.JButton();

        getContentPane().setLayout(new java.awt.GridBagLayout());

        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                closeDialog(evt);
            }
        });

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText(""Progress"");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        getContentPane().add(jLabel1, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(5, 20, 5, 20);
        getContentPane().add(m_progress, gridBagConstraints);

	//        jScrollPane1.setBorder(new javax.swing.border.TitledBorder(""Compilation Information""));
	//        m_state.setBackground((java.awt.Color) javax.swing.UIManager.getDefaults().get(""Button.background""));
	//        m_state.setBorder(null);
        m_state.setEditable(false);
        jScrollPane1.setViewportView(m_state);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 10, 5, 10);
        getContentPane().add(jScrollPane1, gridBagConstraints);

        m_cancelbutton.setText(""Cancel"");
        m_cancelbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelbuttonActionPerformed(evt);
            }
        });

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
        gridBagConstraints.insets = new java.awt.Insets(10, 10, 10, 10);
        gridBagConstraints.weighty = 0.0001;
        gridBagConstraints.fill = java.awt.GridBagConstraints.NONE;
        getContentPane().add(m_cancelbutton, gridBagConstraints);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-319)/2, (screenSize.height-158)/2, 319, 158);
    }//GEN-END:initComponents"
jsmooth,net.charabia.jsmoothgen.application.gui.util.CompilationDialog,complete,,10,14,13,5,0.2222,0.0714,0,0,2,0,1,"public void complete()
	{
		if (!m_canceled)
		{
			m_result = true;
			setNewState(100, ""Done"");
			m_cancelbutton.setText(""Done"");			
			m_cancelbutton.grabFocus();
		}
	}"
jsmooth,net.charabia.jsmoothgen.application.gui.util.CompilationDialog,failed,,17,37,19,4,0.2121,0.2348,1,3,3,0,1,"public void failed()
	{
		if (!m_canceled)
		{
			m_result = false;
			StringBuffer buf = new StringBuffer();
			buf.append(""Compilation failed!\n"");
			Vector v = m_compiler.getErrors();
			for (int i=0; i<v.size(); i++)
			{
				buf.append(""\n- "");
				buf.append(v.get(i).toString());
			}
			buf.append(""\n"");
			setNewState(100, buf.toString());
		}
	}"
jsmooth,net.charabia.jsmoothgen.application.gui.util.PropertyEditorDialog,PropertyEditorDialog,,49,407,184,6,0.109,0.2056,0.5,4,1,0,1,"public PropertyEditorDialog(JavaPropertyPair prop)
    {
	super();
	setTitle(Main.local(""JAVAPROP_DIALOG_TITLE""));
	setModal(true);
	m_prop = prop;
	getContentPane().setLayout(new PanelLayout());

 	JLabel eq = new JLabel("" = "");
	eq.setHorizontalAlignment(JLabel.CENTER);

	OptionalHelpPanel keypane = new OptionalHelpPanel();
	keypane.setLabel(Main.local(""JAVAPROP_DIALOG_LABEL""));
	keypane.setHelpText(Main.local(""JAVAPROP_DIALOG_HELP""));
	keypane.getContentPane().setLayout(new GridBagLayout());

	GridBagConstraints c = new GridBagConstraints();
	c.fill = GridBagConstraints.HORIZONTAL;
	c.gridx = GridBagConstraints.RELATIVE;
	c.gridy = GridBagConstraints.RELATIVE;
	c.gridwidth = 1; // GridBagConstraints.RELATIVE;

	c.weightx = 0.5;
	keypane.getContentPane().add(new JLabel(Main.local(""JAVAPROP_NAME"")), c);
	c.weightx = 0.1;
	keypane.getContentPane().add(new JLabel(""""), c);
	c.weightx = 0.5;
	c.gridwidth = GridBagConstraints.REMAINDER;
	keypane.getContentPane().add(new JLabel(Main.local(""JAVAPROP_VALUE"")), c);

	c.gridwidth = 1; // GridBagConstraints.RELATIVE;
	c.weightx = 0.5;
	keypane.getContentPane().add(m_key, c);

	c.weightx = 0.1;
	keypane.getContentPane().add(eq, c);

	c.weightx = 0.5;
	keypane.getContentPane().add(m_value, c);

 	getContentPane().add(keypane);
	
	getBanner().setVisible(false);
	setResizable(false);
	pack();

	m_key.setText(m_prop.getName());
	m_value.setText(m_prop.getValue());
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.FileSelectionTextField,FileSelectionTextField,,44,24,20,3,0.25,0.1481,0,3,1,0,1,"public FileSelectionTextField()
    {
        m_fileChooser = new javax.swing.JFileChooser();
        m_filename = new javax.swing.JTextField();
        m_buttonFileSelection = new javax.swing.JButton();

        setLayout(new java.awt.BorderLayout());

        add(m_filename, java.awt.BorderLayout.CENTER);

        m_buttonFileSelection.setText(""..."");
        m_buttonFileSelection.addActionListener(new java.awt.event.ActionListener()
	    {
		public void actionPerformed(java.awt.event.ActionEvent evt)
		{
		    buttonFileSelectionActionPerformed(evt);
		}
	    });

	m_filename.addActionListener(new java.awt.event.ActionListener()
	    {
		public void actionPerformed(java.awt.event.ActionEvent evt)
		{
		    if (m_filename.getText().length() > 0)
			setFile(new java.io.File(m_filename.getText()));
		    else
			setFile(null);
		    notifyListeners(m_filename.getText());
		}
	    });
	m_filename.addFocusListener(new java.awt.event.FocusAdapter() {
		public void focusLost(java.awt.event.FocusEvent e) 
		{
		    if (m_filename.getText().length() > 0)
			setFile(new java.io.File(m_filename.getText()));
		    else
			setFile(null);
		    //		    setFile(new java.io.File(m_filename.getText()));
		    notifyListeners(m_filename.getText());
		}
	    });

        add(m_buttonFileSelection, java.awt.BorderLayout.EAST);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.FileSelectionTextField,buttonFileSelectionActionPerformed,,31,136,101,5,0.1526,0.0786,1,6,6,0,1,"private void buttonFileSelectionActionPerformed(java.awt.event.ActionEvent evt)
    {
	String fname = m_filename.getText().trim();
	java.io.File cur = new java.io.File(fname);
	if ((cur.isAbsolute() == false) && (m_basedir != null))
	    {
		cur = new File(m_basedir, cur.toString()).getAbsoluteFile();
		try {
		    cur = cur.getCanonicalFile();
		} catch (IOException iox)
		    {
			iox.printStackTrace();
		    }
	    }
	m_fileChooser.setSelectedFile(cur);
	if (m_fileChooser.showDialog(this, ""Select"") == JFileChooser.APPROVE_OPTION)
	    {
		java.io.File f = m_fileChooser.getSelectedFile();
		if (m_basedir != null)
		    {
			File rel = net.charabia.jsmoothgen.application.JSmoothModelPersistency.makePathRelativeIfPossible(m_basedir, f);
			m_filename.setText(rel.toString());
			notifyListeners(rel.toString());
		    }
		else
		    {
			m_filename.setText(f.getAbsolutePath());
			notifyListeners(f.getAbsolutePath());
		    }
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.RecentFileMenu,loadRecentPrefs,,18,35,25,4,0.2,0.077,0,4,4,0,1,"private void loadRecentPrefs()
    {
	Preferences p = Preferences.systemNodeForPackage(m_prefAttach);
	int count = p.getInt(""recentfilecount"", 0);
		
	m_recent.removeAllElements();
	for (int i=0; i<count; i++)
	    {
		String rf = p.get(""recentfile_"" + i, null);
		
		if ((rf != null) && (m_recent.size()<m_recentCount))
		    {
			m_recent.add(rf);
		    }
	    }
		
	buildMenu();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.RecentFileMenu,savePrefs,,10,23,18,5,0.2292,0.0847,0,2,2,0,1,"public void savePrefs()
    {
	Preferences p = Preferences.systemNodeForPackage(m_prefAttach);
	
	for (int i=0; i<m_recent.size(); i++)
	    {
		p.put(""recentfile_"" + i, m_recent.elementAt(i).toString());
	    }
	p.putInt(""recentfilecount"", m_recent.size());
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.RecentFileMenu,buildMenu,,22,44,33,2,0.1717,0.1015,1,5,2,0,1,"private void buildMenu()
    {
	m_root.removeAll();
	for (int i=0; i<Math.min(m_recent.size(),m_recentCount); i++)
	    {
		JMenuItem item = new JMenuItem(m_recent.elementAt(i).toString());
		ActionRecent ar = new ActionRecent();
		ar.Offset = i;
		item.addActionListener(ar);
		m_root.add(item);
	    }
	m_root.addSeparator();
	JMenuItem clear = new JMenuItem(""Clear"");
	clear.addActionListener(new java.awt.event.ActionListener() {
		public void actionPerformed(java.awt.event.ActionEvent evt)
		{
		    m_recent.removeAllElements();
		    buildMenu();
		}
	    });
	m_root.add(clear);
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.EditableListFileEditor,createNewItem,,18,23,10,2,0.254,0.1306,1,4,4,0,1,"public Object createNewItem(SortedEditableList selist)
    {
	if (m_fileChooser.showOpenDialog(selist) == JFileChooser.APPROVE_OPTION)
	    {
		File[] files = m_fileChooser.getSelectedFiles();
		for (int i=0; i<files.length; i++)
		    {
			File f = files[i];
			if (m_rootDir != null)
			    {
				f = net.charabia.jsmoothgen.application.JSmoothModelPersistency.makePathRelativeIfPossible(m_rootDir, f);
				files[i] = f;
			    }
		    }
		return files;
	    }
	return null;
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.EditableListFileEditor,editItem,,18,8,1,2,0.3333,0.1556,1,3,4,0,1,"public Object editItem(SortedEditableList selist, Object item)
    {
	if (! (item instanceof File))
	    m_fileChooser.setSelectedFile(new File(item.toString()));
	else
	    m_fileChooser.setSelectedFile((File)item);

	if (m_fileChooser.showOpenDialog(selist) == JFileChooser.APPROVE_OPTION)
	    {
		File f = m_fileChooser.getSelectedFile();
		if (m_rootDir != null)
		    {
			f = net.charabia.jsmoothgen.application.JSmoothModelPersistency.makePathRelativeIfPossible(m_rootDir, f);
		    }
		return f;
	    }
	return null;
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.PanelLayout,calculateMinimumSize,,18,36,17,3,0.2222,0.1201,1,5,4,0,1,"private void calculateMinimumSize(Container parent)
    {
	m_minimumSize = new Dimension();
        for (int i = 0; i < parent.getComponentCount(); i++)
	    {
		Component element = parent.getComponent(i);
		if (element.isVisible())
		    {
			Dimension eld = element.getPreferredSize();
			LayoutLengthDescriptor ld = (LayoutLengthDescriptor)m_componentToLayoutLengthDescriptor.get(element);
			if (ld != null)
			    eld.height = ld.getLength(parent.getHeight());

			m_minimumSize.height += eld.height;
			m_minimumSize.width = Math.max(m_minimumSize.width, eld.width);
		    }
	    }
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.PanelLayout,layoutContainer,,26,75,30,3,0.1932,0.1149,1,10,5,0,1,"public void layoutContainer(Container parent) 
    {
        Insets insets = parent.getInsets();
	int xoffset = insets.left;
	int yoffset = insets.top;
	int maxcwidth = parent.getWidth()-(insets.right+insets.left);
	int maxcheight = parent.getHeight()-insets.bottom;

        for (int i = 0; i < parent.getComponentCount(); i++)
	    {
		Component element = parent.getComponent(i);
		if (element.isVisible())
		    {
			Dimension eld = element.getPreferredSize();
			LayoutLengthDescriptor ld = (LayoutLengthDescriptor)m_componentToLayoutLengthDescriptor.get(element);
			if (ld != null)
			    eld.height = ld.getLength(parent.getHeight());

			if ((eld.height + yoffset) > maxcheight)
			    eld.height = maxcheight - yoffset;

			element.setBounds(xoffset, yoffset, maxcwidth, eld.height);
			yoffset += eld.height;
		    }
	    }	
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.RegExDocument,insertString,,28,49,32,2,0.1944,0.101,0,8,4,0,1,"public void insertString(int offset, String string, AttributeSet attributes) throws BadLocationException 
    {
	if (string == null) 
	    return;

	String result;
	int length = getLength();
	if (length == 0) 
	    {
		result = string;
	    } 
	else
	    {
		String currentContent = getText(0, length);
		StringBuffer currentBuffer = new StringBuffer(currentContent);
		currentBuffer.insert(offset, string);
		result = currentBuffer.toString();
	    }
	
	java.util.regex.Matcher m = m_pattern.matcher(result);

	if (m.matches())
	    {
		super.insertString(offset, string, attributes);	    
	    }
	
	java.awt.Toolkit.getDefaultToolkit().beep();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.SimpleFileFilter,accept,,10,8,6,3,0.3333,0.0926,0,2,3,0,1,"public boolean accept(java.io.File f)
	{
		String suffix = getSuffix(f);
		if (suffix.equalsIgnoreCase(m_suffix))
			return true;
		if (f.isDirectory())
			return true;
		
		return false;	
	}"
jsmooth,net.charabia.jsmoothgen.application.gui.util.OptionalHelpPanel,OptionalHelpPanel,,44,3,3,3,0.3333,0,1,3,2,0,1,"public OptionalHelpPanel()
    {
	setLayout(new GridBagLayout());

	m_helptoggle.addActionListener(new ActionListener() {
		public void actionPerformed(ActionEvent e) 
		{
		    m_helpActive = !m_helpActive;
		    toggleHelpCheck();
		}
	    });


	setLayout(new PanelLayout());

	m_titlePanel.setLayout(new BorderLayout());
       	m_titlePanel.add(BorderLayout.CENTER, m_title);
	m_titlePanel.add(BorderLayout.EAST, m_helptoggle);
	m_titlePanel.setOpaque(true);
	m_helptoggle.setOpaque(false);
	m_helptoggle.setBorder(null);
	m_title.setBorder(BorderFactory.createEmptyBorder(2,10,2,2));
 	add(m_titlePanel);
	
 	add(m_panel);
	add(m_helpPanel);

	setBorder(BorderFactory.createCompoundBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(2,2,2,2), BorderFactory.createBevelBorder(BevelBorder.RAISED)), BorderFactory.createEmptyBorder(2,2,2,2)));

	java.net.URL helpimgurl = getClass().getResource(""/icons/stock_help-agent.png"");
	if (helpimgurl != null)
	    {
		javax.swing.ImageIcon leaf = new javax.swing.ImageIcon(helpimgurl);
		m_helptoggle.setIcon(leaf);
		m_helptoggle.setText("""");
	    }
	else
	    {
		m_helptoggle.setText(""(?)"");
	    }
	setLabelColor(Color.white, Color.darkGray);

	toggleHelpCheck();
    }"
jsmooth,net.charabia.jsmoothgen.application.gui.util.CommandRunner,run,,11,19,10,3,0.2,0.0864,1,5,1,0,1,"static public void run(String[] cmd, File curdir) throws Exception
    {
	Process proc = Runtime.getRuntime().exec(cmd, null, curdir);
	InputStream stdin = proc.getInputStream();
	InputStream stderr = proc.getErrorStream();
		
	new Thread(new CmdStdReader(stdin)).start();
	new Thread(new CmdStdReader(stderr)).start();

	s_runningprocs.add(proc);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JavaAppPage,createPageArea,,170,234,168,3,0.0978,0.0918,1,25,1,0,1,"public Control createPageArea(Composite parent) {
        Composite top = new Composite(parent, SWT.NONE);
        top.setLayout(new GridLayout());

        Composite composite = new Composite(top, SWT.NONE);
        GridLayout layout = new GridLayout(3, false);
        layout.marginHeight = 0;
        layout.marginWidth = 0;
        composite.setLayout(layout);
        composite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
        
        usejar = new Button(composite, SWT.CHECK);
        usejar.setText(""Use embedded JAR"");
        usejar.addSelectionListener(LISTENER_USEJAR);
        GridData grid = new GridData(GridData.FILL);
        grid.horizontalSpan = 3;
        usejar.setLayoutData(grid);
        
        // Jar location
        Label label = new Label(composite, SWT.NONE);
        label.setText(""JAR location:"");
        grid = new GridData(GridData.FILL);
        label.setLayoutData(grid);

        jar = new Text(composite, SWT.BORDER);
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 250;
        jar.setLayoutData(grid);
        jar.addModifyListener(new ModifyListener() {
            public void modifyText(ModifyEvent e) {
                setModelJar(jar.getText());
            }
        });
        
        setjar = new Button(composite, SWT.NONE);
        setjar.setText(""Browse..."");
        setjar.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                FileDialog dialog = new FileDialog(getShell(), SWT.SAVE);
                dialog.setText(""JAR Location"");
                String file = dialog.open();
                if (file != null) jar.setText(file);
                setModelJar(file);
            }
        });
        grid = new GridData(GridData.FILL);
        grid.widthHint = 100;
        setjar.setLayoutData(grid);
        
        label = new Label(composite, SWT.SEPARATOR | SWT.HORIZONTAL);
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.horizontalSpan = 3;
        label.setLayoutData(grid);
        
        // Main class
        label = new Label(composite, SWT.NONE);
        label.setText(""Main class:"");
        grid = new GridData(GridData.FILL);
        label.setLayoutData(grid);

        mainclass = new Text(composite, SWT.BORDER);
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 250;
        mainclass.setLayoutData(grid);
        mainclass.addModifyListener(new ModifyListener() {
            public void modifyText(ModifyEvent e) {
                setModelMainclass(mainclass.getText());
            }
        });
        
        new Label(composite, SWT.NONE); // empty cell

        // Arguments
        label = new Label(composite, SWT.NONE);
        label.setText(""Arguments:"");
        grid = new GridData(GridData.FILL);
        label.setLayoutData(grid);

        args = new Text(composite, SWT.BORDER);
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 250;
        args.setLayoutData(grid);
        args.addModifyListener(new ModifyListener() {
            public void modifyText(ModifyEvent e) {
                setModelArguments(args.getText());
            }
        });
        
        new Label(composite, SWT.NONE); // empty cell

        // Classpath list
        Group group = new Group(top, SWT.NONE);
        group.setText(""Classpath"");
        group.setLayout(new GridLayout());
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.horizontalSpan = 3;
        group.setLayoutData(grid);
        group.setLayout(new GridLayout(2, false));

        classpath = new List(group, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL | SWT.MULTI);
        grid = new GridData(GridData.FILL_BOTH);
        grid.widthHint = 250; // TODO: Hardscoded
        grid.heightHint = classpath.getItemHeight() * 10; // TODO: Hardcoded
        classpath.setLayoutData(grid);
        classpath.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                updateRemoveButton();
            }
        });
        
        // The classpath Button bar
        composite = new Composite(group, SWT.NONE);
        composite.setLayoutData(new GridData(GridData.FILL_VERTICAL));
        layout = new GridLayout();
        layout.marginHeight = 0;
        layout.marginWidth = 2;
        composite.setLayout(layout);

        addjar = new Button(composite, SWT.NONE);
        addjar.setText(""Add JAR File..."");
        addjar.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                FileDialog dialog = new FileDialog(getShell(), SWT.OPEN | SWT.MULTI);
                dialog.setText(""JAR File"");
                String choice = dialog.open();
                if (choice != null) {
                    String path = dialog.getFilterPath();
                    String[] filenames = dialog.getFileNames();
                    ArrayList files = new ArrayList();
                    for (int i = 0; i < filenames.length; i++) {
                        files.add(path + File.separator + filenames[i]);
                    }
                    addClasspathItems((String[]) files.toArray(new String[0]));
                }
            }
        });
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 130;
        addjar.setLayoutData(grid);

        addfolder = new Button(composite, SWT.NONE);
        addfolder.setText(""Add Class Folder..."");
        addfolder.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                DirectoryDialog dialog = new DirectoryDialog(getShell(), SWT.SAVE);
                dialog.setText(""Class Folder"");
                String folder = dialog.open();
                if (folder != null) addClasspathItems(new String[]{folder});
            }
        });
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 130;
        addfolder.setLayoutData(grid);

        remove = new Button(composite, SWT.NONE);
        remove.setText(""Remove"");
        remove.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                removeItem();
            }
        });
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 130;
        remove.setLayoutData(grid);
        
        updateRemoveButton();
        updateUsejarWidgets();
        
        return top;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JavaAppPage,updateRemoveButton,,12,25,14,3,0.2667,0.131,0,3,3,0,1,"private void updateRemoveButton() {
        int i = classpath.getItemCount();
        boolean enable = true;
        if (i == 0) {
            enable = false;
        } else {
            int s = classpath.getSelectionCount();
            if (s == 0)
                enable = false;
        }
        remove.setEnabled(enable);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JavaAppPage,addClasspathItems,,9,14,7,3,0.3571,0.1333,0,3,3,0,1,"private void addClasspathItems(String[] items) {
        String[] olditems = classpath.getItems();
        for (int i = 0; i < items.length; i++) {
            // Check for duplicates
            if (Arrays.binarySearch(olditems, items[i]) >= 0) continue;
            classpath.add(items[i]);
        }
        setModelClasspath(classpath.getItems());
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JavaAppPage,load,,22,73,41,4,0.1778,0.1106,0.428571429,11,5,0,1,"public void load() {
        JSmoothModelBean jsmodel = getApplication().getModelBean();
        String[] classpath = jsmodel.getClassPath();
        if (classpath == null) classpath = new String[0];
        this.classpath.setItems(classpath);
        
        boolean usejar = jsmodel.getEmbeddedJar();
        this.usejar.setSelection(usejar);
        LISTENER_USEJAR.widgetSelected(null);
        
        String mainclass = jsmodel.getMainClassName();
        if (mainclass == null) mainclass = """";
        this.mainclass.setText(mainclass);
        
        String jar = jsmodel.getJarLocation();
        if (jar == null) jar = """";
        this.jar.setText(jar);
        
        String args = jsmodel.getArguments();
        if (args == null) args = """";
        this.args.setText(args);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.SkeletonPage,createPageArea,,32,53,40,4,0.15,0.0709,1,7,1,0,1,"public Control createPageArea(Composite parent) {
        Composite top = new Composite(parent, SWT.NONE);
        top.setLayout(new GridLayout(3, false));

        Label label = new Label(top, SWT.NONE);
        label.setText(""Skeleton:"");

        skelcombo = new Combo(top, SWT.READ_ONLY);
        GridData grid = new GridData(GridData.FILL);
        grid.widthHint = 120;
        skelcombo.setLayoutData(grid);
        
        loadSkeleton(getApplication().getInitialSkeletonName());
        skelcombo.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                setSkeletonName(skelcombo.getText());
            }
        });

        Button button = new Button(top, SWT.PUSH);
        grid = new GridData(GridData.FILL);
        grid.widthHint = 120;
        button.setLayoutData(grid);
        button.setText(""Properties..."");
        button.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                (new SkeletonPropertiesDialog(SkeletonPage.this)).open();
            }
        });

        return top;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.SkeletonPage,loadSkeleton,,7,15,9,3,0.3214,0.1,1,3,1,0,1,"private void loadSkeleton(String skelname) {
        String[] skeletons = getApplication().getAllSkeletonNames();
        skelcombo.setItems(skeletons);
        System.out.println(""[DEBUG] Loading skeleton : "" + skelname);
        int index = Arrays.binarySearch(skeletons, skelname);
        skelcombo.select(index);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.WelcomePage,createPageArea,,33,321,264,3,0.1071,0.0635,0,12,1,0,1,"public Control createPageArea(Composite parent) {
        Display display = parent.getDisplay();
        
        Composite top = new Composite(parent, SWT.NONE);
        GridLayout layout = new GridLayout();
        layout.marginHeight = 0;
        layout.marginWidth = 0;
        top.setLayout(layout);
        
        FormToolkit kit = new FormToolkit(parent.getDisplay());
        Form form = kit.createForm(top);
        GridData grid = new GridData(GridData.FILL_BOTH);
        grid.widthHint = 400;
        form.setLayoutData(grid);
        form.setText(""Welcome to JSmooth !"");
        TableWrapLayout wraplayout = new TableWrapLayout();
        form.getBody().setLayout(wraplayout);
        HyperlinkGroup hypergroup = kit.getHyperlinkGroup();
        hypergroup.setActiveForeground(display.getSystemColor(SWT.COLOR_BLUE));
        hypergroup.setForeground(display.getSystemColor(SWT.COLOR_BLUE));
        hypergroup.setHyperlinkUnderlineMode(HyperlinkGroup.UNDERLINE_HOVER);
        
        Label label = kit.createSeparator(form.getBody(), SWT.HORIZONTAL);
        TableWrapData wrapgrid = new TableWrapData(TableWrapData.FILL_GRAB);
        label.setLayoutData(wrapgrid);
        
        FormText text = kit.createFormText(form.getBody(), true);
        wrapgrid = new TableWrapData(TableWrapData.FILL);
        text.setLayoutData(wrapgrid);
        text.setText(JSmoothResources.TEXT_HELP_WELCOME, true, false);
        
        return top;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.RunexeAction,run,,14,17,0,2,0.2889,0.2731,0.5,4,2,0,1,"public boolean run() {
        System.out.println(""[DEBUG] Running exe..."");
        JSmoothApplication app = getApplication();
        if (!app.hasProjectFile()) {
            app.consoleMessage(""Cannot run without a project file. Please save the project or load a new one, then try again."");
            return false;
        }
        
        JSmoothModelBean jsmodel = app.getModelBean();
        String basedir = app.getProjectFile().getParent();
        File exe = new File (basedir, jsmodel.getExecutableName());
        app.consoleMessage(""Running exe "" + exe.getAbsolutePath());
        return Program.launch(exe.getAbsolutePath());
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JVMOptionsPage,createPageArea,,62,80,40,3,0.1591,0.1319,0,10,1,1,1,"public Control createPageArea(Composite parent) {
        Composite top = new Composite(parent, SWT.NONE);
        top.setLayout(new GridLayout());

        // Classpath list
        Group group = new Group(top, SWT.NONE);
        group.setText(""Classpath"");
        group.setLayout(new GridLayout());
        GridData griddata = new GridData(GridData.FILL_HORIZONTAL);
        group.setLayoutData(griddata);
        group.setLayout(new GridLayout(2, false));

        classpath = new List(group, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL | SWT.MULTI);
        griddata = new GridData(GridData.FILL_BOTH);
        griddata.widthHint = 250; // TODO: Hardscoded
        griddata.heightHint = classpath.getItemHeight() * 10; // TODO: Hardcoded
        classpath.setLayoutData(griddata);
        classpath.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
            }
        });
        
        // The classpath Button bar
        Composite composite = new Composite(group, SWT.NONE);
        composite.setLayoutData(new GridData(GridData.FILL_VERTICAL));
        GridLayout layout = new GridLayout();
        layout.marginHeight = 0;
        layout.marginWidth = 2;
        composite.setLayout(layout);

        addjar = new Button(composite, SWT.NONE);
        addjar.setText(""Add JAR File..."");
        addjar.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
            }
        });
        griddata = new GridData(GridData.FILL_HORIZONTAL);
        griddata.widthHint = 130;
        addjar.setLayoutData(griddata);

        addfolder = new Button(composite, SWT.NONE);
        addfolder.setText(""Add Class Folder..."");
        addfolder.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
            }
        });
        griddata = new GridData(GridData.FILL_HORIZONTAL);
        griddata.widthHint = 130;
        addfolder.setLayoutData(griddata);

        remove = new Button(composite, SWT.NONE);
        remove.setText(""Remove"");
        remove.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
            }
        });
        griddata = new GridData(GridData.FILL_HORIZONTAL);
        griddata.widthHint = 130;
        remove.setLayoutData(griddata);
        
        return top;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.ExecutablePage,createPageArea,,98,56,34,3,0.1538,0.1067,1,20,1,1,1,"public Control createPageArea(Composite parent) {
        Composite top = new Composite(parent, SWT.NONE);
        top.setLayout(new GridLayout(3, false));

        // Executable name
        Label label = new Label(top, SWT.NONE);
        label.setText(""Executable name:"");
        GridData grid = new GridData(GridData.FILL);
        label.setLayoutData(grid);

        exe = new Text(top, SWT.BORDER);
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 250;
        exe.setLayoutData(grid);
        exe.addModifyListener(new ModifyListener() {
            public void modifyText(ModifyEvent e) {
                setModelExename(exe.getText());
            }
        });

        Button button = new Button(top, SWT.NONE);
        button.setText(""Browse..."");
        button.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                FileDialog dialog = new FileDialog(getShell(), SWT.SAVE);
                dialog.setText(""Executable Name"");
                String file = dialog.open();
                if (file != null) ExecutablePage.this.exe.setText(file);
            }
        });
        grid = new GridData(GridData.FILL);
        grid.widthHint = 100;
        button.setLayoutData(grid);

        // Current directory
        label = new Label(top, SWT.NONE);
        label.setText(""Current directory:"");
        grid = new GridData(GridData.FILL);
        label.setLayoutData(grid);

        dir = new Text(top, SWT.BORDER);
        grid = new GridData(GridData.FILL_HORIZONTAL);
        grid.widthHint = 250;
        dir.setLayoutData(grid);
        dir.addModifyListener(new ModifyListener() {
            public void modifyText(ModifyEvent e) {
                setModelCurrentdir(dir.getText());
            }
        });
        
        button = new Button(top, SWT.NONE);
        button.setText(""Browse..."");
        button.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                DirectoryDialog dialog = new DirectoryDialog(getShell(), SWT.SAVE);
                dialog.setText(""Current Directory"");
                String dir = dialog.open();
                if (dir != null) ExecutablePage.this.dir.setText(dir);
            }
        });
        grid = new GridData(GridData.FILL);
        grid.widthHint = 100;
        button.setLayoutData(grid);

        Group group = new Group(top, SWT.NONE);
        GridLayout layout = new GridLayout();
        group.setLayout(layout);
        grid = new GridData(GridData.FILL | GridData.HORIZONTAL_ALIGN_CENTER);
        grid.horizontalSpan = 3;
        group.setLayoutData(grid);
        group.setText(""Executable icon"");

        icon = new Label(group, SWT.BORDER | SWT.FLAT);
        grid = new GridData(GridData.FILL | GridData.HORIZONTAL_ALIGN_CENTER);
        grid.widthHint = 48;
        grid.heightHint = 48;
        icon.setLayoutData(grid);

        button = new Button(group, SWT.NONE);
        button.setText(""Browse..."");
        button.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                FileDialog dialog = new FileDialog(getShell(), SWT.OPEN);
                dialog.setText(""Icon File"");
                String file = dialog.open();

                // Means ""CANCEL""
                if (file == null) return;

                setModelIcon(setIcon(file) ? file : null);
            }
        });
        grid = new GridData(GridData.FILL);
        grid.widthHint = 100;
        button.setLayoutData(grid);
        
        return top;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.ExecutablePage,load,,13,26,16,3,0.2222,0.1057,0.6,6,3,0,1,"public void load() {
        JSmoothModelBean jsmodel = getApplication().getModelBean();
        String exename = jsmodel.getExecutableName();
        if (exename == null) exename = """";
        this.exe.setText(exename);
        
        String iconfile = jsmodel.getIconLocation();
        setIcon(iconfile);
        
        String dirname = jsmodel.getCurrentDirectory();
        if (dirname == null) dirname = """";
        this.dir.setText(dirname);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,newProject,,30,155,34,7,0.1125,0.3361,0.2,1,2,0,1,"public void newProject() {
        // Create a new empty JSmoothModelBean
        jsmodel = new JSmoothModelBean();
        jsmodel.setSkeletonName(getInitialSkeletonName());
        setSkeletonProperties(getInititalSkeletonProperties());
        jsmodel.setExecutableName("""");
        jsmodel.setArguments("""");
        jsmodel.setBundledJVMPath("""");
        jsmodel.setClassPath(new String[0]);
        jsmodel.setCurrentDirectory("""");
        jsmodel.setIconLocation("""");
        jsmodel.setJarLocation("""");
        jsmodel.setJavaProperties(new JavaPropertyPair[0]);
        jsmodel.setJVMSearchPath(new String[0]);
        jsmodel.setMainClassName("""");
        jsmodel.setMaximumVersion("""");
        jsmodel.setMinimumVersion("""");
        jsmodel.setNoJvmMessage("""");
        jsmodel.setNoJvmURL("""");
        
        projectfile = null;
        compiler = new ExeCompiler();
        compiler.addListener(new SWTCompileListener());
        
        for (int i = 0; i < PAGES.length; i++) {
            PAGES[i].load();
        }
        
        getShell().setText(getProjectName());
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,createMainMenu,,92,33,21,3,0.2286,0.0962,1,12,1,1,1,"private void createMainMenu(Shell shell) {
        mainmenu = new Menu(shell, SWT.BAR);
        
        /* ==== FILE ACTIONS ==== */
        
        MenuItem topItem = new MenuItem(mainmenu, SWT.CASCADE);
        topItem.setText(""File"");
        Menu menu = new Menu(shell, SWT.DROP_DOWN);
        topItem.setMenu(menu);
        
        MenuItem item = new MenuItem(menu, SWT.NULL);
        item.setText(""New"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_NEW.run();
            }
        });
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Open..."");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_OPEN.run();
            }
        });
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Save"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_SAVE.run();
            }
        });
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Save As..."");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_SAVE_AS.run();
            }
        });
        
        item = new MenuItem(menu, SWT.SEPARATOR);
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Exit"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_EXIT.run();
            }
        });
        
        /* ==== PROJECT ACTIONS ==== */
        
        topItem = new MenuItem(mainmenu, SWT.CASCADE);
        topItem.setText(""Project"");
        menu = new Menu(shell, SWT.DROP_DOWN);
        topItem.setMenu(menu);
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Compile"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_COMPILE.run();
            }
        });
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Run .exe"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_RUNEXE.run();
            }
        });
        
        /* ==== CONSOLE ACTIONS ==== */
        
        topItem = new MenuItem(mainmenu, SWT.CASCADE);
        topItem.setText(""Console"");
        menu = new Menu(shell, SWT.DROP_DOWN);
        topItem.setMenu(menu);
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Clear"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_CONSOLE_CLEAR.run();
            }
        });
        
        shell.setMenuBar(mainmenu);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,createPages,,8,17,13,3,0.2143,0.0708,1,2,2,0,1,"private void createPages(Shell shell) {
        pagearea = new Composite(shell, SWT.NONE);
        stack = new StackLayout();
        pagearea.setLayout(stack);
        for (int i = 0; i < PAGES.length; i++) {
            PAGES[i].createControl(pagearea);
        }
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,showPage,,6,13,11,4,0.25,0.0595,0.5,2,3,0,1,"public void showPage(JSmoothPage page) {
        stack.topControl = page.getControl();
        if (pagearea != null) pagearea.layout();
        ToolItem item = page.getToolItem();
        if (!item.getSelection()) item.setSelection(true);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,run,,20,57,48,7,0.2222,0.15,0,0,5,0,1,"public void run() {
        if (shell == null) createControls();

        // open the window
        shell.open();
        
        newProject();
        showPage(PAGE_WELCOME);
        
        try {
            while (shell != null && !shell.isDisposed()) {
                if (!display.readAndDispatch()) {
                    display.sleep();
                }
            }
            display.update();
        } finally {
            display.dispose();
        }
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,createConsole,,42,71,51,3,0.1488,0.0772,1,8,1,0,1,"private void createConsole(Shell shell) {
        consolearea = new Composite(shell, SWT.NULL);
        GridLayout gridlayout = new GridLayout();
        consolearea.setLayout(gridlayout);
        
        console = new Text(consolearea, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.READ_ONLY | SWT.BORDER);
        console.setBackground(shell.getDisplay().getSystemColor(SWT.COLOR_WHITE));
        console.setForeground(shell.getDisplay().getSystemColor(SWT.COLOR_BLUE));
        GridData gridata = new GridData(GridData.FILL_BOTH);
        console.setLayoutData(gridata);
        
        /* ==== CONSOLE MENU ==== */
        
        Menu menu = new Menu(shell, SWT.NULL);
        
        MenuItem item = new MenuItem(menu, SWT.NULL);
        item.setText(""Clear"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                ACTION_CONSOLE_CLEAR.run();
            }
        });
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Copy"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                console.copy();
            }
        });
        
        item = new MenuItem(menu, SWT.NULL);
        item.setText(""Copy All"");
        item.addSelectionListener(new SelectionAdapter() {
            public void widgetSelected(SelectionEvent e) {
                console.selectAll();
                console.copy();
            }
        });
        
        console.setMenu(menu);
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,fillSkeletonList,,6,7,4,3,0.3333,0.1481,1,2,2,0,1,"private void fillSkeletonList(List list) {
        Iterator i = skeletonList.getIteratorNoDebugName();
        while (i.hasNext()) {
            list.add((String) i.next());
        }
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,saveProjectAs,,12,24,20,5,0.2083,0.0793,1,4,2,0,1,"public boolean saveProjectAs(String projectfile) {
        System.out.println(""[DEBUG] Saving project to file: "" + projectfile);
        this.projectfile = new File(projectfile);
        try {
            JSmoothModelPersistency.save(this.projectfile, jsmodel);
        } catch (IOException e) {
            System.out.println(""[ERROR] Failed saving project : "" + e.getMessage());
            return false;
        }
        getShell().setText(getProjectName());
        return true;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,openProject,,21,69,60,6,0.1538,0.0641,1,7,3,0,1,"public boolean openProject(String projectfile) {
        System.out.println(""[DEBUG] Opening project : "" + projectfile);
        File file = new File(projectfile);
        JSmoothModelBean jsmodel = null;
        try {
            jsmodel = JSmoothModelPersistency.load(file);
        } catch (IOException e) {
            System.out.println(""[ERROR] Failed opening project : "" + e.getMessage());
            return false;
        }
        
        this.projectfile = file;
        this.jsmodel = jsmodel;
        
        for (int i = 0; i < PAGES.length; i++) {
            PAGES[i].load();
        }
        
        getShell().setText(getProjectName());
        return true;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,compileProject,,26,112,88,5,0.1345,0.0545,0.375,7,3,0,1,"public boolean compileProject() {
        consoleMessage(""=== Compilation ==="");
        File basedir = projectfile.getParentFile();
        jsmodel.normalizePaths(basedir);
        String skeletonName = jsmodel.getSkeletonName();
        SkeletonBean skeletonBean = skeletonList.getSkeleton(skeletonName);
        File skeletonRoot = skeletonList.getDirectory(skeletonBean);
        
        // NOTE: We assume the exe name is always relative
        File exename = new File(jsmodel.getExecutableName());
        if (!exename.isAbsolute()) {
            exename = new File(basedir, jsmodel.getExecutableName());
        }
        
        boolean success = false;
        try {
            success = compiler.compile(skeletonRoot, skeletonBean, basedir, jsmodel, exename);
        } catch (Exception e) {
            // Do nothing, bellow we the errors anyway (see bellow).
        }
        
        consoleMessages((String[]) compiler.getErrors().toArray(new String[0]));
        compiler.cleanErrors();
        
        return success;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.JSmoothApplication,consoleSection,,9,14,7,3,0.4286,0.25,0,2,2,0,1,"public void consoleSection(String title) {
        StringBuffer buffer = new StringBuffer(""-------------------------------------------------------------------------------------"");
        if (title == null) {
            consoleMessage(buffer.toString());
            return;
        }
        buffer.replace(0, title.length() + 1, title + "" "");
        consoleMessage(buffer.toString());
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.CompileAction,run,,12,11,1,3,0.7143,0.5,0.4,1,2,0,1,"public boolean run() {
        System.out.println(""[DEBUG] Compiling, stand by..."");
        JSmoothApplication app = getApplication();
        if (!app.hasProjectFile()) {
            app.consoleMessage(""Cannot compile without a project file. Please save the project or load a new one, then try again."");
            return false;
        }
        else {
            app.saveProject();
        }
        return app.compileProject();
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.SkeletonPropertiesDialog,createDialogArea,,17,56,46,3,0.1458,0.0635,0.75,6,3,0,1,"protected Control createDialogArea(Composite parent) {
        Composite cmpDlgArea = new Composite(parent, SWT.NONE);
        cmpDlgArea.setLayout(new GridLayout());

        SkeletonProperty[] props = page.getApplication().getSkeletonProperties();
        for (int i = 0; i < props.length; i++) {
            System.out.println(""[DEBUG] Loading skeleton property: "" + props[i].getIdName() + ""="" + props[i].getValue());
        }
        
        for (int i = 0; i < props.length; i++) {
            Control c = createPropertyControl(cmpDlgArea, props[i]);
            c.setData(props[i]);
            controls.add(c);
        }

        return cmpDlgArea;
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.SkeletonPropertiesDialog,createPropertyControl,,45,487,308,7,0.1425,0.1221,0.333333333,5,4,1,1,"private Control createPropertyControl(Composite wParent, SkeletonProperty prop) {
        Group group = null;
        GridData grid = null;
        if (prop.getType().equals(SkeletonProperty.TYPE_STRING)) {
            group = new Group(wParent, SWT.NONE);
            grid = new GridData(GridData.FILL);
            grid.widthHint = 400;
            group.setLayoutData(grid);
            group.setLayout(new GridLayout());
            group.setText(prop.getLabel());

            text = new Text(group, SWT.SINGLE | SWT.BORDER);
            grid = new GridData(GridData.FILL_BOTH);
            text.setLayoutData(grid);
            text.setText(prop.getValue());

            return text;
        }
        else if (prop.getType().equals(SkeletonProperty.TYPE_TEXTAREA)) {
            group = new Group(wParent, SWT.NONE);
            grid = new GridData(GridData.FILL);
            grid.widthHint = 400;
            grid.heightHint = 100;
            group.setLayoutData(grid);
            group.setLayout(new GridLayout());
            group.setText(prop.getLabel());

            text = new Text(group, SWT.MULTI | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
            grid = new GridData(GridData.FILL_BOTH);
            text.setLayoutData(grid);
            text.setText(prop.getValue());

            return text;
        }
        else if (prop.getType().equals(SkeletonProperty.TYPE_BOOLEAN)) {
            Button chk = new Button(wParent, SWT.CHECK);
            chk.setText(prop.getLabel());
            chk.setSelection(""1"".equals(prop.getValue()));

            return chk;
        }
        else {
            throw new UnsupportedOperationException(""Unknown skeleton property type."");
        }
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.SkeletonPropertiesDialog,okPressed,,28,145,80,4,0.1786,0.1498,0.75,6,6,0,1,"protected void okPressed() {
        Iterator it = controls.iterator();
        
        JSmoothApplication app = page.getApplication();
        Control ctrl = null;
        String value = null;
        SkeletonProperty prop = null;
        while (it.hasNext()) {
            ctrl = (Control) it.next();
            prop = (SkeletonProperty) ctrl.getData();
            if (prop.getType().equals(SkeletonProperty.TYPE_STRING)) {
                value = ((Text) ctrl).getText();
                prop.setValue(value);
            }
            else if (prop.getType().equals(SkeletonProperty.TYPE_TEXTAREA)) {
                value = ((Text) ctrl).getText();
                prop.setValue(value);
            }
            else if (prop.getType().equals(SkeletonProperty.TYPE_BOOLEAN)) {
                boolean b = ((Button) ctrl).getSelection();
                value = (b == true) ? ""1"" : ""0"";
                prop.setValue(value);
            }
            app.setSkeletonProperty(prop);
        }

        super.okPressed();
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.OpenAction,run,,13,34,23,4,0.3333,0.1468,0.5,3,3,0,1,"public boolean run() {
        FileDialog dialog = new FileDialog(getApplication().getShell(), SWT.OPEN);
        dialog.setText(""Open Project"");
        String file = dialog.open();
        if (file != null) {
            boolean ok = getApplication().openProject(file);
            if (ok) getApplication().consoleMessage(""Opened the project file "" + file);
            return ok;
        }
        else {
            return false;
        }
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.SaveAsProjectAction,run,,11,22,16,4,0.375,0.16,0.666666667,2,2,0,1,"public boolean run() {
        FileDialog dialog = new FileDialog(getApplication().getShell(), SWT.SAVE);
        dialog.setText(""Save Project"");
        String file = dialog.open();
        if (file != null) {
            return getApplication().saveProjectAs(file);
        }
        else {
            return false;
        }
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.resources.JSmoothResources,loadImages,,14,8,0,2,0.3333,0.3556,0,2,1,0,1,"public void loadImages(Display display) {
        System.out.println(""[DEBUG] Loading images..."");
        String name = bundle.getString(""img.switcher.skeleton"");
        IMG_SWITCHER_SKELETON_PAGE = new Image(display, getClass().getResourceAsStream(name));
        
        name = bundle.getString(""img.switcher.application"");
        IMG_SWITCHER_APPLICATION = new Image(display, getClass().getResourceAsStream(name));
        
        name = bundle.getString(""img.switcher.executable"");
        IMG_SWITCHER_EXECUTABLE = new Image(display, getClass().getResourceAsStream(name));
        
        name = bundle.getString(""img.switcher.welcome"");
        IMG_SWITCHER_WELCOME = new Image(display, getClass().getResourceAsStream(name));
    }"
jsmooth,net.charabia.jsmoothgen.application.swtgui.resources.JSmoothResources,loadText,,12,15,9,3,0.2571,0.1468,0,3,2,0,1,"public void loadText() {
        System.out.println(""[DEBUG] Loading text..."");
        InputStream stream = getClass().getResourceAsStream(""welcome.xml"");
        byte[] bytes = new byte[5000]; // 50 KB Should be enough.
        try {
            stream.read(bytes);
            TEXT_HELP_WELCOME = (new String(bytes)).trim();
            stream.close();
        } catch (IOException e1) {
            // TODO: Throw some exception at init time.
        }
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEHeader,read,,83,367,0,4,0.0265,0.3132,1,3,1,0,1,"public void read() throws IOException
    {
	FileChannel ch = m_pe.getChannel();
	ByteBuffer head = ByteBuffer.allocate(255);
	head.order(ByteOrder.LITTLE_ENDIAN);
	ch.position(m_baseoffset);
	ch.read(head);
	head.position(0);

	int pemagic = head.getInt();
	//	System.out.println(""MAGIC::: "" + pemagic);
	Machine = head.getShort(); //  4
	NumberOfSections = head.getShort();     //  6
	TimeDateStamp = head.getInt(); //  8
	PointerToSymbolTable = head.getInt();     //  C
	NumberOfSymbols = head.getInt(); // 10
	SizeOfOptionalHeader = head.getShort();     // 14
	Characteristics = head.getShort(); // 16
	// Optional Header 

	Magic = head.getShort();     // 18
	MajorLinkerVersion = head.get();     // 1a
	MinorLinkerVersion = head.get(); // 1b
	SizeOfCode = head.getInt();     // 1c
	SizeOfInitializedData = head.getInt(); // 20
	SizeOfUninitializedData = head.getInt();     // 24
	AddressOfEntryPoint = head.getInt(); // 28
	BaseOfCode = head.getInt();     // 2c
	BaseOfData = head.getInt();    //    // NT additional fields. // 30
	//    
	ImageBase = head.getInt();     // 34
	SectionAlignment = head.getInt(); // 38
	FileAlignment = head.getInt();     // 3c
	MajorOperatingSystemVersion = head.getShort(); // 40
	MinorOperatingSystemVersion = head.getShort();     // 42
	MajorImageVersion = head.getShort(); // 44
	MinorImageVersion = head.getShort();     // 46
	MajorSubsystemVersion = head.getShort(); // 48
	MinorSubsystemVersion = head.getShort();     // 4a
	Reserved1 = head.getInt();     // 4c
	SizeOfImage = head.getInt(); // 50
	SizeOfHeaders = head.getInt();     // 54
	CheckSum = head.getInt();     // 58
	Subsystem = head.getShort(); // 5c
	DllCharacteristics = head.getShort();     // 5e
	SizeOfStackReserve = head.getInt(); // 60
	SizeOfStackCommit = head.getInt();     // 64
	SizeOfHeapReserve = head.getInt(); // 68
	SizeOfHeapCommit = head.getInt();     // 6c
	LoaderFlags = head.getInt(); // 70
	NumberOfRvaAndSizes = head.getInt(); // 74

	ExportDirectory_VA = head.getInt(); // 78
	ExportDirectory_Size = head.getInt(); // 7c
	ImportDirectory_VA = head.getInt(); // 80
	ImportDirectory_Size = head.getInt(); // 84
	ResourceDirectory_VA = head.getInt(); // 88
	ResourceDirectory_Size = head.getInt(); // 8c
	ExceptionDirectory_VA = head.getInt(); // 90
	ExceptionDirectory_Size = head.getInt(); // 94
	SecurityDirectory_VA = head.getInt(); // 98
	SecurityDirectory_Size = head.getInt(); // 9c
	BaseRelocationTable_VA = head.getInt(); // a0
	BaseRelocationTable_Size = head.getInt(); // a4
	DebugDirectory_VA = head.getInt(); // a8
	DebugDirectory_Size = head.getInt(); // ac
	ArchitectureSpecificData_VA = head.getInt(); // b0
	ArchitectureSpecificData_Size = head.getInt(); // b4
	RVAofGP_VA = head.getInt(); // b8
	RVAofGP_Size = head.getInt(); // bc
	TLSDirectory_VA = head.getInt(); // c0
	TLSDirectory_Size = head.getInt(); // c4
	LoadConfigurationDirectory_VA = head.getInt(); // c8
	LoadConfigurationDirectory_Size = head.getInt(); // cc
	BoundImportDirectoryinheaders_VA = head.getInt(); // d0
	BoundImportDirectoryinheaders_Size = head.getInt(); // d4
	ImportAddressTable_VA = head.getInt(); // d8
	ImportAddressTable_Size = head.getInt(); // dc
	DelayLoadImportDescriptors_VA = head.getInt(); // e0
	DelayLoadImportDescriptors_Size = head.getInt(); // e4
	COMRuntimedescriptor_VA = head.getInt(); // e8
	COMRuntimedescriptor_Size = head.getInt(); // ec
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEHeader,dump,,75,137,0,3,0.029,0.3339,0,1,1,0,1,"public void dump(PrintStream out)
    {
	out.println(""HEADER:"");
	out.println(""int  Machine="" + Machine + "" //  4"");
	out.println(""int  NumberOfSections="" + NumberOfSections + ""     //  6"");
	out.println(""long   TimeDateStamp="" + TimeDateStamp + "" //  8"");
	out.println(""long   PointerToSymbolTable="" + PointerToSymbolTable + ""     //  C"");
	out.println(""long   NumberOfSymbols="" + NumberOfSymbols + "" // 10"");
	out.println(""int  SizeOfOptionalHeader="" + SizeOfOptionalHeader + ""     // 14"");
	out.println(""int  Characteristics="" + Characteristics + "" // 16"");
	// Optional Header 

	out.println(""int    Magic="" + Magic + ""     // 18"");
	out.println(""short   MajorLinkerVersion="" + MajorLinkerVersion + ""     // 1a"");
	out.println(""short   MinorLinkerVersion="" + MinorLinkerVersion + "" // 1b"");
	out.println(""long   SizeOfCode="" + SizeOfCode + ""     // 1c"");
	out.println(""long   SizeOfInitializedData="" + SizeOfInitializedData + "" // 20"");
	out.println(""long   SizeOfUninitializedData="" + SizeOfUninitializedData + ""     // 24"");
	out.println(""long   AddressOfEntryPoint="" + AddressOfEntryPoint + "" // 28"");
	out.println(""long   BaseOfCode="" + BaseOfCode + ""     // 2c"");
	out.println(""long   BaseOfData="" + BaseOfData + ""    //    // NT additional fields. // 30"");
	//    
	out.println(""long   ImageBase="" + ImageBase + ""     // 34"");
	out.println(""long   SectionAlignment="" + SectionAlignment + "" // 38"");
	out.println(""long   FileAlignment="" + FileAlignment + ""     // 3c"");
	out.println(""int    MajorOperatingSystemVersion="" + MajorOperatingSystemVersion + "" // 40"");
	out.println(""int    MinorOperatingSystemVersion="" + MinorOperatingSystemVersion + ""     // 42"");
	out.println(""int    MajorImageVersion="" + MajorImageVersion + "" // 44"");
	out.println(""int    MinorImageVersion="" + MinorImageVersion + ""     // 46"");
	out.println(""int    MajorSubsystemVersion="" + MajorSubsystemVersion + "" // 48"");
	out.println(""int    MinorSubsystemVersion="" + MinorSubsystemVersion + ""     // 4a"");
	out.println(""long   Reserved1="" + Reserved1 + ""     // 4c"");
	out.println(""long   SizeOfImage="" + SizeOfImage + "" // 50"");
	out.println(""long   SizeOfHeaders="" + SizeOfHeaders + ""     // 54"");
	out.println(""long   CheckSum="" + CheckSum + ""     // 58"");
	out.println(""int    Subsystem="" + Subsystem + "" // 5c"");
	out.println(""int    DllCharacteristics="" + DllCharacteristics + ""     // 5e"");
	out.println(""long   SizeOfStackReserve="" + SizeOfStackReserve + "" // 60"");
	out.println(""long   SizeOfStackCommit="" + SizeOfStackCommit + ""     // 64"");
	out.println(""long   SizeOfHeapReserve="" + SizeOfHeapReserve + "" // 68"");
	out.println(""long   SizeOfHeapCommit="" + SizeOfHeapCommit + ""     // 6c"");
	out.println(""long   LoaderFlags="" + LoaderFlags + "" // 70"");
	out.println(""long   NumberOfRvaAndSizes="" + NumberOfRvaAndSizes + "" // 74"");

	out.println(""long ExportDirectory_VA="" + ExportDirectory_VA +"" // 78"");
	out.println(""long ExportDirectory_Size="" + ExportDirectory_Size +"" // 7c"");
	out.println(""long ImportDirectory_VA="" + ImportDirectory_VA +"" // 80"");
	out.println(""long ImportDirectory_Size="" + ImportDirectory_Size +"" // 84"");
	out.println(""long ResourceDirectory_VA="" + ResourceDirectory_VA +"" // 88"");
	out.println(""long ResourceDirectory_Size="" + ResourceDirectory_Size +"" // 8c"");
	out.println(""long ExceptionDirectory_VA="" + ExceptionDirectory_VA +"" // 90"");
	out.println(""long ExceptionDirectory_Size="" + ExceptionDirectory_Size +"" // 94"");
	out.println(""long SecurityDirectory_VA="" + SecurityDirectory_VA +"" // 98"");
	out.println(""long SecurityDirectory_Size="" + SecurityDirectory_Size +"" // 9c"");
	out.println(""long BaseRelocationTable_VA="" + BaseRelocationTable_VA +"" // a0"");
	out.println(""long BaseRelocationTable_Size="" + BaseRelocationTable_Size +"" // a4"");
	out.println(""long DebugDirectory_VA="" + DebugDirectory_VA +"" // a8"");
	out.println(""long DebugDirectory_Size="" + DebugDirectory_Size +"" // ac"");
	out.println(""long ArchitectureSpecificData_VA="" + ArchitectureSpecificData_VA +"" // b0"");
	out.println(""long ArchitectureSpecificData_Size="" + ArchitectureSpecificData_Size +"" // b4"");
	out.println(""long RVAofGP_VA="" + RVAofGP_VA +"" // b8"");
	out.println(""long RVAofGP_Size="" + RVAofGP_Size +"" // bc"");
	out.println(""long TLSDirectory_VA="" + TLSDirectory_VA +"" // c0"");
	out.println(""long TLSDirectory_Size="" + TLSDirectory_Size +"" // c4"");
	out.println(""long LoadConfigurationDirectory_VA="" + LoadConfigurationDirectory_VA +"" // c8"");
	out.println(""long LoadConfigurationDirectory_Size="" + LoadConfigurationDirectory_Size +"" // cc"");
	out.println(""long BoundImportDirectoryinheaders_VA="" + BoundImportDirectoryinheaders_VA +"" // d0"");
	out.println(""long BoundImportDirectoryinheaders_Size="" + BoundImportDirectoryinheaders_Size +"" // d4"");
	out.println(""long ImportAddressTable_VA="" + ImportAddressTable_VA +"" // d8"");
	out.println(""long ImportAddressTable_Size="" + ImportAddressTable_Size +"" // dc"");
	out.println(""long DelayLoadImportDescriptors_VA="" + DelayLoadImportDescriptors_VA +"" // e0"");
	out.println(""long DelayLoadImportDescriptors_Size="" + DelayLoadImportDescriptors_Size +"" // e4"");
	out.println(""long COMRuntimedescriptor_VA="" + COMRuntimedescriptor_VA +"" // e8"");
	out.println(""long COMRuntimedescriptor_Size="" + COMRuntimedescriptor_Size +"" // ec"");
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEHeader,updateVAAndSize,,58,501,0,7,0.0655,0.2355,0,20,3,0,1,"public void updateVAAndSize(Vector oldsections, Vector newsections)
    {
	long codebase = findNewVA(this.BaseOfCode, oldsections, newsections);
	long codesize = findNewSize(this.BaseOfCode, oldsections, newsections);
	//	System.out.println(""New BaseOfCode="" + codebase + "" (size="" + codesize + "")"");
	this.BaseOfCode = codebase;
	this.SizeOfCode = codesize;

	this.AddressOfEntryPoint = findNewVA(this.AddressOfEntryPoint, oldsections, newsections);
	
	long database = findNewVA(this.BaseOfData, oldsections, newsections);
	long datasize = findNewSize(this.BaseOfData, oldsections, newsections);
	//	System.out.println(""New BaseOfData="" + database + "" (size="" + datasize + "")"");
	this.BaseOfData = database;

	long imagesize = 0;
	for (int i=0; i<newsections.size(); i++)
	    {
		PESection sect = (PESection)newsections.get(i);
		long curmax = sect.VirtualAddress + sect.VirtualSize;
		if (curmax > imagesize)
		    imagesize = curmax;
	    }
	this.SizeOfImage = imagesize;

	//	this.SizeOfInitializedData = datasize;

	ExportDirectory_Size = findNewSize(ExportDirectory_VA, oldsections, newsections);
	ExportDirectory_VA = findNewVA(ExportDirectory_VA, oldsections, newsections);
	ImportDirectory_Size = findNewSize(ImportDirectory_VA, oldsections, newsections);
	ImportDirectory_VA = findNewVA(ImportDirectory_VA, oldsections, newsections);
	ResourceDirectory_Size = findNewSize(ResourceDirectory_VA, oldsections, newsections);
	ResourceDirectory_VA = findNewVA(ResourceDirectory_VA, oldsections, newsections);
	ExceptionDirectory_Size = findNewSize(ExceptionDirectory_VA, oldsections, newsections);
	ExceptionDirectory_VA = findNewVA(ExceptionDirectory_VA, oldsections, newsections);
	SecurityDirectory_Size = findNewSize(SecurityDirectory_VA, oldsections, newsections);
	SecurityDirectory_VA = findNewVA(SecurityDirectory_VA, oldsections, newsections);
	BaseRelocationTable_Size = findNewSize(BaseRelocationTable_VA, oldsections, newsections);
	BaseRelocationTable_VA = findNewVA(BaseRelocationTable_VA, oldsections, newsections);
	DebugDirectory_Size = findNewSize(DebugDirectory_VA, oldsections, newsections);
	DebugDirectory_VA = findNewVA(DebugDirectory_VA, oldsections, newsections);
	ArchitectureSpecificData_Size = findNewSize(ArchitectureSpecificData_VA, oldsections, newsections);
	ArchitectureSpecificData_VA = findNewVA(ArchitectureSpecificData_VA, oldsections, newsections);
	RVAofGP_Size = findNewSize(RVAofGP_VA, oldsections, newsections);
	RVAofGP_VA = findNewVA(RVAofGP_VA, oldsections, newsections);
	TLSDirectory_Size = findNewSize(TLSDirectory_VA, oldsections, newsections);
	TLSDirectory_VA = findNewVA(TLSDirectory_VA, oldsections, newsections);
	LoadConfigurationDirectory_Size = findNewSize(LoadConfigurationDirectory_VA, oldsections, newsections);
	LoadConfigurationDirectory_VA = findNewVA(LoadConfigurationDirectory_VA, oldsections, newsections);
	BoundImportDirectoryinheaders_Size = findNewSize(BoundImportDirectoryinheaders_VA, oldsections, newsections);
	BoundImportDirectoryinheaders_VA = findNewVA(BoundImportDirectoryinheaders_VA, oldsections, newsections);
	ImportAddressTable_Size = findNewSize(ImportAddressTable_VA, oldsections, newsections);
	ImportAddressTable_VA = findNewVA(ImportAddressTable_VA, oldsections, newsections);
	DelayLoadImportDescriptors_Size = findNewSize(DelayLoadImportDescriptors_VA, oldsections, newsections);
	DelayLoadImportDescriptors_VA = findNewVA(DelayLoadImportDescriptors_VA, oldsections, newsections);
	COMRuntimedescriptor_Size = findNewSize(COMRuntimedescriptor_VA, oldsections, newsections);
	COMRuntimedescriptor_VA = findNewVA(COMRuntimedescriptor_VA, oldsections, newsections);
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEHeader,findNewVA,,25,64,50,5,0.1923,0.0715,0,8,5,0,1,"private long findNewVA(long current, Vector oldsections, Vector newsections)
    {
	for (int i=0; i<oldsections.size(); i++)
	    {
		PESection sect = (PESection)oldsections.get(i);
		if (sect.VirtualAddress == current)
		    {
			PESection newsect = (PESection)newsections.get(i);

			//			System.out.println(""Translation VA found for "" + current + "" = "" + i + "" ("" +newsect.VirtualAddress + "")="" + newsect.getName());
			return newsect.VirtualAddress;
		    }
		else if ((current > sect.VirtualAddress) && (current < (sect.VirtualAddress + sect.VirtualSize)))
		    {
			long diff = current - sect.VirtualAddress;
			PESection newsect = (PESection)newsections.get(i);
			//			System.out.println(""Translation VA found INSIDE "" + current + "" = "" + i + "" ("" +newsect.VirtualAddress + "")="" + newsect.getName());
			return newsect.VirtualAddress + diff;
		    }
	    }

	

	return 0;
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEHeader,findNewSize,,15,23,18,4,0.2292,0.068,0,6,3,0,1,"private long findNewSize(long current, Vector oldsections, Vector newsections)
    {
	for (int i=0; i<oldsections.size(); i++)
	    {
		PESection sect = (PESection)oldsections.get(i);
		if (sect.VirtualAddress == current)
		    {
			PESection newsect = (PESection)newsections.get(i);
			//			System.out.println(""Translation Size found for "" + current + "" = "" + i + "" ("" +newsect.VirtualAddress + "")="" + newsect.getName());
			//			System.out.println(""         Old size "" + sect.VirtualSize + "" vs new size "" + newsect.VirtualSize);
			return newsect.VirtualSize;
		    }
	    }
	return 0;
    }"
jsmooth,net.charabia.jsmoothgen.pe.PESection,read,,23,76,0,3,0.1022,0.2059,1,3,2,0,1,"public void read() throws IOException
    {
	FileChannel ch = m_pe.getChannel();
	ByteBuffer head = ByteBuffer.allocate(40);
	head.order(ByteOrder.LITTLE_ENDIAN);
	ch.position(m_baseoffset);
	ch.read(head);
	head.position(0);

	ANSI_Name = new byte[8];
	for (int i=0; i<8; i++)
	    ANSI_Name[i] = head.get();

	VirtualSize = head.getInt();
	VirtualAddress = head.getInt();
	SizeOfRawData = head.getInt(); 
	PointerToRawData = head.getInt();
	PointerToRelocations = head.getInt();
	PointerToLinenumbers = head.getInt();
	NumberOfRelocations = head.getShort();
	NumberOfLinenumbers = head.getShort();
	Characteristics = head.getInt();
    }"
jsmooth,net.charabia.jsmoothgen.pe.PESection,dump,,18,13,0,2,0.1429,0.3489,0,2,2,1,1,"public void dump(PrintStream out)
    {
	out.println(""SECTION:"");
	out.print(""  Name= "" );
	for (int i=0; i<8; i++)
	    out.print((char)ANSI_Name[i]);
	out.println("""");
	out.println(""  VirtualSize= ""+VirtualSize + ""  // 	The size of the section when it is mapped to memory. Must be a multiple of 4096. (8)(DWORD)"");
	out.println(""  VirtualAddress= "" + VirtualAddress + ""   // 	An rva to where it should be mapped in memory. (12)(DWORD)"");
	out.println(""  SizeOfRawData= "" + SizeOfRawData + ""   // 	The size of the section in the PE file. Must be a multiple of 512 (16)(DWORD)"");
	out.println(""  PointerToRawData= "" + PointerToRawData + ""   // 	A file based offset which points to the location of this sections data (20)(DWORD)"");
	out.println(""  PointerToRelocations= "" + PointerToRelocations + ""   // 	In EXE's this field is meaningless, and is set 0 (24)(DWORD)"");
	out.println(""  PointerToLinenumbers= "" + PointerToLinenumbers + ""   // 	This is the file-based offset of the line number table. This field is only used for debug purposes, and is usualy set to 0 (28)(DWORD)"");
	out.println(""  NumberOfRelocations= "" + NumberOfRelocations + ""   // 	In EXE's this field is meaningless, and is set 0 (32)(WORD)"");
	out.println(""  NumberOfLinenumbers= "" + NumberOfLinenumbers + ""   // 	The number of line numbers in the line number table for this section. This field is only used for debug purposes, and is usualy set to 0 (34)(WORD)"");
	out.println(""  Characteristics= "" + Characteristics + ""   // 	The kind of data stored in this section ie. Code, Data, Import data, Relocation data (36)(DWORD)"");
	
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEOldMSHeader,read,,43,99,0,3,0.0714,0.2569,1,6,5,0,1,"public void read() throws IOException
    {
	FileChannel ch = m_pe.getChannel();
	ByteBuffer mz = ByteBuffer.allocate(64);
	mz.order(ByteOrder.LITTLE_ENDIAN);

	ch.read(mz, 0);
	mz.position(0);
	
	byte m = mz.get();
	byte z = mz.get();
	if ((m == 77) && (z == 90))
	    {
		//		System.out.println(""MZ found !"");
	    }
	
	e_cblp = mz.getShort();          // Bytes on last page of file //  2
	e_cp = mz.getShort();            // Pages in file //  4
	e_crlc = mz.getShort();          // Relocations //  6
	e_cparhdr = mz.getShort();       // Size of header in paragraphs //  8
	e_minalloc = mz.getShort();      // Minimum extra paragraphs needed //  A
	e_maxalloc = mz.getShort();      // Maximum extra paragraphs needed //  C
	e_ss = mz.getShort();            // Initial (relative) SS value //  E
	e_sp = mz.getShort();            // Initial SP value // 10
	e_csum = mz.getShort();          // Checksum // 12
	e_ip = mz.getShort();            // Initial IP value // 14
	e_cs = mz.getShort();            // Initial (relative) CS value // 16
	e_lfarlc = mz.getShort();        // File address of relocation table // 18
	e_ovno = mz.getShort();          // Overlay number // 1A
    
	for (int i=0; i<4; i++)
	    e_res[i] = mz.getShort();

	e_oemid = mz.getShort();         // OEM identifier (for e_oeminfo) // 24
	e_oeminfo = mz.getShort();       // OEM information; e_oemid specific // 26
	
	for (int i=0; i<10; i++)
	    e_res2[i] = mz.getShort();      // Reserved words // 28
	
	e_lfanew = mz.getInt();       // File address of new exe header // 3C
	
	//	System.out.println(""exe header : "" + e_lfanew);
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEOldMSHeader,dump,,23,35,0,3,0.1022,0.2824,0,1,1,1,1,"public void dump(PrintStream out)
    {
	out.println(""MSHeader:"");

	out.println(""e_cblp: "" + e_cblp + "" // Bytes on last page of file //  2"");
	out.println(""e_cp: "" + e_cp + "" // Pages in file //  4"");
	out.println(""e_crlc: "" + e_crlc + "" // Relocations //  6"");
	out.println(""e_cparhdr: "" + e_cparhdr + "" // Size of header in paragraphs //  8"");
	out.println(""e_minalloc: "" + e_minalloc + "" // Minimum extra paragraphs needed //  A"");
	out.println(""e_maxalloc: "" + e_maxalloc + "" // Maximum extra paragraphs needed //  C"");
	out.println(""e_ss: "" + e_ss + "" // Initial (relative) SS value //  E"");
	out.println(""e_sp: "" + e_sp + "" // Initial SP value // 10"");
	out.println(""e_csum: "" + e_csum + "" // Checksum // 12"");
	out.println(""e_ip: "" + e_ip + "" // Initial IP value // 14"");
	out.println(""e_cs: "" + e_cs + "" // Initial (relative) CS value // 16"");
	out.println(""e_lfarlc: "" + e_lfarlc + "" // File address of relocation table // 18"");
	out.println(""e_ovno: "" + e_ovno + "" // Overlay number // 1A"");
	//	int[] e_res = new int[4];        // Reserved words // 1C
	out.println(""e_oemid: "" + e_oemid + "" // OEM identifier (for e_oeminfo) // 24"");
	out.println(""e_oeminfo: "" + e_oeminfo + "" // OEM information; e_oemid specific // 26"");
	//	int[] e_res2 = new int[10];      // Reserved words // 28
	out.println(""e_lfanew: "" + e_lfanew + "" // File address of new exe header // 3C"");
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEResourceDirectory,init,,12,6,2,2,0.32,0.1333,1,2,1,0,1,"public void init() throws IOException
	{
	    ///		System.out.println(""RESOURCE INIT"");
	    //		System.out.println(""   Offset: "" + m_master.PointerToRawData);
		FileChannel chan = m_file.getChannel();
		chan.position(m_master.PointerToRawData);
		PEResourceDirectory.ImageResourceDirectory dir = new PEResourceDirectory.ImageResourceDirectory(chan);
		//		System.out.println(""-----------------\nDUMP\n---------------"");
		m_root = dir;
		
		//		dir.dump(System.out, 0);
	}"
jsmooth,net.charabia.jsmoothgen.pe.PEResourceDirectory,buildResource,,10,9,0,2,0.3143,0.2714,0.5,3,1,0,1,"public ByteBuffer buildResource(long virtualBaseOffset)
	{
	    //		System.out.println(""BUILDING RESOURCE / VIRTUAL: "" + virtualBaseOffset);
		int resourceSize = m_root.diskSize();
		ByteBuffer resbuf = ByteBuffer.allocate(resourceSize);
		resbuf.order(ByteOrder.LITTLE_ENDIAN);
		resbuf.position(0);
		m_root.buildBuffer(resbuf, virtualBaseOffset);
		return resbuf;
	}"
jsmooth,net.charabia.jsmoothgen.pe.PEResourceDirectory,replaceResource,,19,31,17,4,0.1909,0.103,1,8,7,0,1,"public boolean replaceResource(String catId, int resourceId, int langId, ByteBuffer data)
	{
		ResourceEntry catEntry = m_root.getResourceEntry(catId);
		if ((catEntry != null) && (catEntry.Directory != null))
		{
			ResourceEntry identEntry = catEntry.Directory.getResourceEntry(resourceId);
			if ((identEntry != null) && (identEntry.Directory != null))
			{
				ResourceEntry langEntry = identEntry.Directory.getResourceEntry(langId);
				if ((langEntry != null) && (langEntry.Data != null))
				{
					DataEntry dataslot = langEntry.Data;
					dataslot.setData(data);
					return true;
				}
			}
		}
		return false;
	}"
jsmooth,net.charabia.jsmoothgen.pe.PEResourceDirectory,addNewResource,,18,61,44,3,0.1429,0.0636,0.666666667,10,1,0,1,"public void addNewResource(String catId, String resourceId, String languageId, ByteBuffer data)
	{
		DataEntry dataEntry = new DataEntry(data);
		ResourceEntry languageEntry = buildResourceEntry(languageId, dataEntry);
		ImageResourceDirectory languageDir = new ImageResourceDirectory();
		
		languageDir.TimeDateStamp = 0x3F2CCF64;
		languageDir.addEntry(languageEntry);
		
		ResourceEntry identEntry = buildResourceEntry(resourceId, languageDir);
		
		ImageResourceDirectory identDir = new ImageResourceDirectory();
		identDir.TimeDateStamp = 0x3F2CCF64;
		identDir.addEntry(identEntry);
		
		ResourceEntry catEntry = buildResourceEntry(catId, identDir);
		m_root.addEntry(catEntry);
	}"
jsmooth,net.charabia.jsmoothgen.pe.PEResourceDirectory,buildResourceEntry,,10,5,0,2,0.36,0.1367,1,3,3,0,1,"public ResourceEntry buildResourceEntry(String id, DataEntry data)
	{
		if ((id.length() > 1) && (id.charAt(0) == '#'))
		{
			int intid = Integer.parseInt(id.substring(1));
			return new ResourceEntry(intid, data);
		}
		
		return new ResourceEntry(id, data);
	}"
jsmooth,net.charabia.jsmoothgen.pe.PEResourceDirectory,buildResourceEntry,,10,5,0,2,0.36,0.1367,1,3,3,0,1,"public ResourceEntry buildResourceEntry(String id, ImageResourceDirectory dir)
	{
		if ((id.length() > 1) && (id.charAt(0) == '#'))
		{
			int intid = Integer.parseInt(id.substring(1));
			return new ResourceEntry(intid, dir);
		}
		
		return new ResourceEntry(id, dir);
	}"
jsmooth,net.charabia.jsmoothgen.pe.PEFile,open,,46,404,373,11,0.0652,0.0217,0.5,10,4,0,1,"public void open() throws FileNotFoundException, IOException
    {
	m_in = new FileInputStream(m_file);
	m_channel = m_in.getChannel();

	m_oldmsheader = new PEOldMSHeader(this);				

	m_oldmsheader.read();
	// m_oldmsheader.dump(System.out);
	long headoffset = m_oldmsheader.e_lfanew;
		
	m_header = new PEHeader(this, headoffset);
	m_header.read();
	// m_header.dump(System.out);

	int seccount = m_header.NumberOfSections;
	//	System.out.println(""LOADING "" + seccount + "" sections..."");

	long offset = headoffset + (m_header.NumberOfRvaAndSizes * 8) + 24 + 96;
		
	for (int i=0; i<seccount; i++)
	    {
		//		System.out.println(""Offset: "" + offset + "" ("" + this.m_channel.position());

		PESection sect = new PESection(this, offset);
		sect.read();
		// sect.dump(System.out);
		m_sections.add(sect);
		offset += 40;
	    }
	//	System.out.println(""After sections: "" + this.m_channel.position() + "" ("" + offset + "")"");

	ByteBuffer resbuf = null;
	long resourceoffset = m_header.ResourceDirectory_VA;
	for (int i=0; i<seccount; i++)
	    {
		PESection sect = (PESection)m_sections.get(i);
		if (sect.VirtualAddress == resourceoffset)
		    {
			//			System.out.println(""  Resource section found: "" + resourceoffset);
			PEResourceDirectory prd = new PEResourceDirectory(this, sect);
			resbuf = prd.buildResource(sect.VirtualAddress);
			break;
		    }
	    }
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEFile,dumpTo,,185,4374,3698,19,0.0458,0.0449,0.5,54,15,0,1,"public void dumpTo(File destination) throws IOException, CloneNotSupportedException
    {
	int outputcount = 0;
	FileOutputStream fos = new FileOutputStream(destination);
	FileChannel out = fos.getChannel();

	//
	// Make a copy of the Header, for safe modifications
	//
	PEOldMSHeader oldmsheader = (PEOldMSHeader) this.m_oldmsheader.clone();
	PEHeader peheader = (PEHeader) m_header.clone();
	Vector sections = new Vector();
	for (int i=0; i<m_sections.size(); i++)
	    {
		PESection sect = (PESection)m_sections.get(i);
		PESection cs = (PESection)sect.clone();
		sections.add(cs);
	    }
		
	//
	// First, write the old MS Header, the one starting
	// with ""MZ""...
	//
	long newexeoffset = oldmsheader.e_lfanew;
	ByteBuffer msheadbuffer = oldmsheader.get();
	outputcount = out.write(msheadbuffer);
	this.m_channel.position(64);
	out.transferFrom(this.m_channel,  64, newexeoffset - 64);
		
		
	//
	// Then Write the new Header...
	//
	ByteBuffer headbuffer = peheader.get();
	out.position(newexeoffset);
	outputcount = out.write(headbuffer);

	//
	// After the header, there are all the section
	// headers...
	//
	long offset = oldmsheader.e_lfanew + (m_header.NumberOfRvaAndSizes * 8) + 24 + 96;
	out.position(offset);
	for (int i=0; i<sections.size(); i++)
	    {
		// System.out.println(""  offset: "" + out.position());
		PESection sect = (PESection) sections.get(i);
		
		ByteBuffer buf = sect.get();
		outputcount = out.write(buf);
	    }

	//
	// Now, we write the real data: each of the section
	// and their data...
	//

	// Not sure why it's always at 1024... ?
	offset = 1024;

	//
	// Dump each section data
	//

	long virtualAddress = offset;
	if ((virtualAddress % peheader.SectionAlignment)>0)
	    virtualAddress += peheader.SectionAlignment - (virtualAddress%peheader.SectionAlignment);

	long resourceoffset = m_header.ResourceDirectory_VA;
	for (int i=0; i<sections.size(); i++)
	    {
		PESection sect = (PESection) sections.get(i);
		if (resourceoffset == sect.VirtualAddress)
		    {
			//			System.out.println(""Dumping RES section "" + i + "" at "" + offset + "" from "" + sect.PointerToRawData + "" (VA="" + virtualAddress + "")"");
			out.position(offset);
			long sectoffset = offset;
			PEResourceDirectory prd = this.getResourceDirectory();
			ByteBuffer resbuf = prd.buildResource(sect.VirtualAddress);
			resbuf.position(0);

			out.write(resbuf);
			offset += resbuf.capacity();
			long rem = offset % this.m_header.FileAlignment;
			if (rem != 0)
			    offset += this.m_header.FileAlignment - rem;

			if (out.size()+1 < offset)
			    {
				ByteBuffer padder = ByteBuffer.allocate(1);
				out.write(padder, offset - 1);
			    }
			
			long virtualSize = resbuf.capacity();
			if ((virtualSize  % peheader.FileAlignment)>0)
			    virtualSize += peheader.SectionAlignment - (virtualSize%peheader.SectionAlignment);

			sect.PointerToRawData = sectoffset;
			sect.SizeOfRawData = resbuf.capacity();
			if ((sect.SizeOfRawData%this.m_header.FileAlignment)>0)
			    sect.SizeOfRawData += (this.m_header.FileAlignment-(sect.SizeOfRawData%this.m_header.FileAlignment));
			sect.VirtualAddress = virtualAddress;
			sect.VirtualSize = virtualSize;

			virtualAddress += virtualSize;

		    }
		else if (sect.PointerToRawData > 0)
		    {
			//			System.out.println(""Dumping section "" + i + ""/"" + sect.getName() + "" at "" + offset + "" from "" + sect.PointerToRawData + "" (VA="" + virtualAddress + "")"");
			out.position(offset);
			this.m_channel.position(sect.PointerToRawData);
			long sectoffset = offset;

			out.position(offset + sect.SizeOfRawData);
			ByteBuffer padder = ByteBuffer.allocate(1);
			out.write(padder, offset + sect.SizeOfRawData - 1);
				
			long outted = out.transferFrom(this.m_channel, offset, sect.SizeOfRawData);
			offset += sect.SizeOfRawData;
			//			System.out.println(""offset before alignment, "" + offset);

			long rem = offset % this.m_header.FileAlignment;
			if (rem != 0)
			    {
				offset += this.m_header.FileAlignment - rem;
			    }
			//			System.out.println(""offset after alignment, "" + offset);
			
			// 			long virtualSize = sect.SizeOfRawData;
			// 			if ((virtualSize % peheader.SectionAlignment)>0)
			// 			    virtualSize += peheader.SectionAlignment - (virtualSize%peheader.SectionAlignment);
			
			sect.PointerToRawData = sectoffset;
			//			sect.SizeOfRawData = 
			sect.VirtualAddress = virtualAddress;
			//			sect.VirtualSize = virtualSize;

			virtualAddress += sect.VirtualSize;
 			if ((virtualAddress % peheader.SectionAlignment)>0)
 			    virtualAddress += peheader.SectionAlignment - (virtualAddress%peheader.SectionAlignment);
			
		    }
		else
		    {
			// generally a BSS, with a virtual size but no
			// data in the file...
			//			System.out.println(""Dumping section "" + i + "" at "" + offset + "" from "" + sect.PointerToRawData + "" (VA="" + virtualAddress + "")"");
			long virtualSize = sect.VirtualSize;
			if ((virtualSize % peheader.SectionAlignment)>0)
			    virtualSize += peheader.SectionAlignment - (virtualSize%peheader.SectionAlignment);

			sect.VirtualAddress = virtualAddress;
			//			sect.VirtualSize = virtualSize;
			virtualAddress += virtualSize;

		    }
	    }

	// 
	// Now that all the sections have been written, we have the
	// correct VirtualAddress and Sizes, so we can update the new
	// header and all the section headers...
	
	peheader.updateVAAndSize(m_sections, sections);
 	headbuffer = peheader.get();
 	out.position(newexeoffset);
 	outputcount = out.write(headbuffer);

	// peheader.dump(System.out);
	///	System.out.println(""Dumping the section again..."");
 	offset = oldmsheader.e_lfanew + (m_header.NumberOfRvaAndSizes * 8) + 24 + 96;
 	out.position(offset);
	for (int i=0; i<sections.size(); i++)
	    {
		//		System.out.println(""  offset: "" + out.position());
		PESection sect = (PESection) sections.get(i);
		// sect.dump(System.out);
		ByteBuffer buf = sect.get();
		outputcount = out.write(buf);
	    }

	fos.flush();
	fos.close();
    }"
jsmooth,net.charabia.jsmoothgen.pe.PEFile,replaceDefaultIcon,,36,279,233,10,0.1538,0.09,0.666666667,12,2,0,1,"/*
     */

    
    public void replaceDefaultIcon(ResIcon icon) throws Exception
    {
	PEResourceDirectory resdir = getResourceDirectory();
	
	PEResourceDirectory.DataEntry entry = resdir.getData(""#14"", null, null);
	if (entry == null)
	    {
		throw new Exception(""Can't find any icon group in the file!"");
	    }
	
	entry.Data.position(0);
	//	System.out.println(""DataEntry found : "" + entry + "" (size="" + entry.Data.remaining() + "")"");
	entry.Data.position(0);
	
	ResIconDir rid = new ResIconDir(entry.Data);
	//	System.out.println(""ResIconDir :"");
	//	System.out.println(rid.toString());
	int iconid = rid.getEntries()[0].dwImageOffset;
	//	System.out.println(""Icon Index: "" + iconid);
	
	PEResourceDirectory.DataEntry iconentry = resdir.getData(""#3"", ""#""+iconid, null);
	iconentry.Data.position(0);
	//	System.out.println(""Icon :"");
	//	System.out.println(icon.toString());
	
	rid.getEntries()[0].bWidth = (short)icon.Width;
	rid.getEntries()[0].bHeight = (short)(icon.Height/2);
	rid.getEntries()[0].bColorCount = (short)(1 <<icon.BitsPerPixel);
	rid.getEntries()[0].wBitCount = icon.BitsPerPixel;
	rid.getEntries()[0].dwBytesInRes = icon.getData().remaining();
	
	iconentry.Data = icon.getData();
	iconentry.Size = iconentry.Data.remaining();

	entry.setData(rid.getData());
    }"
jsmooth,net.charabia.jsmoothgen.pe.res.ResIconDir,ResIconDir,,12,17,6,3,0.25,0.1111,1,2,2,0,1,"/** Creates a new instance of ResIconDir */
	public ResIconDir(ByteBuffer buf)
	{
		m_idReserved = buf.getShort();
		m_idType = buf.getShort();
		m_idCount = buf.getShort();
		
		m_entries = new ResIconDir.IconDirEntry[m_idCount];
		for (int i=0; i<m_idCount; i++)
		{
			m_entries[i] = new IconDirEntry(buf);
		}
	}"
jsmooth,net.charabia.jsmoothgen.pe.res.ResIconDir,toString,,14,21,0,3,0.1667,0.2821,1,2,2,0,1,"public String toString()
    {
	StringBuffer out = new StringBuffer();
	out.append(""m_idReserved: "" + m_idReserved + ""\n"");   // Reserved (must be 0)
	out.append(""m_idType: "" + m_idType + ""\n"");       // Resource Type (1 for icons)
	out.append(""m_idCount: "" + m_idCount + ""\n"");      // How many images?
	out.append(""entries: ---- \n"" );
	for (int i=0; i<m_entries.length; i++)
	    {
		out.append(m_entries[i].toString());
	    }

	return out.toString();
    }"
jsmooth,net.charabia.jsmoothgen.pe.res.ResIcon,ResIcon,,73,836,637,9,0.054,0.0631,1,11,8,0,1,"/** 
     * Creates a new instance of ResIcon 
     * @see
     * @param in
     */
    public ResIcon(ByteBuffer in)
    {
	Size = in.getInt();
	Width = in.getInt();
	Height = in.getInt();
	Planes = in.getShort();
	BitsPerPixel = in.getShort();
	Compression = in.getInt();
	SizeOfBitmap = in.getInt();
	HorzResolution = in.getInt();
	VertResolution = in.getInt();
	ColorsUsed = in.getInt();
	ColorsImportant = in.getInt();
		
	int cols = (int)ColorsUsed;
	if (cols == 0)
	    cols = 1 << BitsPerPixel;
		
	Palette = new PaletteElement[(int)cols];
	for (int i=0; i<Palette.length; i++)
	    {
		PaletteElement el = new PaletteElement();
		el.Blue = in.get();
		el.Green = in.get();
		el.Red = in.get();
		el.Reserved = in.get();
		Palette[i] = el;
	    }

	// int xorbytes = (((int)Height/2) * (int)Width * (int)BitsPerPixel) / 8;
	int xorbytes = (((int)Height/2) * (int)Width);
	//		System.out.println(""POSITION "" + in.position() + "" : xorbitmap = "" + xorbytes + "" bytes"");
		
	BitmapXOR = new short[xorbytes];
	for (int i=0; i<BitmapXOR.length; i++)
	    {
		switch(BitsPerPixel)
		    {
		    case 4:
			{
			    int pix = in.get();
			    BitmapXOR[i] = (short)((pix >> 4) & 0x0F);
			    i++;
			    BitmapXOR[i] = (short)(pix & 0x0F);
			}
			break;
		    case 8:
			{
			    BitmapXOR[i] = in.get();
			}
			break;
		    }
	    }
		

	int height = (int)(Height/2);
	int rowsize = (int)Width / 8;
	if ((rowsize%4)>0)
	    {
		rowsize += 4 - (rowsize%4);
	    }
		
	//		System.out.println(""POSITION "" + in.position() + "" : andbitmap = "" + andbytes + "" bytes"");

	int andbytes = height * rowsize;   // (((int)Height/2) * (int)Width) / 8;
				
	BitmapAND = new short[andbytes];
	for (int i=0; i<BitmapAND.length; i++)
	    {
		BitmapAND[i] = in.get();
	    }
		
    }"
jsmooth,net.charabia.jsmoothgen.pe.res.ResIcon,ResIcon,,150,3171,3021,36,0.0318,0.0143,1,39,15,0,1,"/** Creates a new instance based on the data of the Image argument.
     * @param img
     */	
    public ResIcon(Image img) throws Exception
    {
	int width = img.getWidth(null);
	int height = img.getHeight(null);
		
	if ((width % 8) != 0)
	    width += (7-(width%8));
		
	if ((height % 8) != 0)
	    height += (7-(height%8));
		
	//		System.out.println(""FOUND WIDTH "" + width + "" (was "" + img.getWidth(null) + "")"");
	//		System.out.println(""FOUND HEIGHT "" + height + "" (was "" + img.getHeight(null) + "")"");

	//	System.out.println(""RESICON..."");
	if (img instanceof BufferedImage)
	    {
		BufferedImage result = (BufferedImage)img;

		for (int y=0; y<result.getHeight(); y++)
		    {
			for (int x=0; x<result.getWidth(); x++)
			    {
				int rgb = result.getRGB(x, y);
				if (((rgb>>24)&0xFF)>0)
				    {
					//					System.out.print(""."");
				    }
				//				else
				//				    System.out.print(""*"");
			    }
			//			System.out.println("""");
		    }

	    }
		
	int[] pixelbuffer = new int[width*height];
	PixelGrabber grabber = new PixelGrabber(img, 0, 0, width, height, pixelbuffer, 0, width);
	try
	    {
		grabber.grabPixels();
	    } catch (InterruptedException e)
		{
		    System.err.println(""interrupted waiting for pixels!"");
		    throw new Exception(""Can't load the image provided"",e);
		}
		
	Hashtable colors = calculateColorCount(pixelbuffer);

	// FORCE ALWAYS to 8
	this.BitsPerPixel = 8;
		
	Palette = new ResIcon.PaletteElement[1 << BitsPerPixel];
	//	System.out.println(""Creating palette of "" + Palette.length + "" colors ("" + colors.size() + "")"");
	for (Enumeration e=colors.keys(); e.hasMoreElements(); )
	    {
		Integer pixi = (Integer)e.nextElement();
		int pix = pixi.intValue();
		int index = ((Integer)colors.get(pixi)).intValue();
		//		System.out.println(""set pixel "" + index);
	
		Palette[index] = new ResIcon.PaletteElement();
		Palette[index].Blue = pix & 0xFF;
		Palette[index].Green = (pix >>  8) & 0xff;
		Palette[index].Red = (pix >> 16) & 0xff;
	    }
	for (int i=0; i<Palette.length; i++)
	    {
		if (Palette[i] == null)
		    Palette[i] = new ResIcon.PaletteElement();
	    }
		
		
	this.Size = 40;
	this.Width = width;
	this.Height = height* 2;
	this.Planes = 1;
	this.Compression = 0;
		
	this.SizeOfBitmap = 0;
	this.HorzResolution = 0;
	this.VertResolution = 0;

	this.ColorsUsed = 0;
	this.ColorsImportant = 0;

	//
	// We calculate the rowsize in bytes. It seems that it must be
	// aligned on a double word, although none of the
	// documentation I have on the icon format states so.
	//
	int rowsize = width / 8;
	if ((rowsize%4)>0)
	    {
		rowsize += 4 - (rowsize%4);
	    }

	BitmapXOR = new short[(((int)Height/2) * (int)Width * (int)BitsPerPixel) / 8];
	BitmapAND = new short[((int)Height/2) * rowsize];
		
	int bxl = BitmapXOR.length-1;
	int bal = BitmapAND.length-1;
	
	for (int i=0; i<pixelbuffer.length; i++)
	    {
		int col = i%width;
		int line = i/width;
			
		bxl = (width * height) - (((i/width)+1)*width) + (i%width);
		//		bal = ((width * height)/8) - ((line+1)*(width/8)) + (col/8);
		bal = (rowsize * height) - ((line+1)*(rowsize)) + (col/8);

		// if ((pixelbuffer[i] & 0xFF000000) != 0x00000000)

		//
		// If the color is transparent, any color will suit
		// (as it is not supposed to be displayed)
		//
		if (  (((pixelbuffer[i]>>24)& 0xFF) == 0))
		    {
			BitmapAND[ bal ] |= 1 << (7-(i%8));
			BitmapXOR[bxl] = 0xFF; // (short)getBrightest(); FF

			// 				int pixel = pixelbuffer[i] & 0x00FFFFFF;
			// 				pixel = 0x000000;
			// 				Integer icol = (Integer)colors.get(new Integer(pixel));
			// 				if (icol != null)
			// 				{
			// 					int palindex = icol.intValue();
			// 					BitmapXOR[bxl] = (short)palindex;
			// 				}
			// 				else
			// 				{
			// 				    BitmapXOR[bxl] = 0; // (short)getBrightest();
			// 				    System.out.println(""Can't find TRANSP BLACK COL "" + icol );
			// 				}
		    }
		else
		    {
			int pixel = pixelbuffer[i] & 0x00FFFFFF;
			// pixel = 0x000000;
			Integer icol = (Integer)colors.get(new Integer(pixel));
			if (icol != null)
			    {
				int palindex = icol.intValue();
				BitmapXOR[bxl] = (short)palindex;
			    }
		    }
	    }
    }"
jsmooth,net.charabia.jsmoothgen.pe.res.ResIcon,calculateColorCount,,22,75,59,5,0.1429,0.0759,0,7,4,0,1,"private Hashtable calculateColorCount(int[] pixels)
    {
	Hashtable result = new Hashtable();
	int colorindex = 0;
	for (int i=0; i<pixels.length; i++)
	    {
		int pix = pixels[i];
		if (((pix>>24)&0xFF) > 0)
		    {
			pix &= 0x00FFFFFF;
			Integer pixi = new Integer(pix);
			Object o = result.get(pixi);
			if (o == null)
			    {
				result.put(pixi, new Integer(colorindex++));
			    }
			//			if (colorindex > 256)
			//			    return result;
		    }
	    }
	return result;
    }"
jsmooth,net.charabia.jsmoothgen.pe.res.ResIcon,toString,,34,3,3,3,0.3333,0,0,3,3,0,1,"public String toString()
    {
	StringBuffer out = new StringBuffer();
		
	out.append(""Size: "" + Size);
	out.append(""\nWidth: "" + Width);
	out.append(""\nHeight: "" + Height);
	out.append(""\nPlanes: "" + Planes);
	out.append(""\nBitsPerPixel: "" + BitsPerPixel);
	out.append(""\nCompression: "" + Compression);
	out.append(""\nSizeOfBitmap: "" + SizeOfBitmap);
	out.append(""\nHorzResolution: "" + HorzResolution);
	out.append(""\nVertResolution: "" + VertResolution);
	out.append(""\nColorsUsed: "" + ColorsUsed);
	out.append(""\nColorsImportant: "" + ColorsImportant);
		
	//		for (int i = 0; i<Palette.length; i++)
	//		{
	//			out.append(""\n"");
	//			out.append(Palette[i].toString());
	//		}
	out.append(""\nBitmapXOR[""+ BitmapXOR.length+ ""]={"");
	for (int i=0; i<BitmapXOR.length; i++)
	    {
		out.append((byte)BitmapXOR[i]);
	    }
	out.append(""}\nBitmapAnd[""+ BitmapAND.length +""]={"");
	for (int i=0; i<BitmapAND.length; i++)
	    {
		out.append((byte)BitmapAND[i]);
	    }
		
	return out.toString();
    }"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,initComponents,,332,663,660,3,0.0293,0.003,0,18,1,0,1,"/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
    private void initComponents()//GEN-BEGIN:initComponents
    {
        java.awt.GridBagConstraints gridBagConstraints;

        m_fileChooser = new javax.swing.JFileChooser();
        m_popupMenu = new javax.swing.JPopupMenu();
        m_menuAddItem = new javax.swing.JMenuItem();
        m_menuRemoveItem = new javax.swing.JMenuItem();
        jSeparator3 = new javax.swing.JSeparator();
        m_menuItemUp = new javax.swing.JMenuItem();
        jPanel1 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        m_exeName = new javax.swing.JTextField();
        m_labelName = new javax.swing.JLabel();
        m_name = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        m_description = new javax.swing.JEditorPane();
        jLabel2 = new javax.swing.JLabel();
        m_categoryName = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        m_jarId = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        m_propsId = new javax.swing.JTextField();
        m_cbDebug = new javax.swing.JCheckBox();
        m_tablescrollpane = new javax.swing.JScrollPane();
        m_propTable = new javax.swing.JTable();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        m_menuNew = new javax.swing.JMenuItem();
        m_menuLoadKBML = new javax.swing.JMenuItem();
        m_menuLoad = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JSeparator();
        m_menuSaveKbml = new javax.swing.JMenuItem();
        m_menuSave = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JSeparator();
        m_menuExit = new javax.swing.JMenuItem();

        m_fileChooser.setCurrentDirectory(new java.io.File(""c:\\""));
            m_fileChooser.setFileFilter(new javax.swing.filechooser.FileFilter()
            {
                public boolean accept(File f)
                {
                    if (f.toString().endsWith("".skel""))
                    return true;
                    if (f.isDirectory())
                    return true;
                    return false;
                }
                public String getDescription()
                {
                    return ""JSmooth Skeletons (*.skel)"";
                }
            });
            m_fileChooser.setFileSelectionMode(javax.swing.JFileChooser.FILES_AND_DIRECTORIES);
            m_menuAddItem.setText(""Add item"");
            m_menuAddItem.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    menuAddItemActionPerformed(evt);
                }
            });

            m_popupMenu.add(m_menuAddItem);

            m_menuRemoveItem.setText(""RemoveItems"");
            m_menuRemoveItem.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    menuRemoveItemActionPerformed(evt);
                }
            });

            m_popupMenu.add(m_menuRemoveItem);

            m_popupMenu.add(jSeparator3);

            m_menuItemUp.setText(""Item Up"");
            m_menuItemUp.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    menuItemUpActionPerformed(evt);
                }
            });

            m_popupMenu.add(m_menuItemUp);

            getContentPane().setLayout(new java.awt.GridBagLayout());

            setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
            setTitle(""JSmooth Skeleton Editor"");
            addWindowListener(new java.awt.event.WindowAdapter()
            {
                public void windowClosing(java.awt.event.WindowEvent evt)
                {
                    exitForm(evt);
                }
            });

            jPanel1.setLayout(new java.awt.GridBagLayout());

            jPanel1.setBorder(new javax.swing.border.EtchedBorder());
            jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
            jLabel5.setText(""Executable Name"");
            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
            jPanel1.add(jLabel5, gridBagConstraints);

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.weightx = 0.5;
            jPanel1.add(m_exeName, gridBagConstraints);

            m_labelName.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
            m_labelName.setText(""Short Name"");
            m_labelName.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridy = 1;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
            jPanel1.add(m_labelName, gridBagConstraints);

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridy = 1;
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.weightx = 0.5;
            jPanel1.add(m_name, gridBagConstraints);

            jLabel1.setText(""Description"");
            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
            jPanel1.add(jLabel1, gridBagConstraints);

            jScrollPane1.setViewportView(m_description);

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.weightx = 0.5;
            gridBagConstraints.weighty = 0.5;
            jPanel1.add(jScrollPane1, gridBagConstraints);

            jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
            jLabel2.setText(""Category Name"");
            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
            jPanel1.add(jLabel2, gridBagConstraints);

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.weightx = 0.5;
            jPanel1.add(m_categoryName, gridBagConstraints);

            jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
            jLabel3.setText(""Resource Id for JAR"");
            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
            jPanel1.add(jLabel3, gridBagConstraints);

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            jPanel1.add(m_jarId, gridBagConstraints);

            jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
            jLabel4.setText(""Resource Id for Properties"");
            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
            jPanel1.add(jLabel4, gridBagConstraints);

            m_propsId.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    m_propsIdActionPerformed(evt);
                }
            });

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            jPanel1.add(m_propsId, gridBagConstraints);

            m_cbDebug.setText(""Mark this wrapper for debugging only"");
            m_cbDebug.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            jPanel1.add(m_cbDebug, gridBagConstraints);

            m_tablescrollpane.addMouseListener(new java.awt.event.MouseAdapter()
            {
                public void mousePressed(java.awt.event.MouseEvent evt)
                {
                    tablescrollpaneMousePressed(evt);
                }
                public void mouseReleased(java.awt.event.MouseEvent evt)
                {
                    tablescrollpaneMouseReleased(evt);
                }
            });

            m_propTable.setModel(new javax.swing.table.DefaultTableModel(
                new Object [][]
                {
                    {null, null, null, null, null},
                    {null, null, null, null, null},
                    {null, null, null, null, null},
                    {null, null, null, null, null}
                },
                new String []
                {
                    ""Id"", ""Label"", ""Description"", ""Type"", ""Value""
                }
            ));
            m_propTable.addMouseListener(new java.awt.event.MouseAdapter()
            {
                public void mouseClicked(java.awt.event.MouseEvent evt)
                {
                    propTableMouseClicked(evt);
                }
                public void mousePressed(java.awt.event.MouseEvent evt)
                {
                    propTableMousePressed(evt);
                }
                public void mouseReleased(java.awt.event.MouseEvent evt)
                {
                    propTableMouseReleased(evt);
                }
            });

            m_tablescrollpane.setViewportView(m_propTable);

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.weightx = 1.0;
            gridBagConstraints.weighty = 1.0;
            jPanel1.add(m_tablescrollpane, gridBagConstraints);

            gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridx = 1;
            gridBagConstraints.gridy = 1;
            gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.gridheight = java.awt.GridBagConstraints.REMAINDER;
            gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
            gridBagConstraints.weightx = 0.9;
            gridBagConstraints.weighty = 0.9;
            getContentPane().add(jPanel1, gridBagConstraints);

            jMenu1.setText(""System"");
            m_menuNew.setText(""New"");
            m_menuNew.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    menuNewActionPerformed(evt);
                }
            });

            jMenu1.add(m_menuNew);

            m_menuLoadKBML.setText(""Load"");
            m_menuLoadKBML.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    menuLoadKBMLActionPerformed(evt);
                }
            });

            jMenu1.add(m_menuLoadKBML);

            m_menuLoad.setText(""Load (deprecated)"");
            m_menuLoad.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    menuLoadActionPerformed(evt);
                }
            });

            jMenu1.add(m_menuLoad);

            jMenu1.add(jSeparator1);

            m_menuSaveKbml.setText(""Save"");
            m_menuSaveKbml.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    saveKbmlActionPerformed(evt);
                }
            });

            jMenu1.add(m_menuSaveKbml);

            m_menuSave.setText(""Save (deprecated)"");
            m_menuSave.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    menuSaveActionPerformed(evt);
                }
            });

            jMenu1.add(m_menuSave);

            jMenu1.add(jSeparator2);

            m_menuExit.setText(""Exit"");
            jMenu1.add(m_menuExit);

            jMenuBar1.add(jMenu1);

            setJMenuBar(jMenuBar1);

            java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
            setBounds((screenSize.width-400)/2, (screenSize.height-254)/2, 400, 254);
        }//GEN-END:initComponents"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,menuLoadKBMLActionPerformed,,16,15,9,2,0.2619,0.1389,1,4,3,0,1,"private void menuLoadKBMLActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_menuLoadKBMLActionPerformed
    {//GEN-HEADEREND:event_menuLoadKBMLActionPerformed
        // Add your handling code here:
        if ( m_fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION)
        {
                File f = m_fileChooser.getSelectedFile();
                System.out.println(""loading "" + m_fileChooser.getSelectedFile().toString());
                try {
                        SkeletonBean skel = SkeletonPersistency.loadWithJox(f);
                        setSkeleton(skel);
                } catch (IOException iox)
                {
                        iox.printStackTrace();
                }
        }
    }//GEN-LAST:event_menuLoadKBMLActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,saveKbmlActionPerformed,,21,23,10,2,0.2593,0.1759,1,4,4,0,1,"private void saveKbmlActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_saveKbmlActionPerformed
    {//GEN-HEADEREND:event_saveKbmlActionPerformed
        // Add your handling code here:
        if ( m_fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
        {
                File f = m_fileChooser.getSelectedFile();
                if (f.toString().endsWith("".skel"") == false)
                {
                        f = new File(f.getAbsolutePath() + "".skel"");
                }	
                System.out.println(""loading "" + m_fileChooser.getSelectedFile().toString());
                try {
                        SkeletonBean skel = getSkeleton();
                        SkeletonPersistency.saveWithJox(f, skel);
                } catch (IOException iox)
                {
                        iox.printStackTrace();
                }
        }

    }//GEN-LAST:event_saveKbmlActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,menuItemUpActionPerformed,,9,0,0,1,0.75,0.5,1,2,2,0,1,"private void menuItemUpActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_menuItemUpActionPerformed
	{//GEN-HEADEREND:event_menuItemUpActionPerformed
		// Add your handling code here:
		int selr = m_propTable.getSelectedRow();
		if (selr > 0)
		{
			m_model.swapItems(selr, selr-1);
		}
	}//GEN-LAST:event_menuItemUpActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,menuRemoveItemActionPerformed,,8,3,0,2,0.4167,0.2222,1,2,2,0,1,"private void menuRemoveItemActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_menuRemoveItemActionPerformed
	{//GEN-HEADEREND:event_menuRemoveItemActionPerformed
		int selr = m_propTable.getSelectedRow();
		if (selr != -1)
		{
			m_model.removeRow(selr);
		}
	}//GEN-LAST:event_menuRemoveItemActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,menuAddItemActionPerformed,,9,5,0,2,0.45,0.2167,1,3,2,0,1,"private void menuAddItemActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_menuAddItemActionPerformed
	{//GEN-HEADEREND:event_menuAddItemActionPerformed
		SkeletonProperty prop = new SkeletonProperty();
		int selr = m_propTable.getSelectedRow();
		if (selr >= 0)
			m_model.add(prop, selr);
		else
			m_model.add(prop);
	}//GEN-LAST:event_menuAddItemActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,menuSaveActionPerformed,,20,23,10,2,0.2593,0.1759,1,4,4,0,1,"private void menuSaveActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_menuSaveActionPerformed
	{//GEN-HEADEREND:event_menuSaveActionPerformed
		// Add your handling code here:
		if ( m_fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File f = m_fileChooser.getSelectedFile();
			if (f.toString().endsWith("".skel"") == false)
			{
				f = new File(f.getAbsolutePath() + "".skel"");
			}	
			System.out.println(""loading "" + m_fileChooser.getSelectedFile().toString());
			try {
				SkeletonBean skel = getSkeleton();
				SkeletonPersistency.save(f, skel);
			} catch (IOException iox)
			{
				iox.printStackTrace();
			}
		}
	}//GEN-LAST:event_menuSaveActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,menuLoadActionPerformed,,16,15,9,2,0.2619,0.1389,1,4,3,0,1,"private void menuLoadActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_menuLoadActionPerformed
	{//GEN-HEADEREND:event_menuLoadActionPerformed
		// Add your handling code here:
		if ( m_fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION)
		{
			File f = m_fileChooser.getSelectedFile();
			System.out.println(""loading "" + m_fileChooser.getSelectedFile().toString());
			try {
				SkeletonBean skel = SkeletonPersistency.load(f);
				setSkeleton(skel);
			} catch (IOException iox)
			{
				iox.printStackTrace();
			}
		}
	}//GEN-LAST:event_menuLoadActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonEditor,showPopupMenu,,9,12,9,3,0.25,0.1071,0,3,2,0,1,"public void showPopupMenu(java.awt.event.MouseEvent evt, JComponent comp)
	{
		int r = m_propTable.rowAtPoint(new Point(evt.getX(), evt.getY()));
		if (r != -1)
		{
			m_propTable.setRowSelectionInterval(r,r);
		}
		m_popupMenu.show(comp, evt.getX(), evt.getY());
	}"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPersistency,load,,14,37,29,4,0.22,0.0947,0,5,2,0,1,"public static SkeletonBean load(File fin) throws IOException
    {
	FileInputStream fis = new FileInputStream(fin);
	try {
	    XMLDecoder dec = new XMLDecoder(fis);
	    dec.setOwner(SkeletonPersistency.class);
	    SkeletonBean obj = (SkeletonBean)dec.readObject();
	    fis.close();
	    return obj;
	} catch (Exception exc)
	    {
		throw new IOException(exc.toString());
	    }
    }"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPersistency,loadWithJox,,20,95,85,8,0.16,0.063,0,5,2,0,1,"public static SkeletonBean loadWithJox(File fin) throws IOException
    {
	Object bean = null;
	try {
	    //FileInputStream istream = new FileInputStream(fin);
	    //	    KBMLDeserializer bxi = new KBMLDeserializer(istream);
	    //	    bean = bxi.readBean();
	    //bxi.close();

	    FileReader fr = new FileReader(fin);
	    JOXBeanReader jbr = new JOXBeanReader(fr);
	    bean = jbr.readObject(SkeletonBean.class);
	    jbr.close();
	    fr.close();

	} catch (Exception e) {
	    e.printStackTrace();
	}
	return (SkeletonBean)bean;
    }"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPersistency,save,,16,38,31,5,0.2,0.0873,0,5,2,0,1,"public static void save(File fout, SkeletonBean obj) throws IOException
    {
	FileOutputStream fos = new FileOutputStream(fout);
	try {
	    XMLEncoder enc = new XMLEncoder(fos);
	    enc.writeObject(obj);
	    enc.close();
	} catch (Exception ex)
	    {
		throw new IOException(ex.toString());
	    }
	finally
	    {
		fos.close();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPersistency,saveWithJox,,13,21,14,3,0.25,0.131,0,5,2,0,1,"public static void saveWithJox(File fout, SkeletonBean obj) throws IOException
    {
	try {
	    FileWriter fw = new FileWriter(fout);
	    JOXBeanWriter jbw = new JOXBeanWriter(fw);
	    jbw.writeObject(""jsmoothskeleton"", obj);
	    jbw.close();
	    fw.close();
	} catch (Exception e) {
	    e.printStackTrace();
	}

    }"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPropertyTableModel,swapItems,,12,6,0,2,0.4286,0.2714,0,4,5,0,1,"public void swapItems(int offset1, int offset2)
	{
		if ((offset1>=0) && (offset1<m_props.size())
			&& (offset2>=0) && (offset2<m_props.size()))
		{
			Object o1 = m_props.get(offset1);
			Object o2 = m_props.get(offset2);
			m_props.set(offset1, o2);
			m_props.set(offset2, o1);
		}
		fireTableRowsUpdated(Math.min(offset1, offset2), Math.max(offset1, offset2));
	}"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPropertyEditor,initComponents,,69,25,22,2,0.175,0.1071,0,5,1,1,1,"/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	private void initComponents()//GEN-BEGIN:initComponents
	{
		m_popupMenu = new javax.swing.JPopupMenu();
		m_menuAddItem = new javax.swing.JMenuItem();
		m_menuRemoveItem = new javax.swing.JMenuItem();
		jScrollPane1 = new javax.swing.JScrollPane();
		m_table = new javax.swing.JTable();
		
		m_menuAddItem.setText(""Add item"");
		m_menuAddItem.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				m_menuAddItemActionPerformed(evt);
			}
		});
		
		m_popupMenu.add(m_menuAddItem);
		
		m_menuRemoveItem.setText(""RemoveItems"");
		m_menuRemoveItem.addActionListener(new java.awt.event.ActionListener()
		{
			public void actionPerformed(java.awt.event.ActionEvent evt)
			{
				m_menuRemoveItemActionPerformed(evt);
			}
		});
		
		m_popupMenu.add(m_menuRemoveItem);
		
		
		setLayout(new java.awt.BorderLayout());
		
		jScrollPane1.setBorder(null);
		m_table.setModel(new javax.swing.table.DefaultTableModel(
		new Object [][]
		{
			{null, null, null, null},
			{null, null, null, null},
			{null, null, null, null},
			{null, null, null, null}
		},
		new String []
		{
			""Title 1"", ""Title 2"", ""Title 3"", ""Title 4""
		}
		));
		m_table.setTableHeader(null);
		m_table.addMouseListener(new java.awt.event.MouseAdapter()
		{
			public void mouseClicked(java.awt.event.MouseEvent evt)
			{
				tableMousePressed(evt);
			}
			public void mousePressed(java.awt.event.MouseEvent evt)
			{
				tableMousePressed(evt);
			}
			public void mouseReleased(java.awt.event.MouseEvent evt)
			{
				tableMousePressed(evt);
			}
		});
		
		jScrollPane1.setViewportView(m_table);
		
		add(jScrollPane1, java.awt.BorderLayout.CENTER);
		
	}//GEN-END:initComponents"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPropertyEditor,m_menuRemoveItemActionPerformed,,9,0,0,1,0.75,0.5,1,2,2,0,1,"private void m_menuRemoveItemActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_m_menuRemoveItemActionPerformed
	{//GEN-HEADEREND:event_m_menuRemoveItemActionPerformed
		// Add your handling code here:
		int selr = m_table.getSelectedRow();
		if (selr != -1)
		{
			m_model.removeRow(selr);
		}
	}//GEN-LAST:event_m_menuRemoveItemActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPropertyEditor,m_menuAddItemActionPerformed,,10,1,0,1,0.5,0.3333,1,3,2,0,1,"private void m_menuAddItemActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_m_menuAddItemActionPerformed
	{//GEN-HEADEREND:event_m_menuAddItemActionPerformed
		// Add your handling code here:
		SkeletonProperty prop = new SkeletonProperty();
		int selr = m_table.getSelectedRow();
		if (selr >= 0)
			m_model.add(prop, selr);
		else
			m_model.add(prop);
	}//GEN-LAST:event_m_menuAddItemActionPerformed"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonPropertyEditor,showPopupMenu,,9,52,49,4,0.1157,0.0278,0,2,2,0,1,"public void showPopupMenu(java.awt.event.MouseEvent evt)
	{
		int r = m_table.rowAtPoint(new Point(evt.getX(), evt.getY()));
		if (r != -1)
		{
			m_table.setRowSelectionInterval(r,r);
		}
		m_popupMenu.show(this, evt.getX(), evt.getY());
	}"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonList,SkeletonList,,17,32,28,3,0.1852,0.0556,1,6,4,0,1,"/** Creates a new instance of SkeletonList */
    public SkeletonList(File directoryToScan)
    {
	File[] subdirs = directoryToScan.listFiles();
	SkelSuffixFilter filter = new SkelSuffixFilter();
	
	for (int i=0; i<subdirs.length; i++)
	    {
		if (subdirs[i].isDirectory())
		    {
			File[] skeldescs = subdirs[i].listFiles((java.io.FileFilter)filter);
			for (int si=0; si<skeldescs.length; si++)
			    {
				addSkeletonDirectory(subdirs[i], skeldescs[si]);
			    }
		    }
	    }
    }"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonList,addSkeletonDirectory,,19,35,25,6,0.15,0.0821,0.666666667,4,5,0,1,"public void addSkeletonDirectory(File dir, File desc)
    {
	try {
	    SkeletonBean skel = SkeletonPersistency.loadWithJox(desc);
	    if ((skel != null) && (skel.getShortName() != null))
		{
		    m_skelsToDirs.put(skel, dir);
		    if (skel.isDebug() == false)
			m_nameToNoDebugSkel.put(skel.getShortName(), skel);
		    else
			m_nameToDebugSkel.put(skel.getShortName(), skel);
		    m_nameToSkel.put(skel.getShortName(), skel);
		}
	} catch (Exception exc)
	    {
		//		System.err.println(""Error adding skeleton "" + dir + "" / "" + desc);
		//		iox.printStackTrace();
	    }
    }"
jsmooth,net.charabia.jsmoothgen.skeleton.SkeletonBean,SkeletonBean,,15,28,0,3,0.1742,0.1792,1,2,2,0,1,"public SkeletonBean(SkeletonBean sb)
    {
	m_executableName = sb.m_executableName;
	m_shortName = sb.m_shortName;
	m_description = sb.m_description;
	m_resourceCategory = sb.m_resourceCategory;
	m_resourceJarId = sb.m_resourceJarId;
	m_resourcePropsId = sb.m_resourcePropsId;
	m_skelproperties = new SkeletonProperty[sb.m_skelproperties.length];
	for (int i=0; i<m_skelproperties.length; i++)
	    {
		m_skelproperties[i] = new SkeletonProperty(sb.m_skelproperties[i]);
	    }
	m_debug = sb.m_debug;
    }"
jsmooth,net.charabia.util.codec.IcoCodec,loadImages,,64,402,339,10,0.0783,0.0458,0.8,15,7,0,1,"static public BufferedImage[] loadImages(File f) throws IOException
    {
	InputStream istream = new FileInputStream(f);
        BufferedInputStream buffin = new BufferedInputStream(istream);
	BinaryInputStream in = new BinaryInputStream(buffin);

	try {
	    in.mark(32000);

	    IconDir dir = new IconDir(in);
	    //	    System.out.println(""DIR = "" + dir);
	    
	    IconEntry[] entries = new IconEntry[dir.idCount];
	    BufferedImage[] images = new BufferedImage[dir.idCount];

	    for (int i=0; i<dir.idCount; i++)
		{
		    entries[i] = new IconEntry(in);
		    //		    System.out.println(""ENTRY "" + i + "" = "" + entries[i]);
		}

	    IconEntry entry = entries[0];
	    //	    System.out.println(""ENTRYx = "" + entry);

	    for (int i=0; i<dir.idCount; i++)
		{
		    in.reset();
		    in.skip(entries[i].dwImageOffset);

		    IconHeader header = new IconHeader(in);
		    //		    System.out.println(""Header: "" + header);

		    long toskip = header.Size - 40;
		    if (toskip>0)
			in.skip((int)toskip);

		    //		    System.out.println(""skipped data"");
		    
		    BufferedImage image = new BufferedImage((int)header.Width, (int)header.Height/2,
							    BufferedImage.TYPE_INT_ARGB);
		    
		    switch(header.BitsPerPixel)
			{
			case 4:
			case 8:
			    loadPalettedImage(in, entries[i], header, image);
			    break;
			    
			default:
			    throw new Exception(""Unsupported ICO color depth: "" + header.BitsPerPixel);
			}

		    images[i] = image;
		}

	    return images;

	} catch (Exception exc)
	    {
		exc.printStackTrace();
	    }

	return null;
    }"
jsmooth,net.charabia.util.codec.IcoCodec,loadPalettedImage,,120,734,648,10,0.0722,0.0332,1,24,13,0,1,"static private void loadPalettedImage(BinaryInputStream in, IconEntry entry, IconHeader header, BufferedImage image) throws Exception
    {
	//	System.out.println(""Loading image..."");
	
	//	System.out.println(""Loading palette..."");

	// 
	// First, load the palette
	//
	int cols = (int)header.ColorsUsed;
	if (cols == 0)
	    {
		if (entry.bColorCount != 0)
		    cols = entry.bColorCount;
		else
		    cols = 1 << header.BitsPerPixel;
	    }

	int[] redp = new int[cols];
	int[] greenp = new int[cols];
	int[] bluep = new int[cols];

 	for (int i=0; i<cols; i++)
	    {
		bluep[i] = in.readUByte();
		greenp[i] = in.readUByte();
		redp[i] = in.readUByte();
		in.readUByte();
	    }

	//	System.out.println(""Palette read!"");

	//
	// Set the image

	int xorbytes = (((int)header.Height/2) * (int)header.Width);
	int readbytes = 0;

	for (int y=(int)(header.Height/2)-1; y>=0; y--)
	    {
		for (int x=0; x<header.Width; x++)
		    {
			switch(header.BitsPerPixel)
			    {
			    case 4:
				{
				    int pix = in.readUByte();
				    readbytes++;

				    int col1 = (pix>>4) & 0x0F;
				    int col2 = pix & 0x0F;
				    image.setRGB(x, y, (0xFF<<24) | (redp[col1]<<16) | (greenp[col1]<<8) | bluep[col1]);
				    image.setRGB(++x, y, (0xFF<<24) | (redp[col2]<<16) | (greenp[col2]<<8) | bluep[col2]);
				}
				break;
			    case 8:
				{
				    int col1 = in.readUByte();
				    readbytes++;

				    image.setRGB(x, y, (0xFF<<24) | (redp[col1]<<16) | (greenp[col1]<<8) | bluep[col1]);
				}
				break;
			    }
		    }
	    }
	//	System.out.println(""XOR data read ("" + readbytes + "" bytes)"");

	int height = (int)(header.Height/2);

	int rowsize = (int)header.Width / 8;
	if ((rowsize%4)>0)
	    {
		rowsize += 4 - (rowsize%4);
	    }
	
	//	System.out.println(""rowsize = "" + rowsize);
	int[] andbytes = new int[rowsize * height ];

	for (int i=0; i<andbytes.length; i++)
	    andbytes[i] = in.readUByte();


	for (int y=height-1; y>=0; y--)
	    {
		for (int x=0; x<header.Width; x++)
		    {
			int offset = ((height - (y+1))*rowsize) + (x/8);
			if ( (andbytes[offset] & (1<<(7-x%8))) != 0)
			    {
				image.setRGB(x, y, 0);
			    }
		    }
	    }

	// 	for (int i=0; i<andbytes; i++)
	// 	    {
	// 		int pix = in.readUByte();
	// 		readbytes++;

	// 		int xb = (i*8) % (int)header.Width;
	// 		int yb = ((int)header.Height/2) - (((i*8) / (int)header.Width)+1);

	// 		for (int offset=7; offset>=0; offset--)
	// 		    {
	// 			//
	// 			// Modify the transparency only if necessary
	// 			//
	// 			System.out.println(""SET AND ("" + xb + "","" + yb + "")-"" + (7-offset));

	// 			if (((1<<offset) & pix)!=0)
	// 			    {
	// 				int argb = image.getRGB(xb+(7-offset), yb);
	// 				image.setRGB(xb+(7-offset), yb, argb & 0xFFFFFF);
	// 			    }
	// 		    }
	// 	    }
	
	//	System.out.println(""AND data read ("" + readbytes + "" bytes total)"");
    }"
jsmooth,net.charabia.util.io.BinaryInputStream,readIntBE,,9,17,13,3,0.2857,0.05,0,4,1,0,1,"public int readIntBE() throws IOException
    {
	int a = read();
	int b = read();
	int c = read();
	int d = read();
	
	return ((a&0xff)<<24) | ((b&0xff)<<16) | ((c&0xff)<<8) | (d&0xff);
    }"
jsmooth,net.charabia.util.io.BinaryInputStream,readUIntBE,,9,17,13,3,0.2857,0.05,0,4,1,0,1,"public long readUIntBE() throws IOException
    {
	int a = read();
	int b = read();
	int c = read();
	int d = read();
	
	return (long)((a&0xff)<<24) | (long)((b&0xff)<<16) | (long)((c&0xff)<<8) | (long)(d&0xff);
    }"
jsmooth,net.charabia.util.io.BinaryInputStream,readIntLE,,9,17,13,3,0.2857,0.05,0,4,1,0,1,"public int readIntLE() throws IOException
    {
	int a = readByte();
	int b = readByte();
	int c = readByte();
	int d = readByte();
	
	return ((d&0xff)<<24) | ((c&0xff)<<16) | ((b&0xff)<<8) | (a&0xff);
    }"
jsmooth,net.charabia.util.io.BinaryInputStream,readUIntLE,,9,17,13,3,0.2857,0.05,0,4,1,0,1,"public long readUIntLE() throws IOException
    {
	int a = readByte();
	int b = readByte();
	int c = readByte();
	int d = readByte();
	
	return (long)((d&0xff)<<24) | (long)((c&0xff)<<16) | (long)((b&0xff)<<8) | (long)(a&0xff);
    }"
neuroph,org.neuroph.adapters.jml.JMLNeurophSample,printDataset,,11,15,9,3,0.3333,0.1667,0,3,2,0,1,"/**
     * Prints Java-ML data set
     *
     * @param jmlDataset Dataset Java-ML data set
     */
    public static void printDataset(Dataset jmlDataset) {
        System.out.println(""JML dataset"");
        Iterator iterator = jmlDataset.iterator();

        while (iterator.hasNext()) {
            Instance instance = (Instance) iterator.next();
            System.out.println(""inputs"");
            System.out.println(instance.values());
            System.out.println(instance.classValue());
        }
    }"
neuroph,org.neuroph.adapters.jml.JMLNeurophSample,printDataset,,14,15,9,3,0.3333,0.1667,0.666666667,4,3,0,1,"/**
     * Prints Neuroph data set
     *
     * @param neurophDataset Dataset Neuroph data set
     */
    public static void printDataset(DataSet neurophDataset) {
        System.out.println(""Neuroph dataset"");
        Iterator iterator = neurophDataset.iterator();

        while (iterator.hasNext()) {
            DataSetRow row = (DataSetRow) iterator.next();
            System.out.println(""inputs"");
            System.out.println(Arrays.toString(row.getInput()));
            if (row.getDesiredOutput().length > 0) {
                System.out.println(""outputs"");
                System.out.println(Arrays.toString(row.getDesiredOutput()));
            }
        }
    }"
neuroph,org.neuroph.adapters.jml.JMLNeurophSample,convertJMLDatasetToMap,,26,19,10,2,0.3,0.1202,0,7,3,0,1,"/**
     * Converts Java-ML data set to Map
     *
     * @param jmlDataset Dataset Java-ML data set
     * @return Map converted from Java-ML data set
     */
    private static Map<double[], String> convertJMLDatasetToMap(Dataset jmlDataset) {

        //number of attributes without class attribute
        int numOfAttributes = jmlDataset.noAttributes();

        //initialize map
        Map<double[], String> itemClassMap = new HashMap<double[], String>();

        //iterate through jml dataset
        for (Instance dataRow : jmlDataset) {

            //initialize double array for values from dataset
            double[] values = new double[numOfAttributes];
            int ind = 0;

            //iterate through values in dataset instance an adding them in double array
            for (Double val : dataRow) {
                values[ind] = val;
                ind++;
            }

            //put attribute values and class value in map
            itemClassMap.put(values, dataRow.classValue().toString());
        }
        return itemClassMap;
    }"
neuroph,org.neuroph.adapters.jml.JMLNeurophSample,testJMLNeurophClassifier,,27,72,53,5,0.1735,0.1245,0.571428571,5,1,0,1,"/**
     * Test JMLNeurophClassifier
     *
     * @param jmlDataset Dataset Java-ML data set
     */
    private static void testJMLNeurophClassifier(Dataset jmlDataset) {
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(4, 16, 3);
        
        // set labels for output neurons
        neuralNet.getOutputNeurons().get(0).setLabel(""Setosa"");
        neuralNet.getOutputNeurons().get(1).setLabel(""Versicolor"");
        neuralNet.getOutputNeurons().get(2).setLabel(""Virginica"");

        // initialize NeurophJMLClassifier
        JMLNeurophClassifier jmlnClassifier = new JMLNeurophClassifier(neuralNet);

        // Process Java-ML data set
        jmlnClassifier.buildClassifier(jmlDataset);

        // test item
        //double[] item = {5.1, 3.5, 1.4, 0.2}; // normalized item is below
        double[] item = {-0.27777777777777773, 0.1249999999999999, -0.4322033898305085, -0.45833333333333337};

        // Java-ML instance out of test item
        Instance instance = new DenseInstance(item);

        // why are these not normalised?
        System.out.println(""NeurophJMLClassifier - classify of {0.22222222222222213, 0.6249999999999999, 0.06779661016949151, 0.04166666666666667}"");
        System.out.println(jmlnClassifier.classify(instance));
        System.out.println(""NeurophJMLClassifier - classDistribution of {0.22222222222222213, 0.6249999999999999, 0.06779661016949151, 0.04166666666666667}"");
        System.out.println(jmlnClassifier.classDistribution(instance));
    }"
neuroph,org.neuroph.adapters.jml.JMLNeurophClassifier,classify,,23,17,6,2,0.3438,0.2024,0.4,5,3,0,1,"/**
     * Classifies instance as one of possible classes
     * @param instnc Instance to classify
     * @return Object class as Object
     */
    @Override
    public Object classify(Instance instnc) {
        
        double[] item = convertInstanceToDoubleArray(instnc);

        // set neural network input
        neuralNet.setInput(item);
        // calculate neural network output
        neuralNet.calculate();

        // find neuron with highest output
        Neuron maxNeuron = null;
        double maxOut = Double.NEGATIVE_INFINITY;
        for (Neuron neuron : neuralNet.getOutputNeurons()) {
            if (neuron.getOutput() > maxOut) {
                maxNeuron = neuron;
                maxOut = neuron.getOutput();
            }
        }

        // and return its label
        return maxNeuron.getLabel();
    }"
neuroph,org.neuroph.adapters.jml.JMLNeurophClassifier,convertInstanceToDoubleArray,,14,35,25,3,0.24,0.1117,0,5,2,0,1,"/**
     * Convert instance attribute values to double array values
     * @param instnc Instance to convert
     * @return double[]
     */
    private double[] convertInstanceToDoubleArray(Instance instnc) {
        Iterator attributeIterator = instnc.iterator();

        double[] item = new double[instnc.noAttributes()];
        int index = 0;

        while (attributeIterator.hasNext()) {
            Double attrValue = (Double) attributeIterator.next();
            item[index] = attrValue.doubleValue();
            index++;
        }
        
        return item;
    }"
neuroph,org.neuroph.adapters.jml.JMLDataSetConverter,convertJMLToNeurophDataset,,79,747,633,4,0.0855,0.0484,0.5,19,14,1,1,"/**
     * Converts Java-ML data set to Neuroph data set
     * @param jmlDataset Dataset Java-ML data set
     * @param numInputs int Number of inputs
     * @param numOutputs int Number of outputs
     * @return Neuroph data set
     */
    public static DataSet convertJMLToNeurophDataset(Dataset jmlDataset, int numInputs, int numOutputs) {

        if (numInputs <= 0) {
            throw new IllegalArgumentException(""Number of inputs  in DataSet cannot be zero or negative!"");
        }

        if (numOutputs < 0) {
            throw new IllegalArgumentException(""Number of outputs  in DataSet cannot be negative!"");
        }

        // get number of attributes + 1 if class counts as attribute
        int rowSize = jmlDataset.noAttributes() + 1;
        if (numOutputs + numInputs < rowSize) {
            throw new IllegalArgumentException(""Number of outputs and inputs should be equal to number of attributes from data set!"");
        }

        // create dataset
        DataSet neurophDataset;

        if (numOutputs == 0) {
            neurophDataset = new DataSet(rowSize);
        } else {
            neurophDataset = new DataSet(numInputs, numOutputs);
        }


        List<String> outputClasses = new ArrayList<String>();

        for (int i = 0; i < jmlDataset.size(); i++) {
            if (!outputClasses.contains(jmlDataset.get(i).classValue().toString())) {
                outputClasses.add(jmlDataset.get(i).classValue().toString());
            }
        }

        // fill neuroph dataset from jml dataset
        for (int i = 0; i < jmlDataset.size(); i++) {
            Iterator attributeIterator = jmlDataset.get(i).iterator();

            double[] values = new double[rowSize];
            int index = 0;

            while (attributeIterator.hasNext()) {
                Double attrValue = (Double) attributeIterator.next();
                values[index] = attrValue.doubleValue();
                index++;
            }

            DataSetRow row = null;
            if (numOutputs == 0) {
                row = new DataSetRow(values);
            } else {
                double[] inputs = new double[numInputs];
                double[] outputs = new double[outputClasses.size()];
                int k = 0;
                int j = 0;
                for (int v = 0; v < values.length; v++) {
                    if (v < numInputs) {
                        inputs[j] = values[v];
                        j++;
                    }
                }
                
                for(String cla:outputClasses){
                    if(cla.equals(jmlDataset.get(i).classValue().toString())){
                        outputs[k] = 1;
                    }else{
                        outputs[k] = 0;
                    }
                    k++;
                }

                row = new DataSetRow(inputs, outputs);
            }
            row.setLabel(jmlDataset.get(i).classValue().toString());
            neurophDataset.addRow(row);
        }

        return neurophDataset;
    }"
neuroph,org.neuroph.adapters.jml.JMLDataSetConverter,convertNeurophToJMLDataset,,30,133,95,3,0.1579,0.0768,0.333333333,10,5,0,1,"/**
     * Converts Neuroph data set to Java-ML data set
     * @param neurophDataset Dataset Neuroph data set
     * @return Dataset Java-ML data set
     */
    public static Dataset convertNeurophToJMLDataset(DataSet neurophDataset) {
        Dataset jmlDataset = new DefaultDataset();

        int numInputs = neurophDataset.getInputSize();
        int numOutputs = neurophDataset.getOutputSize();

        for (DataSetRow row : neurophDataset.getRows()) {

            if (numOutputs > 0) {
                double[] mergedIO = new double[numInputs + numOutputs];
                for (int i = 0; i < numInputs; i++) {
                    mergedIO[i] = row.getInput()[i];
                }

                for (int i = 0; i < numOutputs; i++) {
                    mergedIO[numInputs + i] = row.getDesiredOutput()[i];
                }

                Instance instance = new DenseInstance(mergedIO);
                instance.setClassValue(row.getLabel());
                jmlDataset.add(instance);
            } else {
                Instance instance = new DenseInstance(row.getInput());
                instance.setClassValue(row.getLabel());
                jmlDataset.add(instance);
            }
        }

        return jmlDataset;
    }"
neuroph,org.neuroph.adapters.weka.WekaNeurophSample,printDataSet,,15,32,19,4,0.3,0.2222,0.5,4,3,0,1,"/**
     * Prints Neuroph data set
     *
     * @param neurophDataset Dataset Neuroph data set
     */
    public static void printDataSet(DataSet neurophDataset) {
        System.out.println(""Neuroph dataset"");
        Iterator iterator = neurophDataset.iterator();

        while (iterator.hasNext()) {
            DataSetRow row = (DataSetRow) iterator.next();
            System.out.println(""inputs"");
            System.out.println(Arrays.toString(row.getInput()));
            if (row.getDesiredOutput().length > 0) {
                System.out.println(""outputs"");
                System.out.println(Arrays.toString(row.getDesiredOutput()));
                System.out.println(row.getLabel());
            }
        }
    }"
neuroph,org.neuroph.adapters.weka.WekaNeurophSample,printDataSet,,10,14,7,2,0.3214,0.1508,0.5,4,2,0,1,"/**
     * Prints Weka data set
     *
     * @param wekaDataset Instances Weka data set
     */
    private static void printDataSet(Instances wekaDataset) {
        System.out.println(""Weka dataset"");
        Enumeration en = wekaDataset.enumerateInstances();
        while (en.hasMoreElements()) {
            Instance instance = (Instance) en.nextElement();
            double[] values = instance.toDoubleArray();
            System.out.println(Arrays.toString(values));
            System.out.println(instance.stringValue(instance.classIndex()));
        }
    }"
neuroph,org.neuroph.adapters.weka.WekaNeurophSample,testNeurophWekaClassifier,,38,129,105,5,0.125,0.0827,0.666666667,8,3,1,1,"/**
     * Test NeurophWekaClassifier
     *
     * @param wekaDataset Instances Weka data set
     */
    private static void testNeurophWekaClassifier(Instances wekaDataset) {
        try {
            MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(4, 16, 3);

            // set labels manualy
            neuralNet.getOutputNeurons().get(0).setLabel(""Setosa"");
            neuralNet.getOutputNeurons().get(1).setLabel(""Versicolor"");
            neuralNet.getOutputNeurons().get(2).setLabel(""Virginica"");

            // initialize NeurophWekaClassifier
            WekaNeurophClassifier neurophWekaClassifier = new WekaNeurophClassifier(neuralNet);
            // set class index on data set
            wekaDataset.setClassIndex(4);
            
            // process data set
            neurophWekaClassifier.buildClassifier(wekaDataset);

            // test item
            //double[] item = {5.1, 3.5, 1.4, 0.2, 0.0}; // normalized item is below
            double[] item = {0.22222222222222213, 0.6249999999999999, 0.06779661016949151, 0.04166666666666667, 0};

            // create weka instance for test item
            Instance instance = new DenseInstance(1, item);

            // test classification
            System.out.println(""NeurophWekaClassifier - classifyInstance for {5.1, 3.5, 1.4, 0.2}"");
            System.out.println(""Class idx: ""+neurophWekaClassifier.classifyInstance(instance));
            System.out.println(""NeurophWekaClassifier - distributionForInstance for {5.1, 3.5, 1.4, 0.2}"");
            double dist[] = neurophWekaClassifier.distributionForInstance(instance);            
            for (int i=0; i<dist.length; i++ ) {
                System.out.println(""Class ""+i+"": ""+dist[i]);
            }

        } catch (Exception ex) {
            Logger.getLogger(WekaNeurophSample.class.getName()).log(Level.SEVERE, null, ex);
        }

    }"
neuroph,org.neuroph.adapters.weka.WekaDataSetConverter,convertWekaToNeurophDataset,,69,510,425,4,0.0984,0.0562,0.4,16,13,1,1,"/**
     * Converts Weka data set to Neuroph data set
     * @param wekaDataset Instances Weka data set
     * @param numInputs int Number of inputs
     * @param numOutputs int Number of outputs
     * @return Neuroph data set
     */
    public static DataSet convertWekaToNeurophDataset(Instances wekaDataset, int numInputs, int numOutputs) {
        
        if (numInputs <= 0) {
            throw new IllegalArgumentException(""Number of inputs  in DataSet cannot be zero or negative!"");
        }

        if (numOutputs < 0) {
            throw new IllegalArgumentException(""Number of outputs  in DataSet cannot be negative!"");
        }
        
        if (numOutputs + numInputs < wekaDataset.numAttributes()) {
            throw new IllegalArgumentException(""Number of outputs and inputs should be equal to number of attributes from data set!"");
        }
        
        // create supervised or unsupervised data set that will be returned
        DataSet neurophDataset=null;
        
        if(numOutputs > 0){
            neurophDataset = new DataSet(numInputs,numOutputs);
        }else{
            neurophDataset = new DataSet(numInputs);
        }
        
        List<Double> classValues = new ArrayList<Double>();
        
        // get all different class values (as ints) from weka dataset
        for(Instance inst: wekaDataset){
            Double classDouble = inst.classValue();
            if(!classValues.contains(classDouble)){
                classValues.add(classDouble);
            }
        }
        
        Enumeration en = wekaDataset.enumerateInstances();
        while(en.hasMoreElements()) { // iterate all instances from dataset
            Instance instance = (Instance) en.nextElement();            
            double[] values = instance.toDoubleArray(); // get all the values from current instance
            if(numOutputs == 0){ // add unsupervised row
                neurophDataset.addRow(values);
            } else {  // add supervised row
                double[] inputs = new double[numInputs];
                double[] outputs = new double[numOutputs];
                
                // set inputs 
                for(int k = 0; k < values.length; k++){
                    if(k < numInputs){
                        inputs[k] = values[k];
                    }
                }
                
                // set binary values for class outputs
                int k = 0;
                for(Double entry : classValues){                    
                    if(entry.doubleValue() == instance.classValue()){ // if the 
                        outputs[k] = 1;
                    }else{
                        outputs[k] = 0;
                    }
                    k++;
                }
                
                DataSetRow row = new DataSetRow(inputs, outputs);
                row.setLabel(instance.stringValue(instance.classIndex()));
                neurophDataset.addRow(row);
            }
        }
        
        return neurophDataset;
    }"
neuroph,org.neuroph.adapters.weka.WekaDataSetConverter,convertNeurophToWekaDataset,,56,221,142,2,0.13,0.0839,0.454545455,14,9,0,1,"/**
     * Converts Neuroph data set to Weka data set
     * @param neurophDataset DataSet Neuroph data set
     * @return instances Weka data set
     */
    public static Instances convertNeurophToWekaDataset(DataSet neurophDataset) {
        
        Map<double[], String> classValues = getClassValues(neurophDataset);
        
        Instances instances = createEmptyWekaDataSet(neurophDataset.getInputSize(), neurophDataset.size(), classValues);
        
        int numInputs = neurophDataset.getInputSize();
//        int numOutputs = neurophDataset.getOutputSize();
        int numOutputs = 1; // why is this, and the above line is commented? probably because weka 
        
        instances.setClassIndex(numInputs);
        
        Iterator<DataSetRow> iterator = neurophDataset.iterator();
        while(iterator.hasNext()) { // iterate all dataset rows
            DataSetRow row = iterator.next();
            
            if (numOutputs> 0) { // if it is supervised (has outputs)
                Instance instance = new DenseInstance(numInputs + numOutputs);
                for(int i=0; i< numInputs; i++) {
                    instance.setValue(i, row.getInput()[i] );
                }
                             
                instance.setDataset(instances);     
                
                // set output attribute, as String and double value of class
                for(Map.Entry<double[], String> entry : classValues.entrySet()){
                    if(entry.getValue().equals(row.getLabel())){
                        instance.setValue(numInputs, entry.getValue());
                        double[] rowDouble = row.getDesiredOutput();
                        for(int i = 0; i < rowDouble.length; i++){
                            if(rowDouble[i] == 1){
                                instance.setValue(numInputs, i);
                            }
                            break;
                        }
                        break;
                    }
                }

                           
                instances.add(instance);
            } else { // if it is unsupervised - has only inputs
                // create new instance
                Instance instance = new DenseInstance(numInputs);
                // set all input values
                for(int i=0; i< numInputs; i++) {
                    instance.setValue(i, row.getInput()[i] );
                }
                // and add instance to weka dataset
                instance.setDataset(instances);                        
                instances.add(instance);
            }
        }
        
        return instances;
    }"
neuroph,org.neuroph.adapters.weka.WekaDataSetConverter,createEmptyWekaDataSet,,38,27,18,3,0.1667,0.062,0.75,12,3,0,1,"/**
     * Creates and returns empty weka data set
     * @param numOfAttr int Number of attributes without class attribute
     * @param capacity int Capacity of sample
     * @return empty weka data set
     */
    private static Instances createEmptyWekaDataSet(int numOfAttr, int capacity, Map<double[], String> classValues) {
        //Vector for class attribute possible values
        FastVector fvClassVal = new FastVector();
        //Map double value for every possible class value
        HashMap classVals = new HashMap<String, Double>();
        //Map class label with double key value
        HashMap classValsDoubleAsKey = new HashMap<Double, String>();
        //ind represents double value for class attribute
        int ind = 0;
        
        //loop through possible class values
        for (Map.Entry<double[], String> values : classValues.entrySet()) {

            //add value to vector
            fvClassVal.addElement(values.getValue());

            //map double value for class value
            classVals.put(values.getValue(), new Double(ind));
            //map class label for double key value
            classValsDoubleAsKey.put(new Double(ind),values.getValue());

            ind++;
        }
        //Class attribute with possible values
        Attribute classAttribute = new Attribute(""theClass"", fvClassVal, classValues.size());
        //Creating attribute vector for Instances class instance
        FastVector fvWekaAttributes = new FastVector(numOfAttr + 1);
        //Fill vector with simple attributes
        for (int i = 0; i < numOfAttr; i++) {
            fvWekaAttributes.addElement(new Attribute(i + """", i));
        }
        //Add class attribute to vector
        fvWekaAttributes.addElement(classAttribute);

        //newDataSet as Instances class instance
        Instances newDataSet = new Instances(""newDataSet"", fvWekaAttributes, capacity);
        return newDataSet;
    }"
neuroph,org.neuroph.adapters.weka.WekaDataSetConverter,createDataSetFromFile,,17,23,18,4,0.2031,0.0531,0.75,7,2,0,1,"/**
     * Creates neuroph dataset from arff weka file.
     * 
     * @param filePath Path to the file.
     * @param numInputs Number of inputs.
     * @param numOutputs Number of outputs.
     * @return Neuroph dataset.
     */
    public static DataSet createDataSetFromFile(String filePath, int numInputs, int numOutputs) {

        try {
            ConverterUtils.DataSource dataSource = new ConverterUtils.DataSource(filePath);

            Instances wekaDataset = dataSource.getDataSet();
            
            wekaDataset.setClassIndex(numInputs);

            DataSet neurophDataset = WekaDataSetConverter.convertWekaToNeurophDataset(wekaDataset, numInputs, numOutputs);
            
            return neurophDataset;
            
        } catch (Exception e) {
            return new DataSet(0);
        }
    }"
neuroph,org.neuroph.adapters.weka.WekaNeurophClassifier,classifyInstance,,24,73,55,4,0.1875,0.0926,0.5,7,3,0,1,"/**
     * Classifies instance as one of possible classes
     * @param instance Instance to classify
     * @return double classes double value
     * @throws Exception
     */
    @Override
    public double classifyInstance(Instance instance) throws Exception {
        double[] item = convertInstanceToDoubleArray(instance);

        // set neural network input
        neuralNet.setInput(item);
        // calculate neural network output
        neuralNet.calculate();

        // find neuron with highest output
        List<Neuron> outputNeurons = neuralNet.getOutputNeurons();
        Neuron maxNeuron = null;
        int maxIdx = 0;
        double maxOut = Double.NEGATIVE_INFINITY;
        for (int i=0; i< outputNeurons.size(); i++) {
            if (outputNeurons.get(i).getOutput() > maxOut) {
                maxOut = outputNeurons.get(i).getOutput();
                maxIdx = i;
            }
        }

        // and return its idx (class)
        return maxIdx;
    }"
neuroph,org.neuroph.contrib.RecommenderNetwork,createDemoNetwork,,72,597,491,8,0.0754,0.0476,0.636363636,13,2,0,1,"public void createDemoNetwork() {
		int productsCount = 20;
		int typesCount = 3;
		int brandsCount = 3;
		int priceCount = 3;
		int promoCount = 3;
				
		this.setNetworkType(NeuralNetworkType.RECOMMENDER);
		//this.getLayers().clear();
		// init neuron settings for this type of network
		NeuronProperties neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.RAMP);
		// for sigmoid and tanh transfer functions
		neuronProperties.setProperty(""transferFunction.slope"", new Double(1)); 
		
		// create input layer		
		Layer inputLayer = LayerFactory.createLayer(productsCount,
				neuronProperties);
		this.addLayer(inputLayer);
		createProductLabels(inputLayer);

		
		// create product types layer		
		Layer typeLayer = LayerFactory.createLayer(typesCount,
				neuronProperties);
		createTypeLabels(typeLayer);
		this.addLayer(typeLayer);
		
		
		// create brands layer		
		Layer brandLayer = LayerFactory.createLayer(brandsCount,
				neuronProperties);
		createBrandLabels(brandLayer);
		this.addLayer(brandLayer);	
		
		
		// create price layer		
		Layer priceLayer = LayerFactory.createLayer(priceCount, neuronProperties);
		createPriceLabels(priceLayer);
		this.addLayer(priceLayer);	
		
		// create price layer		
		Layer promoLayer = LayerFactory.createLayer(promoCount, neuronProperties);
		createPromoLabels(promoLayer);
		this.addLayer(promoLayer);		
				
		// create output layer
		Layer outputLayer = LayerFactory.createLayer(productsCount,
				neuronProperties);
		this.addLayer(outputLayer);
		createProductLabels(outputLayer);
		
		createTypeConnections();
		createBrandConnections();
		createPriceConnections();
		createPromoConnections();

        
		// create reccurent self connections in output layer
		for(Neuron neuron : this.getLayerAt(outputLayerIdx).getNeurons()) {
			neuron.addInputConnection(neuron, 1);
		}
		
		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);	
		
		// dont learn the self connections
		// moze cak i posle svakog prolaza da se primenjuje hebbianovo pravilo a ne samo nakon kupovine
		// napravi vise varijanti
		// ako kupuje onda moze da se primenjje winner takes all hebbian learning
		this.setLearningRule(new UnsupervisedHebbianLearning());
	}"
neuroph,org.neuroph.contrib.RecommenderNetwork,createTypeConnections,,44,141,0,2,0.12,0.1256,0.666666667,18,7,0,1,"private void createTypeConnections() {
		// input connections for the first product type
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(i);
			Neuron toNeuron = this.getLayerAt(typeLayerIdx).getNeuronAt(0);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// input connections for the second product type
		for(int i = 7; i < 14; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(i);
			Neuron toNeuron = this.getLayerAt(typeLayerIdx).getNeuronAt(1);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// input connections for the third product type
		for(int i = 14; i < 20; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(i);
			Neuron toNeuron = this.getLayerAt(typeLayerIdx).getNeuronAt(2);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}		
		
		
		// output connections for the first product type
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(typeLayerIdx).getNeuronAt(0);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(i);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the second product type
		for(int i = 7; i < 14; i++) {
			Neuron fromNeuron = this.getLayerAt(typeLayerIdx).getNeuronAt(1);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(i);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the third product type
		for(int i = 14; i < 20; i++) {
			Neuron fromNeuron = this.getLayerAt(typeLayerIdx).getNeuronAt(2);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(i);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}			
	}"
neuroph,org.neuroph.contrib.RecommenderNetwork,createBrandConnections,,48,247,88,9,0.0952,0.0945,0.666666667,21,7,0,1,"private void createBrandConnections() {
		int samsung[] = {0, 1, 7, 8, 9, 14, 15};
		int lg[] = {2, 3, 10, 11, 16, 17};
		int sony[] = {4, 5, 6, 12, 13, 18, 19};
		
		// create samsung input sonnections
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(samsung[i]);
			Neuron toNeuron = this.getLayerAt(brandLayerIdx).getNeuronAt(0);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// create input connections for LG
		for(int i = 0; i < 6; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(lg[i]);
			Neuron toNeuron = this.getLayerAt(brandLayerIdx).getNeuronAt(1);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// create input connections for sony
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(sony[i]);
			Neuron toNeuron = this.getLayerAt(brandLayerIdx).getNeuronAt(2);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}		
		
		
		// output connections for the first brand
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(brandLayerIdx).getNeuronAt(0);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(samsung[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the second brand
		for(int i = 0; i < 6; i++) {
			Neuron fromNeuron = this.getLayerAt(brandLayerIdx).getNeuronAt(1);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(lg[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the third brand
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(brandLayerIdx).getNeuronAt(2);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(sony[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}			
	}"
neuroph,org.neuroph.contrib.RecommenderNetwork,createPriceConnections,,48,247,88,9,0.0952,0.0945,0.666666667,21,7,0,1,"private void createPriceConnections() {
		int low[] = {0, 2, 4, 7, 10, 16, 18};
		int mid[] = {3, 5, 8, 11, 12, 14, 19};
		int high[] = {1, 6, 9, 13, 15, 17};		
		
		// input connections for the first price class
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(low[i]);
			Neuron toNeuron = this.getLayerAt(priceLayerIdx).getNeuronAt(0);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// input connections for the second price class
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(mid[i]);
			Neuron toNeuron = this.getLayerAt(priceLayerIdx).getNeuronAt(1);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// input connections for the third price class
		for(int i = 0; i < 6; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(high[i]);
			Neuron toNeuron = this.getLayerAt(priceLayerIdx).getNeuronAt(2);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}		
		
		
		// output connections for the first price class
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(priceLayerIdx).getNeuronAt(0);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(low[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the second price class
		for(int i = 0; i < 7; i++) {
			Neuron fromNeuron = this.getLayerAt(priceLayerIdx).getNeuronAt(1);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(mid[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the third price class
		for(int i = 0; i < 6; i++) {
			Neuron fromNeuron = this.getLayerAt(priceLayerIdx).getNeuronAt(2);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(high[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}			
	}"
neuroph,org.neuroph.contrib.RecommenderNetwork,createPromoConnections,,48,198,18,2,0.1071,0.1181,0.666666667,21,7,0,1,"private void createPromoConnections() {
		
		int sales[] = {0, 10, 19};
		int new_products[] = {6, 9};
		int bestsellers[] = {3, 12, 14};		
		
		// input connections for the first promo type
		for(int i = 0; i < sales.length; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(sales[i]);
			Neuron toNeuron = this.getLayerAt(promoLayerIdx).getNeuronAt(0);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// input connections for the second promo type
		for(int i = 0; i < new_products.length; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(new_products[i]);
			Neuron toNeuron = this.getLayerAt(promoLayerIdx).getNeuronAt(1);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// input connections for the third promo type
		for(int i = 0; i < bestsellers.length; i++) {
			Neuron fromNeuron = this.getLayerAt(inputLayerIdx).getNeuronAt(bestsellers[i]);
			Neuron toNeuron = this.getLayerAt(promoLayerIdx).getNeuronAt(2);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}		

		// output connections for the first promo type
		for(int i = 0; i < sales.length; i++) {
			Neuron fromNeuron = this.getLayerAt(promoLayerIdx).getNeuronAt(0);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(sales[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the second promo type
		for(int i = 0; i < new_products.length; i++) {
			Neuron fromNeuron = this.getLayerAt(promoLayerIdx).getNeuronAt(1);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(new_products[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}
		
		// output connections for the third promo type
		for(int i = 0; i < bestsellers.length; i++) {
			Neuron fromNeuron = this.getLayerAt(promoLayerIdx).getNeuronAt(2);
			Neuron toNeuron = this.getLayerAt(outputLayerIdx).getNeuronAt(bestsellers[i]);
			this.createConnection(fromNeuron, toNeuron, 0.1);
		}			
	}"
neuroph,org.neuroph.contrib.RecommenderNetwork,createProductLabels,,22,41,0,3,0.9091,0.8261,1,1,1,0,1,"private void createProductLabels(Layer layer) {
		layer.getNeuronAt(0).setLabel(""Samsung LCD TV LE-32A330"");
		layer.getNeuronAt(1).setLabel(""Samsung LCD TV LE-32A558"");
		layer.getNeuronAt(2).setLabel(""LG LCD TV 32LG2000"");
		layer.getNeuronAt(3).setLabel(""LG LCD TV 32LG5010"");
		layer.getNeuronAt(4).setLabel(""Sony LCD TV KDL-32L4000K"");
		layer.getNeuronAt(5).setLabel(""Sony LCD TV KDL-32S4000"");
		layer.getNeuronAt(6).setLabel(""Sony LCD TV KDL-32W4000K"");
		layer.getNeuronAt(7).setLabel(""Samsung Digital Camera S760"");
		layer.getNeuronAt(8).setLabel(""Samsung Digital Camera L100"");
		layer.getNeuronAt(9).setLabel(""Samsung Digital Camera S850"");
		layer.getNeuronAt(10).setLabel(""LG Digital Camera DMCLS80E"");
		layer.getNeuronAt(11).setLabel(""LG Digital Camera DMCLZ8E"");
		layer.getNeuronAt(12).setLabel(""Sony Digital Camera DSCW120S"");
		layer.getNeuronAt(13).setLabel(""Sony Digital Camera DSCW130S"");
		layer.getNeuronAt(14).setLabel(""Samsung Mobile Phone E251"");
		layer.getNeuronAt(15).setLabel(""Samsung Mobile Phone U600"");
		layer.getNeuronAt(16).setLabel(""Sony Mobile Phone KP100"");
		layer.getNeuronAt(17).setLabel(""Sony Mobile Phone KE850"");
		layer.getNeuronAt(18).setLabel(""LG Mobile Phone K330"");
		layer.getNeuronAt(19).setLabel(""LG Mobile Phone K660"");
	}"
neuroph,org.neuroph.contrib.autotrain.AutoTrainer,generateTrainingSettings,,20,47,39,4,0.1364,0.0465,0.2,7,4,0,1,"private void generateTrainingSettings() {
        double pom = minLearningRate;
        for (int hiddenNeurons = minHiddenNeurons; hiddenNeurons <= maxHiddenNeurons; hiddenNeurons += hiddenNeuronsStep) {
            for (double learningRate = minLearningRate; learningRate <= maxLearningRate; learningRate += learningRateStep) {
                //MOMENTUM for (double momentum = 0.1; momentum < maxMomentum; momentum += 0.1) { proveriti za sta je potreban momentum i kako se koristi!
                for (double maxError = maxErrorMin; maxError <= maxErrorMax; maxError += maxErrorStep) {
                    TrainingSettings ts = new TrainingSettings()
                            .setHiddenNeurons(hiddenNeurons)
                            .setLearningRate(learningRate)
                            .setMaxError(maxError)
                            .setMaxIterations(getMaxIterations());

                    this.trainingSettingsList.add(ts);
                    //}
                }
            }
            minLearningRate = pom;
        }
        LOGGER.log(Level.INFO, ""Generated : {0} settings."", this.trainingSettingsList.size());
    }"
neuroph,org.neuroph.contrib.autotrain.TrainingStatistics,calculateIterations,,26,119,67,3,0.1842,0.0957,1,9,4,0,1,"/**
     *Based on list of TrainingResults this method calculate minimum iterations, maximum iterations, mean and standard deviation of list.
     * @param list
     * @return
     */
    public static TrainingStatistics calculateIterations(List<TrainingResult> list) {
        int minIt = list.get(0).getIterations();
        int maxIt = list.get(0).getIterations();
        double meanIt;
        double stdIt;
        
        int sumIt = 0;
        double[] v = new double[list.size()];
        int i = 0;
        for(TrainingResult tr:list){
            if(tr.getIterations() < minIt){
                minIt = tr.getIterations();
            }
            if(tr.getIterations() > maxIt){
                maxIt = tr.getIterations();
            }
            sumIt += tr.getIterations();
            v[i++] = tr.getIterations();
        }
        
        meanIt = sumIt / list.size();
        
        stdIt = std(meanIt,v);
        
        return new TrainingStatistics(minIt, maxIt, meanIt, stdIt);
    }"
neuroph,org.neuroph.contrib.autotrain.TrainingStatistics,calculateMSE,,27,119,67,3,0.1842,0.0957,1,9,4,0,1,"/**
     *Based on list of TrainingResults this method calculate minimum MSE, maximum MSE, mean and standard deviation of list.
     * @param list
     * @return
     */
    public static TrainingStatistics calculateMSE(List<TrainingResult> list) {
        double minIt = list.get(0).getTotalError();
        double maxIt = list.get(0).getTotalError();
        double meanIt;
        double stdIt;
        
        double pom = 0;
        double[] vrednosti = new double[list.size()];
        int i = 0 ;
        for(TrainingResult tr:list){
            if(tr.getTotalError() < minIt){
                minIt = tr.getTotalError();
            }
            if(tr.getTotalError() > maxIt){
                maxIt = tr.getTotalError();
            }
            pom += tr.getTotalError();
            
            vrednosti[i++] = tr.getTotalError();
        }
        
        meanIt = pom / list.size();
        
        stdIt = std(meanIt, vrednosti);
        
        return new TrainingStatistics(minIt, maxIt, meanIt, stdIt);
    }"
neuroph,org.neuroph.contrib.autotrain.TrainingStatistics,calculateStatistic,,24,75,30,3,0.2679,0.1517,0,7,4,0,1,"public static TrainingStatistics calculateStatistic(double[] array) {
        double min = array[0];
        double max = array[0];
        double mean = 0;
        double std = 0;
        
        double sum = 0;

        for(int i = 0; i < array.length; i++){
            if(array[i] < min){
                min = array[i];
            }
            if(array[i] > max){
                max = array[i];
            }
            sum += array[i];
            
        }
        mean = sum / array.length;
        
        std = std(mean, array);
        
        return new TrainingStatistics(min, max, mean, std);
    }"
neuroph,org.neuroph.contrib.autotrain.TrainingStatistics,calculateStatistic,,24,75,30,3,0.2679,0.1517,0,7,4,0,1,"private static TrainingStatistics calculateStatistic(int[] array) {
        int min = array[0];
        int max = array[0];
        double mean = 0;
        double std = 0;
        
        int sum = 0;

        for(int i = 0; i < array.length; i++){
            if(array[i] < min){
                min = array[i];
            }
            if(array[i] > max){
                max = array[i];
            }
            sum += array[i];
            
        }
        mean = sum / array.length;
        
        std = std(mean, array);
        
        return new TrainingStatistics(min, max, mean, std);
    }"
neuroph,org.neuroph.contrib.autotrain.TrainingStatistics,std,,9,10,5,3,0.3333,0.1024,0,4,2,0,1,"private static double std(double mean, int[] sum) {
        double std = 0 ;
        
        for(double temp : sum){
            std += Math.pow(temp - mean, 2); 
        }
        
        return Math.sqrt(std /sum.length);
    }"
neuroph,org.neuroph.contrib.autotrain.TrainingStatistics,std,,9,10,5,3,0.3333,0.1024,0,4,2,0,1,"private static double std(double mean, double[] sum) {
        double std = 0 ;
        
        for(double temp : sum){
            std += Math.pow(temp - mean, 2); 
        }
        
        return Math.sqrt(std /sum.length);
    }"
neuroph,org.neuroph.contrib.bpbench.TrainingSettingsGenerator,TrainingSettingsGenerator,,37,252,228,10,0.0833,0.0497,0,26,10,0,1,"/**
     * Create instance of generator with given parameters
     *
     * @param minLearningRate
     * @param maxLearningRate
     * @param learningRateStep
     * @param minHiddenNeurons
     * @param maxHiddenNeurons
     * @param hiddenNeuronsStep
     * @param momentum
     * @param maxError
     * @param maxIterations
     * @param batchMode
     */
    public TrainingSettingsGenerator(double minLearningRate, double maxLearningRate, double learningRateStep, int minHiddenNeurons, int maxHiddenNeurons, int hiddenNeuronsStep, double momentum, double maxError, int maxIterations, boolean batchMode) {
        if (minLearningRate > 0) {
            this.minLearningRate = minLearningRate;
        } else {
            this.minLearningRate = 0.1;
        }
        if (maxLearningRate > 0 && maxLearningRate > minLearningRate) {
            this.maxLearningRate = maxLearningRate;
        } else {
            this.maxLearningRate = 1;
        }
        if (learningRateStep > 0 && learningRateStep < 1) {
            this.learningRateStep = learningRateStep;
        } else {
            this.learningRateStep = 0.1;
        }
        if (minHiddenNeurons > 0) {
            this.minHiddenNeurons = minHiddenNeurons;
        } else {
            this.minHiddenNeurons = 1;
        }
        if (maxHiddenNeurons > 0 && maxHiddenNeurons > minHiddenNeurons) {
            this.maxHiddenNeurons = maxHiddenNeurons;
        } else {
            this.maxHiddenNeurons = 10;
        }
        if (hiddenNeuronsStep > 0) {
            this.hiddenNeuronsStep = hiddenNeuronsStep;
        } else {
            this.hiddenNeuronsStep = 1;
        }

        this.momentum = momentum;
        this.maxError = maxError;
        this.maxIterations = maxIterations;
        this.batchMode = batchMode;
    }"
neuroph,org.neuroph.contrib.bpbench.BackPropBenchmarks,run,,10,9,3,3,0.2917,0.3,0.5,2,3,0,1,"/**
     * Executes all training`s from list with predefined number of repetitions
     * and resets neural net
     */
    public void run() {
        for (AbstractTraining training : listOfTrainings) {
            for (int i = 0; i < noOfRepetitions; i++) {
                training.testNeuralNet();
                training.getNeuralNet().randomizeWeights();
            }
            System.out.println(training.getStats());
        }

    }"
neuroph,org.neuroph.contrib.bpbench.BackPropBenchmarks,startBenchmark,,19,45,24,4,0.2014,0.1232,1,7,7,0,1,"/**
 * Creates all training`s using list training types, settings and neural network and execute run method
 * @param trainingTypeCollection
 * @param settingsCollection
 * @param trainingSet
 * @param mlp 
 */
   public void startBenchmark(List<Class<? extends AbstractTraining>> trainingTypeCollection, List<TrainingSettings> settingsCollection, DataSet trainingSet, MultiLayerPerceptron mlp) {
        for (TrainingSettings trainingSettings : settingsCollection) {
            for (Class<? extends AbstractTraining> trainingType : trainingTypeCollection) {
                AbstractTraining training = null;
                if (trainingType.equals(BackpropagationTraining.class)) {
                    training = new BackpropagationTraining(mlp, trainingSet, trainingSettings);                   
                } else if (trainingType.equals(MomentumTraining.class)) {
                    training = new MomentumTraining(mlp, trainingSet, trainingSettings);
                } else if (trainingType.equals(QuickpropagationTraining.class)) {
                    training = new QuickpropagationTraining(mlp, trainingSet, trainingSettings);
                } else if (trainingType.equals(ResilientTraining.class)) {
                    training = new ResilientTraining(mlp, trainingSet, trainingSettings);
                }
                this.addTraining(training);
            }
        }
        this.run();
        
    }"
neuroph,org.neuroph.contrib.bpbench.BackPropBenchmarks,startBenchmark,,18,57,36,5,0.1748,0.1065,1,6,7,0,1,"/**
 * Creates all training`s using list training types, settings and execute run method
 * @param trainingTypeCollection
 * @param settingsCollection
 * @param trainingSet 
 */
   public void startBenchmark(List<Class<? extends AbstractTraining>> trainingTypeCollection, List<TrainingSettings> settingsCollection, DataSet trainingSet) {
        for (TrainingSettings trainingSettings : settingsCollection) {
            for (Class<? extends AbstractTraining> trainingType : trainingTypeCollection) {
                AbstractTraining training = null;
                if (trainingType.equals(BackpropagationTraining.class)) {
                    training = new BackpropagationTraining(trainingSet, trainingSettings);
                } else if (trainingType.equals(MomentumTraining.class)) {
                    training = new MomentumTraining(trainingSet, trainingSettings);
                } else if (trainingType.equals(QuickpropagationTraining.class)) {
                    training = new QuickpropagationTraining(trainingSet, trainingSettings);
                } else if (trainingType.equals(ResilientTraining.class)) {
                    training = new ResilientTraining(trainingSet, trainingSettings);
                }
                this.addTraining(training);
            }
        }
        this.run();
    }"
neuroph,org.neuroph.contrib.bpbench.BackPropBenchmarks,saveResults,,7,9,8,4,0.25,0.1111,1,2,2,0,1,"/**
 * Save result of benchmarking in given location as csv
 * @param filePath 
 */
    public void saveResults(String filePath) {
        try {
            ExportUtil.exportToCSV(filePath, listOfTrainings);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }"
neuroph,org.neuroph.contrib.bpbench.QuickpropagationTraining,testNeuralNet,,9,11,7,2,0.3333,0.1429,0.545454545,1,1,0,1,"/**
     * Method that set up learning rule with given settings, learns dataset and
     * creates statistics from results of the test
     */
    @Override
    public void testNeuralNet() {
        QuickPropagation qp = (QuickPropagation) setParameters();
        getNeuralNet().setLearningRule(qp);
        getNeuralNet().learn(getDataset());
        this.getStats().addData(new TrainingResult(qp.getCurrentIteration(), qp.getTotalNetworkError(), createMatrix()));
        this.getStats().calculateParameters();

    }"
neuroph,org.neuroph.contrib.bpbench.AbstractTraining,createMatrix,,9,19,10,3,0.3,0.1216,0.5,3,2,0,1,"/**
     * Method that creates confusion matrix from given dataset and neuraln
     * network
     *
     * @return confusion matrix for this training
     */
    public ConfusionMatrix createMatrix() {
        Evaluation eval = new Evaluation();
        String[] classLabels = new String[dataset.getOutputSize()];
        for (int i = 0; i < dataset.getOutputSize(); i++) {
            classLabels[i] = dataset.getColumnName(dataset.getInputSize() + i);
        }
        eval.addEvaluator(new ClassifierEvaluator.MultiClass(classLabels));
        return eval.evaluateDataSet(neuralNet, dataset).getConfusionMatrix();
    }"
neuroph,org.neuroph.contrib.bpbench.TrainingStatistics,addData,,16,9,0,2,0.3,0.3259,0.5,1,5,0,1,"/**
     * Method that adds new training result to statistic and set minimum and
     * maximum iterations and total error
     *
     * @param result
     */
    public void addData(TrainingResult result) {
        if (result.getTrainingIterations() < minIterations) {
            minIterations = result.getTrainingIterations();
        }
        if (result.getTrainingIterations() > maxIterations) {
            maxIterations = result.getTrainingIterations();
        }
        if (result.getError() < minError) {
            minError = result.getError();
        }
        if (result.getError() > maxError) {
            maxError = result.getError();
        }
        trainingResults.add(result);

    }"
neuroph,org.neuroph.contrib.bpbench.TrainingStatistics,calculateMean,,10,22,8,3,0.2963,0.1505,0.5,3,2,0,1,"/**
     * Method for calculating mean of iterations and total error
     */
    private void calculateMean() {
        int sumIter = 0;
        double sumError = 0;
        for (int i = 0; i < trainingResults.size(); i++) {
            sumError += trainingResults.get(i).getError();
            sumIter += trainingResults.get(i).getTrainingIterations();
        }
        meanError = sumError / trainingResults.size();
        meanIterations = (double) sumIter / (double) trainingResults.size();
    }"
neuroph,org.neuroph.contrib.bpbench.TrainingStatistics,calculateStd,,13,39,23,4,0.2222,0.0734,0.5,3,4,0,1,"/**
     * Method for calculating standard deviation of iterations and total error
     */
    private void calculateStd() {
        if (meanError == 0 || meanIterations == 0) {
            calculateMean();
        }
        double sumError = 0;
        int sumIter = 0;
        for (TrainingResult trainingResult : trainingResults) {
            sumError += Math.pow(trainingResult.getError() - meanError, 2);
            sumIter += Math.pow(trainingResult.getTrainingIterations() - meanIterations, 2);
        }
        stdError = Math.sqrt(sumError / trainingResults.size()); // da li sa size ili sa size-1
        stdIterations = Math.sqrt(sumIter / trainingResults.size());
    }"
neuroph,org.neuroph.contrib.bpbench.MomentumTraining,testNeuralNet,,9,11,7,2,0.3333,0.1429,0.545454545,1,1,0,1,"/**
     * Method that set up learning rule with given settings, learns dataset and
     * creates statistics from results of the test
     */
    
    @Override
    public void testNeuralNet() {
        MomentumBackpropagation mbp = (MomentumBackpropagation) setParameters();
        getNeuralNet().setLearningRule(mbp);
        getNeuralNet().learn(getDataset());
        this.getStats().addData(new TrainingResult(mbp.getCurrentIteration(), mbp.getTotalNetworkError(), createMatrix()));
        this.getStats().calculateParameters();

    }"
neuroph,org.neuroph.contrib.bpbench.ResilientTraining,testNeuralNet,,9,11,7,2,0.3333,0.1429,0.545454545,1,1,0,1,"/**
     * Method that set up learning rule with given settings, learns dataset and
     * creates statistics from results of the test
     */
    @Override
    public void testNeuralNet() {
        ResilientPropagation rp = (ResilientPropagation) setParameters();
        getNeuralNet().setLearningRule(rp);
        getNeuralNet().learn(getDataset());
        this.getStats().addData(new TrainingResult(rp.getCurrentIteration(), rp.getTotalNetworkError(), createMatrix()));
        this.getStats().calculateParameters();

    }"
neuroph,org.neuroph.contrib.bpbench.ExportUtil,exportToCSV,,10,17,6,3,0.3333,0.3086,0,4,2,0,1,"/**
 * Method for writing to csv into given file path
 * @param filePath
 * @param listOfTrainings
 * @throws IOException 
 */
    public static void exportToCSV(String filePath, List<AbstractTraining> listOfTrainings) throws IOException {
        FileWriter out = new FileWriter(filePath + "".csv"");

        out.write(writeheader());
        for (AbstractTraining training : listOfTrainings) {
            out.write(prepareLine(training));
        }
        out.flush();
        out.close();
    }"
neuroph,org.neuroph.contrib.bpbench.ExportUtil,prepareLine,,26,45,0,3,0.6563,0.7252,0.173913043,2,1,0,1,"/**
 * Method for generating one line from training
 * @param training
 * @return 
 */
    private static String prepareLine(AbstractTraining training) {
        String line = """";
        line += training.getNeuralNet().getLearningRule().getClass().getName() + DELIMITER;
        line += training.getStats().getMinIterations() + DELIMITER;
        line += training.getStats().getMaxIterations() + DELIMITER;
        line += training.getStats().getMeanIterations() + DELIMITER;
        line += training.getStats().getStdIterations() + DELIMITER;
        line += training.getStats().getMinError() + DELIMITER;
        line += training.getStats().getMaxError() + DELIMITER;
        line += training.getStats().getMeanError() + DELIMITER;
        line += training.getStats().getStdError() + DELIMITER;

        line += training.getSettings().getLearningRate() + DELIMITER;
        line += training.getSettings().getMomentum() + DELIMITER;
        line += training.getSettings().getMaxIterations() + DELIMITER;
        line += training.getSettings().getMaxError() + DELIMITER;
        line += String.valueOf(training.getSettings().isBatchMode()) + DELIMITER;
        line += training.getSettings().getHiddenNeurons() + DELIMITER;
        line += training.getSettings().getDecreaseFactor() + DELIMITER;
        line += training.getSettings().getIncreaseFactor() + DELIMITER;
        line += training.getSettings().getInitialDelta() + DELIMITER;
        line += training.getSettings().getMaxDelta() + DELIMITER;
        line += training.getSettings().getMinDelta() + DELIMITER + ""\n"";
        
        return line;
    }"
neuroph,org.neuroph.contrib.bpbench.ExportUtil,writeheader,,25,45,0,3,0.875,0.7673,0,1,1,0,1,"/**
 * Method for generating header for csv file
 * @return 
 */
    private static String writeheader() {
        String header = """";
        header += ""Algorithm"" + DELIMITER;
        header += ""Minimum iterations"" + DELIMITER;
        header += ""Maximum iterations"" + DELIMITER;
        header += ""Mean of iterations"" + DELIMITER;
        header += ""Standard deviation of iterations"" + DELIMITER;
        header += ""Minimum total error"" + DELIMITER;
        header += ""Maximum total error"" + DELIMITER;
        header += ""Mean of total error"" + DELIMITER;
        header += ""Standard deviation of total error"" + DELIMITER;
        header += ""Learning rate"" + DELIMITER;
        header += ""Momentum"" + DELIMITER;
        header += ""Maximum iterations"" + DELIMITER;
        header += ""Maximum error"" + DELIMITER;
        header += ""Batch mode"" + DELIMITER;
        header += ""Hidden neurons"" + DELIMITER;
        header += ""Decrease factor"" + DELIMITER;
        header += ""Increase factor"" + DELIMITER;
        header += ""Initial delta"" + DELIMITER;
        header += ""Maximum delta"" + DELIMITER;
        header += ""Minimum delta"" + DELIMITER + ""\n"";
       
        return header;
    }"
neuroph,org.neuroph.contrib.graphml.Graph,addNetwork,,9,6,2,2,0.4667,0.2333,0.666666667,3,3,0,1,"/**
	 * Adds a neuroph neural network to the graphml reprentation. 
	 * @param ann
	 */
	public void addNetwork( final NeuralNetwork ann ) {
	
		for( int layer = 0; layer < ann.getLayersCount(); layer++ ) {
			for( Neuron neuron : ann.getLayerAt( layer ).getNeurons()  ) {
				addNode( neuron );
				addEdges( neuron );
			}
		}
	}"
neuroph,org.neuroph.contrib.graphml.Graph,addEdges,,14,24,3,3,0.2444,0.1217,0.666666667,6,2,0,1,"/**
	 * Adds a child element of type edge for each connection in the given neuron. 
	 * @param neuron
	 */
	private void addEdges( final Neuron neuron ) {
		final String source = neuron.getLabel();
		
		String target; 
		String weight; 
		String weightKeyId = ""d1""; 
		
		for( Connection con : neuron.getOutConnections() ) {
			target = con.getToNeuron().getLabel();
			weight = String.valueOf( con.getWeight() ); 
			
			appendChild( new Edge( source, target, weightKeyId, weight ) );
		}
	}"
neuroph,org.neuroph.contrib.graphml.Graphml,Graphml,,7,15,15,4,0.1667,0,0.75,0,1,0,1,"public Graphml() { 
		addAttribute( new XMLAttribute( ""xmlns"", getNameSpace() ) );
		addAttribute( new XMLAttribute( ""xmlns:xsi"", getXsiNameSpace() ) );
		addAttribute( new XMLAttribute( ""xsi:schemaLocation"", getXsiSchemaLocation() ) );
		
		appendChild( new Key( ""d1"", ""edge"", ""weight"", ""double"" ) );
	}"
neuroph,org.neuroph.contrib.graphml.GraphmlExport,writeToFile,,10,11,7,3,0.2917,0.1556,0,3,2,0,1,"/**
	 * Writes graphml object to specified file. 
	 * @param filePathOut
	 */
	public void writeToFile( final String filePathOut ) {
		
		try {
			File file = new File( filePathOut );
			file.createNewFile();
			print( new PrintStream( file ) );
		} catch (Exception e) {
			e.printStackTrace(); 
		}
	}"
neuroph,org.neuroph.contrib.graphml.GraphmlExport,createGraph,,10,18,8,3,0.3125,0.1667,0.666666667,3,3,0,1,"/**
	 * Create XML graph from neuroph neural network. 
	 * @param ann
	 * @return
	 */
	private Graph createGraph( final NeuralNetwork ann ) {
		String id = ann.getLabel();
		if( id == null || id.length() == 0 ) { 
			id = ""defaultId""; 
		}
		Graph graph = new Graph( id );
		graph.addNetwork( ann ); 
		
		return graph; 
	}"
neuroph,org.neuroph.contrib.graphml.GraphmlExport,labelUnmarkedNeurons,,12,6,2,2,0.4,0.2167,0.666666667,4,3,0,1,"/**
	 * Labels neurons which are yet unlabelled. 
	 *  
	 * @param ann
	 */
	private void labelUnmarkedNeurons( final NeuralNetwork ann ) {
	
		for( int layer = 0; layer < ann.getLayersCount(); layer++ ) {
			
			int neuronCount = 0; 
			for( Neuron neuron : ann.getLayerAt( layer ).getNeurons()  ) {
			
				labelNeuron(layer, neuronCount, neuron);
				neuronCount++;  
			}
		}
	}"
neuroph,org.neuroph.contrib.graphml.GraphmlExport,labelNeuron,,13,11,1,3,0.4286,0.2667,0.5,3,4,0,1,"/**
	 * Labels unlabelled neuron according to following rules. 
	 * 1. If Input neuron: ""Input-[neuronCount]""
	 * 2. If Bias neuron: ""L[layer]-bias""
	 * 3. otherwise: L[layer]-[neuronCount]  
	 * @param layer
	 * @param neuronCount
	 * @param neuron
	 */
	private void labelNeuron( final int layer, final int neuronCount, final Neuron neuron ) { 
		if( neuron.getLabel() == null ) {
			
			if( neuron.getClass() == InputNeuron.class ) {
				neuron.setLabel( ""Input-"" + neuronCount );
			} else if ( neuron.getClass() == BiasNeuron.class ) {
				neuron.setLabel( ""L"" + layer + ""-bias""  );
			} else { 
				neuron.setLabel( ""L"" + layer + ""-"" + neuronCount  );
			}
			
		}
	}"
neuroph,org.neuroph.contrib.graphml.Example,Example,,6,11,7,3,0.3333,0.1667,0.5,2,1,0,1,"/**
	 * 1. Generate trained artificial neural network.
	 * 2. Create GraphmlExport instance. 
	 * 3. Parse the artificial neural network. 
	 * 4. Print to STDOUT
	 *   
	 */
	public Example() {
		NeuralNetwork ann = ExampleNetworXOR.getNetwork(); 
		GraphmlExport ge = new GraphmlExport( ann );
		ge.parse(); 
		ge.printToStdout();
	}"
neuroph,org.neuroph.contrib.learning.CrossEntropyError,addPatternError,,16,29,22,5,0.2222,0.1038,0,4,3,0,1,"@Override
    public double[] addPatternError(double[] predictedOutput, double[] targetOutput) {
        double[] error = new double[targetOutput.length];

        if (predictedOutput.length != targetOutput.length)
            throw new IllegalArgumentException(""Output array length and desired output array length must be the same size!"");

        for (int i = 0; i < predictedOutput.length; i++) {
            errorDerivative[i] =  targetOutput[i] - predictedOutput[i];
            totalError += targetOutput[i] * Math.log(predictedOutput[i]) ;

        }
        n++;
        
        return error;
    }"
neuroph,org.neuroph.contrib.licenceplaterecognition.OcrDemo,crop,,35,126,81,3,0.1617,0.0763,0,10,18,0,1,"/**
     * Crop the part of an image with a white rectangle
     *
     * @return A cropped image File
     */
    public File crop(BufferedImage image) {
        // this will be coordinates of the upper left white pixel
        int upperLeftCornerx = Integer.MAX_VALUE;
        int upperLeftCornery = Integer.MAX_VALUE;
        //this will be coordinates of the lower right white pixel
        int lowerRightCornerx = Integer.MIN_VALUE;
        int lowerRightCornery = Integer.MIN_VALUE;
        //find the minimum and maximum white pixel coordinates
        for (int i = 0; i < image.getWidth(); i++) {
            for (int j = 0; j < image.getHeight(); j++) {
                if (image.getRGB(i, j) == WHITE.getRGB() && (i < upperLeftCornerx && j < upperLeftCornery) 
                        || (i <= upperLeftCornerx && j < upperLeftCornery)
                         || (i < upperLeftCornerx && j <= upperLeftCornery)) {
                    upperLeftCornerx = i;
                    upperLeftCornery = j;
                }
                if (image.getRGB(i, j) == WHITE.getRGB() && ((i > lowerRightCornerx && j >= lowerRightCornery)
                        || (i >= lowerRightCornerx && j > lowerRightCornery)
                        || (i > lowerRightCornerx && j >= lowerRightCornery))) {
                    lowerRightCornerx = i;
                    lowerRightCornery = j;
                }
            }
        }
        //crop the image to the white rectangle size
        BufferedImage croppedImage = image.getSubimage(upperLeftCornerx, upperLeftCornery, lowerRightCornerx - upperLeftCornerx, lowerRightCornery - upperLeftCornery);
       //make a file from that cropped image
        File cropFile = new File(""croppedimage.png"");
        try {
            ImageIO.write(croppedImage, ""png"", cropFile);
        } catch (IOException ex) {
            Logger.getLogger(OcrDemo.class.getName()).log(Level.SEVERE, null, ex);
        }
        return cropFile;
    }"
neuroph,org.neuroph.contrib.licenceplaterecognition.OcrDemo,run,,56,205,179,7,0.0804,0.0375,0.625,10,6,1,1,"public void run() {
        try {

            // load image with text to recognize
            if (image==null){
             image = ImageIO.read(new File(textImageFile));
            }
            //binarize the input image
            image = BinaryOps.binary(textImageFile);
   
            //dataset creation 
            /**
             * CharacterExtractor ce1 = new CharacterExtractor(); File
             * inputImage1 = new File(datasetImageFile); File outputDirectory1 =
             * new File (datasetOutputFile); ce1.slice(inputImage1,
             * outputDirectory1, 60, 60);
             */
            // crop the white rectange from the image
            File cropFile = crop(image);
            
            // extract individual characters from text image
            
            
           //make the output file
            File outputDirectory = new File(charOutputFile);
            //slice the cropped file to individual character with the width and height of 60px

            
            //make a list of character images and add the images form char files
            List<BufferedImage> lista = new ArrayList<BufferedImage>();
            for (int i = 0; i <= 7; i++) {
                File f = new File(""data/char_"" + i + "".png"");
                BufferedImage bi = ImageIO.read(f);
                lista.add(bi);
            }
           
            // load neural network from file
           if (nnet==null){
            NeuralNetwork nnet = NeuralNetwork.createFromFile(neuralNetworkFile);
           }
            // get ocr plugin from neural network
            nnet.addPlugin(new OcrPlugin(new Dimension(10, 10), ColorMode.BLACK_AND_WHITE));
            OcrPlugin ocrPlugin = (OcrPlugin) nnet.getPlugin(OcrPlugin.class);
           
            // and recognize current character - ( have to use ImageJ2SE here to wrap BufferedImage)
            for (int i = 0; i < lista.size(); i++) {
                recognizedCharacters+=ocrPlugin.recognizeCharacter(new ImageJ2SE(lista.get(i))) + "" "";
                System.out.print(ocrPlugin.recognizeCharacter(new ImageJ2SE(lista.get(i))) + "" "");
            }
            recognizedCharacters.trim();
        } catch (IOException e) {
            //Let us know what happened  
            System.out.println(""Error reading dir: "" + e.getMessage());
        }

    }"
neuroph,org.neuroph.contrib.licenceplaterecognition.BinaryOps,invertImage,,32,81,42,3,0.1705,0.144,0,9,5,0,1,"/**
     *
     * Inverts the image colors from negative to positive
     *
     * @return the image with inverted colors
     */
    public static BufferedImage invertImage(String imageName) {

        // read the image file
        BufferedImage inputFile = null;
        try {
            inputFile = ImageIO.read(new File(imageName));
        } catch (IOException e) {
            e.printStackTrace();
        }

        // go through image pixels and reverse their color       
        for (int x = 0; x < inputFile.getWidth(); x++) {
            for (int y = 0; y < inputFile.getHeight(); y++) {
                int rgba = inputFile.getRGB(x, y);
                Color col = new Color(rgba, true);
                col = new Color(255 - col.getRed(),
                        255 - col.getGreen(),
                        255 - col.getBlue());
                inputFile.setRGB(x, y, col.getRGB());
            }
        }

        //write the image to a file blackandwhite.png
        try {
            File outputFile = new File(""blackandwhite.png"");
            ImageIO.write(inputFile, ""png"", outputFile);

        } catch (IOException e) {
            e.printStackTrace();
        }
        return inputFile;
    }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMultiLayerPerceptron,createMatrixLayers,,13,29,13,3,0.2333,0.108,0.833333333,4,2,0,1,"private void createMatrixLayers() {
        matrixLayers = new MatrixLayer[sourceNetwork.getLayersCount()];
        matrixLayers[0] = new MatrixInputLayer(sourceNetwork.getLayerAt(0).getNeuronsCount());

        MatrixLayer prevLayer = matrixLayers[0];
        
         for(int i =1; i < sourceNetwork.getLayersCount(); i++  ) {
            Layer layer = sourceNetwork.getLayerAt(i);
            MatrixMlpLayer newBpLayer = new MatrixMlpLayer(layer, prevLayer, new Tanh());
            matrixLayers[i] = newBpLayer;
            prevLayer = newBpLayer;
        }
    }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMultiLayerPerceptron,calculate,,6,6,6,3,0.25,0,1,1,2,0,1,"@Override
         public void calculate() {
             for(int i = 1; i < matrixLayers.length; i++) {
                 matrixLayers[i].calculate();                 
             }
         }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMlpLayer,MatrixMlpLayer,,23,126,99,8,0.1111,0.0655,1,9,2,0,1,"// vidi konstruktore za MLayer
//    public MatrixBackPropLayer(int inputSize, int outputSize, TransferFunction transferFunction) {
//        inputs = new double[inputSize];
//        outputs = new double[outputSize];
//        weights = new double[outputSize][inputSize];
//
//        this.transferFunction = transferFunction;
//    }



      public MatrixMlpLayer(Layer sourceLayer, MatrixLayer previousLayer, TransferFunction transferFunction) {
          this.sourceLayer = sourceLayer;
          this.previousLayer = previousLayer;
          if (!(previousLayer instanceof MatrixInputLayer)) ((MatrixMlpLayer)previousLayer).setNextLayer(this);
          this.transferFunction = transferFunction;

          this.neuronsCount = sourceLayer.getNeuronsCount();
//          if (sourceLayer.getNeuronAt(neuronsCount-1) instanceof BiasNeuron) this.neuronsCount = this.neuronsCount -1;

          this.inputsCount = previousLayer.getOutputs().length;

          outputs = new double[neuronsCount];
//          biases = new double[neuronsCount];
//          deltaBiases = new double[neuronsCount];
          inputs = new double[inputsCount];
          netInput = new double[neuronsCount];
          weights = new double[neuronsCount][inputsCount];
          deltaWeights = new double[neuronsCount][inputsCount];

          errors = new double[neuronsCount];

          copyNeuronsToMatrices();
      }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMlpLayer,copyNeuronsToMatrices,,17,37,19,3,0.1919,0.1194,0.8,6,4,0,1,"// maybe omit the sourceLayer parmeter
    public void copyNeuronsToMatrices() {

        int neuronIdx = 0, connIdx = 0;
        for(Neuron neuron : this.sourceLayer.getNeurons()) {
            if (neuron instanceof BiasNeuron) {
                this.useBias = true;
            }
            outputs[neuronIdx] = neuron.getOutput();
            // should we copy net inputs also? weightedSums or netInputs = neuron.getNetInput()
            connIdx = 0;
            for(Connection conn : neuron.getInputConnections()) {
                weights[neuronIdx][connIdx] = conn.getWeight().getValue();
                connIdx++;
            }
            neuronIdx++;
        }
    }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMlpLayer,calculate,,14,34,23,4,0.2,0.0762,1,3,4,0,1,"final public void calculate() {
        this.inputs = previousLayer.getOutputs();
       	for (int i = 0; i < neuronsCount; i++) {
            netInput[i] = 0;
            for (int j = 0; j < inputs.length; j++) {
                    netInput[i] += inputs[j] * weights[i][j];
            }
//            netInput[i] = netInput[i] + biases[i];
            outputs[i] = transferFunction.getOutput(netInput[i]);
	}

            if (useBias)
                outputs[neuronsCount-1] = 1; // this one is bias neuron
    }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMomentumBackpropagation,calculateErrorAndUpdateOutputNeurons,,21,24,3,3,0.2222,0.1396,0.571428571,7,2,0,1,"/**
	 * This method implements weights update procedure for the output neurons
	 *
	 * @param patternError
	 *            single pattern error vector
	 */
        @Override
	protected void calculateErrorAndUpdateOutputNeurons(double[] patternError) {
            
                // get output layer
                MatrixMlpLayer outputLayer = (MatrixMlpLayer)matrixLayers[matrixLayers.length - 1];
                TransferFunction transferFunction = outputLayer.getTransferFunction();

                // get output vector
                double[] outputs = outputLayer.getOutputs();
                double[] netInputs = outputLayer.getNetInput();
                double[] neuronErrors = outputLayer.getErrors(); // these will hold  -should be set from here!!!!

                // calculate errors(deltas) for all output neurons
                for(int i = 0; i < outputs.length; i++) {
                    neuronErrors[i] = patternError[i] * transferFunction.getDerivative(netInputs[i]); // ovde mi treba weighted sum, da ne bi morao ponovo da racunam
                }

                // update weights
                this.updateLayerWeights(outputLayer, neuronErrors);
                System.out.println(""MSE:""+getErrorFunction().getTotalError());
        }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMomentumBackpropagation,updateLayerWeights,,18,19,2,2,0.2556,0.1482,0.25,10,3,0,1,"// http://netbeans.org/kb/docs/java/profiler-profilingpoints.html
        protected void updateLayerWeights(MatrixMlpLayer layer, double[] errors) {

            double[] inputs = layer.getInputs();
            double[][] weights = layer.getWeights();
            double[][] deltaWeights = layer.getDeltaWeights();

                for(int neuronIdx = 0; neuronIdx < layer.getNeuronsCount(); neuronIdx++) { // iterate neurons
                  for(int weightIdx = 0; weightIdx < weights[neuronIdx].length; weightIdx++ ) { // iterate weights
                      // calculate weight change
                      double deltaWeight = this.learningRate * errors[neuronIdx] * inputs[weightIdx] +
                                       momentum * (deltaWeights[neuronIdx][weightIdx]);

                      deltaWeights[neuronIdx][weightIdx] = deltaWeight; // save weight change to calculate momentum
                      weights[neuronIdx][weightIdx] += deltaWeight; // apply weight change

                  }
                }
        }"
neuroph,org.neuroph.contrib.matrixmlp.MatrixMomentumBackpropagation,calculateErrorAndUpdateHiddenNeurons,,35,112,71,4,0.1319,0.077,0.375,13,4,0,1,"/**
         * backpropogate errors through all hidden layers and update conneciion weights
         * for those layers.
         */
        @Override
        protected void calculateErrorAndUpdateHiddenNeurons()
        {
            int layersCount = matrixMlp.getLayersCount();
            
            for ( int layerIdx = layersCount -2 ; layerIdx > 0 ; layerIdx--) {
               MatrixMlpLayer currentLayer = (MatrixMlpLayer)matrixLayers[layerIdx];

               TransferFunction transferFunction = currentLayer.getTransferFunction();
               int neuronsCount = currentLayer.getNeuronsCount();

               double[] neuronErrors = currentLayer.getErrors();
               double[] netInputs = currentLayer.getNetInput();

               MatrixMlpLayer nextLayer = (MatrixMlpLayer)currentLayer.getNextLayer();
               double[] nextLayerErrors = nextLayer.getErrors();
               double[][] nextLayerWeights = nextLayer.getWeights();

               // calculate error for each neuron in current layer
               for(int neuronIdx = 0; neuronIdx < neuronsCount; neuronIdx++) {
                   // calculate weighted sum of errors of all neuron it is attached to - calculate how much this neuron is contributing to errors in next layer
                   double weightedErrorsSum = 0;

                   for(int nextLayerNeuronIdx = 0; nextLayerNeuronIdx < nextLayer.getNeuronsCount(); nextLayerNeuronIdx++) {
                     weightedErrorsSum += nextLayerErrors[nextLayerNeuronIdx] * nextLayerWeights[nextLayerNeuronIdx][neuronIdx];
                   }

                   // calculate the error for this neuron
                   neuronErrors[neuronIdx] = transferFunction.getDerivative(netInputs[neuronIdx]) * weightedErrorsSum;
               } // neuron iterator

               this.updateLayerWeights(currentLayer, neuronErrors);
               
            } // layer iterator
        }"
neuroph,org.neuroph.contrib.samples.SunSpots,normalizeSunspots,,18,45,12,3,0.2115,0.1116,0,6,3,0,1,"/**
	 * Normalize the sunspots.
	 * @param lo Low range for normalization.
	 * @param hi High range for normalization.
	 */
	public void normalizeSunspots(double lo, double hi) {
		double min = Double.MAX_VALUE;
		double max = Double.MIN_VALUE;
		for (int year = 0; year < SUNSPOTS.length; year++) {
			min = Math.min(min, SUNSPOTS[year]);
			max = Math.max(max, SUNSPOTS[year]);
		}

		normalizedSunspots = new double[SUNSPOTS.length];
		closedLoopSunspots = new double[SUNSPOTS.length];

		mean = 0;
		for (int year = 0; year < SUNSPOTS.length; year++) {
			normalizedSunspots[year] = closedLoopSunspots[year] = ((SUNSPOTS[year] - min) / (max - min))
					* (hi - lo) + lo;
			mean += normalizedSunspots[year] / SUNSPOTS.length;
		}
	}"
neuroph,org.neuroph.contrib.samples.SunSpots,generateTrainingData,,18,50,34,3,0.1667,0.0546,0.666666667,8,3,0,1,"/**
	 * Generate the training data for the training sunspot years.
	 * @return The training data.
	 */
	public DataSet generateTrainingData() {
		DataSet result = new DataSet(WINDOW_SIZE, 1);

		for (int year = TRAIN_START; year < TRAIN_END; year++) {
			double[] input = new double[WINDOW_SIZE];
			double[] ideal = new double[1];

			int index = 0;
			for (int i = year - WINDOW_SIZE; i < year; i++) {
				input[index++] = this.normalizedSunspots[i];
			}

			ideal[0] = this.normalizedSunspots[year];

			result.addRow(new DataSetRow(input, ideal));
		}
		return result;
	}"
neuroph,org.neuroph.contrib.samples.SunSpots,predict,,40,178,125,4,0.1222,0.0854,0.333333333,13,4,1,1,"/**
	 * Predict sunspots.
	 * @param network Neural network to use.
	 */
	public void predict(NeuralNetwork network) {
		NumberFormat f = NumberFormat.getNumberInstance();
		f.setMaximumFractionDigits(4);
		f.setMinimumFractionDigits(4);

		System.out.println(""Year\tActual\tPredict\tClosed Loop Predict"");

		for (int year = EVALUATE_START; year < EVALUATE_END; year++) {
			// calculate based on actual data
			double[] input = new double[WINDOW_SIZE];
			for (int i = 0; i < input.length; i++) {
				input[i] = this.normalizedSunspots[(year - WINDOW_SIZE) + i];
			}

			network.setInput(input);
			network.calculate();

			double[] output = network.getOutput();
			double prediction = output[0];
			this.closedLoopSunspots[year] = prediction;

			// calculate ""closed loop"", based on predicted data
			for (int i = 0; i < input.length; i++) {
				input[i] = this.closedLoopSunspots[(year - WINDOW_SIZE) + i];
			}

			network.setInput(input);
			network.calculate();
			output = network.getOutput();

			double closedLoopPrediction = output[0];

			// display
			System.out.println((STARTING_YEAR + year) + ""\t""
					+ f.format(this.normalizedSunspots[year]) + ""\t""
					+ f.format(prediction) + ""\t""
					+ f.format(closedLoopPrediction));

		}
	}"
neuroph,org.neuroph.contrib.samples.stockmarket.StockFileReader,read,,42,580,530,10,0.0661,0.0315,0,16,5,1,1,"@SuppressWarnings(""static-access"")
    public void read(String fileName) {
        HashMap hm = new HashMap();
        File file = new File(fileName);
        System.out.println(""file = "" + fileName+"". It will be filtered the values for the moment of the market opened"");
        int counter = 0;
        try {
            FileInputStream fis = new FileInputStream(file);
            BufferedReader dis = new BufferedReader(new InputStreamReader(fis));
            String s;
            while ((s = dis.readLine()) != null) {
                //System.out.println(s);
                String[] s1 = s.split("","");
                String s00 = s1[0].replace('\""', ' ').trim();
                String s01 = s1[1].replace('\""', ' ').trim();
                hm.put(s00, s.replace('\""', ' ').trim());
                //System.out.println(s00 + "" "" + s01);
                counter = counter + 1;
            }
            fis.close();
        } catch (IOException ioe) {
            System.out.println(""Oops- an IOException happened."");
            ioe.printStackTrace();
            System.exit(1);
        }
        System.out.println(""full number of values = "" + counter);        
        Set s = hm.keySet();
        Iterator i = s.iterator();
        valuesRow = new String[this.getMaxCounter()];
        int n = 0;
        while (i.hasNext()) {
            String key = (String) i.next();
            String value = (String) hm.get(key);
            //System.out.println(key + ""->"" + value);
            n = n + 1;
            if (counter - n < this.getMaxCounter()) {
                valuesRow[counter - n] = value;
                System.out.println(counter + "" "" + n + "" "" + valuesRow[counter - n] + "" "" + (counter - n));
            }
        }
        System.out.println(""valuesRow.length="" + valuesRow.length);
    }"
neuroph,org.neuroph.contrib.samples.stockmarket.StockSocketReader,run,,31,235,217,10,0.087,0.0337,0,9,5,0,1,"@SuppressWarnings(""static-access"")
    public void run() {
        valuesRow = new String[this.getMaxCounter()];
        for (int i = 0; i < this.getMaxCounter(); i++) {
            InputStream is = null;
            try {
                String surl = ""http://download.finance.yahoo.com/d/quotes.csv?s=^GDAXI&f=sl1d1t1c1ohgv&e=.csv"";
                URL url = new URL(surl);
                is = url.openStream();
                BufferedReader dis = new BufferedReader(new InputStreamReader(is));
                String s = dis.readLine();
                System.out.println(s);
                valuesRow[i] = s;
                is.close();
            } catch (MalformedURLException mue) {
                System.out.println(""Ouch - a MalformedURLException happened."");
                mue.printStackTrace();
                System.exit(1);
            } catch (IOException ioe) {
                System.out.println(""Oops- an IOException happened."");
                ioe.printStackTrace();
                System.exit(1);
            }
            try {
                Thread.currentThread().sleep(this.getTsleep());
            } catch (InterruptedException e) {
            }
        }//end of for
        System.out.println(""valuesRow.length="" + valuesRow.length);

    }"
neuroph,org.neuroph.contrib.samples.stockmarket.StockTrainingSetImport,importFromArray,,21,69,33,3,0.24,0.1213,0.666666667,9,7,0,1,"/**
     * Creates and returns training set for stock market prediction using the provided data from array
     * @param values an array containing stock data
     * @param inputsCount training element (neural net) inputs count
     * @param outputsCount training element (neural net) ouputs count
     * @return training set with stock data
     */
    public static DataSet importFromArray(double[] values, int inputsCount, int outputsCount) {
        DataSet trainingSet = new DataSet(inputsCount, outputsCount);
        for (int i = 0; i < values.length - inputsCount; i++) {
            ArrayList<Double> inputs = new ArrayList<Double>();
            for (int j = i; j < i + inputsCount; j++) {
                inputs.add(values[j]);
            }
            ArrayList<Double> outputs = new ArrayList<Double>();
            if (outputsCount > 0 && i + inputsCount + outputsCount <= values.length) {
                for (int j = i + inputsCount; j < i + inputsCount + outputsCount; j++) {
                    outputs.add(values[j]);
                }
                if (outputsCount > 0) {
                    trainingSet.addRow(new DataSetRow(inputs, outputs));
                } else {
                    trainingSet.addRow(new DataSetRow(inputs));
                }
            }
        }
        return trainingSet;
    }"
neuroph,org.neuroph.contrib.samples.timeseries.GenerateSet,doIt,,8,15,15,6,0.1667,0,0,0,2,0,1,"/**
         * Does the data set generation
         * @throws IOException
         */
	public void doIt() throws IOException {
		if(simple){
			doItSimple();
		}
		else{
			doItSupposition();
		}
	}"
neuroph,org.neuroph.contrib.samples.timeseries.GenerateSet,doItSimple,,38,142,113,5,0.1134,0.0848,0.5,9,6,0,1,"/**
         * Generates simple sine wave data set
         * @throws IOException
         */
	private void doItSimple() throws IOException {
		
		double buffer[]=new double[memorySize+1]; //the extra one is for the output value
		int bufferSize=buffer.length;
		int bufferFull=buffer.length;
		
		GenerateSineWave gsw=new GenerateSineWave(1,1);
		
		BufferedWriter out=new BufferedWriter(new FileWriter(filename));
		
		for(int samples=0;samples<1000;samples++){
			
			//run through next samples so we take samples EVERY 'sampleEvery' steps
			for(int j=0;j<sampleEvery;j++){
				gsw.getNextSample();
			}
			
			//shift buffer down by one
			for(int i=1;i<bufferSize;i++){
				buffer[i-1]=buffer[i];
			}
			
			//load latest into end of buffer
			buffer[bufferSize-1]=gsw.getNextSample();
			
			//check to see when buffer fills up
			bufferFull--;
			if(bufferFull<=0){ //if buffer full write out the buffer
				for(int i=0;i<bufferSize;i++){
					out.write(buffer[i]+""\t"");
				}
				out.write(""\n"");
			}
		}
		
		out.flush();
		out.close();
	}"
neuroph,org.neuroph.contrib.samples.timeseries.GenerateSet,doItSupposition,,40,162,134,5,0.1167,0.075,0.5,10,6,1,1,"/**
         * Generates supposition sine wave data set
         * @throws IOException
         */
	private void doItSupposition() throws IOException{
		
		BufferedWriter out=new BufferedWriter(new FileWriter(filename));
		
		double buffer[]=new double[memorySize+1]; //the extra one is for the output value
		int bufferSize=buffer.length;
		int bufferFull=buffer.length;
		
		GenerateSineWave gsw1=new GenerateSineWave(1,0.5);
		GenerateSineWave gsw2=new GenerateSineWave(4,0.5);
		
		for(int samples=0;samples<1000;samples++){
			
			//run through next samples so we take samples EVERY
			for(int j=0;j<sampleEvery;j++){
				gsw1.getNextSample();
				gsw2.getNextSample();
			}
			
			//shift buffer down by one
			for(int i=1;i<bufferSize;i++){
				buffer[i-1]=buffer[i];
			}
			
			//load latest into end of buffer
			buffer[bufferSize-1]=gsw1.getNextSample()+gsw2.getNextSample();
			
			//check to see when buffer fills up
			bufferFull--;
			if(bufferFull<=0){ //if buffer full write out the buffer
				for(int i=0;i<bufferSize;i++){
					out.write(buffer[i]+""\t"");
				}
				out.write(""\n"");
			}
		}
		
		out.flush();
		out.close();
	}"
neuroph,org.neuroph.contrib.samples.timeseries.TestTimeSeries,train,,19,18,8,2,0.2188,0.1577,0.857142857,2,1,0,1,"public void train() {
        // get the path to file with data
        String inputFileName = ""C:\\timeseries\\BSW15"";
        
        // create MultiLayerPerceptron neural network
        neuralNet = new MultiLayerPerceptron(TransferFunctionType.TANH, 5, 10, 1);
        MomentumBackpropagation learningRule = (MomentumBackpropagation)neuralNet.getLearningRule();
        learningRule.setLearningRate(0.2);
        learningRule.setMomentum(0.5);
        // learningRule.addObserver(this);
        learningRule.addListener(this);        
        
        // create training set from file
         trainingSet = DataSet.createFromFile(inputFileName, 5, 1, ""\t"", false);
        // train the network with training set
        neuralNet.learn(trainingSet);         
              
        System.out.println(""Done training."");          
    }"
neuroph,org.neuroph.contrib.samples.timeseries.TestTimeSeries,testNeuralNetwork,,11,14,7,2,0.3214,0.1508,0.6,2,2,0,1,"/**
     * Prints network output for the each element from the specified training set.
     * @param neuralNet neural network
     * @param trainingSet training set
     */
    public void testNeuralNetwork() {
        System.out.println(""Testing network..."");
        for(DataSetRow trainingElement : trainingSet.getRows()) {
            neuralNet.setInput(trainingElement.getInput());
            neuralNet.calculate();
            double[] networkOutput = neuralNet.getOutput();

            System.out.print(""Input: "" + Arrays.toString( trainingElement.getInput() ) );
            System.out.println("" Output: "" + Arrays.toString( networkOutput) );
        }
    }"
neuroph,org.neuroph.core.Layer,Layer,,8,13,11,4,0.2222,0.0536,1,4,2,0,1,"/**
     * Creates an instance of Layer with the specified number of neurons with
     * specified neuron properties
     *
     * @param neuronsCount number of neurons in layer
     * @param neuronProperties properties of neurons in layer
     */
    public Layer(int neuronsCount, NeuronProperties neuronProperties) {
        this(neuronsCount);

        for (int i = 0; i < neuronsCount; i++) {
            Neuron neuron = NeuronFactory.createNeuron(neuronProperties);
            this.addNeuron(neuron);
        }
    }"
neuroph,org.neuroph.core.Layer,removeNeuronAt,,10,17,13,4,0.2245,0.1167,0.75,2,2,0,1,"/**
     * Removes neuron at specified index position in this layer
     *
     * @param index index position of neuron to remove
     */
    public final void removeNeuronAt(int index) {
        Neuron neuron = neurons.get(index);
        neuron.setParentLayer(null);
        neuron.removeAllConnections(); // why we're doing this here? maybe we shouldnt
        neurons.remove(index);                
        
        // notify listeners that neuron has been removed
        if (parentNetwork != null)
            parentNetwork.fireNetworkEvent(new NeuralNetworkEvent(this, NeuralNetworkEvent.Type.NEURON_REMOVED));                        
    }"
neuroph,org.neuroph.core.Layer,removeAllNeurons,,7,6,6,4,0.25,0,1,0,2,0,1,"public final void removeAllNeurons() {
        neurons.clear();
        
        // notify listeners that neurons has been removed
        if (parentNetwork != null)
            parentNetwork.fireNetworkEvent(new NeuralNetworkEvent(this, NeuralNetworkEvent.Type.NEURON_REMOVED));                                
    }"
neuroph,org.neuroph.core.Weight,equals,,23,24,12,3,0.2222,0.1757,0,5,7,0,1,"@Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Weight other = (Weight) obj;
        if (Double.doubleToLongBits(this.value) != Double.doubleToLongBits(other.value)) {
            return false;
        }
        if (Double.doubleToLongBits(this.weightChange) != Double.doubleToLongBits(other.weightChange)) {
            return false;
        }
        if (!Objects.equals(this.trainingData, other.trainingData)) {
            return false;
        }
        return true;
    }"
neuroph,org.neuroph.core.Connection,Connection,,16,14,13,5,0.1905,0.0357,1,5,3,0,1,"/**
     * Creates a new connection between specified neurons with random weight
     *
     * @param fromNeuron neuron to connect from
     * @param  toNeuron neuron to connect to
     */
    public Connection(Neuron fromNeuron, Neuron toNeuron) {

        if (fromNeuron == null) {
            throw new IllegalArgumentException(""From neuron in connection cant be null !"");
        } else {
            this.fromNeuron = fromNeuron;
        }

        if (toNeuron == null) {
            throw new IllegalArgumentException(""To neuron in connection cant be null!"");
        } else {
            this.toNeuron = toNeuron;
        }

        this.weight = new Weight();
    }"
neuroph,org.neuroph.core.Connection,equals,,23,24,12,3,0.2593,0.1929,0,5,7,0,1,"@Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Connection other = (Connection) obj;
        if (!Objects.equals(this.fromNeuron, other.fromNeuron)) {
            return false;
        }
        if (!Objects.equals(this.toNeuron, other.toNeuron)) {
            return false;
        }
        if (!Objects.equals(this.weight, other.weight)) {
            return false;
        }
        return true;
    }"
neuroph,org.neuroph.core.NeuralNetwork,addLayer,,21,9,3,2,0.2778,0.1578,1,2,3,0,1,"/**
     * Adds layer to specified index position in network
     *
     * @param index index position to add layer
     * @param layer layer to add
     */
    public void addLayer(int index, Layer layer) {

        // in case of null value throw exception to prevent adding null layers
        if (layer == null) {
            throw new IllegalArgumentException(""Layer cant be null!"");
        }

        // if layer position is negative also throw exception
        if (index < 0) {
            throw new IllegalArgumentException(""Layer index cannot be negative: ""+index);
        }

        // set parent network for added layer
        layer.setParentNetwork(this);        
        
        // add layer to layers collection at specified position        
        layers.add(index, layer);

        // notify listeners that layer has been added
        fireNetworkEvent(new NeuralNetworkEvent(layer, NeuralNetworkEvent.Type.LAYER_ADDED));
    }"
neuroph,org.neuroph.core.NeuralNetwork,calculate,,7,9,8,4,0.24,0.0556,1,2,2,0,1,"//    This can be used to provid difefrent ways for leyer calculation
//    public static interface Calculator {
//        // default calculator
//        public void calculate();
//    }
//    
//    // default calculator is sequential using foreach loop
//    transient Calculator calculator = new Calculator() {
//        @Override
//        public void calculate() {
//            for (Layer layer : getLayers()) {
//                layer.calculate();
//            }
//        }
//    };
//
//    public Calculator getCalculator() {
//        return calculator;
//    }
//
//    public void setCalculator(Calculator calculator) {
//        this.calculator = calculator;
//    }
    
    
    
    /**
     * Performs calculation on whole network
     */
    public void calculate() {
        for (Layer layer : this.layers) {
            layer.calculate();
        }
        
        fireNetworkEvent(new NeuralNetworkEvent(this, NeuralNetworkEvent.Type.CALCULATED));
    }"
neuroph,org.neuroph.core.NeuralNetwork,learn,,7,9,8,4,0.3,0.0714,1,1,2,0,1,"/**
     * Learn the specified training set
     *
     * @param trainingSet set of training elements to learn
     */
    public void learn(DataSet trainingSet) {
        if (trainingSet == null) {
            throw new IllegalArgumentException(""Training set is null!"");
        }

        learningRule.learn(trainingSet);
    }"
neuroph,org.neuroph.core.NeuralNetwork,save,,18,49,32,5,0.1481,0.1559,1,5,4,0,1,"/**
     * Saves neural network into the specified file.
     *
     * @param filePath file path to save network into
     */
    public void save(String filePath) {
        ObjectOutputStream out = null;
        try {
            File file = new File(filePath);
            out = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file)));
            out.writeObject(this);
            out.flush();
        } catch (IOException ioe) {
            throw new NeurophException(""Could not write neural network to file!"", ioe);
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                }
            }
        }
    }"
neuroph,org.neuroph.core.NeuralNetwork,load,,26,101,82,5,0.125,0.0909,1,7,6,0,1,"/**
     * Loads neural network from the specified file.
     *
     * @param filePath file path to load network from
     * @return loaded neural network as NeuralNetwork object
     * @deprecated Use createFromFile method instead
     */
    public static NeuralNetwork load(String filePath) {
        ObjectInputStream oistream = null;

        try {
            File file = new File(filePath);
            if (!file.exists()) {
                throw new FileNotFoundException(""Cannot find file: "" + filePath);
            }

            oistream = new ObjectInputStream(new BufferedInputStream(new FileInputStream(filePath)));
            NeuralNetwork nnet = (NeuralNetwork) oistream.readObject();
            return nnet;

        } catch (IOException ioe) {
            throw new NeurophException(""Could not read neural network file!"", ioe);
        } catch (ClassNotFoundException cnfe) {
            throw new NeurophException(""Class not found while trying to read neural network from file!"", cnfe);
        } finally {
            if (oistream != null) {
                try {
                    oistream.close();
                } catch (IOException ioe) {
                }
            }
        }
    }"
neuroph,org.neuroph.core.NeuralNetwork,load,,22,63,48,5,0.1648,0.1292,1,6,5,0,1,"/**
     * Loads neural network from the specified InputStream.
     *
     * @param inputStream input stream to load network from
     * @return loaded neural network as NeuralNetwork object
     */
    public static NeuralNetwork load(InputStream inputStream) {
        ObjectInputStream oistream = null;

        try {
            oistream = new ObjectInputStream(new BufferedInputStream(inputStream));
            NeuralNetwork nnet = (NeuralNetwork) oistream.readObject();

            return nnet;

        } catch (IOException ioe) {
            throw new NeurophException(""Could not read neural network file!"", ioe);
        } catch (ClassNotFoundException cnfe) {
            throw new NeurophException(""Class not found while trying to read neural network from file!"", cnfe);
        } finally {
            if (oistream != null) {
                try {
                    oistream.close();
                } catch (IOException ioe) {
                }
            }
        }
    }"
neuroph,org.neuroph.core.NeuralNetwork,createFromFile,,25,87,69,5,0.1333,0.1042,1,6,6,0,1,"/**
     * Loads and return s neural network instance from specified file
     *
     * @param file neural network file
     * @return neural network instance
     */
    public static NeuralNetwork createFromFile(File file) {
        ObjectInputStream oistream = null;

        try {
            if (!file.exists()) {
                throw new FileNotFoundException(""Cannot find file: "" + file);
            }

            oistream = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file)));
            NeuralNetwork nnet = (NeuralNetwork) oistream.readObject();
            return nnet;

        } catch (IOException ioe) {
            throw new NeurophException(""Could not read neural network file!"", ioe);
        } catch (ClassNotFoundException cnfe) {
            throw new NeurophException(""Class not found while trying to read neural network from file!"", cnfe);
        } finally {
            if (oistream != null) {
                try {
                    oistream.close();
                } catch (IOException ioe) {
                }
            }
        }
    }"
neuroph,org.neuroph.core.Neuron,hasOutputConnectionTo,,8,5,4,3,0.3333,0.0667,1,2,3,0,1,"public boolean hasOutputConnectionTo(Neuron neuron) {
        for (Connection connection : outConnections) {
            if (connection.getToNeuron() == neuron) {
                return true;
            }
        }
        return false;
    }"
neuroph,org.neuroph.core.Neuron,hasInputConnectionFrom,,8,5,4,3,0.3333,0.0667,1,2,3,0,1,"public boolean hasInputConnectionFrom(Neuron neuron) {
        for (Connection connection : inputConnections) {
            if (connection.getFromNeuron() == neuron) {
                return true;
            }
        }
        return false;
    }"
neuroph,org.neuroph.core.Neuron,addInputConnection,,21,11,1,3,0.3571,0.2333,0.5,3,4,0,1,"/**
     * Adds the specified input connection
     *
     * @param connection input connection to add
     */
    public void addInputConnection(Connection connection) {
        // check whether connection is  null
        if (connection == null) {
            throw new IllegalArgumentException(""Attempt to add null connection to neuron!"");
        }

        // make sure that connection instance is pointing to this neuron
        if (connection.getToNeuron() != this) {
            throw new IllegalArgumentException(""Cannot add input connection - bad toNeuron specified!"");
        }

        // if it already has connection from same neuron do nothing
        if (this.hasInputConnectionFrom(connection.getFromNeuron())) {
            return;
        }

        this.inputConnections.add(connection);

        Neuron fromNeuron = connection.getFromNeuron();
        fromNeuron.addOutputConnection(connection);
    }"
neuroph,org.neuroph.core.Neuron,addOutputConnection,,20,7,4,3,0.4,0.1667,0.5,2,4,0,1,"/**
     * Adds the specified output connection
     *
     * @param connection output connection to add
     */
    protected void addOutputConnection(Connection connection) {
        // First do some checks
        // check whether connection is  null
        if (connection == null) {
            throw new IllegalArgumentException(""Attempt to add null connection to neuron!"");
        }

        // make sure that connection instance is pointing to this neuron
        if (connection.getFromNeuron() != this) {
            throw new IllegalArgumentException(""Cannot add output connection - bad fromNeuron specified!"");
        }

        // if this neuron is already connected to neuron specified in connection do nothing
        if (this.hasOutputConnectionTo(connection.getToNeuron())) {
            return;
        }

        // Now we can safely add new connection
        this.outConnections.add(connection);
    }"
neuroph,org.neuroph.core.data.DataSet,addRow,,21,12,9,4,0.25,0.0833,0.666666667,7,6,0,1,"/**
     * Adds new row row to this data set
     *
     * @param row data set row to add
     */
    public boolean addRow(DataSetRow row)
            throws VectorSizeMismatchException {

        if (row == null) {
            throw new IllegalArgumentException(""Data set row cannot be null!"");
        }

        // check input vector size if it is predefined
        if ((this.inputSize != 0)
                && (row.getInput().length != this.inputSize)) {
            throw new VectorSizeMismatchException(""Input vector size does not match data set input size!"");
        }

        if ((this.outputSize != 0)
                && (row.getDesiredOutput().length != this.outputSize)) {
            throw new VectorSizeMismatchException(""Output vector size does not match data set output size!"");
        }

        // if everything was ok add training row
        return rows.add(row);
    }"
neuroph,org.neuroph.core.data.DataSet,toString,,20,47,16,3,0.2051,0.2554,0,3,4,0,1,"/**
     * Returns string representation of this data set
     *
     * @return string representation of this data set
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""Dataset Label: "").append(label).append(System.lineSeparator());

        if (columnNames != null) {
            sb.append(""Columns: "");
            for (String columnName : columnNames) {
                sb.append(columnName).append("", "");
            }
            sb.delete(sb.length() - 2, sb.length() - 1);
            sb.append(System.lineSeparator());
        }

        for (DataSetRow row : rows) {
            sb.append(row).append(System.lineSeparator());
        }

        return sb.toString();
    }"
neuroph,org.neuroph.core.data.DataSet,toCSV,,19,42,18,3,0.2333,0.2538,1,3,5,0,1,"/**
     * Returns enire dataset in csv format
     *
     * @return
     */
    public String toCSV() {
        StringBuilder sb = new StringBuilder();

        if ((columnNames != null) && (columnNames.length > 0)) {
            for (String columnName : columnNames) {
                sb.append(columnName).append("", "");
            }
            sb.delete(sb.length() - 2, sb.length() - 1);
            sb.append(System.lineSeparator());
        }

        // promeniti
        for (DataSetRow row : rows) {
            sb.append(row.toCSV()); // nije dobro jer lepi input i desired output; treba bez toga mozda dodati u toCSV
            sb.append(System.lineSeparator());
        }

        return sb.toString();
    }"
neuroph,org.neuroph.core.data.DataSet,createTrainingAndTestSubsets,,6,11,7,3,0.2667,0.1333,0.5,4,1,0,1,"// http://java.about.com/od/javautil/a/uniquerandomnum.htm

    /**
     * Returns training and test subsets in the specified percent ratio
     * @param trainSetPercent
     * @param testSetPercent
     * @return
     */
    public DataSet[] createTrainingAndTestSubsets(int trainSetPercent, int testSetPercent) {
        SubSampling sampling = new SubSampling(trainSetPercent, testSetPercent);
        DataSet[] trainAndTestSet =  new DataSet[2];
        sampling.sample(this).toArray(trainAndTestSet);
        return trainAndTestSet;
    }"
neuroph,org.neuroph.core.data.DataSetRow,toString,,20,48,18,4,0.2154,0.2933,0,3,4,0,1,"@Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        
        sb.append(""Input: "");
        for(double in : input) {
            sb.append(in).append("", "");
        }
        sb.delete(sb.length()-2, sb.length()-1);
        
        if (isSupervised()) {
            sb.append("" Desired output: "");
            for(double out : desiredOutput) {
                sb.append(out).append("", "");
            }           
            sb.delete(sb.length()-2, sb.length()-1);
        }
                       
        return sb.toString();        
    }"
neuroph,org.neuroph.core.data.DataSetRow,toCSV,,17,33,21,4,0.22,0.1667,0,3,4,0,1,"public String toCSV() {
        StringBuilder sb = new StringBuilder();
        
        for(double in : input) {
            sb.append(in).append("", "");
        }
        
        if (isSupervised()) {
            for(double out : desiredOutput) {
                sb.append(out).append("", "");
            }           
        }
        
        sb.delete(sb.length()-2, sb.length()-1);        
                       
        return sb.toString();        
    }"
neuroph,org.neuroph.core.data.DataSetRow,equals,,23,24,12,3,0.2222,0.1786,0,5,7,0,1,"@Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final DataSetRow other = (DataSetRow) obj;
        if (!Objects.equals(this.label, other.label)) {
            return false;
        }
        if (!Arrays.equals(this.input, other.input)) {
            return false;
        }
        if (!Arrays.equals(this.desiredOutput, other.desiredOutput)) {
            return false;
        }
        return true;
    }"
neuroph,org.neuroph.core.data.BufferedDataSet,countFileLines,,10,24,20,5,0.2,0.0933,0,2,3,0,1,"/**
     * Counts and returns number of lines in a file
     * @return number of lines in a file
     * @throws FileNotFoundException 
     */
    private long countFileLines() throws FileNotFoundException {
        LineNumberReader lnr = new LineNumberReader(new FileReader(file));
        try {
          //  lnr.skip(Long.MAX_VALUE);
           while(lnr.skip(Long.MAX_VALUE) > 0) {}; 
        } catch (IOException ex) {
            Logger.getLogger(BufferedDataSet.class.getName()).log(Level.SEVERE, null, ex);
        }
        return lnr.getLineNumber() + 1;
    }"
neuroph,org.neuroph.core.data.BufferedDataSet,loadNextBuffer,,60,540,485,7,0.0756,0.066,0.333333333,11,14,1,1,"/**
     * Loads next bufferSize rows from file into buffer
     */
    private void loadNextBuffer() {
        try {
            String line = """";
            this.clear();    // data set buffer

            rowsLoaded = 0;
            while (rowsLoaded < bufferSize) { // 

                line = bufferedReader.readLine();
                if (line == null) {
                    break;
                }

                rowsLoaded++;
                double[] inputs = new double[getInputSize()];
                double[] outputs = new double[getOutputSize()];
                String[] values = line.split(delimiter);

                if (values[0].equals("""")) {
                    continue; // skip if line was empty
                }
                for (int i = 0; i < getInputSize(); i++) {
                    inputs[i] = Double.parseDouble(values[i]);
                }

                for (int i = 0; i < getOutputSize(); i++) {
                    outputs[i] = Double.parseDouble(values[getInputSize() + i]);
                }

                if (getOutputSize() > 0) {
                    this.addRow(new DataSetRow(inputs, outputs));
                } else {
                    this.addRow(new DataSetRow(inputs));
                }
            }

            bufferedRows = this.getRows();
            bufferIterator = bufferedRows.iterator();

        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        } catch (IOException ex) {
            if (fileReader != null) {
                try {
                    fileReader.close();
                } catch (IOException ex1) {
                }
            }
            ex.printStackTrace();
        } catch (NumberFormatException ex) {
            if (fileReader != null) {
                try {
                    fileReader.close();
                } catch (IOException ex1) {
                }
            }
            ex.printStackTrace();
            throw ex;
        }
    }"
neuroph,org.neuroph.core.learning.IterativeLearning,learn,,38,223,215,15,0.0852,0.0313,0.333333333,6,8,0,1,"@Override
    final public void learn(DataSet trainingSet) {
        setTrainingSet(trainingSet); // set this field here su subclasses can access it 
        onStart();

        while (!isStopped()) {
            beforeEpoch();
            doLearningEpoch(trainingSet);
            this.currentIteration++;
            afterEpoch();

            // now check if stop condition is satisfied
            if (hasReachedStopCondition()) {
                stopLearning();
            } else if (!iterationsLimited && (currentIteration == Integer.MAX_VALUE)) {
                // if counter has reached max value and iteration number is not limited restart iteration counter
                this.currentIteration = 1;
            }

            // notify listeners that epoch has ended
            fireLearningEvent(new LearningEvent(this, LearningEvent.Type.EPOCH_ENDED));

            // Thread safe pause when learning is paused
            if (this.pausedLearning) {
                synchronized (this) {
                    while (this.pausedLearning) {
                        try {
                            this.wait();
                        } catch (Exception e) {
                        }
                    }
                }
            }

        }
        onStop();
        fireLearningEvent(new LearningEvent(this, LearningEvent.Type.LEARNING_STOPPED));
    }"
neuroph,org.neuroph.core.learning.IterativeLearning,hasReachedStopCondition,,9,5,4,3,0.375,0.1,1,1,3,0,1,"/**
     * Returns true if any of the stop conditions has been reached.
     * 
     * @return 
     */
    protected final boolean hasReachedStopCondition() {
        for (StopCondition stop : stopConditions) {
            if (stop.isReached()) {
                return true;
            }
        }

        return false;
    }"
neuroph,org.neuroph.core.learning.SupervisedLearning,afterEpoch,,15,19,17,5,0.1837,0.06,1,2,3,0,1,"@Override
    protected void afterEpoch() {
        // calculate abs error change and count iterations if its below specified min error change (used for stop condition)
        double absErrorChange = Math.abs(previousEpochError - errorFunction.getTotalError());
        if (absErrorChange <= this.minErrorChange) {
            minErrorChangeIterationsCount++;
        } else {
            minErrorChangeIterationsCount = 0;
        }

        // if learning is performed in batch mode, apply accumulated weight changes from this epoch        
        if (batchMode == true) {
            doBatchWeightsUpdate();
        }
    }"
neuroph,org.neuroph.core.learning.SupervisedLearning,doLearningEpoch,,8,11,7,3,0.3333,0.131,1,3,3,0,1,"/**
     * This method implements basic logic for one learning epoch for the
     * supervised learning algorithms. Epoch is the one pass through the
     * training set. This method  iterates through the training set
     * and trains network for each element. It also sets flag if conditions
     * to stop learning has been reached: network error below some allowed
     * value, or maximum iteration count
     *
     * @param trainingSet training set for training network
     */
    @Override
    public void doLearningEpoch(DataSet trainingSet) {        
        Iterator<DataSetRow> iterator = trainingSet.iterator();
        while (iterator.hasNext() && !isStopped()) { // iterate all elements from training set - maybe remove isStopped from here
            DataSetRow dataSetRow = iterator.next();
            learnPattern(dataSetRow);             // learn current input/output pattern defined by SupervisedTrainingElement
        }
    }"
neuroph,org.neuroph.core.learning.SupervisedLearning,learnPattern,,10,15,9,3,0.2619,0.0944,0.5,3,2,0,1,"/**
     * Trains network with the input and desired output pattern from the specified training element
     *
     * @param trainingElement supervised training element which contains input and desired output
     */
    protected void learnPattern(DataSetRow trainingElement) {
        neuralNetwork.setInput(trainingElement.getInput());
        neuralNetwork.calculate();
        double[] output = neuralNetwork.getOutput();
        double[] patternError = errorFunction.addPatternError(output, trainingElement.getDesiredOutput());
        calculateWeightChanges(patternError);
        
        if (!batchMode) applyWeightChanges(); // batch mode updates are done i doBatchWeightsUpdate
        
    }"
neuroph,org.neuroph.core.learning.SupervisedLearning,doBatchWeightsUpdate,,16,20,12,2,0.2708,0.122,0.857142857,5,4,0,1,"/**
     * This method updates network weights in batch mode - use accumulated weights change stored in Weight.deltaWeight
     * It is executed after each learning epoch, only if learning is done in batch mode.
     *
     * @see SupervisedLearning#doLearningEpoch(org.neuroph.core.data.DataSet)
     */
    protected void doBatchWeightsUpdate() {
        // iterate layers from output to input
        List<Layer> layers = neuralNetwork.getLayers();
        for (int i = neuralNetwork.getLayersCount() - 1; i > 0; i--) {
            // iterate neurons at each layer
            for (Neuron neuron : layers.get(i).getNeurons()) {
                // iterate connections/weights for each neuron
                for (Connection connection : neuron.getInputConnections()) {
                    // for each connection weight apply accumulated weight change
                    Weight weight = connection.getWeight();
                    weight.value += weight.weightChange / getTrainingSet().size(); // apply delta weight which is the sum of delta weights in batch mode    - TODO: add mini batch
                    weight.weightChange = 0; // reset deltaWeight
                }
            }
        }
    }"
neuroph,org.neuroph.core.learning.SupervisedLearning,applyWeightChanges,,20,44,33,4,0.2121,0.1138,0.857142857,5,5,0,1,"private void applyWeightChanges() {
        List<Layer> layers = neuralNetwork.getLayers();
        for (int i = neuralNetwork.getLayersCount() - 1; i > 0; i--) {
            // iterate neurons at each layer
            for (Neuron neuron : layers.get(i).getNeurons()) {
                // iterate connections/weights for each neuron
                for (Connection connection : neuron.getInputConnections()) {
                    // for each connection weight apply accumulated weight change
                    Weight weight = connection.getWeight();
                    if (!isBatchMode()) {
                        weight.value += weight.weightChange;
                    } else {
                        weight.value += (weight.weightChange / getTrainingSet().size());
                    }
                    
                    weight.weightChange = 0; // reset deltaWeight
                }
            }
        }
    }"
neuroph,org.neuroph.core.learning.UnsupervisedLearning,doLearningEpoch,,8,11,7,3,0.3333,0.131,1,3,3,0,1,"/**
	 * This method does one learning epoch for the unsupervised learning rules.
	 * It iterates through the training set and trains network weights for each
	 * element
	 * 
	 * @param trainingSet
	 *            training set for training network
	 */
         @Override
	public void doLearningEpoch(DataSet trainingSet) {
		Iterator<DataSetRow> iterator = trainingSet.iterator();
		while (iterator.hasNext() && !isStopped()) {
			DataSetRow trainingSetRow = iterator.next();
			learnPattern(trainingSetRow);
		}
	}"
neuroph,org.neuroph.core.learning.UnsupervisedLearning,learnPattern,,6,11,7,3,0.3333,0.125,0.666666667,4,1,0,1,"/**
	 * Trains network with the pattern from the specified training element
	 * 
	 * @param DataSetItem
	 *            unsupervised training element which contains network input
	 */
	protected void learnPattern(DataSetRow trainingElement) {
		double[] input = trainingElement.getInput();
		this.neuralNetwork.setInput(input);
		this.neuralNetwork.calculate();
		this.updateNetworkWeights();
	}"
neuroph,org.neuroph.core.learning.error.MeanSquaredError,addPatternError,,13,13,5,3,0.2857,0.1579,0,4,2,0,1,"@Override
    public double[] addPatternError(double[] predictedOutput, double[] targetOutput) {
        double[] patternError = new double[targetOutput.length];

        for (int i = 0; i < predictedOutput.length; i++) {
            patternError[i] =  predictedOutput[i] - targetOutput[i];
            totalError += patternError[i] * patternError[i];
        }
        
        patternCount++;
        return patternError;
        
    }"
neuroph,org.neuroph.core.learning.stop.MaxErrorStop,isReached,,8,3,3,3,0.3333,0,0.5,0,2,0,1,"@Override
    public boolean isReached() {
        if (learningRule.getTotalNetworkError() < learningRule.getMaxError()) {
            return true;
        }
        
        return false;
    }"
neuroph,org.neuroph.core.learning.stop.SmallErrorChangeStop,isReached,,8,3,3,3,0.3333,0,0.5,0,2,0,1,"@Override
    public boolean isReached() {
        if (learningRule.getMinErrorChangeIterationsCount() >= learningRule.getMinErrorChangeIterationsLimit()) {
            return true;
        }

        return false;
    }"
neuroph,org.neuroph.core.transfer.Linear,Linear,,9,14,13,5,0.2222,0.0833,1,4,3,0,1,"/**
	 * Creates an instance of Linear transfer function with specified properties
	 */		
	public Linear(Properties properties) {
		try {
			this.slope = (Double)properties.getProperty(""transferFunction.slope"");
		} catch (NullPointerException e) {
			// if properties are not set just leave default values
		} catch (NumberFormatException e) {
			System.err.println(""Invalid transfer function properties! Using default values."");
		}
	}"
neuroph,org.neuroph.core.transfer.Trapezoid,Trapezoid,,12,29,22,5,0.1852,0.0909,1,7,3,0,1,"/**
	 * Creates an instance of Trapezoid transfer function with the specified
	 * properties.
	 */		
	public Trapezoid(Properties properties) {
		try {
			this.leftLow = (Double)properties.getProperty(""transferFunction.leftLow"");
			this.leftHigh = (Double)properties.getProperty(""transferFunction.leftHigh"");
			this.rightLow = (Double)properties.getProperty(""transferFunction.rightLow"");
			this.rightHigh = (Double)properties.getProperty(""transferFunction.rightHigh"");
		} catch (NullPointerException e) {
			// if properties are not set just leave default values
		} catch (NumberFormatException e) {
			System.err.println(""Invalid transfer function properties! Using default values."");
		}
	}"
neuroph,org.neuroph.core.transfer.Step,Step,,10,19,17,5,0.2143,0.0741,1,5,3,0,1,"/**
	 * Creates an instance of Step transfer function with specified properties
	 */	
	public Step(Properties properties) {
		try {
			this.yHigh = (Double)properties.getProperty(""transferFunction.yHigh"");
			this.yLow = (Double)properties.getProperty(""transferFunction.yLow"");
		} catch (NullPointerException e) {
			// if properties are not set just leave default values
		} catch (NumberFormatException e) {
			System.err.println(""Invalid transfer function properties! Using default values."");
		}
	}"
neuroph,org.neuroph.core.transfer.Sigmoid,Sigmoid,,9,14,13,5,0.2222,0.0833,1,4,3,0,1,"/**
	 * Creates an instance of Sigmoid neuron transfer function with the
	 * specified properties.
	 * @param properties properties of the sigmoid function
	 */	
	public Sigmoid(Properties properties) {
		try {
			this.slope = (Double)properties.getProperty(""transferFunction.slope"");
		} catch (NullPointerException e) {
			// if properties are not set just leave default values
		} catch (NumberFormatException e) {
			System.err.println(""Invalid transfer function properties! Using default values."");
		}
	}"
neuroph,org.neuroph.core.transfer.Ramp,Ramp,,13,34,23,5,0.1714,0.1032,1,8,3,0,1,"/**
	 * Creates an instance of Ramp transfer function with specified properties.
	 */		
	public Ramp(Properties properties) {
		try {
			this.slope = (Double)properties.getProperty(""transferFunction.slope"");
			this.yHigh = (Double)properties.getProperty(""transferFunction.yHigh"");
			this.yLow = (Double)properties.getProperty(""transferFunction.yLow"");
			this.xHigh = (Double)properties.getProperty(""transferFunction.xHigh"");
			this.xLow = (Double)properties.getProperty(""transferFunction.xLow"");
		} catch (NullPointerException e) {
			// if properties are not set just leave default values
		} catch (NumberFormatException e) {
			System.err.println(""Invalid transfer function properties! Using default values."");
		}
	}"
neuroph,org.neuroph.core.transfer.Tanh,Tanh,,10,20,19,6,0.1905,0.0667,1,4,3,0,1,"/**
     * Creates an instance of Tanh neuron transfer function with the
     * specified properties.
     *
     * @param properties properties of the Tanh function
     */
    public Tanh(Properties properties) {
        try {
            this.slope = (Double) properties.getProperty(""transferFunction.slope"");
            //this.amplitude = (Double) properties.getProperty(""transferFunction.amplitude"");
        } catch (NullPointerException e) {
            // if properties are not set just leave default values
        } catch (NumberFormatException e) {
            System.err.println(""Invalid transfer function properties! Using default values."");
        }
    }"
neuroph,org.neuroph.core.transfer.Gaussian,Gaussian,,9,14,13,5,0.2222,0.0833,1,4,3,0,1,"/**
	 * Creates an instance of Gaussian neuron transfer function with the
	 * specified properties.
	 * @param properties properties of the Gaussian function
	 */	
	public Gaussian(Properties properties) {
		try {
			this.sigma = (Double)properties.getProperty(""transferFunction.sigma"");
		} catch (NullPointerException e) {
			// if properties are not set just leave default values
		} catch (NumberFormatException e) {
			System.err.println(""Invalid transfer function properties! Using default values."");
		}
	}"
neuroph,org.neuroph.eval.CrossValidationResult,printResult,,13,40,25,6,0.2424,0.2885,0,0,1,0,1,"public void printResult() {
        System.out.println(""=== Cross validation result ==="");
        System.out.println(""Instances: "" + numberOfInstances);
        System.out.println(""Number of folds: "" + numberOfFolds);
        System.out.println(""\n"");
        System.out.println(""=== Summary ==="");
        System.out.println(""Mean squared error: "" + average.mserror);
        System.out.println(""Accuracy: "" + average.accuracy);
        System.out.println(""Precision: "" + average.precision);
        System.out.println(""Recall: "" +average.recall);
        System.out.println(""FScore: "" + average.fScore);
        System.out.println(""Correlation coefficient: "" + average.correlationCoefficient);        
    }"
neuroph,org.neuroph.eval.Evaluation,evaluateDataSet,,33,124,95,2,0.15,0.0937,0.466666667,8,5,1,1,"/**
     * Runs evaluation procedure for given neural network and data set through all evaluatoors
     * Evaluation results are stored in evaluators
     * 
     * @param neuralNetwork trained neural network
     * @param dataSet       test data set used for evaluation
     * @return 
     */
    public EvaluationResult evaluateDataSet(NeuralNetwork neuralNetwork, DataSet dataSet) {
        // first reset all evaluators
        for (Evaluator evaluator : evaluators.values()) { // for now we have only classification metrics and mse
                evaluator.reset();
        }        
        
        for (DataSetRow dataRow : dataSet.getRows()) {      // iterate all dataset rows
             neuralNetwork.setInput(dataRow.getInput());    // apply input to neural network
             neuralNetwork.calculate();                     // and calculate neural network    
            
            // feed actual neural network output and desired output to all evaluators
            for (Evaluator evaluator : evaluators.values()) { // for now we have only kfold and mse
                evaluator.processNetworkResult(neuralNetwork.getOutput(), dataRow.getDesiredOutput());
            }
        }
        
        // we should iterate all evaluators and get results here- its hardcoded for now
        ConfusionMatrix confusionMatrix;
        if (neuralNetwork.getOutputsCount() >1) {        
            confusionMatrix = getEvaluator(ClassifierEvaluator.MultiClass.class).getResult();
        } else {
            confusionMatrix = getEvaluator(ClassifierEvaluator.Binary.class).getResult();
        }
        
        double meanSquaredError = getEvaluator(ErrorEvaluator.class).getResult();
                   
        EvaluationResult result = new EvaluationResult();
        result.setDataSet(dataSet); // sta ce nam ovo?
        result.setConfusionMatrix(confusionMatrix);
        result.setMeanSquareError(meanSquaredError);
        
        return result;                
    }"
neuroph,org.neuroph.eval.Evaluation,runFullEvaluation,,27,28,1,2,0.2338,0.2521,0.857142857,7,2,0,1,"/**
     * Out of the box method (util) which computes all metrics for given neural network and test data set
     * 
     * @param neuralNet neural network to evaluate
     * @param dataSet data set to evaluate
     */
    public static void runFullEvaluation(NeuralNetwork<?> neuralNet, DataSet dataSet) {

        Evaluation evaluation = new Evaluation();
        // take onlu output column names here
        evaluation.addEvaluator(new ClassifierEvaluator.MultiClass(dataSet.getColumnNames())); // these two should be added by default

        evaluation.evaluateDataSet(neuralNet, dataSet);
       // use logger here  - see how to make it print out
        // http://saltnlight5.blogspot.com/2013/08/how-to-configure-slf4j-with-different.html
        LOGGER.info(""##############################################################################"");
//        LOGGER.info(""Errors: "");
        LOGGER.info(""MeanSquare Error: "" + evaluation.getEvaluator(ErrorEvaluator.class).getResult());
        LOGGER.info(""##############################################################################"");
        ClassifierEvaluator classificationEvaluator = evaluation.getEvaluator(ClassifierEvaluator.MultiClass.class);
        ConfusionMatrix confusionMatrix = classificationEvaluator.getResult();        
        
        LOGGER.info(""Confusion Matrix: \r\n""+confusionMatrix.toString());
              
        
        LOGGER.info(""##############################################################################"");
        LOGGER.info(""Classification metrics: "");        
        ClassificationMetrics[] metrics = ClassificationMetrics.createFromMatrix(confusionMatrix);      
        for(ClassificationMetrics cm : metrics)
            LOGGER.info(cm.toString());

        LOGGER.info(""##############################################################################"");
    }"
neuroph,org.neuroph.eval.EvaluationResult,toString,,11,10,5,2,0.2778,0.1189,1,3,2,0,1,"@Override
    public String toString() {
        //-- also display getClassificationMetricses here
          ClassificationMetrics[] cms = getClassificationMetricses();
          StringBuilder sb = new StringBuilder();
          for(ClassificationMetrics c : cms ) {
              sb.append(c).append(""\r\n"");
          }
          
        return ""EvaluationResult{"" + ""dataSet="" + dataSet.getLabel() + "", meanSquareError="" + meanSquareError + "", \r\n confusionMatrix=\r\n"" + confusionMatrix +""\r\n"" +sb.toString() +""}\r\n"";
    }"
neuroph,org.neuroph.eval.classification.ClassificationMetrics,toString,,22,198,45,10,0.0895,0.3271,0,1,1,1,1,"@Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        
        sb.append(""Class: ""+classLabel).append(""\n"");
        sb.append(""Total items: "").append(getTotal()).append(""\n"");        
        sb.append(""True positive:"").append(truePositive).append(""\n"");
        sb.append(""True negative:"").append(trueNegative).append(""\n"");
        sb.append(""False positive:"").append(falsePositive).append(""\n"");   
        sb.append(""False negative:"").append(falseNegative).append(""\n"");        
        sb.append(""Accuracy (ACC): "").append(getAccuracy()).append(""\n"");        
        sb.append(""Sensitivity or true positive rate (TPR): "").append(getSensitivity()).append(""\n"");
        sb.append(""Specificity (SPC) or true negative rate (TNR): "").append(getSpecificity()).append(""\n"");
        sb.append(""Fall-out or false positive rate (FPR): "").append(getFalsePositiveRate()).append(""\n"");
        sb.append(""False negative rate (FNR): "").append(getFalseNegativeRate()).append(""\n"");        
        sb.append(""Precision or positive predictive value (PPV): "").append(getPrecision()).append(""\n"");
        sb.append(""Recall: "").append(getSensitivity()).append(""\n"");        
        sb.append(""F-measure: "").append(getFMeasure()).append(""\n"");        
        sb.append(""False discovery rate (FDR): "").append(getFalseDiscoveryRate()).append(""\n"");
        sb.append(""Matthews correlation Coefficient (MCC): "").append(getMatthewsCorrelationCoefficient()).append(""\n"");
        return sb.toString();
    }"
neuroph,org.neuroph.eval.classification.ClassificationMetrics,createFromMatrix,,37,131,52,1,0.1397,0.1244,0.142857143,15,3,0,1,"public static ClassificationMetrics[] createFromMatrix(ConfusionMatrix confusionMatrix) {
        // Create Classification measure for each class 
        // Ovde rezdvojiti binary i multi
        
        int classCount = confusionMatrix.getClassCount();
        if (classCount == 2) { // binary classification
            ClassificationMetrics[] measures = new ClassificationMetrics[1]; 
            String[] classLabels = confusionMatrix.getClassLabels();
            
                int tp = confusionMatrix.get(0, 0);
                int tn = confusionMatrix.get(1, 1);
                int fp = confusionMatrix.get(1, 0); // FalsePositive
                int fn = confusionMatrix.get(0, 1); // FalseNegative
            
            measures[0] = new ClassificationMetrics(tp, tn, fp, fn);         
            measures[0].setClassLabel(classLabels[0]);           
            
            return measures;
            
        } else { // multiclass classification        
            ClassificationMetrics[] measures = new ClassificationMetrics[classCount];
            String[] classLabels = confusionMatrix.getClassLabels();

            for(int clsIdx=0; clsIdx<confusionMatrix.getClassCount(); clsIdx++) { // for each class
                // ove metode mozda ubaciti u matricu Confusion matrix - najbolje tako
                int tp = confusionMatrix.getTruePositive(clsIdx);
                int tn = confusionMatrix.getTrueNegative(clsIdx);
                int fp = confusionMatrix.getFalsePositive(clsIdx);
                int fn = confusionMatrix.getFalseNegative(clsIdx);                                   

                measures[clsIdx] = new ClassificationMetrics(tp, tn, fp, fn);         
                measures[clsIdx].setClassLabel(classLabels[clsIdx]);           
            }        
            return measures;
        }         
        
    }"
neuroph,org.neuroph.eval.classification.Classifier,classify,,20,46,26,3,0.2361,0.1372,0.5,5,4,0,1,"public String classify(double[] pattern) {
        NeuralNetwork<?> nnet = getParentNetwork();
        nnet.setInput(pattern);
        nnet.calculate();
        
        Neuron maxNeuron = null;
        double maxOutput = Double.MIN_VALUE;
        
        for (Neuron neuron : nnet.getOutputNeurons()) {
            if (neuron.getOutput() > maxOutput) {
                maxOutput = neuron.getOutput();
                maxNeuron = neuron;
            }
        }
        
        if (maxOutput > threshold)
                return maxNeuron.getLabel();
        else
            return null;
    }"
neuroph,org.neuroph.eval.classification.ClassificationResult,equals,,11,4,2,2,0.4167,0.1389,0,2,4,0,1,"@Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (obj == this)
            return true;
        if (!(obj instanceof ClassificationResult))
            return false;
        ClassificationResult that = (ClassificationResult) obj;
        return this.getClassIdx() == that.getClassIdx();
    }"
neuroph,org.neuroph.eval.classification.Utils,average,,7,10,5,3,0.3889,0.1429,0,3,2,0,1,"public static double average(double[] array) {
        double accumulator = 0;
        for (double element : array) {
            accumulator += element;
        }
        return accumulator / array.length;
    }"
neuroph,org.neuroph.eval.classification.Utils,maxIdx,,8,11,7,3,0.3889,0.1667,0,3,3,0,1,"public static int maxIdx(double[] array) {
        int maxIdx=0;
        for (int i=1;  i< array.length; i++) {
            if (array[i] > array[maxIdx])
                   maxIdx = i;
        }
        return maxIdx;
    }"
neuroph,org.neuroph.eval.classification.ConfusionMatrix,toString,,23,51,11,3,0.2013,0.1823,0,7,5,1,1,"@Override
    public String toString() {
        StringBuilder builder = new StringBuilder();

        int maxColumnLenght = STRING_DEFAULT_WIDTH;
        for (String label : classLabels)
            maxColumnLenght = Math.max(maxColumnLenght, label.length());

        builder.append(String.format(""%1$"" + maxColumnLenght + ""s"", """"));
        for (String label : classLabels)
            builder.append(String.format(""%1$"" + maxColumnLenght + ""s"", label));
        builder.append(""\n"");

        for (int i = 0; i < values.length; i++) {
            builder.append(String.format(""%1$"" + maxColumnLenght + ""s"", classLabels[i]));
            for (int j = 0; j < values[0].length; j++) {
                builder.append(String.format(""%1$"" + maxColumnLenght + ""s"", values[i][j]));
            }
            builder.append(""\n"");

        }
        return builder.toString();
    }"
neuroph,org.neuroph.eval.classification.McNemarTest,evaluateNetworks,,46,260,220,7,0.1067,0.064,0.833333333,12,5,1,1,"/**
     * @param network1 first trained neurl netowrk
     * @param network2 second trained neural network
     * @param dataSet  data set used for performance evaluation
     * @return if there exists significant difference between two classification models
     */
    public boolean evaluateNetworks(NeuralNetwork network1, NeuralNetwork network2, DataSet dataSet) {
        for (DataSetRow dataRow : dataSet.getRows()) {
            forwardPass(network1, dataRow);
            forwardPass(network2, dataRow);
           
            double[] networkOutput1 = network1.getOutput();
            double[] networkOutput2 = network2.getOutput();
            
            int maxNeuronIdx1 = Utils.maxIdx(networkOutput1);
            int maxNeuronIdx2 = Utils.maxIdx(networkOutput2);         
            
            ClassificationResult output1 = new ClassificationResult(maxNeuronIdx1, networkOutput1[maxNeuronIdx1]);
            ClassificationResult output2 = new ClassificationResult(maxNeuronIdx2, networkOutput2[maxNeuronIdx2]);     

//            ClassificationResult output1 = ClassificationResult.fromMaxOutput(network1.getOutput());
//            ClassificationResult output2 = ClassificationResult.fromMaxOutput(network2.getOutput());

            //are their results different
            if (output1.getClassIdx() != output2.getClassIdx()) {
                //if first one is correct and second incorrect
                if (output1.getClassIdx() == getDesiredClass(dataRow.getDesiredOutput())) {
                    contigencyMatrix[1][0]++;
                    //if first is incorrect and second is correct
                } else {
                    contigencyMatrix[0][1]++;
                }
            } else {
                //if both are correct
                if (output1.getClassIdx() == getDesiredClass(dataRow.getDesiredOutput())) {
                    contigencyMatrix[1][1]++;
                    //if both are incorrect
                } else {
                    contigencyMatrix[0][0]++;
                }
            }
        }

        printContingencyMatrix();

        double a = Math.abs(contigencyMatrix[0][1] - contigencyMatrix[1][0]) - 1;
        double hiSquare = (a * a) / (contigencyMatrix[0][1] + contigencyMatrix[1][0]);


        System.out.println(hiSquare);
        return hiSquare > 3.841;
    }"
neuroph,org.neuroph.eval.classification.McNemarTest,printContingencyMatrix,,8,14,13,5,0.2222,0.0417,0,2,3,0,1,"private void printContingencyMatrix() {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                System.out.print(contigencyMatrix[i][j] + "" "");
            }
            System.out.println();
        }
    }"
neuroph,org.neuroph.imgrec.ImageFilesIterator,ImageFilesIterator,,23,125,114,11,0.1176,0.041,0,7,4,0,1,"/**
     * Creates image files iterator for the specified directory
     *
     * @param dir Directory to iterate images from
     * @throws java.io.IOException
     */
    public ImageFilesIterator(File dir) throws IOException {
        if (!dir.isDirectory()) {
            throw new IllegalArgumentException(dir + "" is not a directory!"");
        }

        String[] imageFilenames = dir.list(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                if (name.length() > 4) {
                    String fileExtension = name.substring(name.length() - 4, name.length());
                    return "".jpg"".equalsIgnoreCase(fileExtension)
                            || "".png"".equalsIgnoreCase(fileExtension);
                }
                return false;
            }
        });

        List<File> imageFiles = new ArrayList<File>();
        for (String imageFile : imageFilenames) {
            imageFiles.add(new File(dir, imageFile));
        }

        imageIterator = imageFiles.iterator();
    }"
neuroph,org.neuroph.imgrec.FractionHSLData,FractionHSLData,,25,110,67,3,0.1667,0.0942,1,1,2,0,1,"public FractionHSLData(BufferedImage img) {
	
		
	if(img!=null){
		width = img.getWidth();
		height = img.getHeight();
			
		hueValues = new double[height][width];
		saturationValues = new double[height][width];
		lightnessValues = new double[height][width];
		flattenedHSLValues = new double[width * height * 3];
                flattenedHueValues = new double[width * height];
			
		populateHSLArrays(new ImageJ2SE(img));  
	}
	else{//no input image specified so default all values
		width=0;
		height=0;
		hueValues = null;
		saturationValues = null;
		lightnessValues = null;
		flattenedHSLValues = null;
                flattenedHueValues = null;
	}
    }"
neuroph,org.neuroph.imgrec.FractionHSLData,populateHSLArrays,,56,386,211,2,0.1164,0.0819,1,15,8,1,1,"/**
	 * Fills the HSL matrices from image
	 * @param img image to get rgb data from
	 * 
	 */
	
    /**
     * Fills the HSL matrices from image - this is where conversion from RGB to HSL is done
     * @param image image to use    
     */
    protected void populateHSLArrays(Image image) {
            
            double red;
            double green;
            double blue;
            
            double Cmax;
            double Cmin;
            
            double delta;
            
            for (int j = 0; j < width; j++) {
                for (int i = 0; i < height; i++) {
                    
                    Color color= new Color(image.getPixel(j, i)); // it was getRGB
                    
                    red = color.getRed();
                    green = color.getGreen();
                    blue = color.getBlue();
                    
                    red = red/255;
                    green = green/255;
                    blue = blue/255;
                    
                    Cmax = Math.max(red, Math.max(green, blue));
                    Cmin = Math.min(red, Math.min(green, blue));
                    
                    delta = Cmax-Cmin;
                    
                    double hue = 0;
                    if (delta != 0) {
                        if (Cmax == red) 
                            hue = 60*(((green - blue)/delta)%6);                       
                        if (Cmax == green)
                            hue = 60*(((blue-red)/delta)+2);
                        if (Cmax == blue)
                            hue = 60*((red-green)/delta + 4);
                    } else {
                        double a = (2*red-green-blue)/2;
                        double b = (green-blue)*Math.sqrt(3)/2;
                        hue = Math.atan2(b, a);
                    }                      
                    hueValues[i][j] = hue/360; //podeli sa 360 da vrednot bude izmedju 0-1
                    
                    double lightness = (Cmax + Cmin)/2;
                    lightnessValues[i][j] = lightness;
                    
                    double saturation = 0;
                    if (delta == 0)
                        saturation = 0;
                    else
                        saturation = delta/(1-Math.abs(2*lightness-1));                   
                    saturationValues[i][j] = saturation;
                }
            }
        }"
neuroph,org.neuroph.imgrec.FractionHSLData,fillFlattenedHueValues,,9,6,2,2,0.3333,0.0867,0,3,3,0,1,"public void fillFlattenedHueValues () {
            
            int position = 0;
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < height; j++) {
                    flattenedHueValues[position++] = hueValues[i][j];
             }
        }
    }"
neuroph,org.neuroph.imgrec.FractionHSLData,fillFlattenedHSLValues,,19,37,19,1,0.1818,0.0888,0,5,3,0,1,"public void fillFlattenedHSLValues(){
            
        int positionHue = 0;
        int positionSaturation = 1;
        int positionLighteness = 2;
            
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                flattenedHSLValues[positionHue] = hueValues[i][j];
                flattenedHSLValues[positionSaturation] = saturationValues[i][j];
                flattenedHSLValues[positionLighteness] = lightnessValues[i][j];
                positionHue = positionHue + 3;
                positionSaturation = positionSaturation + 3;
                positionLighteness = positionLighteness + 3;
            }
        }
            
            
    }"
neuroph,org.neuroph.imgrec.ImageRecognitionHelper,createNewNeuralNetwork,,27,87,54,2,0.151,0.0996,0.625,10,3,0,1,"/**
         * Creates and returns new neural network for image recognition.
	 * Assumes that all of the FractionRgbData objects in the given map have identical 
	 * length arrays in them so that the input layer of the neural network can be 
	 * created here.
	 *
         * @param label neural network label
         * @param samplingResolution sampling resolution (image size)
	 * @param imageLabels image labels
         * @param layersNeuronsCount neuron counts in hidden layers
	 * @param transferFunctionType type of transfer function to use for neurons in network
         * @param colorMode color mode
     * @return 
	 */
	public static NeuralNetwork createNewNeuralNetwork(String label, Dimension samplingResolution, ColorMode colorMode, List<String> imageLabels,  List<Integer> layersNeuronsCount, TransferFunctionType transferFunctionType) {

                int numberOfInputNeurons;
                if ((colorMode == ColorMode.COLOR_RGB) || (colorMode == ColorMode.COLOR_HSL) ){ // for full color rgb or hsl
                    numberOfInputNeurons = 3 * samplingResolution.getWidth() * samplingResolution.getHeight();
                } else { // for black n white network
                    numberOfInputNeurons = samplingResolution.getWidth() * samplingResolution.getHeight();
                }

                int numberOfOuputNeurons = imageLabels.size();

		layersNeuronsCount.add(0, numberOfInputNeurons);
		layersNeuronsCount.add(numberOfOuputNeurons);
		
		System.out.println(""Neuron layer size counts vector = "" + layersNeuronsCount);
		
		NeuralNetwork neuralNetwork = new MultiLayerPerceptron(layersNeuronsCount, transferFunctionType);

		neuralNetwork.setLabel(label);
		PluginBase imageRecognitionPlugin = new ImageRecognitionPlugin(samplingResolution, colorMode);
		neuralNetwork.addPlugin(imageRecognitionPlugin);

		assignLabelsToOutputNeurons(neuralNetwork, imageLabels);
                neuralNetwork.setLearningRule(new MomentumBackpropagation());

            return neuralNetwork;
	}"
neuroph,org.neuroph.imgrec.ImageRecognitionHelper,assignLabelsToOutputNeurons,,9,14,7,3,0.2857,0.11,1,6,2,0,1,"/**
         * Assign labels to output neurons
         * @param neuralNetwork neural network
         * @param imageLabels image labels
         */
	private static void assignLabelsToOutputNeurons(NeuralNetwork neuralNetwork, List<String> imageLabels) {
		List<Neuron> outputNeurons = neuralNetwork.getOutputNeurons();
		
		for(int i=0; i<outputNeurons.size(); i++) {
			Neuron neuron = outputNeurons.get(i);
			String label = imageLabels.get(i);
			neuron.setLabel(label);
		}
	}"
neuroph,org.neuroph.imgrec.ImageRecognitionHelper,createRGBTrainingSet,,19,52,26,3,0.1795,0.0889,0.428571429,11,3,0,1,"/**
         * Creates training set for the specified image labels and rgb data
         * @param imageLabels image labels
         * @param rgbDataMap map collection of rgb data
         * @return training set for the specified image data
         */
	public static DataSet createRGBTrainingSet(List<String> imageLabels, Map<String, FractionRgbData> rgbDataMap) 	{	
                int inputCount = rgbDataMap.values().iterator().next().getFlattenedRgbValues().length;
                int outputCount = imageLabels.size();
		DataSet trainingSet = new DataSet(inputCount, outputCount);

		for (Entry<String, FractionRgbData> entry : rgbDataMap.entrySet()) {
			double[] input = entry.getValue().getFlattenedRgbValues();
			double[] response = createResponse(entry.getKey(), imageLabels);
			trainingSet.addRow(new DataSetRow(input, response));
		}
                
                // set labels for output columns
                int inputSize = trainingSet.getInputSize();
                for (int c= 0; c<trainingSet.getOutputSize() ; c++) {
                    trainingSet.setColumnName(inputSize+c, imageLabels.get(c));
                }

                return trainingSet;
	}"
neuroph,org.neuroph.imgrec.ImageRecognitionHelper,createHSLTrainingSet,,20,52,26,3,0.1795,0.0889,0.428571429,11,3,0,1,"/**
         * Creates training set for the specified image labels and hsl data
         * @param imageLabels image labels
         * @param hslDataMap map colletction of hsl data
         * @return training set for the specified image data
         */        
        public static DataSet createHSLTrainingSet(List<String> imageLabels, Map<String, FractionHSLData> hslDataMap) 	{	
                int inputCount = hslDataMap.values().iterator().next().getFlattenedHSLValues().length;
                int outputCount = imageLabels.size();
		DataSet trainingSet = new DataSet(inputCount, outputCount);

		for (Entry<String, FractionHSLData> entry : hslDataMap.entrySet()) {
			double[] input = entry.getValue().getFlattenedHSLValues();
			double[] response = createResponse(entry.getKey(), imageLabels);
			trainingSet.addRow(new DataSetRow(input, response));
		}

                // set labels for output columns
                int inputSize = trainingSet.getInputSize();
                for (int c= 0; c<trainingSet.getOutputSize() ; c++) {
                    trainingSet.setColumnName(inputSize+c, imageLabels.get(c));
                }
                
                
                return trainingSet;
	}"
neuroph,org.neuroph.imgrec.ImageRecognitionHelper,createBlackAndWhiteTrainingSet,,22,51,24,2,0.1703,0.0905,0.375,12,3,0,1,"/**
         * Creates binary black and white training set for the specified image labels and rgb data
         * white = 0 black = 1
         * @param imageLabels image labels
         * @param rgbDataMap map collection of rgb data
         * @return binary black and white training set for the specified image data
         */
        public static DataSet createBlackAndWhiteTrainingSet(List<String> imageLabels, Map<String, FractionRgbData> rgbDataMap) throws VectorSizeMismatchException
	{
            // TODO: Use some binarization image filter to do this; currently it works  with averaging RGB values
                int inputCount = rgbDataMap.values().iterator().next().getFlattenedRgbValues().length / 3;
                int outputCount = imageLabels.size();
		DataSet trainingSet = new DataSet(inputCount, outputCount);

		for (Entry<String, FractionRgbData> entry : rgbDataMap.entrySet()) {
			double[] inputRGB = entry.getValue().getFlattenedRgbValues();
                        double[] inputBW = FractionRgbData.convertRgbInputToBinaryBlackAndWhite(inputRGB);
                        double[] response = createResponse(entry.getKey(), imageLabels);
			trainingSet.addRow(new DataSetRow(inputBW, response));
		}
                
                // set labels for output columns
                int inputSize = trainingSet.getInputSize();
                for (int c= 0; c<trainingSet.getOutputSize() ; c++) {
                    trainingSet.setColumnName(inputSize+c, imageLabels.get(c));
                }
              
            return trainingSet;
	}"
neuroph,org.neuroph.imgrec.ImageRecognitionHelper,createResponse,,14,33,21,4,0.24,0.1667,0,5,3,0,1,"/**
         * Creates binary network output vector (response) for the specified list of images
         * Each network output (neuron) corresponds to one image.
         * @param inputLabel label of the input image
         * @param imageLabels labels used for output neurons
         * @return network response for the specified input
         */
	private static double[] createResponse(String inputLabel, List<String> imageLabels)
	{
		double[] response = new double[imageLabels.size()];
		int i=0;
		for(String imageLabel : imageLabels) {
			if(inputLabel.startsWith(imageLabel)) {
				response[i] = 1d;
			} else {
				response[i] = 0d;
			}
			i++;
		}
		return response;
	}"
neuroph,org.neuroph.imgrec.ImageRecognitionHelper,createLabels,,13,31,17,3,0.26,0.1894,0,5,3,0,1,"private static List<String> createLabels(HashMap<String,?> map)
    {
        List<String> imageLabels = new ArrayList<String>();
        for (String imgName : map.keySet()) {
            StringTokenizer st = new StringTokenizer(imgName, ""._"");
            String imageLabel = st.nextToken();
            if (!imageLabels.contains(imageLabel)) {
                imageLabels.add(imageLabel);
            }
        }
        Collections.sort(imageLabels); 
        return imageLabels;
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,blackAndWhiteCleaning,,10,11,1,3,0.5238,0.2833,0,3,4,0,1,"/**
     * This method cleans input image by replacing all non black pixels with
     * white pixels TODO: some should be used here
     *
     * @param image - input image that will be cleaned
     * @return - cleaned input image as BufferedImage
     */
    public static BufferedImage blackAndWhiteCleaning(BufferedImage image) {
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getRGB(i, j) != -16777216) {
                    image.setRGB(i, j, -1);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,blackAndGrayCleaning,,12,13,0,3,0.5833,0.3457,0,3,4,0,1,"/**
     * This method cleans input image by replacing all pixels with RGB values
     * from -4473925 (gray) to -1 (white) with white pixels and from -4473925
     * (gray) to -16777216 (black) with black pixels
     *
     * @param image - input image that will be cleaned
     * @return - cleaned input image as BufferedImage
     */
    public static BufferedImage blackAndGrayCleaning(BufferedImage image) {
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getRGB(i, j) > -4473925) {
                    image.setRGB(i, j, -1);
                } else {
                    image.setRGB(i, j, -16777216);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,blackAndLightGrayCleaning,,12,13,0,3,0.5833,0.3457,0,3,4,0,1,"/**
     * This method cleans input image by replacing all pixels with RGB values
     * from -3092272 (light gray) to -1 (white) with white pixels and from
     * -3092272 (light gray) to -16777216 (black) with black pixels
     *
     * @param image - input image that will be cleaned
     * @return - cleaned input image as BufferedImage
     */
    public static BufferedImage blackAndLightGrayCleaning(BufferedImage image) {
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getRGB(i, j) > -4473925) {
                    image.setRGB(i, j, -1);
                } else {
                    image.setRGB(i, j, -16777216);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,colorCleaning,,12,13,0,3,0.4688,0.3117,0,4,4,0,1,"/**
     * This method cleans input image by replacing all pixels with RGB values
     * from RGBcolor input (the input color) to -1 (white) with white pixels and
     * from RGBcolor input (the input color) to -16777216 (black) with black
     * pixels
     *
     * @param image - input image that will be cleaned
     * @param RGBcolor - input RGB value of wanted color as reference for
     * celaning
     * @return - cleaned input image as BufferedImage
     */
    public static BufferedImage colorCleaning(BufferedImage image, int RGBcolor) {
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getRGB(i, j) == RGBcolor) {
                    image.setRGB(i, j, -16777216);
                } else {
                    image.setRGB(i, j, -1);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,loadAndCleanImage,,9,13,11,4,0.2222,0.0476,0,3,2,0,1,"/**
     * This method loads the input Image and returns the cleaned version
     *
     * @param file - input file that will be loaded as image
     * @return - return cleaned loaded image as BufferedImage
     */
    public static BufferedImage loadAndCleanImage(File file) {
        try {
            BufferedImage image = ImageIO.read(file);
            return blackAndLightGrayCleaning(image);
        } catch (IOException ex) {
            Logger.getLogger(ImageUtilities.class.getName()).log(Level.SEVERE, null, ex);
            return null;
        }
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,save,,7,8,6,3,0.2667,0.0741,0,4,2,0,1,"public static void save(BufferedImage image, String filename, String type) {
        try {
            ImageIO.write(image, type, new File(filename));
        } catch (IOException ex) {
            throw new RuntimeException(""IOException whle trying to save image file"" + filename, ex);
        }
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,trimLockup,,10,10,5,3,0.4444,0.1786,0,3,4,0,1,"/**
     * This method reads the image pixels until it reads the first black pixel
     * by height and then returns that value
     *
     * @param Img - input image that will be read
     * @return - returns the value of height when conditions are true
     */
    private static int trimLockup(BufferedImage img) {
        for (int j = 0; j < img.getHeight(); j++) {
            for (int i = 0; i < img.getWidth(); i++) {
                if (img.getRGB(i, j) == -16777216) {
                    return j;
                }
            }
        }
        return 0;
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,trimLockdown,,21,37,8,3,0.3167,0.2077,0,5,7,0,1,"/**
     * This method reads the input image from the input from start pixel height
     * (y1) until it reads the first next row where all pixel are white by
     * height and return that value
     *
     * @param Img - input image that will be read
     * @param y1 - input start height pixel of image
     * @return - returns the value of height when conditions are true
     */
    private static int trimLockdown(BufferedImage img, int y1) {
        for (int j = y1 + 1; j < img.getHeight(); j++) {
            int counterWhite = 0;
            for (int i = 0; i < img.getWidth(); i++) {
                if (img.getRGB(i, j) == -1) {
                    counterWhite++;
                }
            }
            if (counterWhite == img.getWidth()) {
                //this is a chek for dots over the letters i and j
                //so they wont be missread as dots
                if (j > (img.getHeight() / 2)) {
                    return j;
                }
            }
            if (j == img.getHeight() - 1) {
                return j + 1;
            }
        }
        return 0;
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,trimImage,,7,14,7,3,0.3714,0.1425,0,5,1,0,1,"/**
     * This method trims the input image and returns it as a BufferedImage
     *
     * @param imageToTrim input image that will be trimed
     * @return return trimed input image as BufferedImage
     */
    public static BufferedImage trimImage(BufferedImage imageToTrim) {
        int y1 = trimLockup(imageToTrim);
        int y2 = trimLockdown(imageToTrim, y1);
        int x1 = 0; // why zero? search white pixels from left...
        int x2 = imageToTrim.getWidth();
        return cropImage(imageToTrim, x1, y1, x2, y2);
    }"
neuroph,org.neuroph.imgrec.ImageUtilities,resizeImage,,7,14,7,3,0.3143,0.1217,0,5,1,0,1,"/**
     * Resize image to specified dimensions
     *
     * @param image image to resize
     * @param width new image width
     * @param height new image height
     * @return resized image
     */
    public static BufferedImage resizeImage(BufferedImage image, int width, int height) {
        BufferedImage resizedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        Graphics2D g = resizedImage.createGraphics();
        g.drawImage(image, 0, 0, width, height, null);
        g.dispose();
        return resizedImage;
    }"
neuroph,org.neuroph.imgrec.FractionRgbData,populateRGBArrays,,22,63,21,3,0.2103,0.1212,0.5,7,3,1,1,"/**
         * Fills the rgb arrays from image
         * @param image image to get rgb data from
         */
	protected final void populateRGBArrays(Image image)
	{
		int color;
		
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				color = image.getPixel(x, y);

				double red = ((double) Color.getRed(color)) / 256d;
				redValues[y][x] = red;
				flattenedRgbValues[(y * width + x)] = red;

				double green = ((double) Color.getGreen(color)) / 256d;
				greenValues[y][x] = green;
				flattenedRgbValues[(width * height + y * width + x)] = green;

				double blue = ((double) Color.getBlue(color)) / 256d;
				blueValues[y][x] = blue;
				flattenedRgbValues[(2 * width * height + y * width + x)] = blue;
			}
		}
	}"
neuroph,org.neuroph.imgrec.FractionRgbData,convertRgbInputToBinaryBlackAndWhite,,16,35,25,4,0.275,0.1402,0,5,3,0,1,"/**
         * Converts image rgb data to binary black and white data (1 for black, 0 for white)
         * @param inputRGB flatten rgb data
         * @return binary black and white representation of image
         */
        public static double[] convertRgbInputToBinaryBlackAndWhite(double[] inputRGB) {
            int length = inputRGB.length/3;
            double inputBinary[]= new double[length];
            // black =1 , white = 0 which is opposite from color information
            for(int i=0; i<length; i++) { // problem sa ovime je sto pixele koji nisu skroz crni prebacuje u bele!
                // if (r+g+b)/3 < thresh then black (1) else white (0)
                double rgbColorAvg = (inputRGB[i] +inputRGB[length+i] + inputRGB[2*length+i])/3;
                if (rgbColorAvg<0.19) {   
                    inputBinary[i] = 1;   // then its 1 (black)
                } else {
                    inputBinary[i] = 0;   // otherwise its 0 (white)
                }
            }

            return inputBinary;
        }"
neuroph,org.neuroph.imgrec.FractionRgbData,equals,,9,8,6,3,0.3333,0.0926,0,2,3,0,1,"@Override
	public boolean equals(Object obj)
	{
		if(obj == null || !(obj instanceof FractionRgbData)) {
			return false;
		}
		FractionRgbData other = (FractionRgbData) obj;
		return Arrays.equals(flattenedRgbValues, other.getFlattenedRgbValues());
	}"
neuroph,org.neuroph.imgrec.ImageSampler,downSampleImage,,39,263,175,2,0.1132,0.0834,0.428571429,15,7,1,1,"//	/**
//	 * Scans screen location using screenshot
//	 * @param robot
//	 * @param rectangleAsDecimalPercent
//	 * @param samplingResolution
//	 * @return image sample from the specified location
//	 */
//	public static BufferedImage scanLocationUsingScreenshot(Robot robot,
//			Rectangle2D.Double rectangleAsDecimalPercent, Dimension samplingResolution)
//	{
//		return scanLocationUsingScreenshot(robot, rectangleAsDecimalPercent, samplingResolution, BufferedImage.TYPE_INT_RGB);
//	}
//	
//	/**
//	 * Scans screen location using screenshot
//	 * @param robot
//	 * @param rectangleAsDecimalPercent
//	 * @param samplingResolution
//	 * @param imageType
//	 * @return image sample from the specified location
//	 */
//	public static BufferedImage scanLocationUsingScreenshot(Robot robot,
//			Rectangle2D.Double rectangleAsDecimalPercent, Dimension samplingResolution,
//			int imageType)
//	{
//		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
//		
//		int inspectX = (int) Math.round((screenSize.getWidth() * rectangleAsDecimalPercent.x));
//		int inspectY = (int) Math.round((screenSize.getHeight() * rectangleAsDecimalPercent.y));
//		int inspectWidth = (int) Math.round((screenSize.getWidth() * rectangleAsDecimalPercent.width));
//		int inspectHeight = (int) Math.round((screenSize.getHeight() * rectangleAsDecimalPercent.height));
//		
//		Rectangle screenRect = new Rectangle(inspectX, inspectY, inspectWidth, inspectHeight);
//		BufferedImage screenCapture = robot.createScreenCapture(screenRect);
//		
//		
//		return downSampleImage(samplingResolution, screenCapture, imageType);
//	}
//
//        /**
//         * Scales image to the specified dimension
//         * @param samplingResolution sampling resolution/image size
//         * @param bigImg image to scale
//         * @return image scaled/downsampled to the specified dimension/resolution
//         */
//	public static BufferedImage downSampleImage(
//			Dimension samplingResolution, BufferedImage bigImg) {
//		return downSampleImage(samplingResolution, bigImg, BufferedImage.TYPE_INT_RGB);
//	}
//
//
//        /**
//         * Scales image to the specified dimension
//         * @param samplingResolution sampling resolution/image size
//         * @param bigImg image to scale
//         * @param returnImageType type of the return image
//         * @return image scaled/downsampled to the specified dimension/resolution
//         */
//	public static BufferedImage downSampleImage(Dimension samplingResolution,
//			BufferedImage bigImg, int returnImageType) {
//		int inspectX;
//		int inspectY;
//		int numberOfSamplesAcross = samplingResolution.getWidth();
//		int numberOfSamplesDown = samplingResolution.getHeight();
//		
//		if(bigImg.getWidth() <= numberOfSamplesAcross || bigImg.getHeight() <= numberOfSamplesDown) {
//			return bigImg;
//		}
//		
//		BufferedImage img = new BufferedImage(
//				numberOfSamplesAcross, numberOfSamplesDown, 
//				returnImageType);
//		
//		double samplingIncrementX = bigImg.getWidth() / (samplingResolution.getWidth() - 1);
//		double samplingIncrementY = bigImg.getHeight() / (samplingResolution.getHeight() - 1);
//		
//		double sampleX = 0;
//		double sampleY = 0;
//		for(int y=0; y < numberOfSamplesDown; y++) {
//			for(int x=0; x < numberOfSamplesAcross; x++) {
//				inspectX = (int) Math.round(sampleX);
//				inspectY = (int) Math.round(sampleY);
//				
//				if(inspectX >= bigImg.getWidth()) {
//					inspectX = bigImg.getWidth() - 1;
//				}
//				if(inspectY >= bigImg.getHeight()) {
//					inspectY = bigImg.getHeight() - 1;
//				}
//				int color = bigImg.getRGB(inspectX, inspectY);
//				img.setRGB(x, y, color);
//				sampleX+=samplingIncrementX;
//			}
//			sampleX=0;
//			sampleY+=samplingIncrementY;
//		}
//		
//		return img;
//	}
//	
//	/**
//	 * Scans screen location using sampling
//	 * @param robot an instance of java.awt.Robot for the scaned screen
//	 * @param rectangleAsDecimalPercent
//	 * @param samplingResolution
//	 * @return image sample from the specified location
//	 */
//	public static BufferedImage scanLocationUsingSampling(Robot robot,
//			Rectangle2D.Double rectangleAsDecimalPercent, Dimension samplingResolution)
//	{
//		return scanLocationUsingSampling(robot, rectangleAsDecimalPercent, samplingResolution, BufferedImage.TYPE_INT_RGB);
//	}
//	
//	/**
//	 * Scans screen location using sampling
//	 * @param robot an instance of java.awt.Robot for the scaned screen
//	 * @param rectangleAsDecimalPercent
//	 * @param samplingResolution
//	 * @param imageType
//	 * @return image sample from the specified location
//	 */
//	public static BufferedImage scanLocationUsingSampling(Robot robot,
//			Rectangle2D.Double rectangleAsDecimalPercent, Dimension samplingResolution,
//			int imageType)
//	{
//		double slotULXAsDecimalPercent = rectangleAsDecimalPercent.x; 
//		double slotULYAsDecimalPercent = rectangleAsDecimalPercent.y;
//		double sampleIncrementAcrossAsDecimalPercent = rectangleAsDecimalPercent.width / (samplingResolution.getWidth()-1);
//		double sampleIncrementDownAsDecimalPercent = rectangleAsDecimalPercent.height / (samplingResolution.getHeight()-1);
//		
//		int numberOfSamplesAcross = samplingResolution.width;
//		int numberOfSamplesDown = samplingResolution.height;
//		BufferedImage img = new BufferedImage(
//				numberOfSamplesAcross, numberOfSamplesDown, 
//				imageType);
//		
//		Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
//		
//		waitForVerticalScreenRefresh();
//		
//		double inspectXAsDecimalPercent = slotULXAsDecimalPercent;
//		double inspectYAsDecimalPercent = slotULYAsDecimalPercent;
//		for(int y=0; y < numberOfSamplesDown; y++) {
//			for(int x=0; x < numberOfSamplesAcross; x++) {
//				int inspectX = (int) Math.round((screenSize.width * inspectXAsDecimalPercent));
//				int inspectY = (int) Math.round((screenSize.height * inspectYAsDecimalPercent));
//				Color color = robot.getPixelColor(inspectX, inspectY);
//				img.setRGB(x, y, color.getRGB());
//				inspectXAsDecimalPercent+=sampleIncrementAcrossAsDecimalPercent;
//			}
//			inspectXAsDecimalPercent = slotULXAsDecimalPercent;
//			inspectYAsDecimalPercent+=sampleIncrementDownAsDecimalPercent;
//		}
//		return img;
//	}
//
//	/**
//	 * Another name for this is ""Vertical Sync"".  Minimizes frame shearing.
//	 */
//	private static void waitForVerticalScreenRefresh()
//	{
//		Toolkit.getDefaultToolkit().sync();
//	}
    
	public static Image downSampleImage(Dimension samplingResolution,
			Image bigImage, int returnImageType) {
		int inspectX;
		int inspectY;
		int numberOfSamplesAcross = samplingResolution.getWidth();
		int numberOfSamplesDown = samplingResolution.getHeight();
		
		if(bigImage.getWidth() <= numberOfSamplesAcross || bigImage.getHeight() <= numberOfSamplesDown) {
			return bigImage;
		}
		
		Image image = ImageFactory.createImage(new Integer(numberOfSamplesAcross), new Integer(numberOfSamplesDown), new Integer(returnImageType));
		
		double samplingIncrementX = bigImage.getWidth() / (samplingResolution.getWidth() - 1);
		double samplingIncrementY = bigImage.getHeight() / (samplingResolution.getHeight() - 1);
		
		double sampleX = 0;
		double sampleY = 0;
		for(int y=0; y < numberOfSamplesDown; y++) {
			for(int x=0; x < numberOfSamplesAcross; x++) {
				inspectX = (int) Math.round(sampleX);
				inspectY = (int) Math.round(sampleY);
				
				if(inspectX >= bigImage.getWidth()) {
					inspectX = bigImage.getWidth() - 1;
				}
				if(inspectY >= bigImage.getHeight()) {
					inspectY = bigImage.getHeight() - 1;
				}
				int color = bigImage.getPixel(inspectX, inspectY);
				image.setPixel(x, y, color);
				sampleX+=samplingIncrementX;
			}
			sampleX=0;
			sampleY+=samplingIncrementY;
		}
		
		return image;
	}"
neuroph,org.neuroph.imgrec.filter.ImageFilterChain,processImage,,12,3,0,1,0.4,0.2833,1,4,2,0,1,"/**
     * Apply all filters from a chain on image 
     * @param image image to process
     * @return processed image
     */
    @Override
    public BufferedImage processImage(BufferedImage image) {
        
        BufferedImage tempImage = image;
        for (ImageFilter filter : filters) {
            BufferedImage filteredImage = filter.processImage(tempImage);
            tempImage = filteredImage;
        }

        return tempImage;

    }"
neuroph,org.neuroph.imgrec.filter.ImageFilterChain,processImageTest,,13,42,29,3,0.2045,0.0932,1,7,2,0,1,"/**
     * Returns images of all stages in processing
     * Used for testing 
     * @param image
     * @return 
     */
    public List<FilteredImage> processImageTest(BufferedImage image){
        List<FilteredImage> list = new ArrayList<FilteredImage>();
        BufferedImage tempImage = image;
        for (ImageFilter filter : filters) {
            BufferedImage processedImage = filter.processImage(tempImage);
            String filterName = filter.toString();
            FilteredImage filteredImage = new FilteredImage(processedImage,filterName);
            list.add(filteredImage);
            tempImage = processedImage;
        }

        return list;
    }"
neuroph,org.neuroph.imgrec.filter.impl.EdgeDetection,processImage,,46,310,269,6,0.0899,0.0259,0,16,7,1,1,"public BufferedImage processImage(BufferedImage image) {
        originalImage = image;
        setAttributes(image);
        int width = originalImage.getWidth();
        int height = originalImage.getHeight();

        filteredImage = new BufferedImage(width, height, originalImage.getType());

        int[][] filter1 = {{-1, 0, 1},
        {-2, 0, 2},
        {-1, 0, 1}
        };
        int[][] filter2 = {{1, 2, 1},
        {0, 0, 0},
        {-1, -2, -1}
        };

        for (int y = 1; y < height - 1; y++) {
            for (int x = 1; x < width - 1; x++) {

                // get 3-by-3 array of colors in neighborhood
                int[][] gray = new int[3][3];
                for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        gray[i][j] = (int) lum(new Color(originalImage.getRGB(x - 1 + i, y - 1 + j)));
                    }
                }

                // apply filter
                int gray1 = 0, gray2 = 0;
                for (int i = 0; i < 3; i++) {
                    for (int j = 0; j < 3; j++) {
                        gray1 += gray[i][j] * filter1[i][j];
                        gray2 += gray[i][j] * filter2[i][j];
                    }
                }
                // int magnitude = 255 - truncate(Math.abs(gray1) + Math.abs(gray2));
                int magnitude = 255 - truncate((int) Math.sqrt(gray1 * gray1 + gray2 * gray2));
                Color grayscale = new Color(magnitude, magnitude, magnitude);
                filteredImage.setRGB(x, y, grayscale.getRGB());

            }
        }
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.EdgeDetection,truncate,,9,5,4,3,0.5,0.2,0,1,3,0,1,"/**
     * Truncate color component to be between 0 and 255.
     * @param a
     * @return 
     */
    public static int truncate(int a) {
        if (a < 0) {
            return 0;
        } else if (a > 255) {
            return 255;
        } else {
            return a;
        }
    }"
neuroph,org.neuroph.imgrec.filter.impl.MedianFilter,processImage,,29,86,52,2,0.1652,0.0701,1,9,3,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
		
        originalImage = image;
		
	int width = originalImage.getWidth();
	int height = originalImage.getHeight();
		
	filteredImage = new BufferedImage(width, height, originalImage.getType());
		
	int [] arrayOfPixels;
	int median;
	int alpha;
	int newColor;
		
	for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
				
		arrayOfPixels = getArrayOfPixels(i, j);
		median = findMedian(arrayOfPixels);
		alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
				
		newColor = ImageUtilities.colorToRGB(alpha, median, median, median);
		filteredImage.setRGB(i, j, newColor);
            }
        }
		
	return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,processImage,,56,341,247,2,0.1016,0.0802,0,15,9,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
		
        int width = image.getWidth();
	int height = image.getHeight();

        while (width % N != 0) {
            width--;
        }
        
        while (height % N != 0) {
            height--;
        }
        
        originalImage = resize(image, width, height);

        filteredImage = new BufferedImage(width, height, originalImage.getType());
    
        
        
        int numXpatches = width/N;
        int numYpatches = height/N;
        
        
        double [][] T = createT();
        
        double [][] Tinv = null;
        if (N == 8)
            Tinv = createTinv();
        if (N==16)
            Tinv = createTinv16X16();
        
        
        
         for (int i = 0; i < numXpatches; i++) {
             for (int j = 0; j < numYpatches; j++) {
                 
                 double [][] M = createM(i, j);
                 double[][] D = multiply(multiply(T, M), Tinv);
                 int [][] Q = null;
                 if (N == 8) {
                    Q = createQ50();
                    updateQ(Q);
                 }
                 if (N == 16) {
                    Q = createQ16X16();
                 }
                 
                 int [][] C = createC(D, Q);
                 double [][] R = createR(Q, C);
                 int [][] Nmatrix = createN(Tinv, R, T);
                 fillFilteredImage(i, j, Nmatrix);
             }
         }
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,resize,,10,33,21,3,0.2286,0.1245,0,7,1,0,1,"public  BufferedImage resize(BufferedImage img, int newW, int newH) {  
        int w = img.getWidth();  
        int h = img.getHeight();  
        BufferedImage dimg = dimg = new BufferedImage(newW, newH, img.getType());  
        Graphics2D g = dimg.createGraphics();  
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);  
        g.drawImage(img, 0, 0, newW, newH, 0, 0, w, h, null);  
        g.dispose();  
        return dimg;  
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,createT,,13,21,6,3,0.3148,0.1505,0,4,4,0,1,"public double[][] createT () { 
        double [][] T = new double [N][N];
        for (int i = 0; i < N; i++) {
            T[0][i] = roundFourDecimals(1.0/Math.sqrt(N));
        }     
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < N; j++) {
                
                T[i][j] = roundFourDecimals(Math.sqrt(2.0/N)*Math.cos(((2.0*j+1)*i*Math.PI)/(2.0*N)));
            }
        }
        return T;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,createM,,14,51,36,3,0.1667,0.0988,0,7,3,0,1,"public double [][] createM (int i, int j) {
        double [][] M = new double [N][N];
        int xx = 0;
        int yy = 0;
        for (int x = i*N; x < i*N+N; x++) {
            for (int y = j*N; y < j*N+N; y++) {    
                M[xx][yy] = new Color(originalImage.getRGB(x, y)).getRed() - 128;
                yy++;   
            }
            xx++;
            yy=0;
        }
        return M;    
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,multiply,,16,36,27,3,0.19,0.0616,0,12,5,0,1,"public double[][] multiply(double[][] m1, double[][] m2) {
    int m1rows = m1.length;
    int m1cols = m1[0].length;
    int m2rows = m2.length;
    int m2cols = m2[0].length;
    if (m1cols != m2rows)
      throw new IllegalArgumentException(""matrices don't match: "" + m1cols + "" != "" + m2rows);
    double[][] result = new double[m1rows][m2cols];
 
    // multiply
    for (int i=0; i<m1rows; i++)
      for (int j=0; j<m2cols; j++)
        for (int k=0; k<m1cols; k++)
        result[i][j] += m1[i][k] * m2[k][j];
    return result;
  }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,createC,,9,15,9,3,0.2449,0.0976,0,5,3,0,1,"public int [][] createC (double [][] D, int [][] Q) {
        int [][] C = new int[N][N];     
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {       
                C[i][j] = (int) Math.round(D[i][j]/Q[i][j]);
            }
        }     
        return C;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,createR,,9,15,9,3,0.2619,0.1033,0,5,3,0,1,"public double [][] createR (int [][] Q, int [][] C) {
        double [][] R = new double[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                R[i][j] = Q[i][j]*C[i][j];
            }
        }   
        return R;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,createN,,10,21,14,3,0.2,0.0807,0,7,3,0,1,"public int [][] createN (double [][] Tinv, double [][] R, double [][] T) {
        int [][] Nmatrix = new int [N][N];
        double [][] tmp = multiply(multiply(Tinv, R), T);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                Nmatrix[i][j] = (int) (Math.round(tmp[i][j])+128);
            }
        }
        return Nmatrix;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,fillFilteredImage,,15,68,58,5,0.1346,0.0672,1,10,3,0,1,"public void fillFilteredImage (int i, int j, int[][] Nmatrix) {
        int xx =0;
        int yy =0;
        for (int x = i*N; x < i*N+N; x++) {
            for (int y = j*N; y < j*N+N; y++) {
                int alpha = new Color(originalImage.getRGB(x, y)).getAlpha();
                int color = Nmatrix[xx][yy];
                int rgb = ImageUtilities.colorToRGB(alpha, color, color, color);  
                yy++;
                filteredImage.setRGB(x, y, rgb);                        
            }
            xx++;
            yy=0;
        } 
    }"
neuroph,org.neuroph.imgrec.filter.impl.DCTgrayscale,updateQ,,18,25,5,2,0.2625,0.1621,0,5,8,0,1,"public void updateQ(int [][] Q) {
        if (qualityLevel == 50)
            return;
        if (qualityLevel > 50) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    Q[i][j] = (int) Math.round(Q[i][j]*(100-qualityLevel)*1.0/50);
                }
            }
        }
        if (qualityLevel < 50) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    Q[i][j] = (int)Math.round(Q[i][j]*50.0/qualityLevel);
                }
            }
        }
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRSeparationFilter,processImage,,36,135,99,4,0.1263,0.0606,0,7,7,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;
        width = originalImage.getWidth();
        height = originalImage.getHeight();

        prepare();

        visited = new boolean[height][width];

        int color;
        int white = 255;

        for (int line = 0; line < linePositions.length; line++) {
            for (int k = -1; k <= 1; k++) {
                int i = linePositions[line]+k;
                if (i == -1 || i == height)
                    continue;;
//        for (int i = 0; i < height; i++) {

                for (int j = 0; j < width; j++) {

                    color = new Color(originalImage.getRGB(j, i)).getRed();
                    if (color == white) {
                        visited[i][j] = true;
                    } else {
                        BFStraverseAndSave(i, j);

                    }

                }
            }
        }
        return originalImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRSeparationFilter,saveToFile,,16,46,37,4,0.1932,0.0738,0.333333333,6,4,0,1,"private void saveToFile(BufferedImage img, String letterName) {
        File outputfile = new File(location + letterName + "".png"");
        BufferedImage crop = img;
        if (cropHeight != 0 || cropWidth != 0) {
            OCRCropImage ci = new OCRCropImage();
            ci.setDimension(cropWidth, cropHeight);
            crop = ci.processImage(img);
        }
        
        
        try {
            ImageIO.write(crop, ""png"", outputfile);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRSeparationFilter,prepare,,23,60,42,3,0.1923,0.1111,0,4,6,0,1,"/**
     *  pretopstavka da s ekoriste samo slova, mala i velika
     *  26 mali i 26 velikih, zato je counts[52]
     */
    private void prepare() {
        counts = new int[52];
        for (int i = 0; i < counts.length; i++) {
            counts[i] = 1;
        }
        String pom = """";
        for (int i = 0; i < text.length(); i++) {
            if (Character.isLetter(text.charAt(i))) {
                pom += text.charAt(i);
            }
        }
        text = pom;
        //====================================================
        // ako nije setovan linepostions proci kroz sve linije
        if (linePositions == null) {
            linePositions = new int[height];

            for (int i = 0; i < linePositions.length; i++) {
                linePositions[i] = i;
            }
        }

    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRSeparationFilter,createName,,21,93,66,4,0.1813,0.0746,0,7,2,0,1,"/**
     * trenutno radi samo sa slovima, malim i velikim
     * promeniti da prepoznaje i druge karaktere
     * @return naziv slova, npr A ili c
     */
    private String createName() {

        int offsetBIG = 65;
        int offsetSMALL = 97;
        int offsetARRAY = 26;

        char c = text.charAt(seqNum);
        int key = c;
//        System.out.println(key+"" ""+c);
        int number;
        if (key < 95) { //smallLetter
            number = counts[key - offsetBIG];
            counts[key - offsetBIG]++;
        } else { //big letter
            number = counts[key - offsetSMALL + offsetARRAY];
            counts[key - offsetSMALL + offsetARRAY]++;
        }
        String name = c + ""_"" + number;
//        letterLabels.add(c+"""");
        return name;
    }"
neuroph,org.neuroph.imgrec.filter.impl.EraseBlackBorderFilter,processImage,,54,387,278,2,0.0961,0.0551,1,20,8,1,1,"@Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;

        int width = originalImage.getWidth();
        int height = originalImage.getHeight();

        filteredImage = new BufferedImage(width, height, originalImage.getType());

        int centerI = width / 2;
        int centerJ = height / 2;

        int lengthI = width / 4;
        int lengthJ = height / 6;

        int startI = centerI - lengthI / 2;
        int goalI = centerI + lengthI / 2;

        int startJ = centerJ - lengthJ / 2;
        int goalJ = centerJ + lengthJ / 2;
        boolean[][] visited;
        visited = new boolean[width][height];
        int color;

        for (int i = startI; i < goalI; i++) {
            for (int j = startJ; j < goalJ; j++) {

                color = new Color(originalImage.getRGB(i, j)).getRed();
                if (color == 0) {
                    if (!visited[i][j]) {
                        BFS(i, j, visited);
                    }
                }
            }
        }

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                if (!visited[i][j]) {
                    int white = 255;
                    color = ImageUtilities.colorToRGB(alpha, white, white, white);
                    filteredImage.setRGB(i, j, color);
                } else {
                    int black = 0;
                    color = ImageUtilities.colorToRGB(alpha, black, black, black);
                    filteredImage.setRGB(i, j, color);
                }
            }
        }

        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.EraseBlackBorderFilter,BFS,,30,133,76,2,0.1733,0.0993,0,13,12,0,1,"public void BFS(int startI, int startJ, boolean[][] visited) {
        LinkedList<String> queue = new LinkedList<String>();

        String positions = startI + "" "" + startJ;
        visited[startI][startJ] = true;
        queue.addLast(positions);

        while (!queue.isEmpty()) {
            String pos = queue.removeFirst();
            String[] posArray = pos.split("" "");
            int x = Integer.parseInt(posArray[0]);
            int y = Integer.parseInt(posArray[1]);
            visited[x][y] = true;
            for (int i = x - 1; i <= x + 1; i++) {
                for (int j = y - 1; j <= y + 1; j++) {
                    if (i >= 0 && j >= 0 && i < originalImage.getWidth() && j < originalImage.getHeight() && i != x && j != y) {
                        if (!visited[i][j]) {
                            int color = new Color(originalImage.getRGB(i, j)).getRed();
                            if (color == 0) {
                                visited[i][j] = true;
                                String tmpPos = i + "" "" + j;
                                queue.addLast(tmpPos);
                            }
                        }
                    }
                } //i
            } //j
        }

    }"
neuroph,org.neuroph.imgrec.filter.impl.GuoHallThiningFilter,processImage,,74,427,326,4,0.0886,0.052,1,15,14,0,1,"/**
     *
     * @param image The input image should be binary
     * @return
     */
    @Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;
        width = originalImage.getWidth();
        height = originalImage.getHeight();

        filteredImage = new BufferedImage(width, height, originalImage.getType());
        imageM = new int[width][height];

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                int col = new Color(originalImage.getRGB(i, j)).getRed();
                if (blackLetters) {
                    imageM[i][j] = 1 - (col / 255);
                } else {
                    imageM[i][j] = col / 255;
                }

            }

        }

        
        while (true) {

            int[][] start = new int[width][height];

            for (int i = 0; i < width; i++) {
                for (int j = 0; j < height; j++) {
                    start[i][j] = imageM[i][j];
                }
            }

            thiningGuoHallIteration(0);
            thiningGuoHallIteration(1);

            boolean same = true;
            MainforLoop:
            for (int i = 0; i < width; i++) {
                for (int j = 0; j < height; j++) {
                    if (start[i][j] != imageM[i][j]) {
                        same = false;
                        break MainforLoop;
                    }

                }
            }
            if (same) {
                break;
            }

        }

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                int col;
                if (blackLetters) {
                    col = 255 - imageM[i][j] * 255;
                } else {
                    col = imageM[i][j] * 255;
                }
                int rgb = ImageUtilities.colorToRGB(alpha, col, col, col);

                filteredImage.setRGB(i, j, rgb);
            }
        }

        return filteredImage;

    }"
neuroph,org.neuroph.imgrec.filter.impl.GuoHallThiningFilter,thiningGuoHallIteration,,42,261,222,3,0.0991,0.0355,0,20,12,0,1,"public void thiningGuoHallIteration(int iter) {
        int[][] marker = new int[width][height];
        for (int i = 1; i < width - 1; i++) {
            for (int j = 1; j < height - 1; j++) {
                
                int p2 = imageM[i - 1][j];
                int p3 = imageM[i - 1][j + 1];
                int p4 = imageM[i][j + 1];
                int p5 = imageM[i + 1][j + 1];
                int p6 = imageM[i + 1][j];
                int p7 = imageM[i + 1][j - 1];
                int p8 = imageM[i][j - 1];
                int p9 = imageM[i - 1][j - 1];

                int C = (~p2 & (p3 | p4)) + (~p4 & (p5 | p6))
                        + (~p6 & (p7 | p8)) + (~p8 & (p9 | p2));
                int N1 = (p9 | p2) + (p3 | p4) + (p5 | p6) + (p7 | p8);
                int N2 = (p2 | p3) + (p4 | p5) + (p6 | p7) + (p8 | p9);
                int N = N1 < N2 ? N1 : N2;
                int m = iter == 0 ? ((p6 | p7 | ~p9) & p8) : ((p2 | p3 | ~p5) & p4);

                if (C == 1 && (N >= 2 && N <= 3) & m == 0) {
                    marker[i][j] = 1;
                }

            }

        }
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                int tmp = 1 - marker[i][j];
                if (imageM[i][j] == tmp && imageM[i][j] == 1) {
                    imageM[i][j] = 1;
                } else {
                    imageM[i][j] = 0;
                }

            }
        }

    }"
neuroph,org.neuroph.imgrec.filter.impl.ZhangSuenThinFilter,processImage,,74,427,326,4,0.0886,0.052,1,15,14,0,1,"/**
     *
     * @param image The input image should be binary
     * @return
     */
    @Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;
        width = originalImage.getWidth();
        height = originalImage.getHeight();

        filteredImage = new BufferedImage(width, height, originalImage.getType());
        imageM = new int[width][height];

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                int col = new Color(originalImage.getRGB(i, j)).getRed();
                if (blackLetters) {
                    imageM[i][j] = 1 - (col / 255);
                } else {
                    imageM[i][j] = col / 255;
                }

            }

        }

        
        while (true) {

            int[][] start = new int[width][height];

            for (int i = 0; i < width; i++) {
                for (int j = 0; j < height; j++) {
                    start[i][j] = imageM[i][j];
                }
            }

            thiningIteration(0);
            thiningIteration(1);

            boolean same = true;
            MainforLoop:
            for (int i = 0; i < width; i++) {
                for (int j = 0; j < height; j++) {
                    if (start[i][j] != imageM[i][j]) {
                        same = false;
                        break MainforLoop;
                    }

                }
            }
            if (same) {
                break;
            }

        }

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                int col;
                if (blackLetters) {
                    col = 255 - imageM[i][j] * 255;
                } else {
                    col = imageM[i][j] * 255;
                }
                int rgb = ImageUtilities.colorToRGB(alpha, col, col, col);

                filteredImage.setRGB(i, j, rgb);
            }
        }

        return filteredImage;

    }"
neuroph,org.neuroph.imgrec.filter.impl.ZhangSuenThinFilter,thiningIteration,,80,1096,1016,10,0.0565,0.0277,0,27,30,0,1,"public void thiningIteration(int iter) {
        int[][] marker = new int[width][height];

        for (int i = 1; i < width - 1; i++) {
            for (int j = 1; j < height - 1; j++) {

                int p2 = imageM[i - 1][j];
                int p3 = imageM[i - 1][j + 1];
                int p4 = imageM[i][j + 1];
                int p5 = imageM[i + 1][j + 1];
                int p6 = imageM[i + 1][j];
                int p7 = imageM[i + 1][j - 1];
                int p8 = imageM[i][j - 1];
                int p9 = imageM[i - 1][j - 1];

//                int A  = (p2 == 0 && p3 == 1) + (p3 == 0 && p4 == 1) + 
//                     (p4 == 0 && p5 == 1) + (p5 == 0 && p6 == 1) + 
//                     (p6 == 0 && p7 == 1) + (p7 == 0 && p8 == 1) +
//                     (p8 == 0 && p9 == 1) + (p9 == 0 && p2 == 1); 
                int c1 = 0; //p2 == 0 && p3 == 1
                int c2 = 0; //p3 == 0 && p4 == 1
                int c3 = 0; //p4 == 0 && p5 == 1
                int c4 = 0; //p5 == 0 && p6 == 1
                int c5 = 0; //p6 == 0 && p7 == 1
                int c6 = 0; //p7 == 0 && p8 == 1
                int c7 = 0; //p8 == 0 && p9 == 1
                int c8 = 0; //p9 == 0 && p2 == 1

                if (p2 == 0 && p3 == 1) {
                    c1 = 1;
                }
                if (p3 == 0 && p4 == 1) {
                    c2 = 1;
                }
                if (p4 == 0 && p5 == 1) {
                    c3 = 1;
                }
                if (p5 == 0 && p6 == 1) {
                    c4 = 1;
                }
                if (p6 == 0 && p7 == 1) {
                    c5 = 1;
                }
                if (p7 == 0 && p8 == 1) {
                    c6 = 1;
                }
                if (p8 == 0 && p9 == 1) {
                    c7 = 1;
                }
                if (p9 == 0 && p2 == 1) {
                    c8 = 1;
                }

                int A = c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8;
                int B = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9;

                int m1 = iter == 0 ? (p2 * p4 * p6) : (p2 * p4 * p8);
                int m2 = iter == 0 ? (p4 * p6 * p8) : (p2 * p6 * p8);

                if (A == 1 && (B >= 2 && B <= 6) && m1 == 0 && m2 == 0) {
                    marker[i][j] = 1;
                }

            }
        }

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                int tmp = 1 - marker[i][j];
                if (imageM[i][j] == tmp && imageM[i][j] == 1) {
                    imageM[i][j] = 1;
                } else {
                    imageM[i][j] = 0;
                }

            }
        }

    }"
neuroph,org.neuroph.imgrec.filter.impl.GenericConvolution,processImage,,27,97,74,4,0.1287,0.0454,1,10,4,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;
        int width = originalImage.getWidth();
        int height = originalImage.getHeight();

        filteredImage = new BufferedImage(width, height, originalImage.getType());
        
        int radius = kernel.length/2;
        
        if (normalize) {
            normalizeKernel();
        }
        
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {                
                double result = convolve(x, y, radius);                
                int gray = (int)Math.round(result);                
                int alpha = new Color(originalImage.getRGB(x, y)).getAlpha();
                int rgb = ImageUtilities.colorToRGB(alpha, gray, gray, gray);                
                filteredImage.setRGB(x, y, rgb);
            }
        }
                       
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.GenericConvolution,convolve,,17,65,52,4,0.1469,0.0649,0,9,7,0,1,"protected double convolve(int x, int y, int radius) {        
        double sum = 0;
        int kernelI = 0;
        for (int i = x-radius; i <= x+radius; i++) {
            int kernelJ = 0;
            for (int j = y-radius; j <= y+radius; j++) {              
                if (i>=0 && i<originalImage.getWidth() && j>0 && j<originalImage.getHeight()) {                
                    int color = new Color(originalImage.getRGB(i, j)).getRed();
                    sum = sum + color*kernel[kernelI][kernelJ];                    
                }
                kernelJ++;
            }
            kernelI++;
        }
        
        return sum;
    }"
neuroph,org.neuroph.imgrec.filter.impl.GenericConvolution,normalizeKernel,,15,19,2,3,0.3148,0.161,0,5,5,0,1,"/*
    * Mak sure that kernel element sum is 1
    */
    private void normalizeKernel() {
        int n = 0;
        for (int i = 0; i < kernel.length; i++) {
            for (int j = 0; j < kernel.length; j++) {
                n += kernel[i][j];
            }
            
        }
        for (int i = 0; i < kernel.length; i++) {
            for (int j = 0; j < kernel.length; j++) {
                kernel[i][j] = kernel[i][j]/n;
            }
            
        }
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRCropImage,processImage,,19,44,33,3,0.1515,0.0491,0,5,1,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {

        width = image.getWidth();
        height = image.getHeight();

        originalImage = image;
        filteredImage = new BufferedImage(newWidth, newHeight, image.getType());

        int startH = createStartH();
        int startW = createStartW();
        int endH = createEndH();
        int endW = createEndW();

        fillImage(startH, startW, endH, endW);
        

        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRCropImage,createStartH,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createStartH() {
        int color;
        int black = 0;
        int startH = 0;
        loop:
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    startH = i;
                    break loop;
                }
            }
        }
        return startH;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRCropImage,createStartW,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createStartW() {
        int color;
        int black = 0;
        int startW = 0;
        loop:
        for (int j = 0; j < width; j++) {
            for (int i = 0; i < height; i++) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    startW = j;
                    break loop;
                }
            }
        }
        return startW;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRCropImage,createEndH,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createEndH() {
        int color;
        int black = 0;
        int endH = 0;
        loop:
        for (int i = height - 1; i >= 0; i--) {
            for (int j = width-1; j >= 0; j--) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    endH = i;
                    break loop;
                }
            }
        }
        return endH;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OCRCropImage,createEndW,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createEndW() {
        int color;
        int black = 0;
        int endW = 0;
        loop:
        for (int j = width-1; j >= 0; j--) {
            for (int i = height - 1; i >= 0; i--) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    endW = j;
                    break loop;
                }
            }
        }
        return endW;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,processImage,,61,463,365,2,0.087,0.0727,0,16,9,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
		
        int width = image.getWidth();
	int height = image.getHeight();

        while (width % N != 0) {
            width--;
        }
        
        while (height % N != 0) {
            height--;
        }
        
        originalImage = resize(image, width, height);

        filteredImage = new BufferedImage(width, height, originalImage.getType());
    

        int numXpatches = width/N;
        int numYpatches = height/N;
        
        double treshold = 3*sigma;
        

        double [][] T = createT();
        
        
        double [][] Tinv = null;
        
        if (N==16) {
            Tinv = createTinv16X16();
        }
        if (N==8) {
            Tinv = createTinv();
        }
        
         for (int i = 0; i < numXpatches; i++) {
             for (int j = 0; j < numYpatches; j++) {
                 
                 double [][] M = createM(i, j);
                 double[][] D = multiply(multiply(T, M), Tinv);
                 tresholdDmatrix(D, treshold);
                 
                 int [][] Q = null;
                 
                 if (N==16) {
                     Q = createQ16X16();
                 }
                 if (N==8){
                     Q = createQ50(); 
                     updateQ(Q);
                 }
                 int [][] C = createC(D, Q);
                 double [][] R = createR(Q, C);
                 int [][] Nmatrix = createN(Tinv, R, T);
                 fillFilteredImage(i, j, Nmatrix);
             }
         }
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,resize,,10,33,21,3,0.2286,0.1245,0,7,1,0,1,"public  BufferedImage resize(BufferedImage img, int newW, int newH) {  
        int w = img.getWidth();  
        int h = img.getHeight();  
        BufferedImage dimg = dimg = new BufferedImage(newW, newH, img.getType());  
        Graphics2D g = dimg.createGraphics();  
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);  
        g.drawImage(img, 0, 0, newW, newH, 0, 0, w, h, null);  
        g.dispose();  
        return dimg;  
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,createT,,13,21,6,3,0.3148,0.1505,0,4,4,0,1,"public double[][] createT () { 
        double [][] T = new double [N][N];
        for (int i = 0; i < N; i++) {
            T[0][i] = roundFourDecimals(1.0/Math.sqrt(N));
        }     
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < N; j++) {
                
                T[i][j] = roundFourDecimals(Math.sqrt(2.0/N)*Math.cos(((2.0*j+1)*i*Math.PI)/(2.0*N)));
            }
        }
        return T;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,createM,,14,51,36,3,0.1667,0.0988,0,7,3,0,1,"public double [][] createM (int i, int j) {
        double [][] M = new double [N][N];
        int xx = 0;
        int yy = 0;
        for (int x = i*N; x < i*N+N; x++) {
            for (int y = j*N; y < j*N+N; y++) {    
                M[xx][yy] = new Color(originalImage.getRGB(x, y)).getRed() - 128;
                yy++;   
            }
            xx++;
            yy=0;
        }
        return M;    
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,multiply,,16,36,27,3,0.19,0.0616,0,12,5,0,1,"public double[][] multiply(double[][] m1, double[][] m2) {
    int m1rows = m1.length;
    int m1cols = m1[0].length;
    int m2rows = m2.length;
    int m2cols = m2[0].length;
    if (m1cols != m2rows)
      throw new IllegalArgumentException(""matrices don't match: "" + m1cols + "" != "" + m2rows);
    double[][] result = new double[m1rows][m2cols];
 
    // multiply
    for (int i=0; i<m1rows; i++)
      for (int j=0; j<m2cols; j++)
        for (int k=0; k<m1cols; k++)
        result[i][j] += m1[i][k] * m2[k][j];
    return result;
  }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,createC,,9,15,9,3,0.2449,0.0976,0,5,3,0,1,"public int [][] createC (double [][] D, int [][] Q) {
        int [][] C = new int[N][N];     
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {       
                C[i][j] = (int) Math.round(D[i][j]/Q[i][j]);
            }
        }     
        return C;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,createR,,9,15,9,3,0.2619,0.1033,0,5,3,0,1,"public double [][] createR (int [][] Q, int [][] C) {
        double [][] R = new double[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                R[i][j] = Q[i][j]*C[i][j];
            }
        }   
        return R;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,createN,,10,21,14,3,0.2,0.0807,0,7,3,0,1,"public int [][] createN (double [][] Tinv, double [][] R, double [][] T) {
        int [][] Nmatrix = new int [N][N];
        double [][] tmp = multiply(multiply(Tinv, R), T);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                Nmatrix[i][j] = (int) (Math.round(tmp[i][j])+128);
            }
        }
        return Nmatrix;
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,fillFilteredImage,,15,68,58,5,0.1346,0.0672,1,10,3,0,1,"public void fillFilteredImage (int i, int j, int[][] Nmatrix) {
        int xx =0;
        int yy =0;
        for (int x = i*N; x < i*N+N; x++) {
            for (int y = j*N; y < j*N+N; y++) {
                int alpha = new Color(originalImage.getRGB(x, y)).getAlpha();
                int color = Nmatrix[xx][yy];
                int rgb = ImageUtilities.colorToRGB(alpha, color, color, color);  
                yy++;
                filteredImage.setRGB(x, y, rgb);                        
            }
            xx++;
            yy=0;
        } 
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,tresholdDmatrix,,9,11,7,3,0.2619,0.0561,0,5,4,0,1,"public void tresholdDmatrix (double [][] D, double treshold) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                double coef = D[i][j];
                if (Math.abs(coef) < treshold) 
                    D[i][j] = 0;
            }
        }
    }"
neuroph,org.neuroph.imgrec.filter.impl.DenoiseDCTFilter,updateQ,,18,25,5,2,0.2625,0.1621,0,5,8,0,1,"public void updateQ(int [][] Q) {
        if (qualityLevel == 50)
            return;
        if (qualityLevel > 50) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    Q[i][j] = (int) Math.round(Q[i][j]*(100-qualityLevel)*1.0/50);
                }
            }
        }
        if (qualityLevel < 50) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    Q[i][j] = (int)Math.round(Q[i][j]*50.0/qualityLevel);
                }
            }
        }
    }"
neuroph,org.neuroph.imgrec.filter.impl.GaussianBluring,processImage,,36,84,48,3,0.1424,0.0689,1,12,3,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;
        
        int oldWidth = image.getWidth();
        int oldHeight = image.getHeight();
        
        int width = image.getWidth() - 2*radius;
        int height = image.getHeight() - 2*radius;
        
        
        
        
        
        filteredImage = new BufferedImage(width, height, originalImage.getType());
        
        createKernel();
        

        for (int i = radius; i < oldWidth - radius; i++) {
            for (int j = radius; j < oldHeight - radius; j++) {
                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                int newColor = getNewColor(i, j);
                int rgb = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
                
                int x = i-radius;
                int y = j-radius;
                filteredImage.setRGB(x,y, rgb);
                
            }
        }
  
        
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.GaussianBluring,createKernel,,23,29,0,1,0.2179,0.1592,0,11,5,0,1,"protected void createKernel() {
        
        int size = radius*2 + 1;
        int center = radius;
        kernel = new double [size][size];
        
        for (int i = 0; i < kernel.length; i++) {
            for (int j = 0; j < kernel[0].length; j++) {
                int distanceX = Math.abs(center - i);
                int distanceY = Math.abs(center - j);
                kernel [i][j] = gaussianFormula(distanceX, distanceY);
            }
        }
        
        double noralizationValue = getNormalizationValue(kernel);
        
        for (int i = 0; i < kernel.length; i++) {
            for (int j = 0; j < kernel[0].length; j++) {
                kernel[i][j] = kernel[i][j]*noralizationValue;
            }
        }
    
    }"
neuroph,org.neuroph.imgrec.filter.impl.GaussianBluring,gaussianFormula,,8,21,14,3,0.25,0.1049,0,5,1,0,1,"public double gaussianFormula (double x, double y) {
        double one = 1.0;
        double value = one/(2*Math.PI*sigma*sigma);
        double exp = -(x*x+y*y)/(2*sigma*sigma);
        exp = Math.pow(Math.E, exp);
        value = value*exp;
        return value;
    }"
neuroph,org.neuroph.imgrec.filter.impl.MaskSegmentationFilter,processImage,,40,194,135,3,0.1259,0.0584,0.666666667,12,4,1,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
		
        originalImage =  image;
		
	int width = originalImage.getWidth();
	int height = originalImage.getHeight();
		
	filteredImage = new BufferedImage(width, height, originalImage.getType());
		
	OtsuBinarizeFilter obf = new OtsuBinarizeFilter();
	BufferedImage tempImage = obf.processImage(originalImage);
		
	int gray;
	int alpha;
	int discreteColor;
	int newColor;
	int white = 255;
			
	for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
				
		gray = new Color(originalImage.getRGB(i, j)).getRed();
		alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
				
		discreteColor = new Color(tempImage.getRGB(i, j)).getRed();
                if (discreteColor == white) {
                    newColor = gray;
		}
		else {
                    newColor = white;
		}
		newColor = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
		filteredImage.setRGB(i, j, newColor);
	
            }
	}
		
	return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OtsuBinarizeFilter,processImage,,41,151,92,2,0.1402,0.0641,1,13,4,1,1,"@Override
	
    public BufferedImage processImage(BufferedImage image) {
		
        originalImage = image;
		
	int width = originalImage.getWidth();
	int height = originalImage.getHeight();
		
	filteredImage = new BufferedImage(width, height, originalImage.getType());
		
	int [] histogram = imageHistogram(originalImage);
		
	int totalNumberOfpixels = height*width;
		
	int treshold = treshold(histogram, totalNumberOfpixels);
		
	int black = 0;
	int white = 255;
		
	int alpha;
	int gray;
	int newColor;
		
	for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
		gray = new Color(originalImage.getRGB(i, j)).getRed();
		alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
				
		if (gray > treshold)
                    newColor = white;
		else
                    newColor = black;
				
		newColor = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
		filteredImage.setRGB(i, j, newColor);
            }
	}
		
	return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OtsuBinarizeFilter,imageHistogram,,15,12,9,3,0.2667,0.0889,0,6,4,0,1,"public int[] imageHistogram(BufferedImage image) {

	int[] histogram = new int[256];

	for (int i = 0; i < histogram.length; i++)
            histogram[i] = 0;

            for (int i = 0; i < image.getWidth(); i++) {
		for (int j = 0; j < image.getHeight(); j++) {
                    int gray = new Color(image.getRGB(i, j)).getRed();
                    histogram[gray]++;
		}
            }
        return histogram;
    }"
neuroph,org.neuroph.imgrec.filter.impl.OtsuBinarizeFilter,treshold,,34,182,133,3,0.1329,0.0765,0,13,6,0,1,"private int treshold(int [] histogram, int total) {
	float sum = 0;
	for (int i = 0; i < 256; i++)
            sum += i * histogram[i];

            float sumB = 0;
            int wB = 0;
            int wF = 0;

            float varMax = 0;
            int threshold = 0;

            for (int i = 0; i < 256; i++) {
		wB += histogram[i];
		if (wB == 0)
                    continue;
		wF = total - wB;

		if (wF == 0)
                    break;

		sumB += (float) (i * histogram[i]);
                float mB = sumB / wB;
                float mF = (sum - sumB) / wF;

                float varBetween = (float) wB * (float) wF * (mB - mF) * (mB - mF);

                if (varBetween > varMax) {
                    varMax = varBetween;
                    threshold = i;
                }
            }
	return threshold;
    }"
neuroph,org.neuroph.imgrec.filter.impl.GrayscaleFilter,processImage,,28,143,76,3,0.1577,0.0769,1,10,3,1,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
        originalImage = image;
        int alpha;
        int red;
        int green;
        int blue;
        int gray;
        int width = originalImage.getWidth();
        int height = originalImage.getHeight();
        filteredImage = new BufferedImage(width, height, originalImage.getType());
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                red = new Color(originalImage.getRGB(i, j)).getRed();
                green = new Color(originalImage.getRGB(i, j)).getGreen();
                blue = new Color(originalImage.getRGB(i, j)).getBlue();

                gray = (int) (0.21 * red + 0.71 * green + 0.07 * blue);

                gray = ImageUtilities.colorToRGB(alpha, gray, gray, gray);

                filteredImage.setRGB(i, j, gray);
            }
        }
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.NormalizationFilter,processImage,,54,228,156,3,0.1136,0.0566,1,10,6,1,1,"@Override

    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;

       

        width = originalImage.getWidth();
        height = originalImage.getHeight();

        filteredImage = new BufferedImage(width, height, originalImage.getType());
        imageMatrix = new int[width][height];

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                imageMatrix[i][j] = new Color(originalImage.getRGB(i, j)).getRed();

            }
        }
        
        mean = calculateMean();
        var = calculateVariance();
        
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                
                double normalizedPixel = 0;
                double squareError = 0;
                
                if (imageMatrix[i][j] > mean) {
                    squareError = (imageMatrix[i][j] - mean)*(imageMatrix[i][j]-mean);
                    normalizedPixel = (GOAL_MEAN + Math.sqrt(((GOAL_VARIANCE * squareError / var))));
                }
                else {
                    squareError = (imageMatrix[i][j] - mean)*(imageMatrix[i][j]-mean);
                    normalizedPixel = (GOAL_MEAN - Math.sqrt(((GOAL_VARIANCE * squareError / var))));
                }
                
                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                
                int rgb = (int)-normalizedPixel;
                
                int color = ImageUtilities.colorToRGB(alpha, rgb, rgb, rgb);
                
                filteredImage.setRGB(i, j, color);
                
            }
        }
        

        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.NormalizationFilter,calculateVariance,,11,8,1,2,0.3095,0.1006,0,3,3,0,1,"/**
     *
     * @param x x coordinate of block
     * @param y y coordinate of block
     * @return
     */
    public int calculateVariance() {

        int var = 0;
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                var += (imageMatrix[i][j]-mean)*(imageMatrix[i][j] - mean);
                
            }
        }
        return (int)var/ (height*width*255); //255 for white color
    }"
neuroph,org.neuroph.imgrec.filter.impl.NormalizationFilter,calculateMean,,12,14,7,3,0.2857,0.0825,0,3,3,0,1,"public int calculateMean() {
        double mean = 0;

        for (int i = 0; i < width; i++) {
            for (int j = 0 ; j < height; j++) {
                mean += imageMatrix[i][j];

            }
        }

        return (int) mean / (width*height);
    }"
neuroph,org.neuroph.imgrec.filter.impl.LetterSeparationFilter,processImage,,58,337,239,2,0.1091,0.0579,1,17,7,1,1,"/**
 * radi otsu da dobije spojena crna slova i ra
 * @param image
 * @return 
 */
    @Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;

        int width = originalImage.getWidth();
        int height = originalImage.getHeight();

        boolean[][] matrix = new boolean[width][height]; // black n white oolean matrix; true = blck, false = white

        filteredImage = new BufferedImage(width, height, originalImage.getType());

        int[] histogram = imageHistogram(originalImage);

        int totalNumberOfpixels = height * width;

        int threshold = threshold(histogram, totalNumberOfpixels);

        int black = 0;
        int white = 255;

        int gray;
        int alpha;
        int newColor;

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                gray = new Color(originalImage.getRGB(i, j)).getRed();

                if (gray > threshold) {
                    matrix[i][j] = false;
                } else {
                    matrix[i][j] = true;
                }

            }
        }

        int blackTreshold = letterThreshold(originalImage, matrix);

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                gray = new Color(originalImage.getRGB(i, j)).getRed();
                alpha = new Color(originalImage.getRGB(i, j)).getAlpha();

                if (gray > blackTreshold) {
                    newColor = white;
                } else {
                    newColor = black;
                }

                newColor = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
                filteredImage.setRGB(i, j, newColor);
            }
        }

        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.LetterSeparationFilter,imageHistogram,,16,20,12,3,0.25,0.1429,0,6,4,0,1,"// hitoram from otsu method for grayscae dimage
    public int[] imageHistogram(BufferedImage image) {

        int[] histogram = new int[256];

        for (int i = 0; i < histogram.length; i++) {
            histogram[i] = 0;
        }

        for (int i = 0; i < image.getWidth(); i++) {
            for (int j = 0; j < image.getHeight(); j++) {
                int gray = new Color(image.getRGB(i, j)).getRed();
                histogram[gray]++;
            }
        }
        return histogram;
    }"
neuroph,org.neuroph.imgrec.filter.impl.LetterSeparationFilter,letterThreshold,,21,53,40,4,0.1771,0.0987,0,7,5,0,1,"public int letterThreshold(BufferedImage original, boolean[][] matrix) {
        double sum = 0;
        int count = 0;

        for (int i = 0; i < original.getWidth(); i++) {
            for (int j = 0; j < original.getHeight(); j++) {

                if (matrix[i][j] == true) {
                    int gray = new Color(original.getRGB(i, j)).getRed();
                    sum += gray;
                    count++;
                }
            }
        }

        if (count == 0) {
            return 0;
        }

        return (int) Math.round((sum * 3) / (count * 2)); // 3 i 2 su plinkove konstnte
    }"
neuroph,org.neuroph.imgrec.filter.impl.LetterSeparationFilter,threshold,,37,203,153,3,0.1304,0.0712,0,13,6,0,1,"// thresold po otsu metodi
    private int threshold(int[] histogram, int total) {
        float sum = 0;
        for (int i = 0; i < 256; i++) {
            sum += i * histogram[i];
        }

        float sumB = 0;
        int wB = 0;
        int wF = 0;

        float varMax = 0;
        int threshold = 0;

        for (int i = 0; i < 256; i++) {
            wB += histogram[i];
            if (wB == 0) {
                continue;
            }
            wF = total - wB;

            if (wF == 0) {
                break;
            }

            sumB += (float) (i * histogram[i]);
            float mB = sumB / wB;
            float mF = (sum - sumB) / wF;

            float varBetween = (float) wB * (float) wF * (mB - mF) * (mB - mF);

            if (varBetween > varMax) {
                varMax = varBetween;
                threshold = i;
            }
        }
        return threshold;
    }"
neuroph,org.neuroph.imgrec.filter.impl.LetterSeparationFilter,numberOfBlackPixels,,13,22,16,4,0.25,0.142,0,4,4,0,1,"public int numberOfBlackPixels(boolean[][] matrix) {
        int count = 0;
        for (int i = 0; i < originalImage.getWidth(); i++) {
            for (int j = 0; j < originalImage.getHeight(); j++) {

                if (matrix[i][j] == false) {
                    count++;
                }

            }
        }
        return count;
    }"
neuroph,org.neuroph.imgrec.filter.impl.AdaptiveThresholdBinarizeFilter,processImage,,98,1207,929,2,0.078,0.0507,1,22,12,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;

        int width = originalImage.getWidth();
        int height = originalImage.getHeight();

        filteredImage = new BufferedImage(width, height, originalImage.getType());

        int alpha;
        double gray;

        double[][] G = new double[width][height]; //Integral sum G

        gray = new Color(originalImage.getRGB(0, 0)).getRed();
        G[0][0] = gray / 255;

        for (int i = 1; i < width; i++) {
            gray = new Color(originalImage.getRGB(i, 0)).getRed();
            G[i][0] = G[i - 1][0] + gray / 255;
        }
        for (int j = 1; j < height; j++) {
            gray = new Color(originalImage.getRGB(0, j)).getRed();
            G[0][j] = G[0][j - 1] + gray / 255;
        }
        for (int i = 1; i < width; i++) {
            for (int j = 1; j < height; j++) {
                gray = new Color(originalImage.getRGB(i, j)).getRed();
                G[i][j] = gray / 255 + G[i][j - 1] + G[i - 1][j] - G[i - 1][j - 1];
            }
        }

        int d = windowSize / 2;

        int A = 0;
        int B = 0;
        int C = 0;
        int D = 0;

        double s;
        double m;
        double delta;
        double treshold;

        int newColor;

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                if (i + d - 1 >= width) {
                    A = width - 1;
                } else {
                    A = i + d - 1;
                }

                if (j + d - 1 >= height) {
                    B = height - 1;
                } else {
                    B = j + d - 1;
                }

                if (i - d < 0) {
                    C = 0;
                } else {
                    C = i - d;
                }

                if (j - d < 0) {
                    D = 0;
                } else {
                    D = j - d;
                }

                s = (G[A][B] + G[C][D]) - (G[C][B] + G[A][D]);
                m = s / (windowSize * windowSize);

                gray = new Color(originalImage.getRGB(i, j)).getRed();

                delta = gray / 255 - m;

                treshold = m * (1 + k * (delta / (1.0 - delta) - 1));

                if (gray / 255 > treshold) {
                    newColor = 255;
                } else {
                    newColor = 0;
                }

                alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                newColor = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);

                filteredImage.setRGB(i, j, newColor);
            }
        }

        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.MeanFilter,processImage,,27,27,9,1,0.225,0.0964,1,8,3,0,1,"    public BufferedImage processImage(BufferedImage image) {
    
        originalImage = image;
        
        int width = originalImage.getWidth();
        int height = originalImage.getHeight();
        
        filteredImage = new BufferedImage(width, height, originalImage.getType());
        
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                
                int color = findMean(i, j);
                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                
                int rgb = ImageUtilities.colorToRGB(alpha, color, color, color);
                filteredImage.setRGB(i, j, rgb);
                
            }
        }
        
        
        return filteredImage;
        
        
    }"
neuroph,org.neuroph.imgrec.filter.impl.MeanFilter,findMean,,14,45,35,4,0.157,0.0642,0,7,7,0,1,"public int findMean (int x, int y) {       
        double sum = 0;
        int n = 0;  
        for (int i = x-radius; i <= x+radius; i++) {
            for (int j = y-radius; j <= y+radius; j++) {              
                if (i>0 && i<originalImage.getWidth() && j>0 && j<originalImage.getHeight()) {                
                    int color = new Color(originalImage.getRGB(i, j)).getRed(); // why we use only red component here?
                    sum = sum + color;
                    n++;
                }   
            }
        }
        return (int) Math.round(sum/n);      
    }"
neuroph,org.neuroph.imgrec.filter.impl.SobelEdgeDetection,processImage,,56,245,190,3,0.1073,0.0446,1,14,7,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
        
        originalImage = image;
        
        int width = image.getWidth();
        int height = image.getHeight();
        
        filteredImage = new BufferedImage(width, height, image.getType());
        
        treshold = 0.1;
        generateSobelOperators();
        
        double [][] Gx = new double[width][height];
        double [][] Gy = new double[width][height];
        double [][] G = new double[width][height];
        
        double max = 0;
        
        for (int i = 1; i < width-1; i++) {
            for (int j = 1; j < height-1; j++) {
                
                Gx[i][j] = calculateGradient(i, j, sobelX);
                Gy[i][j] = calculateGradient(i, j, sobelY);
                
                G[i][j] = Math.abs(Gx[i][j]) + Math.abs(Gy[i][j]);
                
                if (G[i][j] > max)
                    max = G[i][j];
                
                
            }
            
        }
        
        
        treshold = treshold*max;
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                
                int newColor;
                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                
                if (G[i][j] > treshold)
                    newColor = 0;
                else
                    newColor = 255;
               
                int rgb = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
                filteredImage.setRGB(i, j, rgb);
                
            }
        }
      
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.SobelEdgeDetection,generateSobelOperators,,27,65,10,1,0.3,0.2597,0,2,1,0,1,"protected void generateSobelOperators () {
        
        sobelX = new double[3][3];
        sobelX [0][0] = -0.25;  sobelX [0][1] = -0.5;  sobelX [0][2] = -0.25;
        sobelX [1][0] = 0;      sobelX [1][1] = 0;     sobelX [1][2] = 0;
        sobelX [2][0] = 0.25;   sobelX [2][1] = 0.5;   sobelX [2][2] = 0.25;
        
        sobelY = new double[3][3];
        sobelY [0][0] = -0.25;  sobelY [0][1] = 0;  sobelY [0][2] = 0.25;
        sobelY [1][0] = -0.5;   sobelY [1][1] = 0;  sobelY [1][2] = 0.5;
        sobelY [2][0] = -0.25;  sobelY [2][1] = 0;  sobelY [2][2] = 0.25;
 
        
        double one = 1;
        double oneThird = one/3;
        
        
        sobelX [0][0] = -oneThird;  sobelX [0][1] = -oneThird;  sobelX [0][2] = -oneThird;
        sobelX [1][0] = 0;          sobelX [1][1] = 0;          sobelX [1][2] = 0;
        sobelX [2][0] = oneThird;   sobelX [2][1] = oneThird;   sobelX [2][2] = oneThird;
        
        sobelY [0][0] = -oneThird;   sobelY [0][1] = 0;  sobelY [0][2] = oneThird;
        sobelY [1][0] = -oneThird;   sobelY [1][1] = 0;  sobelY [1][2] = oneThird;
        sobelY [2][0] = -oneThird;   sobelY [2][1] = 0;  sobelY [2][2] = oneThird;
        
        
    }"
neuroph,org.neuroph.imgrec.filter.impl.SobelEdgeDetection,calculateGradient,,19,56,46,5,0.1417,0.0672,0,9,3,0,1,"protected double calculateGradient (int i, int j, double [][] sobelOperator) {           
    	double sum = 0;
        
        int posX = 0;
        for (int x = i-1; x <= i+1; x++) {
            
            int posY = 0;
            for (int y = j-1; y <= j+1; y++) {
                
                double gray = new Color(originalImage.getRGB(x, y)).getRed();
                
                sum = sum + gray*sobelOperator[posX][posY];
                posY++;
            }
            posX++;
        }
        
        return sum;
    }"
neuroph,org.neuroph.imgrec.filter.impl.GaussianNoise,processImage,,52,140,109,2,0.11,0.0475,1,15,6,1,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
        
        
        double variance = sigma*sigma;
        
        originalImage = image;
        
        int width = originalImage.getWidth();
        int height = originalImage.getHeight();
        
        filteredImage = new BufferedImage(width, height, originalImage.getType());
        
        double a = 0.0;
        double b = 0.0;
        
        
        
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                
                while (a == 0.0)
                    a = Math.random();
                b = Math.random();
                
                double x = Math.sqrt(-2*Math.log(a)) * Math.cos(2*Math.PI*b);
                double noise = mean + Math.sqrt(variance) * x;
                
                //
                //
                
                int gray = new Color(originalImage.getRGB(i, j)).getRed();
                int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                
                double color = gray + noise;
                if (color > 255)
                    color = 255;
                if (color < 0)
                    color = 0;
                
                int newColor = (int) Math.round(color);
                
                int rgb = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
                
                filteredImage.setRGB(i, j, rgb);                
                
            }//j
        }//i
        
        
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.HistogramEqualizationFilter,processImage,,41,150,90,2,0.1402,0.0661,1,12,4,1,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
		
	originalImage = image;
		
	int width = originalImage.getWidth();
	int height = originalImage.getHeight();
		
	filteredImage = new BufferedImage(width, height, originalImage.getType());
		
	int [] histogram = imageHistogram(originalImage);
		
	int [] histogramCumulative = new int[histogram.length];
		
	histogramCumulative[0] = histogram[0];
	for (int i = 1; i < histogramCumulative.length; i++) {
            histogramCumulative[i] = histogramCumulative[i-1] + histogram[i];
	}
		
	int G = 256;
	int gray;
	int alpha;
		
	int newColor;
		
	for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
				
		gray = new Color(originalImage.getRGB(i, j)).getRed();
		alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
				
		newColor = (G-1)*histogramCumulative[gray]/(width*height); //zaokruziti izbeci celobrojno deljenje

				
		newColor = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
		filteredImage.setRGB(i, j, newColor);
            }
	}
		
	return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.HistogramEqualizationFilter,imageHistogram,,16,12,9,3,0.2667,0.0889,0,6,4,0,1,"public int[] imageHistogram(BufferedImage image) {

	int[] histogram = new int[256];

	for (int i = 0; i < histogram.length; i++)
            histogram[i] = 0;

	for (int i = 0; i < image.getWidth(); i++) {
            for (int j = 0; j < image.getHeight(); j++) {
		int gray = new Color(image.getRGB(i, j)).getRed();
		histogram[gray]++;
            }
	}

	return histogram;
    }"
neuroph,org.neuroph.imgrec.filter.impl.Dilation,processImage,,30,116,96,4,0.1255,0.0421,1,8,4,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {
        
        originalImage = image;
        
        width = originalImage.getWidth();
        height = originalImage.getHeight();
        
        filteredImage = new BufferedImage(width, height, originalImage.getType());
        
        kernel = createKernel();
        
        int white = 255;
        int black = 0;
        
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                int color = new Color(originalImage.getRGB(i, j)).getRed();
                if (color == black) {
                    convolve(i, j);
                }
                else {
                    int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
                    int rgb = ImageUtilities.colorToRGB(alpha, white, white, white);
                    filteredImage.setRGB(i, j, rgb);
                }         
            }
        }
        return filteredImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.Dilation,createKernel,,9,1,1,2,0.5,0,0,1,1,1,0,"private int [][] createKernel () {
        int [][] kernel = { {0,1,1,1,0},
                            {1,1,1,1,1},
                            {1,1,1,1,1},
                            {1,1,1,1,1},
                            {0,1,1,1,0}
                          };
        return kernel;
    }"
neuroph,org.neuroph.imgrec.filter.impl.Dilation,convolve,,12,28,20,3,0.1818,0.0507,1,7,7,0,1,"private void convolve (int i, int j) {
        for (int x = i-2; x <= i+2; x++) {
            for (int y = j-2; y <= j+2; y++) {
                if (x>=0 && y>=0 && x<width && y<height) {
                    int black = 0;
                    int alpha = new Color(originalImage.getRGB(x, y)).getAlpha();
                    int rgb = ImageUtilities.colorToRGB(alpha, black, black, black);
                    filteredImage.setRGB(x, y, rgb);
                }
            }
        }
    }"
neuroph,org.neuroph.imgrec.filter.impl.LetterSegmentationFilter,processImage,,30,89,58,2,0.1648,0.1032,0,5,5,0,1,"@Override
    public BufferedImage processImage(BufferedImage image) {

        originalImage = image;
        width = originalImage.getWidth();
        height = originalImage.getHeight();

        visited = new boolean[width][height];

        int name = 1;

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {

                int color = new Color(originalImage.getRGB(i, j)).getRed();
                if (color == 255) {
                    visited[i][j] = true;
                } else {
                    if (name > 3000) {
                        return originalImage;
                    }
                    BFS(i, j, name + """");
                    name++;
                }

            }
        }

        return originalImage;
    }"
neuroph,org.neuroph.imgrec.filter.impl.LetterSegmentationFilter,BFS,,76,1071,966,6,0.0606,0.0334,1,28,15,0,1,"public void BFS(int startI, int startJ, String imageName) {
        LinkedList<String> queue = new LinkedList<String>();

        //=============================================================================
        int letterWidth = 80;
        int letterHeight = 80;
        int gapX = 30;
        int gapY = 30;
        BufferedImage letter = new BufferedImage(letterWidth, letterHeight, BufferedImage.TYPE_BYTE_BINARY);
        int alpha = new Color(originalImage.getRGB(startI, startJ)).getAlpha();
        int white = ImageUtilities.colorToRGB(alpha, 255, 255, 255);
        int black = ImageUtilities.colorToRGB(alpha, 0, 0, 0);
        for (int i = 0; i < letterWidth; i++) {
            for (int j = 0; j < letterHeight; j++) {
                letter.setRGB(i, j, white);

            }
        }
        //=============================================================================

        int count = 0;
        String positions = startI + "" "" + startJ;
        visited[startI][startJ] = true;
        queue.addLast(positions);

        while (!queue.isEmpty()) {
            String pos = queue.removeFirst();
            String[] posArray = pos.split("" "");
            int x = Integer.parseInt(posArray[0]);
            int y = Integer.parseInt(posArray[1]);
            visited[x][y] = true;

            //set black pixel to letter image===================================
            int posX = startI - x + gapX;
            int posY = startJ - y + gapY;

            count++;
            try {
                letter.setRGB(posX, posY, black);
            } catch (Exception e) {
                e.printStackTrace();
                System.out.println(""posX "" + posX);
                System.out.println(""posY "" + posY);
                System.out.println(""letterWidth "" + letter.getWidth());
                System.out.println(""letterHeight "" + letter.getHeight());
                throw e;
            }
            //==================================================================
            for (int i = x - 1; i <= x + 1; i++) {
                for (int j = y - 1; j <= y + 1; j++) {
                    if (i >= 0 && j >= 0 && i < originalImage.getWidth() && j < originalImage.getHeight()) {
                        if (!visited[i][j]) {
                            int color = new Color(originalImage.getRGB(i, j)).getRed();
                            if (color < 10) {
                                visited[i][j] = true;
                                String tmpPos = i + "" "" + j;
                                queue.addLast(tmpPos);
                            }
                        }
                    }
                } //i
            } //j
        }

        System.out.println(""count = "" + count);
        //save letter=========================================================== 
        if (count < 3) {
            return;
        }
        try {
            saveToFile(letter, imageName);
            //
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }"
neuroph,org.neuroph.imgrec.image.ImageFactory,createImage,,11,25,22,5,0.1719,0.0537,0,4,2,0,1,"public static Image createImage(Integer width, Integer height, Integer imageType) {
        try {
            constructor = imageClass.getDeclaredConstructor(new Class[]{Integer.class, Integer.class, Integer.class});
            constructor.setAccessible(true);
            image = (Image) constructor.newInstance(width, height, imageType);
        } catch (Exception e) {
            handleException(e);
        }

        return image;
    }"
neuroph,org.neuroph.imgrec.image.ImageAndroid,imageTypeToBitmapConfig,,18,56,46,3,0.4167,0.2222,0,2,4,0,1,"private Bitmap.Config imageTypeToBitmapConfig(int imageType) throws IllegalArgumentException {
        Bitmap.Config bitmapConfig = null;
        switch (imageType) {
            case ImageType.ANDROID_TYPE_ALPHA_8:
                bitmapConfig = Bitmap.Config.ALPHA_8;
                break;
            case ImageType.ANDROID_TYPE_ARGB_8888:
                bitmapConfig = Bitmap.Config.ARGB_8888;
                break;
            case ImageType.ANDROID_TYPE_RGB_565:
                bitmapConfig = Bitmap.Config.RGB_565;
                break;
            default:
                throw new IllegalArgumentException(""Illegal image type, image type: "" + imageType);
        }

        return bitmapConfig;
    }"
neuroph,org.neuroph.nnet.Kohonen,createNetwork,,33,15,2,2,0.2083,0.1116,0.75,6,1,0,1,"/**
	 * Creates Kohonen network architecture with specified number of neurons in
	 * input and map layer
	 * 
	 * @param inputNeuronsCount
	 *            number of neurons in input layer
	 * @param outputNeuronsCount
	 *            number of neurons in output layer
	 */
	private void createNetwork(int inputNeuronsCount, int outputNeuronsCount) {

		// specify input neuron properties (use default: weighted sum input with
		// linear transfer)
		NeuronProperties inputNeuronProperties = new NeuronProperties();

		// specify map neuron properties
		NeuronProperties outputNeuronProperties = new NeuronProperties(
                                            Neuron.class,        // neuron type
                                            Difference.class,   // input function
                                            Linear.class       // transfer function
                                                    );
		// set network type
		this.setNetworkType(NeuralNetworkType.KOHONEN);

		// createLayer input layer
		Layer inLayer = LayerFactory.createLayer(inputNeuronsCount,
				inputNeuronProperties);
		this.addLayer(inLayer);

		// createLayer map layer
		Layer mapLayer = LayerFactory.createLayer(outputNeuronsCount,
				outputNeuronProperties);
		this.addLayer(mapLayer);

		// createLayer full connectivity between input and output layer
		ConnectionFactory.fullConnect(inLayer, mapLayer);

		// set network input and output cells
		NeuralNetworkFactory.setDefaultIO(this);

		this.setLearningRule(new KohonenLearning());
	}"
neuroph,org.neuroph.nnet.Hopfield,Hopfield,,12,7,0,2,0.325,0.381,0.5,2,1,0,1,"/**
	 * Creates new Hopfield network with specified neuron number
	 * 
	 * @param neuronsCount
	 *            neurons number in Hopfied network
	 */
	public Hopfield(int neuronsCount) {

		// init neuron settings for hopfield network
		NeuronProperties neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""neuronType"", InputOutputNeuron.class);
		neuronProperties.setProperty(""bias"", new Double(0));
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.STEP);
		neuronProperties.setProperty(""transferFunction.yHigh"", new Double(1));
		neuronProperties.setProperty(""transferFunction.yLow"", new Double(0));

		this.createNetwork(neuronsCount, neuronProperties);
	}"
neuroph,org.neuroph.nnet.Instar,createNetwork,,27,33,11,2,0.1901,0.1288,0.666666667,4,1,0,1,"/**
	 * Creates Instar architecture with specified number of input neurons
	 * 
	 * @param inputNeuronsCount
	 *            number of neurons in input layer
	 */
	private void createNetwork(int inputNeuronsCount ) {

		// set network type
		this.setNetworkType(NeuralNetworkType.INSTAR);

		// init neuron settings for this type of network
		NeuronProperties neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.STEP);
		
		// create input layer
		Layer inputLayer = LayerFactory.createLayer(inputNeuronsCount, neuronProperties);
		this.addLayer(inputLayer);

		// createLayer output layer
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.STEP);
		Layer outputLayer = LayerFactory.createLayer(1,	neuronProperties);
		this.addLayer(outputLayer);

		// create full conectivity between input and output layer
		ConnectionFactory.fullConnect(inputLayer, outputLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);

		// set appropriate learning rule for this network
		this.setLearningRule(new InstarLearning());
	}"
neuroph,org.neuroph.nnet.Perceptron,createNetwork,,36,39,12,1,0.1471,0.1144,0.7,6,1,0,1,"/**
	 * Creates perceptron architecture with specified number of neurons in input
	 * and output layer, specified transfer function
	 * 
	 * @param inputNeuronsCount
	 *            number of neurons in input layer
	 * @param outputNeuronsCount
	 *            number of neurons in output layer
	 * @param transferFunctionType
	 *            neuron transfer function type
	 */
	private void createNetwork(int inputNeuronsCount, int outputNeuronsCount, TransferFunctionType transferFunctionType) {
		// set network type
		this.setNetworkType(NeuralNetworkType.PERCEPTRON);

                Layer inputLayer = new InputLayer(inputNeuronsCount);
		this.addLayer(inputLayer);

		NeuronProperties outputNeuronProperties = new NeuronProperties();
		outputNeuronProperties.setProperty(""neuronType"", ThresholdNeuron.class);
		outputNeuronProperties.setProperty(""thresh"", new Double(Math.abs(Math.random())));
		outputNeuronProperties.setProperty(""transferFunction"", transferFunctionType);
		// for sigmoid and tanh transfer functions set slope propery
		outputNeuronProperties.setProperty(""transferFunction.slope"", new Double(1));

		// createLayer output layer
		Layer outputLayer = LayerFactory.createLayer(outputNeuronsCount, outputNeuronProperties);
		this.addLayer(outputLayer);

		// create full conectivity between input and output layer
		ConnectionFactory.fullConnect(inputLayer, outputLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);
                
                this.setLearningRule(new BinaryDeltaRule());
		// set appropriate learning rule for this network
//		if (transferFunctionType == TransferFunctionType.STEP) {
//			this.setLearningRule(new BinaryDeltaRule(this));
//		} else if (transferFunctionType == TransferFunctionType.SIGMOID) {
//			this.setLearningRule(new SigmoidDeltaRule(this));
//		} else if (transferFunctionType == TransferFunctionType.TANH) {
//			this.setLearningRule(new SigmoidDeltaRule(this));
//		} else {
//			this.setLearningRule(new PerceptronLearning(this));
//		}
	}"
neuroph,org.neuroph.nnet.SupervisedHebbianNetwork,createNetwork,,34,68,16,2,0.1473,0.1624,0.666666667,6,1,0,1,"/**
	 *Creates an instance of Supervised Hebbian Network with specified number
	 * of neurons in input layer, output layer and transfer function
	 * 
	 * @param inputNeuronsNum
	 *            number of neurons in input layer
	 * @param outputNeuronsNum
	 *            number of neurons in output layer
	 * @param transferFunctionType
	 *            transfer function type
	 */
	private void createNetwork(int inputNeuronsNum, int outputNeuronsNum,
		TransferFunctionType transferFunctionType) {

		// init neuron properties
		NeuronProperties neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""transferFunction"", transferFunctionType);
		neuronProperties.setProperty(""transferFunction.slope"", new Double(1));
		neuronProperties.setProperty(""transferFunction.yHigh"", new Double(1));
		neuronProperties.setProperty(""transferFunction.xHigh"", new Double(1));		
		neuronProperties.setProperty(""transferFunction.yLow"", new Double(-1));
		neuronProperties.setProperty(""transferFunction.xLow"", new Double(-1));
		
		// set network type code
		this.setNetworkType(NeuralNetworkType.SUPERVISED_HEBBIAN_NET);

		// createLayer input layer
		Layer inputLayer = LayerFactory.createLayer(inputNeuronsNum,
			neuronProperties);
		this.addLayer(inputLayer);

		// createLayer output layer
		Layer outputLayer = LayerFactory.createLayer(outputNeuronsNum,
			neuronProperties);
		this.addLayer(outputLayer);

		// createLayer full conectivity between input and output layer
		ConnectionFactory.fullConnect(inputLayer, outputLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);

		// set appropriate learning rule for this network
		this.setLearningRule(new SupervisedHebbianLearning());
	}"
neuroph,org.neuroph.nnet.UnsupervisedHebbianNetwork,createNetwork,,34,33,11,2,0.1748,0.1142,0.666666667,6,1,0,1,"/**
	 * Creates an instance of Unsuervised Hebian net with specified number
	 * of neurons in input layer and output layer, and transfer function
	 * 
	 * @param inputNeuronsNum
	 *            number of neurons in input layer
	 * @param outputNeuronsNum
	 *            number of neurons in output layer
	 * @param transferFunctionType
	 *            transfer function type
	 */
	private void createNetwork(int inputNeuronsNum, int outputNeuronsNum,
		TransferFunctionType transferFunctionType) {

		// init neuron properties
		NeuronProperties neuronProperties = new NeuronProperties();
//		neuronProperties.setProperty(""bias"", new Double(-Math
//				.abs(Math.random() - 0.5))); // Hebbian network cann not work
		// without bias
		neuronProperties.setProperty(""transferFunction"", transferFunctionType);
		neuronProperties.setProperty(""transferFunction.slope"", new Double(1));

		// set network type code
		this.setNetworkType(NeuralNetworkType.UNSUPERVISED_HEBBIAN_NET);

		// createLayer input layer
		Layer inputLayer = LayerFactory.createLayer(inputNeuronsNum,
			neuronProperties);
		this.addLayer(inputLayer);

		// createLayer output layer
		Layer outputLayer = LayerFactory.createLayer(outputNeuronsNum,
			neuronProperties);
		this.addLayer(outputLayer);

		// createLayer full conectivity between input and output layer
		ConnectionFactory.fullConnect(inputLayer, outputLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);

		// set appropriate learning rule for this network
		this.setLearningRule(new UnsupervisedHebbianLearning());
	//this.setLearningRule(new OjaLearning(this));
	}"
neuroph,org.neuroph.nnet.JordanNetwork,createNetwork,,36,125,79,3,0.1257,0.0801,0.727272727,9,1,0,1,"// three layers: input, hidden, output
    // as mlp add context layer
    // jordan  connect output of output  layer to input of context layer
    // output of context to input of hidden layer 
    
    
    
        
    
	private void createNetwork(int inputNeuronsCount, int hiddenNeuronsCount, int contextNeuronsCount, int outputNeuronsCount) {

                // create input layer
                InputLayer inputLayer = new InputLayer(inputNeuronsCount);
                inputLayer.addNeuron(new BiasNeuron());
                addLayer(inputLayer);
                
		NeuronProperties neuronProperties = new NeuronProperties();
               // neuronProperties.setProperty(""useBias"", true);
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.SIGMOID);      // use linear or logitic function! (TR-8604.pdf)          
            
                Layer hiddenLayer = new Layer(hiddenNeuronsCount, neuronProperties); 
                hiddenLayer.addNeuron(new BiasNeuron());
                addLayer(hiddenLayer);
                
                ConnectionFactory.fullConnect(inputLayer, hiddenLayer);
                
                Layer contextLayer = new Layer(contextNeuronsCount, neuronProperties); 
                addLayer(contextLayer); // we might also need bias for context neurons?
                                                                               
                Layer outputLayer = new Layer(outputNeuronsCount, neuronProperties); 
                addLayer(outputLayer);
                
                ConnectionFactory.fullConnect(hiddenLayer, outputLayer);
                
                ConnectionFactory.fullConnect(outputLayer, contextLayer);
                ConnectionFactory.fullConnect(contextLayer, hiddenLayer);
                
                                
		// set input and output cells for network
                  NeuralNetworkFactory.setDefaultIO(this);

                  // set learnng rule
		this.setLearningRule(new BackPropagation());
				
	}"
neuroph,org.neuroph.nnet.CompetitiveNetwork,createNetwork,,32,65,39,2,0.1381,0.1064,0.7,6,1,0,1,"/**
	 * Creates Competitive network architecture
	 * 
	 * @param inputNeuronsCount
	 *            input neurons number
         * @param outputNeuronsCount
         *            output neurons number
	 * @param neuronProperties
	 *            neuron properties
	 */
	private void createNetwork(int inputNeuronsCount, int outputNeuronsCount) {
		// set network type
		this.setNetworkType(NeuralNetworkType.COMPETITIVE);

		// createLayer input layer
		Layer inputLayer = LayerFactory.createLayer(inputNeuronsCount, new NeuronProperties());
		this.addLayer(inputLayer);

		// createLayer properties for neurons in output layer
		NeuronProperties neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""neuronType"", CompetitiveNeuron.class);
		neuronProperties.setProperty(""inputFunction"",	WeightedSum.class);
		neuronProperties.setProperty(""transferFunction"",TransferFunctionType.RAMP);

		// createLayer full connectivity in competitive layer
		CompetitiveLayer competitiveLayer = new CompetitiveLayer(outputNeuronsCount, neuronProperties);

		// add competitive layer to network
		this.addLayer(competitiveLayer);

		double competitiveWeight = -(1 / (double) outputNeuronsCount);
		// createLayer full connectivity within competitive layer
		ConnectionFactory.fullConnect(competitiveLayer, competitiveWeight, 1);

		// createLayer full connectivity from input to competitive layer
		ConnectionFactory.fullConnect(inputLayer, competitiveLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);

		this.setLearningRule(new CompetitiveLearning());
	}"
neuroph,org.neuroph.nnet.NeuroFuzzyPerceptron,createStudentNFR,,126,2193,1971,5,0.0465,0.0325,0.529411765,39,12,0,1,"// build example network for student classification
	private void createStudentNFR(int inputNum, List<Integer> inputSets, int outNum,
			double[][] pointsSets, double[][] timeSets) {

		// set network type
		this.setNetworkType(NeuralNetworkType.NEURO_FUZZY_REASONER);

		// createLayer input layer
		NeuronProperties neuronProperties = new NeuronProperties();
		Layer inLayer = LayerFactory.createLayer(inputNum, neuronProperties);
		this.addLayer(inLayer);

		// createLayer fuzzy set layer
		neuronProperties.setProperty(""transferFunction"",
				TransferFunctionType.TRAPEZOID);
		Iterator<Integer> e = inputSets.iterator();
		int fuzzySetsNum = 0;
		while (e.hasNext()) {
			Integer i = e.next();
			fuzzySetsNum = fuzzySetsNum + i.intValue();
		}
		Layer setLayer = LayerFactory.createLayer(fuzzySetsNum,
				neuronProperties);
		this.addLayer(setLayer);

		// TODO: postavi parametre funkcija pripadnosti
		// nizove sa trning elementima iznesi van klase i prosledjuj ih kao
		// parametre
//		Iterator<Neuron> ii = setLayer.getNeuronsIterator();
		Iterator<Integer> en;// =setLayer.neurons();
		int c = 0;
                for(Neuron cell : setLayer.getNeurons()) {
//		while (ii.hasNext()) {
//			Neuron cell = ii.next();
			Trapezoid tf = (Trapezoid) cell.getTransferFunction();

			if (c <= 3) {
				tf.setLeftLow(pointsSets[c][0]);
				tf.setLeftHigh(pointsSets[c][1]);
				tf.setRightLow(pointsSets[c][3]);
				tf.setRightHigh(pointsSets[c][2]);
			} else {
				tf.setLeftLow(timeSets[c - 4][0]);
				tf.setLeftHigh(timeSets[c - 4][1]);
				tf.setRightLow(timeSets[c - 4][3]);
				tf.setRightHigh(timeSets[c - 4][2]);
			}
			c++;
		}

		// povezi prvi i drugi sloj
		int s = 0; // brojac celija sloja skupova (fazifikacije)
		for (int i = 0; i < inputNum; i++) { // brojac ulaznih celija
			Neuron from = inLayer.getNeuronAt(i);
			int jmax = inputSets.get(i).intValue();
			for (int j = 0; j < jmax; j++) {
				Neuron to = setLayer.getNeuronAt(s);
				ConnectionFactory.createConnection(from, to, 1);
				s++;
			}
		}

		// ----------------------------------------------------------

		// createLayer rules layer
		NeuronProperties ruleNeuronProperties = new NeuronProperties(
                        Neuron.class,
                        WeightedSum.class,
                        Linear.class);
		en = inputSets.iterator();
		int fuzzyAntNum = 1;
		while (en.hasNext()) {
			Integer i = en.next();
			fuzzyAntNum = fuzzyAntNum * i.intValue();
		}
		Layer ruleLayer = LayerFactory.createLayer(fuzzyAntNum,
				ruleNeuronProperties);
		this.addLayer(ruleLayer);

		int scIdx = 0; // set cell index

		for (int i = 0; i < inputNum; i++) { // brojac ulaza (grupa fuzzy
												// skupova)
			int setsNum = inputSets.get(i).intValue();

			for (int si = 0; si < setsNum; si++) { // brojac celija fuzzy
													// skupova
				if (i == 0) {
					Neuron from = setLayer.getNeuronAt(si);
					int connPerCell = fuzzyAntNum / setsNum;
					scIdx = si;

					for (int k = 0; k < connPerCell; k++) { // brojac celija
															// hipoteza
						Neuron to = ruleLayer.getNeuronAt(si * connPerCell + k);
						ConnectionFactory.createConnection(from, to, 1);
					} // for
				} // if
				else {
					scIdx++;
					Neuron from = setLayer.getNeuronAt(scIdx);
					int connPerCell = fuzzyAntNum / setsNum;

					for (int k = 0; k < connPerCell; k++) { // brojac celija
															// hipoteza
						int toIdx = si + k * setsNum;
						Neuron to = ruleLayer.getNeuronAt(toIdx);
						ConnectionFactory.createConnection(from, to, 1);
					} // for k
				} // else
			} // for si
		} // for i

		// kreiraj izlazni sloj
		neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""transferFunction"",
				TransferFunctionType.STEP);
		Layer outLayer = LayerFactory.createLayer(outNum, neuronProperties);
		this.addLayer(outLayer);

		ConnectionFactory.fullConnect(ruleLayer, outLayer);

		// inicijalizuj ulazne i izlazne celije
		NeuralNetworkFactory.setDefaultIO(this);

		this.setLearningRule(new LMS());
	}"
neuroph,org.neuroph.nnet.NeuroFuzzyPerceptron,createNetwork,,117,1968,1791,11,0.0437,0.0259,0.615384615,36,11,0,1,"/**
	 * Creates custom NFR architecture
	 * 
	 * @param inputNum
	 *            number of getInputsIterator
	 * @param inputSets
	 *            input fuzzy sets
	 * @param outNum
	 *            number of outputs
	 */
	private void createNetwork(int inputNum, Vector<Integer> inputSets, int outNum) {

		// set network type
		this.setNetworkType(NeuralNetworkType.NEURO_FUZZY_REASONER);

		// CREATE INPUT LAYER
		NeuronProperties neuronProperties = new NeuronProperties();
		Layer inLayer = LayerFactory.createLayer(inputNum, neuronProperties);
		this.addLayer(inLayer);

		// CREATE FUZZY SET LAYER
		neuronProperties.setProperty(""transferFunction"",
				TransferFunctionType.TRAPEZOID);
		Enumeration<Integer> e = inputSets.elements();
		int fuzzySetsNum = 0;
		while (e.hasMoreElements()) {
			Integer i = e.nextElement();
			fuzzySetsNum = fuzzySetsNum + i.intValue();
		}
		Layer setLayer = LayerFactory.createLayer(fuzzySetsNum, neuronProperties);
		this.addLayer(setLayer);

		// TODO: postavi parametre funkcija pripadnosti
		// nizove sa trning elementima iznesi van klase i prosledjuj ih kao
		// parametre
//		Iterator<Neuron> ii = setLayer.getNeuronsIterator();
		Enumeration<Integer> en;// =setLayer.neurons();
		int c = 0;
                for(Neuron cell : setLayer.getNeurons()) {                
//		while (ii.hasNext()) {
//			Neuron cell = ii.next();
			Trapezoid tf = (Trapezoid) cell.getTransferFunction();
			/*
			 * if (c<=3) { tf.setLeftLow(pointsSets[c][0]);
			 * tf.setLeftHigh(pointsSets[c][1]); tf.setRightLow(pointsSets[c][3]);
			 * tf.setRightHigh(pointsSets[c][2]); } else { tf.setLeftLow(timeSets[c-4][0]);
			 * tf.setLeftHigh(timeSets[c-4][1]); tf.setRightLow(timeSets[c-4][3]);
			 * tf.setRightHigh(timeSets[c-4][2]); } c++;
			 */
		}

		// createLayer connections between input and fuzzy set getLayersIterator
		int s = 0; // brojac celija sloja skupova (fazifikacije)
		for (int i = 0; i < inputNum; i++) { // brojac ulaznih celija
			Neuron from = inLayer.getNeuronAt(i);
			int jmax = inputSets.elementAt(i).intValue();
			for (int j = 0; j < jmax; j++) {
				Neuron to = setLayer.getNeuronAt(s);
				ConnectionFactory.createConnection(from, to, 1);
				s++;
			}
		}

		// ----------------------------------------------------------

		// kreiraj sloj pravila
		neuronProperties.setProperty(""inputFunction"", Min.class);
		neuronProperties.setProperty(""transferFunction"",
				Linear.class);
		en = inputSets.elements();
		int fuzzyAntNum = 1;
		while (en.hasMoreElements()) {
			Integer i = en.nextElement();
			fuzzyAntNum = fuzzyAntNum * i.intValue();
		}
		Layer ruleLayer = LayerFactory.createLayer(fuzzyAntNum, neuronProperties);
		this.addLayer(ruleLayer);

		// povezi set i rule layer

		int scIdx = 0; // set cell index

		for (int i = 0; i < inputNum; i++) { // brojac ulaza (grupa fuzzy
												// skupova)
			int setsNum = inputSets.elementAt(i).intValue();

			for (int si = 0; si < setsNum; si++) { // brojac celija fuzzy
													// skupova
				if (i == 0) {
					Neuron from = setLayer.getNeuronAt(si);
					int connPerCell = fuzzyAntNum / setsNum;
					scIdx = si;

					for (int k = 0; k < connPerCell; k++) { // brojac celija
															// hipoteza
						Neuron to = ruleLayer.getNeuronAt(si * connPerCell + k);
						ConnectionFactory.createConnection(from, to, 1);
					} // for
				} // if
				else {
					scIdx++;
					Neuron from = setLayer.getNeuronAt(scIdx);
					int connPerCell = fuzzyAntNum / setsNum;

					for (int k = 0; k < connPerCell; k++) { // brojac celija
															// hipoteza
						int toIdx = si + k * setsNum;
						Neuron to = ruleLayer.getNeuronAt(toIdx);
						ConnectionFactory.createConnection(from, to, 1);
					} // for k
				} // else
			} // for si
		} // for i

		// set input and output cells for this network
		neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.STEP);
		Layer outLayer = LayerFactory.createLayer(outNum, neuronProperties);
		this.addLayer(outLayer);

		ConnectionFactory.fullConnect(ruleLayer, outLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);

		this.setLearningRule(new LMS());
	}"
neuroph,org.neuroph.nnet.ElmanNetwork,createNetwork,,36,124,77,3,0.1257,0.0863,0.666666667,9,1,0,1,"// three layers: input, hidden, output
    // as mlp add context layer
    // elman connect output of hidden layer to input of context layer
    // output of context to input of hidden layer 
    
    
    
    
    
	private void createNetwork(int inputNeuronsCount, int hiddenNeuronsCount, int contextNeuronsCount, int outputNeuronsCount) {

                // create input layer
                InputLayer inputLayer = new InputLayer(inputNeuronsCount);
                inputLayer.addNeuron(new BiasNeuron());
                addLayer(inputLayer);
                
		NeuronProperties neuronProperties = new NeuronProperties();
               // neuronProperties.setProperty(""useBias"", true);
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.SIGMOID);                
            
                Layer hiddenLayer = new Layer(hiddenNeuronsCount, neuronProperties); 
                hiddenLayer.addNeuron(new BiasNeuron());
                addLayer(hiddenLayer);
                
                ConnectionFactory.fullConnect(inputLayer, hiddenLayer);
                
                Layer contextLayer = new Layer(contextNeuronsCount, neuronProperties); 
                addLayer(contextLayer); // we might also need bias for context neurons?
                                                                               
                Layer outputLayer = new Layer(outputNeuronsCount, neuronProperties); 
                addLayer(outputLayer);
                
                ConnectionFactory.fullConnect(hiddenLayer, outputLayer);
                
                ConnectionFactory.forwardConnect(hiddenLayer, contextLayer); // forward or full connectivity?
                ConnectionFactory.fullConnect(contextLayer, hiddenLayer);
                
                                
		// set input and output cells for network
                  NeuralNetworkFactory.setDefaultIO(this);

                  // set learnng rule
		this.setLearningRule(new BackPropagation());
				
	}"
neuroph,org.neuroph.nnet.Outstar,createNetwork,,27,33,11,2,0.1901,0.1288,0.666666667,4,1,0,1,"/**
	 * Creates Outstar architecture with specified number of neurons in 
	 * output layer
	 * 
	 * @param outputNeuronsCount
	 *            number of neurons in output layer
	 */
	private void createNetwork(int outputNeuronsCount ) {

		// set network type
		this.setNetworkType(NeuralNetworkType.OUTSTAR);

		// init neuron settings for this type of network
		NeuronProperties neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.STEP);
		
		// create input layer
		Layer inputLayer = LayerFactory.createLayer(1, neuronProperties);
		this.addLayer(inputLayer);

		// createLayer output layer
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.RAMP);
		Layer outputLayer = LayerFactory.createLayer(outputNeuronsCount, neuronProperties);
		this.addLayer(outputLayer);

		// create full conectivity between input and output layer
		ConnectionFactory.fullConnect(inputLayer, outputLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);

		// set outstar learning rule for this network
		this.setLearningRule(new OutstarLearning());
	}"
neuroph,org.neuroph.nnet.MaxNet,createNetwork,,31,46,26,2,0.1736,0.0959,0.666666667,5,1,0,1,"/**
	 * Creates MaxNet network architecture
	 * 
	 * @param neuronNum
	 *            neuron number in network
	 * @param neuronProperties
	 *            neuron properties
	 */
	private void createNetwork(int neuronsCount) {

		// set network type
		this.setNetworkType(NeuralNetworkType.MAXNET);

		// createLayer input layer in layer
		Layer inputLayer = LayerFactory.createLayer(neuronsCount,
				new NeuronProperties());
		this.addLayer(inputLayer);

		// createLayer properties for neurons in output layer
		NeuronProperties neuronProperties = new NeuronProperties();
		neuronProperties.setProperty(""neuronType"", CompetitiveNeuron.class);
		neuronProperties.setProperty(""transferFunction"", TransferFunctionType.RAMP);

		// createLayer full connectivity in competitive layer
		CompetitiveLayer competitiveLayer = new CompetitiveLayer(neuronsCount, neuronProperties);

		// add competitive layer to network
		this.addLayer(competitiveLayer);

		double competitiveWeight = -(1 / (double) neuronsCount);
		// createLayer full connectivity within competitive layer
		ConnectionFactory.fullConnect(competitiveLayer, competitiveWeight, 1);

		// createLayer forward connectivity from input to competitive layer
		ConnectionFactory.forwardConnect(inputLayer, competitiveLayer, 1);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);
	}"
neuroph,org.neuroph.nnet.Adaline,createNetwork,,36,151,131,8,0.1012,0.0408,0.75,5,1,0,1,"/**
	 * Creates adaline network architecture with specified number of input neurons
	 * 
	 * @param inputNeuronsCount
         *              number of neurons in input layer
	 */
	private void createNetwork(int inputNeuronsCount) {
		// set network type code
		this.setNetworkType(NeuralNetworkType.ADALINE);
                
                // create input layer neuron settings for this network
		NeuronProperties inNeuronProperties = new NeuronProperties();
		inNeuronProperties.setProperty(""transferFunction"", TransferFunctionType.LINEAR);

		// createLayer input layer with specified number of neurons
		//Layer inputLayer = LayerFactory.createLayer(inputNeuronsCount, inNeuronProperties);
                Layer inputLayer = new InputLayer(inputNeuronsCount);
                inputLayer.addNeuron(new BiasNeuron()); // add bias neuron (always 1, and it will act as bias input for output neuron)
		this.addLayer(inputLayer);
                
               // create output layer neuron settings for this network
		NeuronProperties outNeuronProperties = new NeuronProperties();
		outNeuronProperties.setProperty(""transferFunction"", TransferFunctionType.LINEAR); // was RAMP
//		outNeuronProperties.setProperty(""transferFunction.slope"", new Double(1));
//		outNeuronProperties.setProperty(""transferFunction.yHigh"", new Double(1));
//		outNeuronProperties.setProperty(""transferFunction.xHigh"", new Double(1));
//		outNeuronProperties.setProperty(""transferFunction.yLow"", new Double(-1));
//		outNeuronProperties.setProperty(""transferFunction.xLow"", new Double(-1));

		// createLayer output layer (only one neuron)
		Layer outputLayer = LayerFactory.createLayer(1, outNeuronProperties);
		this.addLayer(outputLayer);

		// createLayer full conectivity between input and output layer
		ConnectionFactory.fullConnect(inputLayer, outputLayer);

		// set input and output cells for network
		NeuralNetworkFactory.setDefaultIO(this);

		// set LMS learning rule for this network
		this.setLearningRule(new LMS());
	}"
neuroph,org.neuroph.nnet.MultiLayerPerceptron,createNetwork,,54,188,123,3,0.1223,0.0926,0.714285714,8,7,0,1,"/**
     * Creates MultiLayerPerceptron Network architecture - fully connected
     * feed forward with specified number of neurons in each layer
     *
     * @param neuronsInLayers  collection of neuron numbers in getLayersIterator
     * @param neuronProperties neuron properties
     */
    private void createNetwork(List<Integer> neuronsInLayers, NeuronProperties neuronProperties) {

        // set network type
        this.setNetworkType(NeuralNetworkType.MULTI_LAYER_PERCEPTRON);

        // create input layer
        NeuronProperties inputNeuronProperties = new NeuronProperties(InputNeuron.class, Linear.class);
        Layer layer = LayerFactory.createLayer(neuronsInLayers.get(0), inputNeuronProperties);

        boolean useBias = true; // use bias neurons by default
        if (neuronProperties.hasProperty(""useBias"")) {
            useBias = (Boolean) neuronProperties.getProperty(""useBias"");
        }

        if (useBias) {
            layer.addNeuron(new BiasNeuron());
        }

        this.addLayer(layer);

        // create layers
        Layer prevLayer = layer;

        //for(Integer neuronsNum : neuronsInLayers)
        for (int layerIdx = 1; layerIdx < neuronsInLayers.size(); layerIdx++) {
            Integer neuronsNum = neuronsInLayers.get(layerIdx);
            // createLayer layer
            layer = LayerFactory.createLayer(neuronsNum, neuronProperties);

            if (useBias && (layerIdx < (neuronsInLayers.size() - 1))) {
                layer.addNeuron(new BiasNeuron());
            }

            // add created layer to network
            this.addLayer(layer);
            // createLayer full connectivity between previous and this layer
            if (prevLayer != null) {
                ConnectionFactory.fullConnect(prevLayer, layer);
            }

            prevLayer = layer;
        }

        // set input and output cells for network
        NeuralNetworkFactory.setDefaultIO(this);

        // set learnng rule
//        this.setLearningRule(new BackPropagation());
        this.setLearningRule(new MomentumBackpropagation());
        // this.setLearningRule(new DynamicBackPropagation());

        this.randomizeWeights(new RangeRandomizer(-0.7, 0.7));

    }"
neuroph,org.neuroph.nnet.RBFNetwork,createNetwork,,33,69,33,2,0.1524,0.1095,0.666666667,7,1,0,1,"/**
	 * Creates RBFNetwork architecture with specified number of neurons in input
	 * layer, output layer and transfer function
	 * 
	 * @param inputNeuronsCount
	 *		number of neurons in input layer
	 * @param rbfNeuronsCount
	 *		number of neurons in rbf layer
	 * @param outputNeuronsCount
	 *		number of neurons in output layer
	 */
	private void createNetwork(int inputNeuronsCount, int rbfNeuronsCount,
			int outputNeuronsCount) {
		// init neuron settings for this network
		NeuronProperties rbfNeuronProperties = new NeuronProperties();
		rbfNeuronProperties.setProperty(""inputFunction"", Difference.class);
		rbfNeuronProperties.setProperty(""transferFunction"", Gaussian.class);

		// set network type code
		this.setNetworkType(NeuralNetworkType.RBF_NETWORK);

		// create input layer
		Layer inputLayer = LayerFactory.createLayer(inputNeuronsCount, TransferFunctionType.LINEAR);
		this.addLayer(inputLayer);

		// create rbf layer
		Layer rbfLayer = LayerFactory.createLayer(rbfNeuronsCount, rbfNeuronProperties);
		this.addLayer(rbfLayer);

		// create output layer
		Layer outputLayer = LayerFactory.createLayer(outputNeuronsCount, TransferFunctionType.LINEAR);
		this.addLayer(outputLayer);

		// create full conectivity between input and rbf layer
		ConnectionFactory.fullConnect(inputLayer, rbfLayer);
		// create full conectivity between rbf and output layer
		ConnectionFactory.fullConnect(rbfLayer, outputLayer);

		// set input and output cells for this network
		NeuralNetworkFactory.setDefaultIO(this);

		// set appropriate learning rule for this network
		this.setLearningRule(new RBFLearning());
	}"
neuroph,org.neuroph.nnet.comp.ConvolutionalUtils,fullConnectMapLayers,,17,38,10,3,0.2315,0.1426,0.333333333,9,6,0,1,"/**
     * Creates full connectivity between feature maps in two layers
     *
     * @param fromLayer from feature maps layer
     * @param toLayer   to feature maps layer
     */
    public static void fullConnectMapLayers(FeatureMapsLayer fromLayer, FeatureMapsLayer toLayer) {
        if (toLayer instanceof ConvolutionalLayer) {
            for (int i = 0; i < fromLayer.getNumberOfMaps(); i++) {
                for (int j = 0; j < toLayer.getNumberOfMaps(); j++) {
                    FeatureMapLayer fromMap = fromLayer.getFeatureMap(i);
                    FeatureMapLayer toMap = toLayer.getFeatureMap(j);
                    toLayer.connectMaps(fromMap, toMap);                // da li treba svaka sa svakom ???
                }
            }
        } else if (toLayer instanceof PoolingLayer) { // ???? CHECK: da li je ovo dobro
            for (int i = 0; i < toLayer.getNumberOfMaps(); i++) {
                FeatureMapLayer fromMap = fromLayer.getFeatureMap(i);
                FeatureMapLayer toMap = toLayer.getFeatureMap(i);
                toLayer.connectMaps(fromMap, toMap);
            }
        }
    }"
neuroph,org.neuroph.nnet.comp.Kernel,initWeights,,11,20,12,3,0.2222,0.0627,0.5,5,3,0,1,"public void initWeights(double min, double max) {
        weights = new Weight[height][width];

        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                Weight weight = new Weight();
                weight.randomize(min, max);
                weights[i][j] = weight;
            }
        }        
    }"
neuroph,org.neuroph.nnet.comp.layer.FeatureMapLayer,FeatureMapLayer,,8,13,11,4,0.2222,0.0476,0.75,5,2,0,1,"/**
     * Creates an empty 2D layer with specified dimensions
     *
     * @param dimensions layer dimensions (width and weight)
     */    
    public FeatureMapLayer(Dimension2D dimensions, NeuronProperties neuronProperties) {
        this.dimensions = dimensions;
        
        for (int i = 0; i < dimensions.getHeight() * dimensions.getWidth(); i++) {
            Neuron neuron = NeuronFactory.createNeuron(neuronProperties);
            addNeuron(neuron);
        }        
    }"
neuroph,org.neuroph.nnet.comp.layer.FeatureMapLayer,FeatureMapLayer,,8,13,11,4,0.2222,0.0476,0.75,5,2,0,1,"/**
     * Creates 2D layer with specified dimensions, filled with neurons with
     * specified properties
     *
     * @param dimensions       layer dimensions
     * @param neuronProperties neuron properties
     */
    public FeatureMapLayer(Dimension2D dimensions, NeuronProperties neuronProperties, Dimension2D kernelDimension) {
        this(dimensions, kernelDimension);

        for (int i = 0; i < dimensions.getHeight() * dimensions.getWidth(); i++) {
            Neuron neuron = NeuronFactory.createNeuron(neuronProperties);
            addNeuron(neuron);
        }
    }"
neuroph,org.neuroph.nnet.comp.layer.ConvolutionalLayer,connectMaps,,45,263,226,11,0.1067,0.0402,0.454545455,13,5,0,1,"/**
     * Creates connections with shared weights between two feature maps Assumes
     * that toMap is from Convolutional layer.
     * <p/>
     * Kernel is used as a sliding window, and kernel positions overlap. Kernel
     * is shifting right by one position at a time. Neurons at the same kernel
     * position share the same weights
     *
     * @param fromMap source feature map
     * @param toMap destination feature map
     */
    @Override
    public void connectMaps(FeatureMapLayer fromMap, FeatureMapLayer toMap) {

        Kernel kernel = toMap.getKernel();
        kernel.initWeights(-0.15, 0.15); // zasto ove vrednosti ???
      //  int numberOfSharedWeights = kernel.getArea();
//        Weight[][] weights = new Weight[kernel.getHeight()][kernel.getWidth()];
//        //double coefficient = getWeightCoeficient(toMap);
//        // initialize kernel with random weights
//        // ovo prebaciti u kernel
//        for (int i = 0; i < kernel.getHeight(); i++) {
//            for (int j = 0; j < kernel.getWidth(); j++) {
//                Weight weight = new Weight();
//                weight.randomize(-0.15, 0.15); // zasto ove vrednosti?
//                weights[i][j] = weight;
//            }
//        }
//        kernel.setWeights(weights); // na kraju svi kerneli od svih feature mapa imaju iste tezine jer gadjaju istu instancu kernela od nadklase!!!!
//                                    // kernel prebaciti u Layer2D preimenovati ga u FeatureMapLayer i dodati mu kernel...
//                                    // pored kernela dodati mu i BiasNeuron...
        BiasNeuron biasNeuron = new BiasNeuron();
        fromMap.addNeuron(biasNeuron);
                                    
                                    
        // ovo se koristi samo za povezivanje dva konvoluciona sloja !!! 
        // dodati step za from - ne mora da bude samo 1
        // ostaje pitanje kako se primenjuje na ivici - trebalo bi od centra - dodati onaj okvir sa strane!!!!
        for (int y = 0; y < toMap.getHeight(); y++) { // iterate all neurons by height in toMap  -- verovatno bi i ovde trebalo zameniti redosled x i y!!!
            for (int x = 0; x < toMap.getWidth(); x++) { // iterate all neurons by width in toMap
                Neuron toNeuron = toMap.getNeuronAt(x, y); // get neuron at specified position in toMap
                for (int ky = 0; ky < kernel.getHeight(); ky++) { // iterate kernel positions by y
                    for (int kx = 0; kx < kernel.getWidth(); kx++) { // iterate kernel positions by x
                        int fromX = x + kx; // calculate the x position of from neuron
                        int fromY = y + ky; // calculate the y position of from neuron
                        //int currentWeightIndex = kx + ky * kernel.getHeight(); // find the idx of the shared weight
                        Weight[][] concreteKernel = kernel.getWeights();
                        Neuron fromNeuron = fromMap.getNeuronAt(fromX, fromY);
                        ConnectionFactory.createConnection(fromNeuron, toNeuron, concreteKernel[kx][ky]);  // - da li je ovo dobro ???
                        // also create connection from bias
                        ConnectionFactory.createConnection(biasNeuron, toNeuron);
                    }
                }
            }
        }
    }"
neuroph,org.neuroph.nnet.comp.layer.InputLayer,InputLayer,,8,13,11,4,0.2222,0.0417,1,4,2,0,1,"/**
     * Creates a new instance of InputLayer with specified number of input neurons
     * @param neuronsCount input neurons count for this layer
     */
    public InputLayer(int neuronsCount) {
        NeuronProperties inputNeuronProperties = new NeuronProperties(InputNeuron.class, Linear.class);

        for (int i = 0; i < neuronsCount; i++) {
            Neuron neuron = NeuronFactory.createNeuron(inputNeuronProperties);
            this.addNeuron(neuron);
        }
    }"
neuroph,org.neuroph.nnet.comp.layer.CompetitiveLayer,calculate,,37,138,105,3,0.1474,0.0931,0.75,9,9,0,1,"/**
	 * Performs calculaton for all neurons in this layer
	 */
	@Override
	public void calculate() {
		boolean hasWinner = false;
		
		int iterationsCount = 0;
		
		while (!hasWinner) {
			int fireingNeurons = 0;
			for(Neuron neuron : this.getNeurons()) {
				neuron.calculate();
				if (neuron.getOutput() > 0)
					fireingNeurons += 1;
			} // for
			
			if (iterationsCount > this.maxIterations) break;
			
			if (fireingNeurons == 1)
				hasWinner = true;
			iterationsCount++;
			
		} // while !done

		if (hasWinner) { 
			// now set reference to winner
			double maxOutput = Double.MIN_VALUE;

			for(Neuron neuron : this.getNeurons()) {	
				CompetitiveNeuron cNeuron = (CompetitiveNeuron)neuron;
				cNeuron.setIsCompeting(false); // turn off competing mode
				if (cNeuron.getOutput() > maxOutput) {
					maxOutput = cNeuron.getOutput();
					this.winner = cNeuron;
				}
			}
		}
		
	}"
neuroph,org.neuroph.nnet.comp.layer.PoolingLayer,PoolingLayer,,11,25,14,3,0.2121,0.0736,0.333333333,8,1,0,1,"/**
     * Creates pooling layer with specified kernel, appropriate map
     * dimensions in regard to previous layer (fromLayer param) and specified
     * number of feature maps with default neuron settings for pooling layer.
     * Number of maps in pooling layer must be the same as number of maps in previous
     * layer.
     *
     * @param fromLayer previous layer, which will be connected to this layer
     * @param kernel    kernel for all feature maps
     */
    public PoolingLayer(FeatureMapsLayer fromLayer, Dimension2D kernelDim) {
        this.kernel = new Kernel(kernelDim);
        int numberOfMaps = fromLayer.getNumberOfMaps();
        Dimension2D fromDimension = fromLayer.getMapDimensions();

        int mapWidth = fromDimension.getWidth() / kernel.getWidth();
        int mapHeight = fromDimension.getHeight() / kernel.getHeight();
        this.mapDimensions = new Dimension2D(mapWidth, mapHeight);

        createFeatureMaps(numberOfMaps, mapDimensions, kernelDim, DEFAULT_NEURON_PROP);
    }"
neuroph,org.neuroph.nnet.comp.layer.PoolingLayer,connectMaps,,20,64,37,3,0.1667,0.0629,0.571428571,13,5,0,1,"/**
     * Creates connections with shared weights between two feature maps
     * Assumes that toMap is from Pooling layer.
     * <p/>
     * In this implementation, there is no overlapping between kernel positions.
     *
     * @param fromMap source feature map
     * @param toMap   destination feature map
     */
    @Override
    public void connectMaps(FeatureMapLayer fromMap, FeatureMapLayer toMap) {
        int kernelWidth = kernel.getWidth();
        int kernelHeight = kernel.getHeight();
        Weight weight = new Weight(1);
        for (int x = 0; x < fromMap.getWidth() - kernelWidth + 1; x += kernelWidth) { // < da li step treba da je kernel
            for (int y = 0; y < fromMap.getHeight() - kernelHeight + 1; y += kernelHeight) {

                Neuron toNeuron = toMap.getNeuronAt(x / kernelWidth, y / kernelHeight);
                for (int dy = 0; dy < kernelHeight; dy++) {
                    for (int dx = 0; dx < kernelWidth; dx++) {
                        int fromX = x + dx;
                        int fromY = y + dy;
                        Neuron fromNeuron = fromMap.getNeuronAt(fromX, fromY);
                        ConnectionFactory.createConnection(fromNeuron, toNeuron, weight);
                    }
                }
            }
        }
    }"
neuroph,org.neuroph.nnet.comp.neuron.InputOutputNeuron,calculate,,18,9,3,2,0.2407,0.1274,1,3,4,0,1,"/**
	 * Calculates neuron output
	 */
	@Override
	public void calculate() {

		if (!externalInputSet) { // ako ulaz nije setovan spolja
			if (this.hasInputConnections()) // bias neuroni ne racunaju ulaz iz mreze jer
									// nemaju ulaze
				totalInput = inputFunction.getOutput(this.inputConnections);
		}

		// calculqate cell output
		this.output = transferFunction.getOutput(this.totalInput + bias); // izracunaj
																		// izlaz

		if (externalInputSet) { // ulaz setovan 'spolja' vazi samo za jedno izracunavanje
			externalInputSet = false;
			totalInput = 0;
		}
	}"
neuroph,org.neuroph.nnet.comp.neuron.CompetitiveNeuron,addInputConnection,,14,22,16,5,0.2188,0.1136,1,1,2,0,1,"/**
	 * Adds input connection for this competitive neuron
	 * @param connection input connection
	 */
	@Override
	public void addInputConnection(Connection connection) {
		super.addInputConnection(connection);
		if (connection.getFromNeuron().getParentLayer() == this
				.getParentLayer()) {
//                    this.connectionsFromThisLayer =  Arrays.copyOf(connectionsFromThisLayer, connectionsFromThisLayer.length+1);     // grow existing connections  array to make space for new connection
//                    this.connectionsFromThisLayer[connectionsFromThisLayer.length - 1] = connection;                    
			connectionsFromThisLayer.add(connection);
		} else {
//                    this.connectionsFromOtherLayers =  Arrays.copyOf(connectionsFromOtherLayers, connectionsFromOtherLayers.length+1);     // grow existing connections  array to make space for new connection
//                    this.connectionsFromOtherLayers[connectionsFromOtherLayers.length - 1] = connection;                          
			connectionsFromOtherLayers.add(connection);
		}
	}"
neuroph,org.neuroph.nnet.learning.BackPropagation,calculateErrorAndUpdateOutputNeurons,,24,66,41,4,0.1786,0.1398,0.666666667,7,3,0,1,"/**
     * This method implements weights update procedure for the output neurons
     * Calculates delta/error and calls updateNeuronWeights to update neuron's weights
     * for each output neuron
     *
     * @param outputError error vector for output neurons
     */
    protected void calculateErrorAndUpdateOutputNeurons(double[] outputError) {
        int i = 0;
        
        // for all output neurons
        List<Neuron> outputNeurons = neuralNetwork.getOutputNeurons();
        for (Neuron neuron : outputNeurons) {
            // if error is zero, just set zero error and continue to next neuron
            if (outputError[i] == 0) {
                neuron.setError(0);
                i++;
                continue;
            }

            // otherwise calculate and set error/delta for the current neuron
            TransferFunction transferFunction = neuron.getTransferFunction();
            double neuronInput = neuron.getNetInput();
            double delta = outputError[i] * transferFunction.getDerivative(neuronInput); // delta = (y-d)*df(net)
            neuron.setError(delta);

            // and update weights of the current neuron
            updateNeuronWeights(neuron);
            i++;
        } // for
    }"
neuroph,org.neuroph.nnet.learning.BackPropagation,calculateErrorAndUpdateHiddenNeurons,,11,19,10,3,0.3,0.1512,1,4,3,0,1,"/**
     * This method implements weights adjustment for the hidden layers
     */
    protected void calculateErrorAndUpdateHiddenNeurons() {
        List<Layer> layers = neuralNetwork.getLayers();
        for (int layerIdx = layers.size() - 2; layerIdx > 0; layerIdx--) {
            for (Neuron neuron : layers.get(layerIdx).getNeurons()) {
                // calculate the neuron's error (delta)
                double delta = calculateHiddenNeuronError(neuron);
                neuron.setError(delta);
                updateNeuronWeights(neuron);
            } // for
        } // for
    }"
neuroph,org.neuroph.nnet.learning.BackPropagation,calculateHiddenNeuronError,,13,43,31,3,0.2045,0.0701,0.428571429,9,2,0,1,"/**
     * Calculates and returns the neuron's error (neuron's delta) for the given neuron param
     *
     * @param neuron neuron to calculate error for
     * @return neuron error (delta) for the specified neuron
     */
    protected double calculateHiddenNeuronError(Neuron neuron) {
        double deltaSum = 0d;
        for (Connection connection : neuron.getOutConnections()) {
            double delta = connection.getToNeuron().getError() * connection.getWeight().value;
            deltaSum += delta; // weighted delta sum from the next layer
        } // for

        TransferFunction transferFunction = neuron.getTransferFunction();
        double netInput = neuron.getNetInput();
        double f1 = transferFunction.getDerivative(netInput);   // does this use netInput or cached output in order to avoid double caluclation? 
        double delta = f1 * deltaSum;
        return delta;
    }"
neuroph,org.neuroph.nnet.learning.LMS,calculateWeightChanges,,11,21,14,3,0.25,0.1142,1,4,2,0,1,"/**
     * This method implements the weights update procedure for the whole network
     * for the given output error vector.
     *   
     * @param outputError
     *            output error vector for some network input- the difference between desired and actual output
     * @see SupervisedLearning#learnPattern(org.neuroph.core.data.DataSetRow)  learnPattern
     */
    @Override
    protected void calculateWeightChanges(double[] outputError) {
        int i = 0;
        // for each neuron in output layer
        List<Neuron> outputNeurons = neuralNetwork.getOutputNeurons();
        for (Neuron neuron : outputNeurons) {
            neuron.setError(outputError[i]); // set the neuron error, as difference between desired and actual output 
            updateNeuronWeights(neuron); // and update neuron weights
            i++;
        }
    }"
neuroph,org.neuroph.nnet.learning.QuickPropagation,updateNeuronWeights,,68,333,231,9,0.1639,0.0898,0.6,10,10,1,1,"//  private final static double shrinkFactor = maximumGrowthFactor / (1.0 + maximumGrowthFactor);
    // hes mapu koristim da cuvam vrednosti prethodnih iteracija - koristi training data

    @Override
    public void updateNeuronWeights(Neuron neuron) {
        double delta = neuron.getError();
        for (Connection con : neuron.getInputConnections()) {
            
            Weight<QuickPropData> w = con.getWeight();
            QuickPropData qpData = w.getTrainingData();

            double input = con.getInput();
            if (input == 0) continue;            
            
            double gradient = delta * input;            
            double previousWeightChange = qpData.previousWeightChange;  //  this is positive gradiend dE/dw  (ili ipak -dE/dw)
            
            // neuronError je delta  a ne gradijent
            //double previousError = qpData.previousError;                // delta    dE/dy * y'  - ovo bi morao da bude gradijent - ne sadrzi input
            double prevGradient = qpData.prevGradient;
            
            double currentWeightChange = 0;
            
            
                
            //1. tekuci gradijent i prethdoni gradijent  su istog znaka, i tekuci gradijent je manji od prethodnog gradijenta
            //????????????????????????(t) = (S(t)/(S(t-1)-S(t))) * ????????????????????????(t????????????????????????1)
            //
            //
            //2. tekuci gradijent i prethdoni gradijent nisu istog znaka,  (i tekuci gradijent je manji od prethodnog gradijent - da li vazi i ovaj uslov, mislim d amora inace menja znak, ali izgleda da nema veze)
            //????????????????????????(t) = (S(t)/(S(t-1)-S(t))) * ????????????????????????(t????????????????????????1)
            //
            //
            //3. tekuci gradijent i prethdoni gradijent su istog znaka, i tekuci delta je jednak ili veci od prethodnog delta 

            //1. tekuci delta i prethdoni delta su istog znaka, i tekuci delta je manji od prethodnog delta
            if ((prevGradient * gradient > 0) && (gradient < prevGradient)) {    // gradijenti istog znaka i tekuci gradijent je manji od prethodnog (1 slucaj)
                currentWeightChange = (gradient / (prevGradient - gradient)) * previousWeightChange; // quick prop  // ovde bi trebalo dodati epsilon
                // currentWeightChange = learningRate * error * input;
                if (Math.abs(currentWeightChange) >= Math.abs((maximumGrowthFactor * previousWeightChange))) {
                    currentWeightChange = maximumGrowthFactor * previousWeightChange;
                }
            }
             //3. tekuci delta i prethdoni delta su istog znaka, i tekuci delta je jednak ili veci od prethodnog delta 
            else if ((prevGradient * gradient > 0) && (gradient >= prevGradient)) { // gradijenti istog znaka i tekuci gradijent je veci od prethodnog (3 slucaj)
                currentWeightChange = maximumGrowthFactor * previousWeightChange; // ???
              //  currentWeightChange = previousWeightChange; // ???

            } else if (prevGradient * gradient < 0) { // gradijenti razlicitog znaka (2 slucaj)
                currentWeightChange = (gradient / (prevGradient - gradient)) * previousWeightChange; // quick prop 

                // sta kad ej negativno
                if (Math.abs(currentWeightChange) >= Math.abs((maximumGrowthFactor * previousWeightChange))) {
                    currentWeightChange = maximumGrowthFactor * previousWeightChange;
                }
            } else { // gradijent je 0, standardni backprop
                currentWeightChange = -learningRate * delta * input;
            }
            
            w.weightChange += currentWeightChange;
         //   System.out.println(""currentWeightChange: "" + currentWeightChange);
//            if (currentWeightChange > 10) {
//                System.out.println(getCurrentIteration() + "" iteration : ""+ currentWeightChange);
//            }
            qpData.previousWeightChange = currentWeightChange;
            qpData.prevGradient = gradient;
         //   qpData.previousError = delta;
            
        }
       
    }"
neuroph,org.neuroph.nnet.learning.QuickPropagation,onStart,,15,10,10,5,0.2,0,0.857142857,4,4,0,1,"@Override
    protected void onStart() {
        super.onStart(); //To change body of generated methods, choose Tools | Templates.
        for (Layer layers : neuralNetwork.getLayers()) {
            for (Neuron neuron : layers.getNeurons()) {
                for (Connection connection : neuron.getInputConnections()) {
                    //connection.getWeight().setTrainingData(new QuickPropData());
                    Weight<QuickPropData> qpWeight = new Weight<>();
                    qpWeight.setTrainingData(new QuickPropData());
                    connection.setWeight(qpWeight);                    
                }
            }
        }

    }"
neuroph,org.neuroph.nnet.learning.RBFLearning,calculateSigma,,11,13,5,3,0.3143,0.1508,1,4,2,0,1,"/**
     * Calculates and returns  width of a gaussian function
     * @param centroid
     * @param nearestNeighbours
     * @return 
     */
    private double calculateSigma(KVector centroid,  KVector[] nearestNeighbours) {
       double sigma = 0;
              
       for(KVector nn : nearestNeighbours){
           sigma += Math.pow( centroid.distanceFrom(nn), 2 ) ;
       }
       
       sigma = Math.sqrt(1/((double)nearestNeighbours.length)  * sigma);
       
       return sigma;
    }"
neuroph,org.neuroph.nnet.learning.BinaryHebbianLearning,updateNeuronWeights,,13,19,10,3,0.3,0.1358,0.5,6,6,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights
	 */
	@Override
	protected void updateNeuronWeights(Neuron neuron) {
		double output = neuron.getOutput();
		for (Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();

			if (((input>0) && (output>0)) || ((input<=0) && (output<=0))) {
				connection.getWeight().inc(this.learningRate);
			} else {
				connection.getWeight().dec(this.learningRate);
			}
		}
	}"
neuroph,org.neuroph.nnet.learning.GeneralizedHebbianLearning,updateNeuronWeights,,10,18,8,3,0.2917,0.1037,0.5,7,2,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights
	 */
	@Override
	protected void updateNeuronWeights(Neuron neuron) {
		double output = neuron.getOutput();
		for(Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();
                        double netInput = neuron.getNetInput();
			double deltaWeight = (input - netInput) * output * this.learningRate; // is it right to use netInput here?
			connection.getWeight().inc(deltaWeight);
		}
	}"
neuroph,org.neuroph.nnet.learning.OutstarLearning,updateNeuronWeights,,10,19,10,3,0.2321,0.1049,0.5,7,2,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights for
	 */
	@Override
	protected void updateNeuronWeights(Neuron neuron) {
		double output = neuron.getOutput();
		for (Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();
			double weight = connection.getWeight().getValue();
			double deltaWeight = this.learningRate * input * (output-weight);
			connection.getWeight().inc(deltaWeight);
		}
	}"
neuroph,org.neuroph.nnet.learning.SimulatedAnnealingLearning,randomize,,13,11,1,2,0.2679,0.1333,1,10,3,0,1,"/**
     * Randomize the weights and thresholds. This function does most of the work
     * of the class. Each call to this class will randomize the data according
     * to the current temperature. The higher the temperature the more
     * randomness.
     * @param randomChance 
     */
    public void randomize(double randomChance ) {

        for (int i = 0; i < this.weights.length; i++)
          if (Math.random() < randomChance)
          {
            double add = 0.5 - (Math.random());
            add /= this.startTemperature;
            add *= this.temperature;
            this.weights[i] = this.weights[i] + add;
          }

        NeuralNetworkCODEC.array2network(this.weights, getNetwork());
    }"
neuroph,org.neuroph.nnet.learning.SimulatedAnnealingLearning,determineError,,24,117,98,3,0.1412,0.0541,0.666666667,10,4,0,1,"/**
     * Used internally to calculate the error for a training set.
     *
     * @param trainingSet The training set to calculate for.
     * @return The error value.
     */
    private double determineError(DataSet trainingSet) {
        double result = 0d;

        Iterator<DataSetRow> iterator = trainingSet.iterator();
        while (iterator.hasNext() && !isStopped()) {
            DataSetRow trainingSetRow = iterator.next();
            double[] input = trainingSetRow.getInput();
            getNetwork().setInput(input);
            getNetwork().calculate();
            double[] output = getNetwork().getOutput();
            double[] desiredOutput = trainingSetRow
                    .getDesiredOutput();

            double[] patternError = getErrorFunction().addPatternError(desiredOutput, output);
            double sqrErrorSum = 0;
            for (double error : patternError) {
                sqrErrorSum += (error * error);
            }
            result += sqrErrorSum / (2 * patternError.length);

        }

        return result;
    }"
neuroph,org.neuroph.nnet.learning.SimulatedAnnealingLearning,doLearningEpoch,,39,68,58,7,0.1302,0.0547,1,27,4,1,0,"public void doLearningEpoch(DataSet trainingSet, double randomChance)
    {
        System.arraycopy(this.weights, 0, this.bestWeights, 0,
                this.weights.length);

        double bestError = determineError(trainingSet);

        this.temperature = this.startTemperature;

        for (int i = 0; i < this.cycles; i++) {

            randomize( randomChance );
            double currentError = determineError(trainingSet);

            if (currentError < bestError) {
                System.arraycopy(this.weights, 0, this.bestWeights, 0,
                        this.weights.length);
                bestError = currentError;
            } else
                System.arraycopy(this.bestWeights, 0, this.weights, 0,
                        this.weights.length);

            NeuralNetworkCODEC.array2network(this.bestWeights, getNetwork());

            final double ratio = Math.exp(Math.log(this.stopTemperature
                    / this.startTemperature)
                    / (this.cycles - 1));
            this.temperature *= ratio;
        }

        // the following line is probably wrong (when is reset() called?), but the result might not be used for anything
        this.previousEpochError = getErrorFunction().getTotalError();

        // moved stopping condition to separate method hasReachedStopCondition()
        // so it can be overriden / customized in subclasses
        if (hasReachedStopCondition()) {
            stopLearning();
        }
    }"
neuroph,org.neuroph.nnet.learning.SupervisedHebbianLearning,calculateWeightChanges,,9,8,6,3,0.28,0.125,1,3,2,0,1,"/**
	 * Learn method override without network error and iteration limit
	 * Implements just one pass through the training set Used for testing -
	 * debugging algorithm
	 * 
	 * public void learn(TrainingSet trainingSet) { Iterator
	 * iterator=trainingSet.iterator(); while(iterator.hasNext()) {
	 * SupervisedTrainingElement trainingElement =
	 * (SupervisedTrainingElement)iterator.next();
	 * this.learnPattern(trainingElement); } }
	 */


    //TODO --- Check if this breaks something...??????
//	/**
//	 * Trains network with the pattern from the specified training element
//	 *
//	 * @param trainingSetRow
//	 *            a single  data set row to learn which contains input and desired output patterns (arrays)
//	 */
//	@Override
//	protected void learnPattern(DataSetRow trainingSetRow) {
//                double[] input = trainingSetRow.getInput();
//                this.neuralNetwork.setInput(input); // set network input
//                this.neuralNetwork.calculate(); // calculate the network
//                double[] output = this.neuralNetwork.getOutput(); // get actual network output
//                double[] desiredOutput = trainingSetRow.getDesiredOutput();
//
//                double[] outputError = this.calculateOutputError(desiredOutput, output); // calculate error as difference between desired and actual
//                this.addToSquaredErrorSum(outputError); // add error to total MSE
//
//                this.calculateWeightChanges(desiredOutput); // apply the weights update procedure
//	}

	/**
	 * This method implements weight update procedure for the whole network for
	 * this learning rule
	 * 
	 * @param desiredOutput
	 *            desired network output
	 */
	@Override
	protected void calculateWeightChanges(double[] desiredOutput) {
		int i = 0;
		for (Neuron neuron : neuralNetwork.getOutputNeurons()) {
			this.updateNeuronWeights(neuron, desiredOutput[i]);
			i++;
		}

	}"
neuroph,org.neuroph.nnet.learning.SupervisedHebbianLearning,updateNeuronWeights,,7,10,5,3,0.3,0.1071,0.75,6,2,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights
	 *        desiredOutput
	 *	      desired output of the neuron
	 */
	protected void updateNeuronWeights(Neuron neuron, double desiredOutput) {
		for (Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();
			double deltaWeight = input * desiredOutput * this.learningRate;
			connection.getWeight().inc(deltaWeight);
		}
	}"
neuroph,org.neuroph.nnet.learning.MomentumBackpropagation,updateNeuronWeights,,31,86,67,6,0.175,0.0811,0.666666667,7,4,0,1,"/**
     * This method implements weights update procedure for the single neuron for
     * the back propagation with momentum factor
     *
     * @param neuron neuron to update weights
     */
    @Override
    public void updateNeuronWeights(Neuron neuron) {
        for (Connection connection : neuron.getInputConnections()) {
            double input = connection.getInput();
            if (input == 0) {
                continue;
            }

            // get the error for specified neuron,
            double neuronDelta = neuron.getError();

            // tanh can be used to minimise the impact of big error values, which can cause network instability
            // suggested at https://sourceforge.net/tracker/?func=detail&atid=1107579&aid=3130561&group_id=238532
            // double neuronError = Math.tanh(neuron.getError());

            Weight<MomentumTrainingData> weight = connection.getWeight();
            MomentumTrainingData weightTrainingData = weight.getTrainingData();

            //double currentWeightValue = weight.getValue();
            double weightChange = -learningRate * neuronDelta * input + momentum * weightTrainingData.previousWeightChange;
            weightTrainingData.previousWeightChange = weight.weightChange;


            // if the learning is in batch mode apply the weight change immediately
            if (isBatchMode() == false) {
                weight.weightChange = weightChange;
            } else { // otherwise, sum the weight changes and apply them after at the end of epoch
                weight.weightChange += weightChange;
            }
        }
    }"
neuroph,org.neuroph.nnet.learning.MomentumBackpropagation,onStart,,12,7,4,2,0.32,0.1,1,3,4,0,1,"@Override
    protected void onStart() {
        super.onStart();
        // create MomentumTrainingData objects that will be used during the training to store previous weight value
        for (Layer layer : neuralNetwork.getLayers()) {
            for (Neuron neuron : layer.getNeurons()) {
                for (Connection connection : neuron.getInputConnections()) {
                    connection.getWeight().setTrainingData(new MomentumTrainingData());
                }
            } // for
        } // for        
    }"
neuroph,org.neuroph.nnet.learning.SigmoidDeltaRule,calculateWeightChanges,,23,54,30,4,0.1978,0.1591,0.666666667,6,3,0,1,"/**
	 * This method implements weight update procedure for the whole network for
	 * this learning rule
	 * 
	 * @param outputError
	 *            output error vector
	 */
	@Override
	protected void calculateWeightChanges(double[] outputError) {
		int i = 0;
                // for all output neurons
		for(Neuron neuron : neuralNetwork.getOutputNeurons()) {
                        // if error is zero, just set zero error and continue to next neuron
			if (outputError[i] == 0) {
				neuron.setError(0);
                                i++;
				continue;
			}
			
                        // otherwise calculate and set error/delta for the current neuron
			TransferFunction transferFunction = neuron.getTransferFunction();
			double neuronInput = neuron.getNetInput();
			double delta = outputError[i] * transferFunction.getDerivative(neuronInput); // delta = (d-y)*df(net)
			neuron.setError(delta);
                        
                        // and update weights of the current neuron
			updateNeuronWeights(neuron);				
			i++;
		} // for				
	}"
neuroph,org.neuroph.nnet.learning.OjaLearning,updateNeuronWeights,,10,17,6,3,0.2917,0.116,0.5,7,2,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights
	 */
	@Override
	protected void updateNeuronWeights(Neuron neuron) {
		double output = neuron.getOutput();
		for(Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();
			double weight = connection.getWeight().getValue();
			double deltaWeight = (input - output*weight) * output * this.learningRate;
			connection.getWeight().inc(deltaWeight);
		}
	}"
neuroph,org.neuroph.nnet.learning.ConvolutionalBackpropagation,calculateErrorAndUpdateHiddenNeurons,,13,24,12,3,0.2963,0.1605,1,4,4,0,1,"@Override
	protected void calculateErrorAndUpdateHiddenNeurons() {
		List<Layer> layers = neuralNetwork.getLayers();
		for (int layerIdx = layers.size() - 2; layerIdx > 0; layerIdx--) {
			for (Neuron neuron : layers.get(layerIdx).getNeurons()) {
				double neuronError = this.calculateHiddenNeuronError(neuron);
				neuron.setError(neuronError);
				if (layers.get(layerIdx) instanceof ConvolutionalLayer) { // if it is convolutional layer c=adapt weughts, dont touch pooling. Pooling just propagate the error
					this.updateNeuronWeights(neuron);
				}
			} // for
		} // for
	}"
neuroph,org.neuroph.nnet.learning.ConvolutionalBackpropagation,calculateHiddenNeuronError,,18,20,12,2,0.3125,0.1667,0.4,5,3,0,1,"// ova mora da se overriduje jer glavna uzima izvod //  ali ova treba samo za pooling sloj 
    @Override     
    protected double calculateHiddenNeuronError(Neuron neuron) {

        // for convolutional layers use standard backprop formula
        if (neuron.getParentLayer() instanceof ConvolutionalLayer ) {
            return super.calculateHiddenNeuronError(neuron);
        }
                
        // for pooling layer just transfer error without using tranfer function derivative
        double deltaSum = 0d;
        for (Connection connection : neuron.getOutConnections()) {
            double delta = connection.getToNeuron().getError()
                    * connection.getWeight().value;
            deltaSum += delta; // weighted delta sum from the next layer
        } // for

       return deltaSum;
    }"
neuroph,org.neuroph.nnet.learning.UnsupervisedHebbianLearning,updateNeuronWeights,,9,14,7,3,0.3143,0.1042,0.6,6,2,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights
	 */
	protected void updateNeuronWeights(Neuron neuron) {
		double output = neuron.getOutput();

		for (Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();
			double deltaWeight = input * output * this.learningRate;
			connection.getWeight().inc(deltaWeight);
		}
	}"
neuroph,org.neuroph.nnet.learning.AntiHebbianLearning,updateNeuronWeights,,10,14,7,3,0.3143,0.1042,0.6,6,2,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights
	 */
         @Override
	protected void updateNeuronWeights(Neuron neuron) {
		double output = neuron.getOutput();

		for (Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();
			double deltaWeight = input * output * this.learningRate;                       
			connection.getWeight().dec(deltaWeight); // the only difference to UnsupervisedHebbianLearning is this substraction instead addition
		}
	}"
neuroph,org.neuroph.nnet.learning.CompetitiveLearning,updateNetworkWeights,,16,6,0,2,0.3667,0.1833,0.714285714,7,2,0,1,"/**
	 * Adjusts weights for the winning neuron
	 */
	protected void updateNetworkWeights() {
		// find active neuron in output layer
		// TODO : change idx, in general case not 1
		CompetitiveNeuron winningNeuron = ((CompetitiveLayer) neuralNetwork
				.getLayerAt(1)).getWinner();

		List<Connection> inputConnections = winningNeuron
				.getConnectionsFromOtherLayers();

		for(Connection connection : inputConnections) {
			double weight = connection.getWeight().getValue();
			double input = connection.getInput();
			double deltaWeight = this.learningRate * (input - weight);
			connection.getWeight().inc(deltaWeight);			
		}
	}"
neuroph,org.neuroph.nnet.learning.KohonenLearning,learn,,17,47,39,4,0.1405,0.05,0.75,5,6,0,1,"@Override
	public void learn(DataSet trainingSet) {
                
		for (int phase = 0; phase < 2; phase++) {
			for (int k = 0; k < iterations[phase]; k++) {
				Iterator<DataSetRow> iterator = trainingSet.iterator();
				while (iterator.hasNext() && !isStopped()) {
					DataSetRow trainingSetRow = iterator.next();
					learnPattern(trainingSetRow, nR[phase]);				
				} // while
				currentIteration = k;
                                fireLearningEvent(new LearningEvent(this, LearningEvent.Type.EPOCH_ENDED));
				if (isStopped()) return;
			} // for k
			learningRate = learningRate * 0.5;
		} // for phase
	}"
neuroph,org.neuroph.nnet.learning.KohonenLearning,learnPattern,,22,66,41,2,0.1905,0.1092,0.5,8,5,0,1,"private void learnPattern(DataSetRow dataSetRow, int neighborhood) {
		neuralNetwork.setInput(dataSetRow.getInput());
		neuralNetwork.calculate();
		Neuron winner = getClosestNeuron();
		if (winner.getOutput() == 0)
			return; // ako je vec istrenirana jedna celija, izadji

		Layer mapLayer = neuralNetwork.getLayerAt(1);
		int winnerIdx = mapLayer.indexOf(winner);
		adjustCellWeights(winner, 0);

		int cellNum = mapLayer.getNeuronsCount();
		for (int p = 0; p < cellNum; p++) {
			if (p == winnerIdx)
				continue;
			if (isNeighbor(winnerIdx, p, neighborhood)) {
				Neuron cell = mapLayer.getNeuronAt(p);
				adjustCellWeights(cell, 1);
			} // if
		} // for

	}"
neuroph,org.neuroph.nnet.learning.KohonenLearning,adjustCellWeights,,7,7,4,3,0.35,0.1389,0.6,4,2,0,1,"private void adjustCellWeights(Neuron cell, int r) {
                for(Connection conn : cell.getInputConnections()) {
			double dWeight = (learningRate / (r + 1))   
					* (conn.getInput() - conn.getWeight().getValue());
			conn.getWeight().inc(dWeight);
		}
	}"
neuroph,org.neuroph.nnet.learning.KohonenLearning,isNeighbor,,41,199,122,4,0.1577,0.0939,0,12,8,1,1,"private boolean isNeighbor(int i, int j, int n) {
		// i - centralna celija
		// n - velicina susedstva
		// j - celija za proveru
		n = 1;
		int d = mapSize;

		// if (j<(i-n*d-n)||(j>(i+n*d+n))) return false;

		int rt = n; // broj celija ka gore
		while ((i - rt * d) < 0) {
			rt--;
                }

		int rb = n; // broj celija ka dole
		while ((i + rb * d) > (d * d - 1)) {
			rb--;
                }

		for (int g = -rt; g <= rb; g++) {
			int rl = n; // broj celija u levu stranu
			int rlMod = (i - rl) % d;
			int i_mod = i % d;
			while (rlMod > i_mod) {
				rl--;
				rlMod = (i - rl) % d;
			}

			int rd = n; // broj celija u desnu stranu
			int rdMod = (i + rd) % d;
			while (rdMod < i_mod) {
				rd--;
				rdMod = (i + rd) % d;
			}

			if ((j >= (i + g * d - rl)) && (j <= (i + g * d + rd)))
				return true;
			// else if (j<(i+g*d-rl)) return false;
		} // for
		return false;
	}"
neuroph,org.neuroph.nnet.learning.ResilientPropagation,sign,,9,3,3,3,0.3333,0,0,1,3,0,1,"private int sign(final double value) {
        if (Math.abs(value) < ZERO_TOLERANCE) {
            return 0;
        } else if (value > 0) {
            return 1;
        } else {
            return -1;
        }
    }"
neuroph,org.neuroph.nnet.learning.ResilientPropagation,onStart,,13,7,4,2,0.3,0.0917,1,4,4,0,1,"@Override
    protected void onStart() {
        super.onStart(); // init all stuff from superclasses

        // create ResilientWeightTrainingtData objects that will hold additional data (resilient specific) during the training 
        for (Layer layer : this.neuralNetwork.getLayers()) {
            for (Neuron neuron : layer.getNeurons()) {
                for (Connection connection : neuron.getInputConnections()) {
                    connection.getWeight().setTrainingData(new ResilientWeightTrainingtData());
                }
            }
        }
    }"
neuroph,org.neuroph.nnet.learning.ResilientPropagation,updateNeuronWeights,,19,26,16,3,0.2593,0.0929,0.6,6,3,0,1,"/**
     * Calculate and sum gradients for each neuron's weight, the actual weight update is done in batch mode.
     * 
     * @see ResilientPropagation#resillientWeightUpdate(org.neuroph.core.Weight) 
     */
    @Override
    public void updateNeuronWeights(Neuron neuron) {
        for (Connection connection : neuron.getInputConnections()) {
            double input = connection.getInput();
            if (input == 0) {
                continue;
            }

            // get the error for specified neuron,
            double neuronError = neuron.getError();
            // get the current connection's weight
            Weight weight = connection.getWeight();
            // ... and get the object that stores reislient training data for that weight
            ResilientWeightTrainingtData weightData = (ResilientWeightTrainingtData) weight.getTrainingData();

            // calculate the weight gradient (and sum gradients since learning is done in batch mode)
            weightData.gradient += -neuronError * input;  // - ili + ovde ? bilo je +
        }
    }"
neuroph,org.neuroph.nnet.learning.ResilientPropagation,doBatchWeightsUpdate,,16,15,9,2,0.2857,0.0913,0.8,5,4,0,1,"@Override
    protected void doBatchWeightsUpdate() {
        // iterate layers from output to input
        List<Layer> layers = neuralNetwork.getLayers();
        for (int i = neuralNetwork.getLayersCount() - 1; i > 0; i--) {            
            // iterate neurons at each layer
            for (Neuron neuron : layers.get(i).getNeurons()) {
                // iterate connections/weights for each neuron
                for (Connection connection : neuron.getInputConnections()) {
                    // for each connection weight apply following changes
                    Weight weight = connection.getWeight();
                    resillientWeightUpdate(weight);
                }
            }
        }
    }"
neuroph,org.neuroph.nnet.learning.ResilientPropagation,resillientWeightUpdate,,45,47,0,3,0.2157,0.3161,1,5,4,0,1,"/**
     * Weight update by done by ResilientPropagation  learning rule
     * Executed at the end of epoch (in batch mode)
     * @param weight 
     */
    protected void resillientWeightUpdate(Weight weight) {
        // get resilient training data for the current weight
        ResilientWeightTrainingtData weightData = (ResilientWeightTrainingtData) weight.getTrainingData();

        // multiply the current and previous gradient, and take the sign. 
        // We want to see if the gradient has changed its sign.            
        int gradientSignChange = sign(weightData.previousGradient * weightData.gradient);

        double weightChange = 0; // weight change to apply (delta weight)
        double delta; //  adaptation factor - svaka tezina treba da ima svoj delta i d ag apamti - u tom ej epoenta!!!!

        if (gradientSignChange > 0) {
            // if the gradient has retained its sign, then we increase delta (adaptation factor) so that it will converge faster
            delta = Math.min(
                    weightData.previousDelta * increaseFactor,
                    maxDelta);
            //  weightChange = -sign(weightData.gradient) * delta; // if error is increasing (gradient is positive) then subtract delta, if error is decreasing (gradient negative) then add delta
            // note that our gradient has different sign eg. -dE_dw so we omit the minus here
            weightChange = sign(weightData.gradient) * delta;
            weightData.previousDelta = delta;
        } else if (gradientSignChange < 0) {
            // if gradientSignChange<0, then the sign has changed, and the last weight change was too big                
            delta = Math.max(
                    weightData.previousDelta * decreaseFactor,
                    minDelta);
            // weightChange = - weightData.previousDelta;// 0;// -delta  - weightData.previousDelta; // ovo je problematicno treba da bude weightChange          
            weightChange = -weightData.previousWeightChange; // if it skipped min in previous step go back
            // avoid double punishment
            weightData.gradient = 0;
            weightData.previousGradient = 0;

            //move values in the past
            weightData.previousDelta = delta;
        } else if (gradientSignChange == 0) {
            // if gradientSignChange==0 then there is no change to the delta
            delta = weightData.previousDelta;
            //delta = weightData.previousGradient; // note that encog does this
            weightChange = sign(weightData.gradient) * delta;
        }

        //weight.value += weightChange; -- ovo mora da se radi simultano
        weightData.previousWeightChange = weightChange;
        weightData.previousGradient = weightData.gradient; // as in moveNowValuesToPreviousEpochValues
        weightData.gradient = 0;
    }"
neuroph,org.neuroph.nnet.learning.BinaryDeltaRule,calculateWeightChanges,,23,73,55,4,0.1429,0.0742,0.8,10,2,0,1,"/**
	 * This method implements weight update procedure for the whole network for
	 * this learning rule
	 *
	 * @param patternError
	 *            single pattern error vector
         *
         * if the output is 0 and required value is 1, increase rthe weights
         * if the output is 1 and required value is 0, decrease the weights
         * otherwice leave weights unchanged
         *
	 */
	@Override
	protected void calculateWeightChanges(double[] patternError) {
		int i = 0;
                List<Neuron> outputNeurons = neuralNetwork.getOutputNeurons();
                for (Neuron outputNeuron : outputNeurons) {
			ThresholdNeuron neuron = (ThresholdNeuron)outputNeuron;
			double outErr = patternError[i];
			double thresh = neuron.getThresh();
			double netInput = neuron.getNetInput();
			// double threshError =  thresh - netInput; // distance from zero
			double threshError =  thresh - netInput; // distance from zero
                        // use output error to decide weathet to inrease, decrase or leave unchanged weights
                        // add errorCorrection to threshError to move above or below zero
                        double neuronError = outErr * (Math.abs(threshError) + errorCorrection);

                        // use same adjustment principle as PerceptronLearning,
                        // just with different neuronError
                        neuron.setError(neuronError);
			updateNeuronWeights(neuron);

			i++;
		} // for
	}"
neuroph,org.neuroph.nnet.learning.DynamicBackPropagation,adjustLearningRate,,65,2,0,1,0.4,0.1944,1,12,3,0,1,"// Adjusting learning rate dynamically
        /* If network error of current epoch is higher than the network error of the previous
         * epoch the learning rate is adjusted by minus 1 per cent of current learning rate.
         * Otherwise the learning rate is adjusted by plus 1 per cent of current learning
         * rate. So, learning rate increases faster than decreasing does. But if learning rate
         * reaches 0.9 it switches back to 0.5 to avoid endless training. The lowest learning
         * rate is 0.5 also to avoid endless training.
         */
        protected void adjustLearningRate() {

            // 1. First approach - probably the best
            // bigger error -> smaller learning rate; minimize the error growth
            // smaller error -> bigger learning rate; converege faster
            // the amount of earning rate change is proportional to error change - by using errorChange

            double errorChange = this.previousEpochError - getErrorFunction().getTotalError();
            this.learningRate = this.learningRate + (errorChange*learningRateChange);

            if (this.learningRate > this.maxLearningRate)
               this.learningRate = this.maxLearningRate;

            if (this.learningRate < this.minLearningRate)
               this.learningRate = this.minLearningRate;


//            System.out.println(""Learning rate: ""+this.learningRate);

            // 2. Second approach
            // doing this lineary for each epoch considering network error behaviour
            // probbaly the worst one
/*
            if (this.totalNetworkError >= this.totalNetworkErrorInPreviousEpoch) {
                this.learningRate = this.learningRate * this.learningRateChange;

                if (this.learningRate < this.minLearningRate)
                    this.learningRate = this.minLearningRate;

            } else {
                this.learningRate = this.learningRate * (1 + (1 - this.learningRateChange)); // *1.01

                if (this.learningRate > this.maxLearningRate)
                    this.learningRate = this.maxLearningRate;

            }
*/
// third approach used by sharky nn
// By default It starts with ni = 0,9, and after each epoch ni is changed by: 0,99977 ^ N
//    where N is number of points, and ^ is power.
// ni = ni * 0,99977 ^ N
// this one drops the learning rate too fast
//           this.learningRate = this.learningRate * Math.pow(learningRateChange, this.getTrainingSet().size());
//            if (this.learningRate > this.maxLearningRate)
//               this.learningRate = this.maxLearningRate;
//
//            if (this.learningRate < this.minLearningRate)
//               this.learningRate = this.minLearningRate;

  //          System.out.println(""Iteration: ""+currentIteration + "" Learning rate: ""+ this.learningRate);

            // one more approach suggested at https://sourceforge.net/tracker/?func=detail&atid=1107579&aid=3130561&group_id=238532
//            if (this.totalNetworkError >= this.previousEpochError) {
//            // If going wrong way, drop to minimum learning and work our way back up.
//            // This way we accelerate as we improve.
//            learningRate=minLearningRate;
//            } else {
//            this.learningRate = this.learningRate * (1 + (1 - this.learningRateChange)); // *1.01
//
//            if (this.learningRate > this.maxLearningRate)
//            this.learningRate = this.maxLearningRate;
//
//            }

        }"
neuroph,org.neuroph.nnet.learning.DynamicBackPropagation,adjustMomentum,,21,6,2,2,0.32,0.1167,1,12,3,0,1,"protected void adjustMomentum() {
            double errorChange = this.previousEpochError - getErrorFunction().getTotalError();
            this.momentum = this.momentum + (errorChange*momentumChange);

            if (this.momentum > this.maxMomentum)
               this.momentum = this.maxMomentum;

            if (this.momentum < this.minMomentum)
               this.momentum = this.minMomentum;

            // one more approach suggested at https://sourceforge.net/tracker/?func=detail&atid=1107579&aid=3130561&group_id=238532
            // Probably want to drop momentum to minimum value.
//            if (this.totalNetworkError >= this.previousEpochError) {
//                momentum = momentum * momentumChange;
//                if (momentum < minMomentum) momentum = minMomentum;
//            } else {
//                momentum = momentum * (1 + (1 - momentumChange)); // *1.01
//                if (momentum > maxMomentum) momentum = maxMomentum;
//            }

        }"
neuroph,org.neuroph.nnet.learning.DynamicBackPropagation,doLearningEpoch,,11,5,4,3,0.3125,0.0556,0,1,4,0,1,"@Override
	public void doLearningEpoch(DataSet trainingSet) {
           super.doLearningEpoch(trainingSet);

           if (currentIteration > 0) {
                    if (useDynamicLearningRate) adjustLearningRate();
                    if (useDynamicMomentum) adjustMomentum();
           }


        }"
neuroph,org.neuroph.nnet.learning.InstarLearning,updateNeuronWeights,,10,19,10,3,0.2321,0.1049,0.5,7,2,0,1,"/**
	 * This method implements weights update procedure for the single neuron
	 * 
	 * @param neuron
	 *            neuron to update weights for
	 */
	@Override
	protected void updateNeuronWeights(Neuron neuron) {
		double output = neuron.getOutput();
		for (Connection connection : neuron.getInputConnections()) {
			double input = connection.getInput();
			double weight = connection.getWeight().getValue();
			double deltaWeight = this.learningRate * output * (input-weight);
			connection.getWeight().inc(deltaWeight);
		}
	}"
neuroph,org.neuroph.nnet.learning.HopfieldLearning,learn,,26,140,109,3,0.1283,0.0536,0.777777778,15,5,0,1,"/**
	 * Calculates weights for the hopfield net to learn the specified training
	 * set
	 * 
	 * @param trainingSet
	 *            training set to learn
	 */
	public void learn(DataSet trainingSet) {
		int M = trainingSet.size();
		int N = neuralNetwork.getLayerAt(0).getNeuronsCount();
		Layer hopfieldLayer = neuralNetwork.getLayerAt(0);

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				if (j == i)
					continue;
				Neuron ni = hopfieldLayer.getNeuronAt(i);
				Neuron nj = hopfieldLayer.getNeuronAt(j);
				Connection cij = nj.getConnectionFrom(ni);
				Connection cji = ni.getConnectionFrom(nj);
				double w = 0;
				for (int k = 0; k < M; k++) {
					DataSetRow trainingSetRow = trainingSet.getRowAt(k);
					double pki = trainingSetRow.getInput()[i];
					double pkj = trainingSetRow.getInput()[j];
					w = w + pki * pkj;
				} // k
				cij.getWeight().setValue(w);
				cji.getWeight().setValue(w);
			} // j
		} // i

	}"
neuroph,org.neuroph.nnet.learning.kmeans.Cluster,equals,,20,27,18,3,0.2407,0.1071,0.5,5,5,0,1,"/**
     * Returns true if two clusters have same centroid
     * @param obj
     * @return 
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        
        final Cluster other = (Cluster) obj;
        double[] otherValues = other.getCentroid().getValues();
        double[] values = other.getCentroid().getValues();
        // do this ina for loop here
        for(int i=0; i<centroid.size(); i++) {
            if (otherValues[i] != values[i])
                return false;
        }
                       
        return true;
    }"
neuroph,org.neuroph.nnet.learning.kmeans.KMeansClustering,KMeansClustering,,14,33,21,3,0.2286,0.1076,0.75,8,2,0,1,"public KMeansClustering(DataSet dataSet) {
        this.dataSet = dataSet;
        this.dataVectors = new KVector[dataSet.size()];
        // iterate dataset and create dataVectors field
        this.dataVectors = new KVector[dataSet.size()];
         // iterate dataset and create dataVectors field
        int i=0;
        for(DataSetRow row : dataSet.getRows()) {
            KVector vector = new KVector(row.getInput());
            this.dataVectors[i]=vector;
            i++;
            
        }        
    }"
neuroph,org.neuroph.nnet.learning.kmeans.KMeansClustering,KMeansClustering,,13,37,29,4,0.1667,0.0689,0.75,9,2,0,1,"public KMeansClustering(DataSet dataSet, int numberOfClusters) {
        this.dataSet = dataSet;
        this.numberOfClusters = numberOfClusters;
        this.dataVectors = new KVector[dataSet.size()];
         // iterate dataset and create dataVectors field
        int i=0;
        for(DataSetRow row : dataSet.getRows()) {
            KVector vector = new KVector(row.getInput());
            this.dataVectors[i]=vector;
            i++;
            
        }
    }"
neuroph,org.neuroph.nnet.learning.kmeans.KMeansClustering,doClustering,,31,75,59,5,0.2143,0.1364,0.666666667,5,6,0,1,"// runs cluctering
    public void doClustering() {
        // throw exception if number of clusters is 0 
        if (numberOfClusters <= 0) {
            throw new RuntimeException(""Error: Number of clusters must be greater then zero!"");
        }
        
        // initialize clusters
        initClusters();
        
        // initial nearest cluster assignement
        for (KVector vector : dataVectors) { // Iterate all dataSet    
            Cluster nearestCluster = getNearestCluster(vector);
            nearestCluster.assignVector(vector);
        }

        // this is the loop doing the main thing
        //  keep re-calculating centroids and assigning points until there is no change
        boolean clustersChanged; // flag to indicate cluster change
        do {
            clustersChanged = false;            
            recalculateCentroids();                      

            for (KVector vector : dataVectors) {
                Cluster nearestCluster = getNearestCluster(vector);
                if (!vector.getCluster().equals(nearestCluster)) {
                    nearestCluster.assignVector(vector);
                    clustersChanged = true;
                }
            }
        } while(clustersChanged);
    }"
neuroph,org.neuroph.nnet.learning.kmeans.KMeansClustering,recalculateCentroids,,9,4,0,2,0.4667,0.3167,0.5,2,3,0,1,"/**
     * Calculate new centroids as an average of all dataSet in cluster
     */
    private void recalculateCentroids() {
        // for each cluster do the following
        for (Cluster cluster : clusters) { // for each cluster
            if (cluster.size()>0) {         // that cointains data
                double[] avgSum = cluster.getAvgSum();  // calculate avg sum
                cluster.getCentroid().setValues(avgSum);  // and set new centroid to avg sum
            }                                  
        }
    }"
neuroph,org.neuroph.nnet.learning.kmeans.KVector,toString,,11,11,1,3,0.3333,0.3667,0,2,2,0,1,"@Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""KMeansVector{"");
        for(int i=0; i<values.length; i++)
            sb.append(""[""+i+""]=""+values[i]+"","");
        
        sb.append('}');
        
        return  sb.toString();
    }"
neuroph,org.neuroph.ocr.OCRTraining,createCharacterLabels,,9,14,7,3,0.3929,0.1583,0,2,3,0,1,"//=========================================================================
    private void createCharacterLabels() {
        characterLabels = new ArrayList<String>();
        for (int i = 0; i < trainingText.length(); i++) {
            String c = trainingText.charAt(i) + """";
            if (!characterLabels.contains(c)) {
                characterLabels.add(trainingText.charAt(i) + """");
            }
        }
    }"
neuroph,org.neuroph.ocr.OCRTraining,prepateText,,10,19,10,3,0.3,0.1265,0,3,4,0,1,"private void prepateText() {
        String tmp = """";
        for (int i = 0; i < trainingText.length(); i++) {
            char c = trainingText.charAt(i);
            if ((!Character.isSpaceChar(c)) && (!Character.isWhitespace(c))) {
                tmp += c;
            }
        }
        trainingText = tmp;
    }"
neuroph,org.neuroph.ocr.OCRTraining,createImagesWithLetters,,58,670,599,9,0.0611,0.0267,0.454545455,23,9,1,1,"private void createImagesWithLetters() {
        int cropWidth = letterInformation.getCropWidth();
        int cropHeight = letterInformation.getCropHeight();
        int tmpWidth = 3 * cropWidth;
        int tmpHeight = 3 * cropHeight;
        int trashSize = letterInformation.getTrashSize();
        
        OCRExtractLetter extractionLetter = new OCRExtractLetter(tmpWidth, tmpHeight, trashSize);
        
        int letterSize = letterInformation.getLetterSize();
        int imageHeight = image.getHeight();
        int imageWidth = image.getWidth();
        boolean[][] visited = new boolean[imageHeight][imageWidth];
        Color white = Color.WHITE;
        Color color;
        int seqNum = 0;

        for (int line = 0; line < textInformation.numberOfRows(); line++) {

//==============================================================================
            for (int j = 0; j < imageWidth; j++) {
                for (int k = -(letterSize / 4); k < (letterSize / 4); k++) {
                    int rowPixel = textInformation.getRowAt(line);
                    int i = rowPixel + k;
                    if (i < 0 || i >= imageHeight) {
                        continue;
                    }
//==============================================================================
//                   fornja verzija radi, ova ima gresku 
//            for (int k = -(letterSize / 4); k < (letterSize / 4); k++) {
//                int rowPixel = textInformation.getRowAt(line);
//                int i = rowPixel + k;
//                if (i < 0 || i >= imageHeight) {
//                    continue;
//                }
//                for (int j = 0; j < imageWidth; j++) {
//==============================================================================
                    color = new Color(image.getRGB(j, i));
                    if (color.equals(white)) {
                        visited[i][j] = true;
                    } else if (visited[i][j] == false) {
                        BufferedImage letter = extractionLetter.extraxtLetter(image, visited, i, j); // OCRUtilities.extraxtCharacterImage(image, visited, i, j, tmpWidth, tmpHeight, letterInformation.getTrashSize());
                        if (letter != null) {
                            OCRCropLetter crop = new OCRCropLetter(letter, cropWidth, cropHeight);
                            BufferedImage croped = crop.processImage();
                            String character = trainingText.charAt(seqNum) + """";
                            String name = character + ""_"" + seqNum;
                            OCRUtilities.saveToFile(croped, folderPath, name, imageExtension);
                            seqNum++;
                        }
                    }

                }
            }

        }

    }"
neuroph,org.neuroph.ocr.CharExtractor,findCropTopY,,12,16,11,4,0.2449,0.085,0,3,4,0,1,"/**
     * This method scans image pixels until it finds the first black pixel (TODO: use foreground color which is black by default).
     * When it finds black pixel, it sets cropTopY and returns true. if it reaches end of image and does not find black pixels, 
     * it sets endOfImage flag and returns false.
     * @return - returns true when black pixel is found and cropTopY value is changed, and false if cropTopY value is not changed
     */
    private boolean findCropTopY() {
        for (int y = cropBottomY; y < imageWithChars.getHeight(); y++) { // why cropYDown? - for multiple lines of text using cropBottomY from previous line above; for first line its zero
            for (int x = cropLeftX; x < imageWithChars.getWidth(); x++) { // scan starting from the previous left crop position - or it shoud be right???
                if (imageWithChars.getRGB(x, y) == -16777216) { // if its black rixel (also consider condition close to black or not white or different from background)
                    this.cropTopY = y;   // save the current y coordiante
                    return true;        // and return true
                }
            }
        }
        endOfImage = true;  //sets this flag if no black pixels are found
        return false;       // and return false
    }"
neuroph,org.neuroph.ocr.CharExtractor,findCropBottomY,,20,46,26,4,0.2083,0.1313,0,3,6,0,1,"/**
     * This method scans image pixels until it finds first row with white pixels. (TODO: background color which is white by default).
     * When it finds line whith all white pixels, it sets cropBottomY and returns true
     * @return - returns true when cropBottomY value is set, false otherwise
     */
    private boolean findCropBottomY() {
        for (int y = cropTopY + 1; y < imageWithChars.getHeight(); y++) { // scan image from top to bottom           
            int whitePixCounter = 0; //counter of white pixels in a row
            for (int x = cropLeftX; x < imageWithChars.getWidth(); x++) { // scan all pixels to right starting from left crop position
                if (imageWithChars.getRGB(x, y) == -1) {    // if its white pixel
                    whitePixCounter++;                      // increase counter
                }
            }
            if (whitePixCounter == imageWithChars.getWidth()) { // if we have reached end of line counting white pixels (x pos)
                cropBottomY = y;                                // that means that we've found white line, so set current y coordinate minus 1
                return true;                                    // as cropBottomY and finnish with true
            }
            if (y == imageWithChars.getHeight() - 1) {  // if we have reached end of image 
                cropBottomY = y;                        // set crop bottom
                endOfImage = true;                      // set corresponding endOfImage flag
                return true;                            // and return true
            }
        }
        return false;                                   // this should never happen, however its possible if image has non white bg
    }"
neuroph,org.neuroph.ocr.CharExtractor,findCropLeftX,,19,45,35,5,0.1616,0.1333,0,3,5,0,1,"/**
     * This method scans image pixels to the right  until it finds first black pixel, or reach end of row.
     * When black pixel is found it sets cropLeftX and returns true. It should set cropLeftX to the next letter in a row.
     * @return - return true when true when black pixel is found and cropLeftX is changed, false otherwise
     */
    private boolean findCropLeftX() {        
        int whitePixCounter = 0;                                            // white pixel counter between the letters
        for (int x = cropRightX; x < imageWithChars.getWidth(); x++) {      // start from previous righ crop position (previous letter), and scan following pixels to the right
            for (int y = cropTopY; y <= cropBottomY; y++) {             // vertical pixel scan at current x coordinate
                if (imageWithChars.getRGB(x, y) == -16777216) {             // when we find black pixel
                    cropLeftX = x;                                          // set cropLeftX
                    return true;                                            // and return true
                }
            }
            
            // BUG?: this condition looks strange.... we might not need whitePixCounter at all, it might be used for 'I' letter
            whitePixCounter++;                                              // if its not black pixel assume that its white pixel
            if (whitePixCounter == 3) {                                     // why 3 pixels? its hard coded for some case and does not work in general...!!!
                whitePixCounter = 0;                                        // why does it sets to zero, this has no purporse at all...
            }
        }
        endOfRow = true;        // if we have reached end of row and we have not found black pixels, set the endOfRow flag
        return false;           // and return false
    }"
neuroph,org.neuroph.ocr.CharExtractor,findCropRightX,,27,50,34,4,0.1917,0.0933,0,4,6,0,1,"/**
     * This method scans image pixels to the right until it finds next row where all pixel are white, y1 and y2.
     * TODO: resiti broblem tolerancije n aboju bacgrounda kada ima prelaz...
     * @return - return true  when x2 value is changed and false when x2 value is not changed
     */
    private boolean findCropRightX() {
        for (int x = cropLeftX + 1; x < imageWithChars.getWidth(); x++) {   // start from current cropLeftX position and scan pixels to the right
            int whitePixCounter = 0;
            for (int y = cropTopY; y <= cropBottomY; y++) {             // vertical pixel scan at current x coordinate
                if (imageWithChars.getRGB(x, y) == -1) {                    // if we have white pixel at current (x, y)
                    whitePixCounter++;                                      // increase whitePixCounter
                }
            }
            
            // this is for space!
            int heightPixels = cropBottomY - cropTopY;                      // calculate crop height
            if (whitePixCounter == heightPixels+1) {                         // if white pixel count is equal to crop height+1  then this is white vertical line, means end of current char/ (+1 is for case when there is only 1 pixel; a 'W' bug fix)
                cropRightX = x;                                             // so set cropRightX    
                return true;                                                // and return true
            }
            
            // why we need this when we allready have condiiton in the for loop? - for the last letter in the row.
            if (x == imageWithChars.getWidth() - 1) {                       // if we have reached end of row with x position    
                cropRightX = x;                                             // set cropRightX
                endOfRow = true;                                            // set endOfRow flag
                return true;                                                // and return true
            }
        }
        
//        endOfRow = true;                                                    // da li ovo treba , nije ga bilo?
        return false;                                                       // return false if we have not found vertical white line (end of letter) to the right
    }"
neuroph,org.neuroph.ocr.CharExtractor,extractCharImagesToLearn,,60,776,732,17,0.0637,0.026,0.4,11,7,0,1,"/**
     * Creates HashMap with characters as keys and BufferedImages as values
     * @param Dimensions to which output char images has to be resized to
     * @param list of letters which are names of images
     * @return HashMap with characters as keys and char images as values
     * This method returns HashMap with characters as keys and char images as values
     */
    public HashMap<String, BufferedImage> extractCharImagesToLearn(BufferedImage imageWithText, List<String> chars, Dimension dim) {
        this.imageWithChars = imageWithText;
        
        HashMap<String, BufferedImage> charImages = new HashMap<String, BufferedImage>();

        // scans image from top to botoom, and left to right and seeks nonwhite/black pixels
        
        int i = 0;
        while (endOfImage == false) {               // until the end of the image is reached do the following
            endOfRow = false;                       // reset endOfRow flag on each new text row start
            boolean foundTop = findCropTopY();      // find top coordinate for crop
            boolean foundBottom = false;            // reset foundBottom flag on each new text row start, after the top coordinate is found
            if (foundTop == true) {                 // make sure we have top position and proceed. Otherwise we have reached end of image
                foundBottom = findCropBottomY();    // find bottom coordinate for crop
                if (foundBottom == true) {          // make sure we have bottom coordinateand  proceed. At this point we have top and bottom crop coordinates.
                    while (endOfRow == false) {     // while we have not reached the end of row
                        boolean foundLeft = false;      // at  begining of the row set left and right crop flags to false
                        boolean foundRight = false;
                        foundLeft = findCropLeftX();    // first find left crop position
                        if (foundLeft == true) {        // make sure we have left crop position and proceed
                            foundRight = findCropRightX();  // find right crop position
                            if (foundRight == true) {       // make sure we have right position, and proceed
                                // crop, trim and resize character image - next two lines extracts characers, this should be fixed to deal with variable spacing between chars ...
                                BufferedImage charImage = ImageUtilities.cropImage(imageWithText, cropLeftX, cropTopY, cropRightX, cropBottomY);  // first crop  image at specified positions
                                charImage =  ImageUtilities.trimImage(charImage);   // then trim image just in case
                                // deal with 'I' 'i' 'l' 'j' chars - ako su manji zalepi ih centrirane na blok...
//                                if (charImage.getWidth() < (charImage.getHeight() /2)) {
//                                    BufferedImage bi = new BufferedImage(dim.getWidth(), dim.getHeight(), BufferedImage.TYPE_INT_RGB);
//                                    bi.getGraphics().setColor(Color.WHITE);
//                                    bi.getGraphics().fillRect(0, 0, bi.getWidth(), bi.getHeight());
//                                    bi.getGraphics().drawImage(charImage, bi.getWidth()/2 - charImage.getWidth()/2, 0, null);
//                                    charImage = bi;
//                                }    else 
                                
                                // and at the end scale image to specified size
                                charImage = ImageUtilities.resizeImage(charImage, dim.getWidth(), dim.getHeight());                               
                                charImages.put(chars.get(i), charImage);    // add char image to collection which will be returned
                                // we can write images to file here to see what comes out, for debuging
//                                try {
//                                    ImageIO.write(charImage  , ""PNG"", new File(chars.get(i)+"".png""));
//                                } catch (IOException ex) {
//                                    Exceptions.printStackTrace(ex);
//                                }
                                i++;

                            } // found right
                        } // found left
                    } // end of row
                    cropLeftX = 0;  // at th eend of each row reset left and right x coordinates
                    cropRightX = 0;
                } //foundBottom
            } // foundTop
        } // end of image
        
        cropTopY = 0;
        cropBottomY = 0;
        endOfImage = false;

        return charImages;
    }"
neuroph,org.neuroph.ocr.CharExtractor,extractCharImagesToRecognize,,35,315,279,7,0.0903,0.0501,0.5,7,7,0,1,"/**
     * Extracts and returns char images to recognize as list of images
     * @return 
     */
    public List<BufferedImage> extractCharImagesToRecognize() {
        List<BufferedImage> trimedImages = new ArrayList<BufferedImage>();
        int i = 0;

        while (endOfImage == false) {
            endOfRow = false;
            boolean foundTop = findCropTopY();
            boolean foundBottom = false;
            if (foundTop == true) {
                foundBottom = findCropBottomY();
                if (foundBottom == true) {
                    while (endOfRow == false) {
                        boolean foundLeft = false;
                        boolean foundRight = false;
                        foundLeft = findCropLeftX();
                        if (foundLeft == true) {
                            foundRight = findCropRightX();
                            if (foundRight == true) {
                                BufferedImage image = ImageUtilities.trimImage(ImageUtilities.cropImage(imageWithChars, cropLeftX, cropTopY, cropRightX, cropBottomY));
                                trimedImages.add(image);                                
                                i++;                                                                               
                            }
                        }
                    }
                    cropLeftX = 0;
                    cropRightX = 0;
                }
            }
        }
        cropTopY = 0;
        cropBottomY = 0;
        endOfImage = false;

        return trimedImages;
    }"
neuroph,org.neuroph.ocr.OCRTextRecognition,recognize,,15,46,37,4,0.1717,0.0583,1,4,3,0,1,"/**
     * recognize the text on the image (document)
     */
    public void recognize() {
        int imageHeight = image.getHeight();
        int imageWidth = image.getWidth();
        visited = new boolean[imageHeight][imageWidth];
        text = """";

        for (int i = 0; i < textInformation.numberOfRows(); i++) {
            String rowText = recognizeRow(i);
            if (!rowText.isEmpty()) {
                text += rowText + ""\n"";
            }
        }

        visited = null; //prevent lottering
    }"
neuroph,org.neuroph.ocr.OCRTextRecognition,recognizeRow,,19,40,14,2,0.25,0.171,0.5,7,3,0,1,"private String recognizeRow(int row) {
        String rowText = """";
        List<WordPosition> words = textInformation.getWordsAtRow(row);

        for (int i = 0; i < words.size(); i++) {
            int rowPixel = textInformation.getRowAt(row);
            WordPosition word = words.get(i);
            rowText += recognizeWord(word, rowPixel);

            if ((i + 1) == words.size()) { //trenutno smo na poslednjoj reci u redu
                rowText += addSpaces(word, null);
            } else {
                WordPosition next = words.get(i + 1);
                rowText += addSpaces(word, next);
            }
        }
        return rowText;

    }"
neuroph,org.neuroph.ocr.OCRTextRecognition,recognizeWord,,49,443,390,9,0.0775,0.0331,0.4,18,8,1,1,"private String recognizeWord(WordPosition word, int rowPixel) {
        String wordText = """";

        
        int tmpWidth = 3 * letterInformation.getCropWidth();
        int tmpHeight = 3 * letterInformation.getCropHeight();
        int trashsize = letterInformation.getTrashSize();
        
        OCRExtractLetter extractionLetter = new OCRExtractLetter(tmpWidth, tmpHeight, trashsize);
        
        int letterSize = letterInformation.getLetterSize();

        int start = word.getStartPixel();
        int end = word.getEndPixel();

        Color white = Color.WHITE;
        Color color;
        //======================================================================
        for (int j = start; j < end; j++) {
            for (int k = -(letterSize / 4); k < (letterSize / 4); k++) {
                int i = rowPixel + k;
                if (i < 0 || i > image.getHeight()) {
                    continue;
                }

        //======================================================================
//        gornja vrzija je ispravna ova ne radi kako treba
//            for (int k = -(letterSize / 4); k < (letterSize / 4); k++) {
//            int i = rowPixel + k;
//            if (i < 0 || i > image.getHeight()) {
//                continue;
//            }
//            for (int j = start; j < end; j++) {
        //======================================================================
                color = new Color(image.getRGB(j, i));
                if (color.equals(white)) {
                    visited[i][j] = true;
                } else if (visited[i][j] == false) {
                    BufferedImage letter = extractionLetter.extraxtLetter(image, visited, i, j);  //OCRUtilities.extraxtCharacterImage(image, visited, i, j, tmpWidth, tmpHeight, letterInformation.getTrashSize());
                    if (letter != null) {
                        OCRCropLetter crop = new OCRCropLetter(letter, letterInformation.getCropWidth(), letterInformation.getCropHeight());
                        BufferedImage croped = crop.processImage();
                        wordText += recognizeLetter(croped);
                    }
                }
            }
        }
        return wordText;
    }"
neuroph,org.neuroph.ocr.OCRTextRecognition,addSpaces,,13,30,24,4,0.1905,0.1081,0.666666667,6,3,0,1,"private String addSpaces(WordPosition first, WordPosition second) {
        if (second == null) {
            return """";
        }
        String space = """";
        int gap = second.getStartPixel() - first.getEndPixel();
        int num = gap / letterInformation.getSpaceGap();

        for (int i = 0; i < num; i++) {
            space += "" "";
        }
        return space;
    }"
neuroph,org.neuroph.ocr.OCRTextRecognition,saveText,,19,65,52,4,0.1635,0.0962,0,6,4,0,1,"/**
     * save the recognized text to the file specified earlier in location folder
     */
    public void saveText() {
        try {
            File file = new File(recognizedTextPath);
            if (!file.exists()) {
                file.createNewFile();
            }
            String[] lines = text.split(""\n"");
            FileWriter fw = new FileWriter(file.getAbsoluteFile());
            BufferedWriter bw = new BufferedWriter(fw);
            for (String line : lines) {
                bw.write(line);
                bw.newLine();
            }
            bw.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }

    }"
neuroph,org.neuroph.ocr.OcrUtils,blackAndWhiteCleaning,,10,11,1,3,0.5238,0.2833,0.25,3,4,0,1,"/**
     * This method cleans input image by replacing
     * all non black pixels with white pixels
     * @param image - input image that will be cleaned
     * @return - cleaned input image as BufferedImage
     */
    public static Image blackAndWhiteCleaning(Image image) {
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getPixel(i, j) != -16777216) {
                    image.setPixel(i, j, -1);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.ocr.OcrUtils,blackAndGrayCleaning,,12,13,0,3,0.5833,0.3457,0.25,3,4,0,1,"/**
     * This method cleans input image by replacing all pixels with RGB values
     * from -4473925 (gray) to -1 (white) with white pixels and
     * from -4473925 (gray) to -16777216 (black) with black pixels
     * @param image - input image that will be cleaned
     * @return - cleaned input image as BufferedImage
     */
    public static Image blackAndGrayCleaning(Image image) {
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getPixel(i, j) > -4473925) {
                    image.setPixel(i, j, -1);
                } else {
                    image.setPixel(i, j, -16777216);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.ocr.OcrUtils,blackAndLightGrayCleaning,,12,13,0,3,0.5833,0.3457,0.25,3,4,0,1,"/**
     * This method cleans input image by replacing all pixels with RGB values
     * from -3092272 (light gray) to -1 (white) with white pixels and
     * from -3092272 (light gray) to -16777216 (black) with black pixels
     * @param image - input image that will be cleaned
     * @return - cleaned input image as BufferedImage
     */
    public static Image blackAndLightGrayCleaning(Image image) {
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getPixel(i, j) > -4473925) {
                    image.setPixel(i, j, -1);
                } else {
                    image.setPixel(i, j, -16777216);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.ocr.OcrUtils,colorCleaning,,12,13,0,3,0.4688,0.3117,0.25,4,4,0,1,"/**
     * This method cleans input image by replacing all pixels with RGB values
     * from RGBcolor input (the input color) to -1 (white) with white pixels and
     * from RGBcolor input (the input color) to -16777216 (black) with black pixels
     * @param image - input image that will be cleaned
     * @param RGBcolor - input RGB value of wanted color as reference for celaning
     * @return - cleaned input image as BufferedImage
     */
    public static Image colorCleaning(Image image, int RGBcolor) {  	
        for (int j = 0; j < image.getHeight(); j++) {
            for (int i = 0; i < image.getWidth(); i++) {
                if (image.getPixel(i, j) == RGBcolor) {
                    image.setPixel(i, j, -16777216);
                } else {
                    image.setPixel(i, j, -1);
                }
            }
        }
        return image;
    }"
neuroph,org.neuroph.ocr.OcrUtils,trimLockup,,10,10,5,3,0.4444,0.1786,0.333333333,3,4,0,1,"/**
     * This method reads the image pixels until it reads the first black pixel
     * by height and then returns that value
     * @param Img - input image that will be read
     * @return - returns the value of height when conditions are true
     */
    private static int trimLockup(Image img) {
        for (int j = 0; j < img.getHeight(); j++) {
            for (int i = 0; i < img.getWidth(); i++) {
                if (img.getPixel(i, j) == -16777216) {
                    return j;
                }
            }
        }
        return 0;
    }"
neuroph,org.neuroph.ocr.OcrUtils,trimLockdown,,21,37,8,3,0.3167,0.2077,0.333333333,5,7,0,1,"/**
     * This method reads the input image from the input from
     * start pixel height (y1) until it reads the first next row
     * where all pixel are white by height and return that value
     * @param Img - input image that will be read
     * @param y1 - input start height pixel of image
     * @return - returns the value of height when conditions are true
     */
    private static int trimLockdown(Image img, int y1) {
        for (int j = y1 + 1; j < img.getHeight(); j++) {
            int counterWhite = 0;
            for (int i = 0; i < img.getWidth(); i++) {
                if (img.getPixel(i, j) == -1) {
                    counterWhite++;
                }
            }
            if (counterWhite == img.getWidth()) {
                //this is a chek for dots over the letters i and j
                //so they wont be missread as dots
                if (j > (img.getHeight() / 2)) {
                    return j;
                }
            }
            if (j == img.getHeight() - 1) {
                return j + 1;
            }
        }
        return 0;
    }"
neuroph,org.neuroph.ocr.OcrPlugin,sortHashMapByValues,,32,194,157,3,0.1224,0.0709,0,11,4,0,1,"/**
     * This private method sorts the result of the recogntion, in order to
     * see which letter has the highest probability
     *
     * @param passedMap the HashMap that holds the resault of the recognition process
     *
     * @return LinkedHashMap that represents the combination of letters with the
     *                       probability of the correct recognition
     */
    private LinkedHashMap sortHashMapByValues(HashMap passedMap) {
        List mapKeys = new ArrayList(passedMap.keySet());
        List mapValues = new ArrayList(passedMap.values());
        Collections.sort(mapValues);
        Collections.sort(mapKeys);
        Collections.reverse(mapValues);

        LinkedHashMap sortedMap = new LinkedHashMap();

        Iterator valueIt = mapValues.iterator();
        while (valueIt.hasNext()) {
            Object val = valueIt.next();
            Iterator keyIt = mapKeys.iterator();

            while (keyIt.hasNext()) {
                Object key = keyIt.next();
                String comp1 = passedMap.get(key).toString();
                String comp2 = val.toString();

                if (comp1.equals(comp2)) {
                    passedMap.remove(key);
                    mapKeys.remove(key);
                    Character charKey = Character.valueOf(key.toString().charAt(0));
                    sortedMap.put(charKey, (Double) val);
                    break;
                }

            }

        }
        return sortedMap;
    }"
neuroph,org.neuroph.ocr.OcrHelper,createTrainingSet,,62,752,724,24,0.0513,0.0186,0.75,15,3,0,1,"/**
     * Create training set 
     * 
     * @param imageWithChars
     * @param chars
     * @param scaleToDim
     * @param trainingSetName 
     */
    public static DataSet createTrainingSet (String trainingSetName, BufferedImage imageWithChars, String chars, Dimension scaleToDim, List<String> imageLabels){

        // convert chars from string to list 
        List<String> charList = Arrays.asList(chars.split("" ""));        // izgleda da ovo zeza...
        // extract individual char images which will be used to create training set
        CharExtractor charExtractor = new CharExtractor(imageWithChars);
        HashMap <String, BufferedImage> charImageMap = charExtractor.extractCharImagesToLearn(imageWithChars, charList, scaleToDim);
        
       
       // prepare image labels (we need them to label output neurons...)
       // ArrayList<String> imageLabels = new ArrayList<String>();   
        for (String imgName : charImageMap.keySet()) {
            StringTokenizer st = new StringTokenizer(imgName, ""._"");
            String imgLabel = st.nextToken();
            if (!imageLabels.contains(imgLabel)) { // check for duplicates ...
                imageLabels.add(imgLabel);
            }
        }
        Collections.sort(imageLabels);
        
        // get RGB image data - map chars and their their rgb data
        Map<String, FractionRgbData> imageRgbData = ImageUtilities.getFractionRgbDataForImages(charImageMap);
                       
        // also put junk all black and white image in training set (for black n whit emode)
        BufferedImage allWhite = new BufferedImage(scaleToDim.getWidth(), scaleToDim.getHeight(), BufferedImage.TYPE_INT_RGB);
        Graphics g = allWhite.getGraphics();
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, allWhite.getWidth(), allWhite.getHeight());
        imageRgbData.put(""allWhite"", new FractionRgbData(allWhite));
        
//        BufferedImage allBlack = new BufferedImage(charDimension.getWidth(), charDimension.getHeight(), BufferedImage.TYPE_INT_RGB);
//        g = allBlack.getGraphics();
//        g.setColor(Color.BLACK);
//        g.fillRect(0, 0, allBlack.getWidth(), allBlack.getHeight());
//        imageRgbData.put(""allBlack"", new FractionRgbData(allBlack));        
                      
        // put junk images (all red, blue, green) to avoid errors (used for full color mode)
//        BufferedImage allRed = new BufferedImage(charDimension.getWidth(), charDimension.getHeight(), BufferedImage.TYPE_INT_RGB);
//        Graphics g = allRed.getGraphics();
//        g.setColor(Color.RED);
//        g.fillRect(0, 0, allRed.getWidth(), allRed.getHeight());
//        imageRgbData.put(""allRed"", new FractionRgbData(allRed));        
//        
//        BufferedImage allBlue = new BufferedImage(charDimension.getWidth(), charDimension.getHeight(), BufferedImage.TYPE_INT_RGB);
//        g = allBlue.getGraphics(); 
//        g.setColor(Color.BLUE);
//        g.fillRect(0, 0, allBlue.getWidth(), allBlue.getHeight());
//        imageRgbData.put(""allBlue"", new FractionRgbData(allBlue));        
//        
//        BufferedImage allGreen = new BufferedImage(charDimension.getWidth(), charDimension.getHeight(), BufferedImage.TYPE_INT_RGB);
//        g = allGreen.getGraphics(); 
//        g.setColor(Color.GREEN);
//        g.fillRect(0, 0, allGreen.getWidth(), allGreen.getHeight());
//        imageRgbData.put(""allGreen"", new FractionRgbData(allGreen));                
                
        // create training set using image rgb data
        DataSet dataSet = ImageRecognitionHelper.createBlackAndWhiteTrainingSet(imageLabels, imageRgbData);
         //DataSet dataSet = ImageRecognitionHelper.createTrainingSet(this.imageLabels, imageRgbData);
        dataSet.setLabel(trainingSetName); 
                
        return dataSet;   
    }"
neuroph,org.neuroph.ocr.OcrHelper,recognize,,10,23,18,4,0.1875,0.0889,1,7,2,0,1,"public static List<Character> recognize (NeuralNetwork nnet, List<BufferedImage> images, Dimension charDimension){
        OcrPlugin  ocrPlugin = (OcrPlugin) nnet.getPlugin(OcrPlugin.class);      
        List<Character> letters = new ArrayList<Character>();

        for (BufferedImage img : images) {
            Character letter = ocrPlugin.recognizeCharacter(new ImageJ2SE(img), charDimension);
            letters.add(letter);
        }
        return letters;
    }"
neuroph,org.neuroph.ocr.filter.OCRCropLetter,createStartH,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createStartH() {
        int color;
        int black = 0;
        int startH = 0;
        loop:
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    startH = i;
                    break loop;
                }
            }
        }
        return startH;
    }"
neuroph,org.neuroph.ocr.filter.OCRCropLetter,createStartW,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createStartW() {
        int color;
        int black = 0;
        int startW = 0;
        loop:
        for (int j = 0; j < width; j++) {
            for (int i = 0; i < height; i++) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    startW = j;
                    break loop;
                }
            }
        }
        return startW;
    }"
neuroph,org.neuroph.ocr.filter.OCRCropLetter,createEndH,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createEndH() {
        int color;
        int black = 0;
        int endH = 0;
        loop:
        for (int i = height - 1; i >= 0; i--) {
            for (int j = width - 1; j >= 0; j--) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    endH = i;
                    break loop;
                }
            }
        }
        return endH;
    }"
neuroph,org.neuroph.ocr.filter.OCRCropLetter,createEndW,,16,44,33,3,0.1717,0.0778,0,5,4,0,1,"private int createEndW() {
        int color;
        int black = 0;
        int endW = 0;
        loop:
        for (int j = width - 1; j >= 0; j--) {
            for (int i = height - 1; i >= 0; i--) {
                color = new Color(originalImage.getRGB(j, i)).getRed();
                if (color == black) {
                    endW = j;
                    break loop;
                }
            }
        }
        return endW;
    }"
neuroph,org.neuroph.ocr.filter.OCRCropLetter,fillImage,,51,434,372,5,0.0689,0.0349,1,27,8,1,1,"private void fillImage(int startH, int startW, int endH, int endW) {

        // fill the image with white color
        int alpha = new Color(originalImage.getRGB(width / 2, height / 2)).getRed();
        int whiteRGB = ImageUtilities.colorToRGB(alpha, 255, 255, 255);
        for (int i = 0; i < newHeight; i++) {
            for (int j = 0; j < newWidth; j++) {
                filteredImage.setRGB(j, i, whiteRGB);
            }
        }

        // fill black pixels
        int oldCenterH = (startH + endH) / 2;
        int oldCenterW = (startW + endW) / 2;

        int newCenterH = newHeight / 2;
        int newCenterW = newWidth / 2;

        boolean[][] visited = new boolean[newHeight][newWidth];

        LinkedList<String> queue = new LinkedList<String>();
        String pos = newCenterH + "" "" + newCenterW + "" "" + oldCenterH + "" "" + oldCenterW;
        queue.addLast(pos);
        visited[newCenterH][newCenterW] = true;
        try {
            while (!queue.isEmpty()) {
                String tmp = queue.removeFirst();
                int nh = Integer.parseInt(tmp.split("" "")[0]);
                int nw = Integer.parseInt(tmp.split("" "")[1]);
                int oh = Integer.parseInt(tmp.split("" "")[2]);
                int ow = Integer.parseInt(tmp.split("" "")[3]);

                filteredImage.setRGB(nw, nh, originalImage.getRGB(ow, oh));

                for (int i = -1; i <= 1; i++) {
                    for (int j = -1; j <= 1; j++) {
                        int n_tmpH = nh + i;
                        int n_tmpW = nw + j;
                        int o_tmpH = oh + i;
                        int o_tmpW = ow + j;
                        if (!visited[n_tmpH][n_tmpW]) {
                            visited[n_tmpH][n_tmpW] = true;
                            queue.addLast(n_tmpH + "" "" + n_tmpW + "" "" + o_tmpH + "" "" + o_tmpW);
                        }
                    }
                }
            }

        } catch (IndexOutOfBoundsException e) {
        }
    }"
neuroph,org.neuroph.ocr.filter.OCRExtractLetter,extraxtLetter,,55,612,521,4,0.0763,0.0393,0,25,13,1,1,"/**
     * 
     * @param image image with whole text
     * @param visited matrix of boolean, size of the matrix should correspond to size of the image with text. This matrix is used like in BFS traversal.
     * @param startX starting point on X coordinate where the black pixel is found
     * @param startY starting point on Y coordinate where the black pixel is found
     * @return new image with extracted letter only if number of pixel in that letter is greater than trashSize 
     */
    public BufferedImage extraxtLetter(BufferedImage image, boolean[][] visited, int startX, int startY) {
        int gapWidth = cropWidth / 5 * 2;  //start x coordinate of letter, 2/5 itended
        int gapHeight = cropHeight / 5 * 2;  //start y coordinate of letter 
        LinkedList<String> queue = new LinkedList<String>();
        BufferedImage letter = new BufferedImage(cropWidth, cropHeight, image.getType());
        Color white = Color.WHITE;
        Color black = Color.BLACK;

        // fill all letter image with white pixels
        for (int i = 0; i < cropHeight; i++) {
            for (int j = 0; j < cropWidth; j++) {
                letter.setRGB(j, i, white.getRGB());
            }
        }
        int countPixels = 0; // ignore dots
        String positions = startX + "" "" + startY;
        visited[startX][startY] = true;
        queue.addLast(positions);
        while (!queue.isEmpty()) {
            String pos = queue.removeFirst();
            String[] posArray = pos.split("" "");
            int H = Integer.parseInt(posArray[0]); // H-height
            int W = Integer.parseInt(posArray[1]); // W-width
            visited[H][W] = true;

            int posW = W - startY + gapWidth;
            int posH = H - startX + gapHeight;

            countPixels++;

            letter.setRGB(posW, posH, black.getRGB());

            int color;
            int blackInt = 0;
            for (int i = H - 1; i <= H + 1; i++) {
                for (int j = W - 1; j <= W + 1; j++) {
                    if (i >= 0 && j >= 0 && i < image.getHeight() && j < image.getWidth()) {
                        if (!visited[i][j]) {
                            color = new Color(image.getRGB(j, i)).getRed();
                            if (color == blackInt) {
                                visited[i][j] = true;
                                String tmpPos = i + "" "" + j;
                                queue.addLast(tmpPos);
                            }
                        }
                    }
                }
            }
        }
        if (countPixels < trashSize) { //da ne bi uzimao male crtice, tacke

            return null;
        }
        return letter;
    }"
neuroph,org.neuroph.ocr.util.Letter,Letter,,14,45,35,4,0.157,0.104,0.666666667,6,1,0,1,"//    public Letter(int scanQuality, int fontSize) {
//        this.scanQuality = scanQuality;
//        this.fontSize = fontSize;
//
//        calculateDimensions();
//        calculateSmallestSizeLetter();
//        calculateLetterSize();
//        calculateTrashsize();
//        calculateSpaceGap();
//    }
    
    public Letter(int scanQuality, BufferedImage image) {
        this.scanQuality = scanQuality;
        this.image = image;    
        heightHistogram = Histogram.heightHistogram(image);
        gradient = Histogram.gradient(heightHistogram);
        calculateSmallestSizeLetter();
        List<Integer> rowHeights = OCRUtilities.rowHeights(gradient, smallestSizeLetter);
        int meanHeight = (int) caluclateMean(rowHeights);
        calculateDimensions(meanHeight);  
        calculateLetterSize(meanHeight);
        calculateSpaceGap(meanHeight);
        
        
    }"
neuroph,org.neuroph.ocr.util.Letter,calculateSmallestSizeLetter,,11,22,16,4,0.375,0.2222,0,0,4,0,1,"private void calculateSmallestSizeLetter() {
        if (scanQuality == 300) {
            smallestSizeLetter = 9;
        }
        if (scanQuality == 600) {
            smallestSizeLetter = 18;
        }
        if (scanQuality == 1200) {
            smallestSizeLetter = 36;
        }
    }"
neuroph,org.neuroph.ocr.util.Letter,caluclateMean,,7,10,5,3,0.3889,0.1429,0,3,2,0,1,"private double caluclateMean(List<Integer> list) {
        double sum = 0;
        for (Integer element : list) {
            sum+=element;
        }
        return sum/list.size();
    }"
neuroph,org.neuroph.ocr.util.OCRUtilities,wordsPositions,,21,92,64,3,0.1442,0.1044,0.666666667,12,4,0,1,"/**
     * Word is class with two parameters, startPixel and endPixel. This method
     * calculates these pixels for given row and return them as List of Word
     *
     * @param image input image, should be black-white
     * @param row given row
     * @param letterHeight predicted letter size
     * @param spaceGap predicted space size, spaces smaller that spaceGap are
     * not spaces between word, they are spaces between letter. Ignore spaces
     * between letters.
     * @return
     */
    public static List<WordPosition> wordsPositions(BufferedImage image, int row, int letterHeight, int spaceGap) {
        List<WordPosition> words = new ArrayList<WordPosition>();
        int[] histogram = OCRHistogram.widthRowHistogram(image, row, letterHeight);
        int[] histogramWLS = OCRHistogram.histogramWithoutLetterSpaces(histogram, spaceGap);

        int count = 0;
        for (int i = 0; i < histogramWLS.length; i++) {
            if (histogramWLS[i] != 0) {
                count++;
            } else { //(histogram[i] == 0) drugim recima vece je od nule
                if (count > 0) {
                    int start = i - count;
                    int end = i - 1;
                    WordPosition w = new WordPosition(start, end);
                    words.add(w);
                }
                count = 0;
            }
        }
        return words;
    }"
neuroph,org.neuroph.ocr.util.OCRUtilities,linePositions,,26,99,62,2,0.1765,0.1376,0,9,5,0,1,"/**
     * @param gradient gradient array calculated with method gradient(int [])
     * @param ignoredSize - noise - what is the minimum size of letter to be
     * recognized <br/>
     * With lower value you will probably find trash as separate line <br/>
     * With higher value you will probably miss the letter <br/>
     * Ideal value is less that the letter size
     * @return List of integers where each element represent center of line.
     * First element corresponds to the first line etc.
     */
    public static List<Integer> linePositions(int[] gradient, int ignoredSize) {
        ArrayList<Integer> lines = new ArrayList<Integer>();
        int sum = 0;
        int count = 0;
        for (int row = 0; row < gradient.length; row++) {
            
            sum += gradient[row];
            if (sum != 0) {
                count++;
                continue;
            }
            if (sum == 0) {
                if (count < ignoredSize) {
                    count = 0;
                } else { //count >= lineHeightThresh // found line!
                    int startLetter = row - count;
                    int endLetter = row;
                    int line = (startLetter + endLetter) / 2;
                    lines.add(line);
                    count = 0;
                }
            }
        }
        return lines;

    }"
neuroph,org.neuroph.ocr.util.OCRUtilities,rowHeights,,22,76,47,3,0.2111,0.1678,0,6,5,0,1,"public static List<Integer> rowHeights(int [] gradient, int ignoredSize) {
         ArrayList<Integer> heights = new ArrayList<Integer>();
        int sum = 0;
        int count = 0;
        for (int row = 0; row < gradient.length; row++) {
            
            sum += gradient[row];
            if (sum != 0) {
                count++;
                continue;
            }
            if (sum == 0) {
                if (count < ignoredSize) {
                    count = 0;
                } else { //count >= lineHeightThresh // found line!
                    heights.add(count);
                    count=0;
                }
            }
        }
        return heights;
    }"
neuroph,org.neuroph.ocr.util.histogram.Histogram,heightHistogram,,17,62,46,3,0.1795,0.0719,0,8,4,0,1,"/**
     * @param image binarized image, letters are black, background is white
     * @return array which length is height of image, every element of array
     * represent count of black pixels in that row.
     */
    public static int[] heightHistogram(BufferedImage image) {
        int height = image.getHeight();
        int width = image.getWidth();

        int[] histogram = new int[height];
        int black = 0;
        int color;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                color = new Color(image.getRGB(j, i)).getRed();
                if (color == black) {
                    histogram[i]++;
                }
            }
        }
        return histogram;
    }"
neuroph,org.neuroph.ocr.util.histogram.Histogram,widthHistogram,,17,62,46,3,0.1795,0.0719,0,8,4,0,1,"/**
     * @param image binarized image, letters are black, background is white
     * @return array which length is width of image, every element of array
     * represent count of black pixels in that column of pixels.
     */
    public static int[] widthHistogram(BufferedImage image) {
        int height = image.getHeight();
        int width = image.getWidth();

        int[] histogram = new int[width];
        int black = 0;
        int color;
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                color = new Color(image.getRGB(i, j)).getRed();
                if (color == black) {
                    histogram[i]++;
                }
            }
        }
        return histogram;
    }"
neuroph,org.neuroph.ocr.util.histogram.Histogram,gradient,,7,9,3,3,0.3889,0.2381,0,3,2,0,1,"/**
     * @param histogram histogram calculated by method
     * <b>heightHistogram(BufferedImage)</b> or 
     * <b>widthHistogram(BufferedImage)</b>
     * @return array that represents gradient Each element in array is
     * calculated in the following way:<br/>
     * gradient[i] = histogram[i] - histogram[i-1]
     */
    public static int[] gradient(int[] histogram) {
        int[] gradient = new int[histogram.length];
        for (int i = 1; i < gradient.length; i++) {
            gradient[i] = histogram[i] - histogram[i - 1];
        }
        return gradient;
    }"
neuroph,org.neuroph.ocr.util.histogram.OCRHistogram,widthRowHistogram,,20,73,55,3,0.1558,0.0658,0,10,6,0,1,"/**
     * Calculate the width histogram for single row. <br/>
     * Make the rectangle with: <br/>
     * width = width of the image<br/>
     * height = predicted height of letter<br/>
     * It scans this rectangle by width, start from left to right and finds all black
     * pixels in each column. Method returns array which length is width of the image. 
     * Every element in array corresponds to number of black pixels in the column of 
     * the rectangle.
     * @param image input image with multiple lines and letters
     * @param row pixel position of the row. It should be center of the single row.
     * This number can be calculated by method findRowPixels
     * @param letterHeight predicted letter size (above and below row)
     * @return 
     */
    public static int[] widthRowHistogram(BufferedImage image, int row, int letterHeight) {
        int width = image.getWidth();
        int height = image.getHeight();
        int color;
        int black = 0;
        int[] histogram = new int[width];
        for (int i = 0; i < width; i++) {
            for (int j = row - (letterHeight / 2); j <= row + (letterHeight / 2); j++) {
                if (j < 0 || j >= height) {
                    continue;
                }
                color = new Color(image.getRGB(i, j)).getRed();
                if (color == black ) {
                    histogram[i]++;
                }
            }

        }
        return histogram;
    }"
neuroph,org.neuroph.ocr.util.histogram.OCRHistogram,histogramWithoutLetterSpaces,,18,43,20,4,0.2667,0.1619,0,5,6,0,1,"/**
     * Method for finding histogram but with ignoring spaces between lines/words<br/>
     * When you use only widthHistogram() method, it will find spaces between letters.
     * With this method you need to set the space gap will be ignored so you will get new 
     * histogram where the words are separated, not letters.
     * @param histogram classic width histogram
     * @param spaceGap size of the space which will be ignored
     * @return new histogram with ignored spaces. <br/>
     * Previously in histogram these spaces have had values of zero<br/>
     * Now they are filled with ones: histogram[i] = 1
     */
    public static int[] histogramWithoutLetterSpaces(int[] histogram, int spaceGap) {
        int count = 0;
        for (int i = 0; i < histogram.length; i++) {
            if (histogram[i] == 0) {
                count++;
            } else { //(histogram[i] != 0) drugim recima vece je od nule
//                System.out.println(i+""-""+count);
                if (count > 0 && count < spaceGap) {
                    for (int j = i - count; j < i; j++) {
                        histogram[j] = 1; // letter space
                    }
                }
                count = 0;
            }

        }
        return histogram;
    }"
neuroph,org.neuroph.samples.PerceptronSample,testNeuralNetwork,,11,14,7,2,0.3214,0.1508,0.6,4,2,0,1,"/**
     * Prints network output for the each element from the specified training set.
     * @param neuralNet neural network
     * @param testSet data set used for testing
     */
    public static void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        for(DataSetRow trainingElement : testSet.getRows()) {
            neuralNet.setInput(trainingElement.getInput());
            neuralNet.calculate();
            double[] networkOutput = neuralNet.getOutput();

            System.out.print(""Input: "" + Arrays.toString(trainingElement.getInput()) );
            System.out.println("" Output: "" + Arrays.toString(networkOutput) );
        }
    }"
neuroph,org.neuroph.samples.RBFClassificationSample,testNeuralNetwork,,10,21,14,3,0.2813,0.1173,0.6,4,2,0,1,"/**
     * Prints network output for the each element from the specified training set.
     * @param neuralNet neural network
     * @param testSet test data set
     */
    public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {
        for(DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();
            double[] networkOutput = neuralNet.getOutput();

            System.out.print(""Input: "" + Arrays.toString( testSetRow.getInput() ) );
            System.out.println("" Output: "" + Arrays.toString( networkOutput) );
        }
    }"
neuroph,org.neuroph.samples.XorResilientPropagationSample,run,,28,68,31,3,0.1744,0.1303,0.7,4,1,1,1,"/**
     * Runs this sample
     */
    public  void run() {
    	
        // create training set (logical XOR function)
        DataSet trainingSet = new DataSet(2, 1);
        trainingSet.addRow(new DataSetRow(new double[]{0, 0}, new double[]{0}));
        trainingSet.addRow(new DataSetRow(new double[]{0, 1}, new double[]{1}));
        trainingSet.addRow(new DataSetRow(new double[]{1, 0}, new double[]{1}));
        trainingSet.addRow(new DataSetRow(new double[]{1, 1}, new double[]{0}));

        // create multi layer perceptron
        MultiLayerPerceptron myMlPerceptron = new MultiLayerPerceptron(TransferFunctionType.SIGMOID, 2, 3, 1);
        // set ResilientPropagation learning rule
        myMlPerceptron.setLearningRule(new ResilientPropagation()); 
        LearningRule learningRule = myMlPerceptron.getLearningRule();
        learningRule.addListener(this);       
        
        // learn the training set
        System.out.println(""Training neural network..."");
        myMlPerceptron.learn(trainingSet);

        int iterations = ((SupervisedLearning)myMlPerceptron.getLearningRule()).getCurrentIteration();        
        System.out.println(""Learned in ""+iterations+"" iterations"");
        
        // test perceptron
        System.out.println(""Testing trained neural network"");
        testNeuralNetwork(myMlPerceptron, trainingSet);

    }"
neuroph,org.neuroph.samples.XorResilientPropagationSample,testNeuralNetwork,,11,14,7,2,0.3214,0.1508,0.6,4,2,0,1,"/**
     * Prints network output for each element from the specified training set.
     * @param neuralNet neural network
     * @param trainingSet training set
     */
    public static void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        for(DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();
            double[] networkOutput = neuralNet.getOutput();

            System.out.print(""Input: "" + Arrays.toString( testSetRow.getInput() ) );
            System.out.println("" Output: "" + Arrays.toString( networkOutput) );
        }
    }"
neuroph,org.neuroph.samples.XorResilientPropagationSample,handleLearningEvent,,6,5,4,3,0.5,0.2,1,2,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation)event.getSource();
        if (event.getEventType() != LearningEvent.Type.LEARNING_STOPPED)
            System.out.println(bp.getCurrentIteration() + "". iteration : ""+ bp.getTotalNetworkError());
    }"
neuroph,org.neuroph.samples.RandomizationSample,printWeights,,10,18,15,4,0.25,0.0648,1,5,4,0,1,"public static void printWeights(NeuralNetwork<?> neuralNet) {
        for (Layer layer : neuralNet.getLayers()) {
            for (Neuron neuron : layer.getNeurons()) {
                for (Connection connection : neuron.getInputConnections()) {
                    System.out.print(connection.getWeight().value + "" "");
                }
                System.out.println();
            }
        }
    }"
neuroph,org.neuroph.samples.XorMultiLayerPerceptronSample,run,,43,166,101,6,0.1165,0.1167,0.533333333,4,1,1,1,"/**
     * Runs this sample
     */
    public void run() {
    	
        // create training set (logical XOR function)
        DataSet trainingSet = new DataSet(2, 1);
        trainingSet.addRow(new DataSetRow(new double[]{0, 0}, new double[]{0}));
        trainingSet.addRow(new DataSetRow(new double[]{0, 1}, new double[]{1}));
        trainingSet.addRow(new DataSetRow(new double[]{1, 0}, new double[]{1}));
        trainingSet.addRow(new DataSetRow(new double[]{1, 1}, new double[]{0}));

        // create multi layer perceptron
        MultiLayerPerceptron myMlPerceptron = new MultiLayerPerceptron(TransferFunctionType.SIGMOID, 2, 3, 1);
        myMlPerceptron.randomizeWeights(new WeightsRandomizer(new Random(123)));
        
        System.out.println(Arrays.toString(myMlPerceptron.getWeights()));

        myMlPerceptron.setLearningRule(new BackPropagation());
      
        myMlPerceptron.getLearningRule().setLearningRate(0.5);
        // enable batch if using MomentumBackpropagation
//        if( myMlPerceptron.getLearningRule() instanceof MomentumBackpropagation )
//        	((MomentumBackpropagation)myMlPerceptron.getLearningRule()).setBatchMode(false);

        LearningRule learningRule = myMlPerceptron.getLearningRule();
        learningRule.addListener(this);
        
        // learn the training set
        System.out.println(""Training neural network..."");
        myMlPerceptron.learn(trainingSet);

        // test perceptron
        System.out.println(""Testing trained neural network"");
        testNeuralNetwork(myMlPerceptron, trainingSet);

        // save trained neural network
        myMlPerceptron.save(""myMlPerceptron.nnet"");

        // load saved neural network
        NeuralNetwork loadedMlPerceptron = NeuralNetwork.createFromFile(""myMlPerceptron.nnet"");

        // test loaded neural network
        System.out.println(""Testing loaded neural network"");
        testNeuralNetwork(loadedMlPerceptron, trainingSet);
    }"
neuroph,org.neuroph.samples.XorMultiLayerPerceptronSample,testNeuralNetwork,,11,14,7,2,0.3214,0.1508,0.6,4,2,0,1,"/**
     * Prints network output for the each element from the specified training set.
     * @param neuralNet neural network
     * @param testSet test set
     */
    public static void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        for(DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();
            double[] networkOutput = neuralNet.getOutput();

            System.out.print(""Input: "" + Arrays.toString( testSetRow.getInput() ) );
            System.out.println("" Output: "" + Arrays.toString( networkOutput) );
        }
    }"
neuroph,org.neuroph.samples.XorMultiLayerPerceptronSample,handleLearningEvent,,6,5,4,3,0.5,0.2,1,2,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation)event.getSource();
        if (event.getEventType() != LearningEvent.Type.LEARNING_STOPPED)
            System.out.println(bp.getCurrentIteration() + "". iteration : ""+ bp.getTotalNetworkError());
    }"
neuroph,org.neuroph.samples.IrisClassificationSample,testNeuralNetwork,,11,14,7,2,0.3214,0.1508,0.6,4,2,0,1,"/**
     * Prints network output for the each element from the specified training set.
     * @param neuralNet neural network
     * @param testSet test data set
     */
    public static void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        for(DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();
            double[] networkOutput = neuralNet.getOutput();

            System.out.print(""Input: "" + Arrays.toString( testSetRow.getInput() ) );
            System.out.println("" Output: "" + Arrays.toString( networkOutput) );
        }
    }"
neuroph,org.neuroph.samples.adalineDigits.DigitsRecognition,testNeuralNetwork,,22,38,21,3,0.2208,0.125,0.666666667,6,4,0,1,"/**
     * Prints network output for the each element from the specified training
     * set.
     *
     * @param neuralNet neural network
     * @param testSet test data set
     */
    public static void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        System.out.println(""--------------------------------------------------------------------"");
        System.out.println(""***********************TESTING NEURAL NETWORK***********************"");
        for (DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();

            int izlaz = maxOutput(neuralNet.getOutput());

            String[] niz = Data.convertDataIntoImage(testSetRow.getInput());

            for (int i = 0; i < niz.length; i++) {
                if (i != niz.length - 1) {
                    System.out.println(niz[i]);
                } else {
                    System.out.println(niz[i] + ""----> "" + izlaz);
                }
            }
            System.out.println("""");
        }
    }"
neuroph,org.neuroph.samples.adalineDigits.DigitsRecognition,generateTraining,,27,40,25,2,0.1919,0.11,0.6,7,4,0,1,"public static DataSet generateTraining() {

        DataSet dataSet = new DataSet(Data.CHAR_WIDTH * Data.CHAR_HEIGHT, Data.DIGITS.length);

        for (int i = 0; i < Data.DIGITS.length; i++) {

            // setup input 
            DataSetRow inputRow = Data.convertImageIntoData(Data.DIGITS[i]);
            double[] input = inputRow.getInput();

            // setup output
            double[] output = new double[Data.DIGITS.length];

            for (int j = 0; j < Data.DIGITS.length; j++) {
                if (j == i) {
                    output[j] = 1;
                } else {
                    output[j] = 0;
                }
            }
            //creating new training element with specified input and output
            DataSetRow row = new DataSetRow(input, output);
            //adding row to data set
            dataSet.addRow(row);
        }
        return dataSet;
    }"
neuroph,org.neuroph.samples.adalineDigits.DigitsRecognition,maxOutput,,13,17,6,2,0.4063,0.2083,0,4,3,0,1,"public static int maxOutput(double[] array) {

        double max = array[0];
        int index = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                index = i;
                max = array[i];
            }
        }
        return index;
    }"
neuroph,org.neuroph.samples.adalineDigits.Data,convertImageIntoData,,16,20,12,2,0.2344,0.0815,0.5,7,4,0,1,"public static DataSetRow convertImageIntoData(String[] image) {

        DataSetRow dataSetRow = new DataSetRow(Data.CHAR_HEIGHT * Data.CHAR_WIDTH);

        double[] array = new double[Data.CHAR_WIDTH * Data.CHAR_HEIGHT];

        for (int row = 0; row < Data.CHAR_HEIGHT; row++) {
            for (int column = 0; column < Data.CHAR_WIDTH; column++) {
                int index = (row * Data.CHAR_WIDTH) + column;
                char ch = image[row].charAt(column);
                array[index] = (ch == 'O' ? 1 : -1);
            }
        }
        dataSetRow.setInput(array);
        return dataSetRow;
    }"
neuroph,org.neuroph.samples.adalineDigits.Data,convertDataIntoImage,,18,34,13,2,0.3182,0.2697,0,4,5,0,1,"public static String[] convertDataIntoImage(double[] data) {

        String[] image = new String[data.length / Data.CHAR_WIDTH];
        String row = """";

        for (int i = 0; i < data.length; i++) {
            if (data[i] == 1) {
                row += ""O"";
            } else {
                row += "" "";
            }
            if (row.length() % 5 == 0 && row.length() != 0) {
                image[i / 5] = row;
                row = """";
            }
        }
        return image;
    }"
neuroph,org.neuroph.samples.brestCancer.BrestCancerSample,run,,44,200,169,5,0.1039,0.0556,0.666666667,10,1,0,1,"public void run() {

        System.out.println(""Creating training and test set from file..."");
        String trainingSetFileName = ""data_sets/breast cancer.txt"";
        int inputsCount = 30;
        int outputsCount = 2;

        //Create data set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","");
        dataSet.shuffle();

        //Normalizing data set
        Normalizer normalizer = new MaxNormalizer();
        normalizer.normalize(dataSet);

        //Creatinig training set (70%) and test set (30%)
        DataSet[] trainingAndTestSet = dataSet.createTrainingAndTestSubsets(70, 30);
        DataSet trainingSet = trainingAndTestSet[0];
        DataSet testSet = trainingAndTestSet[1];

        System.out.println(""Creating neural network..."");
        //Create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 16, outputsCount);

        //attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        learningRule.setLearningRate(0.3);
        learningRule.setMaxError(0.001);
        learningRule.setMaxIterations(5000);

        System.out.println(""Training network..."");
        //train the network with training set
        neuralNet.learn(trainingSet);

        System.out.println(""Testing network...\n\n"");
        testNeuralNetwork(neuralNet, testSet);

        System.out.println(""Done."");

        System.out.println(""**************************************************"");

    }"
neuroph,org.neuroph.samples.brestCancer.BrestCancerSample,testNeuralNetwork,,36,132,93,3,0.1498,0.0984,0.5,22,2,1,1,"public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        System.out.println(""**************************************************"");
        System.out.println(""**********************RESULT**********************"");
        System.out.println(""**************************************************"");
        for (DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();

            //Finding network output
            double[] networkOutput = neuralNet.getOutput();
            int predicted = maxOutput(networkOutput);

            //Finding actual output
            double[] networkDesiredOutput = testSetRow.getDesiredOutput();
            int ideal = maxOutput(networkDesiredOutput);

            //Colecting data for network evaluation
            keepScore(predicted, ideal);
        }

        System.out.println(""Total cases: "" + this.count[2] + "". "");
        System.out.println(""Correctly predicted cases: "" + this.correct[2] + "". "");
        System.out.println(""Incorrectly predicted cases: "" + (this.count[2] - this.correct[2] - unpredicted) + "". "");
        System.out.println(""Unrecognized cases: "" + unpredicted + "". "");
        double percentTotal = (double) this.correct[2] * 100 / (double) this.count[2];
        System.out.println(""Predicted correctly: "" + formatDecimalNumber(percentTotal) + ""%. "");

        double percentM = (double) this.correct[0] * 100.0 / (double) this.count[0];
        System.out.println(""Prediction for 'M (malignant)' => (Correct/total): ""
                + this.correct[0] + ""/"" + count[0] + ""("" + formatDecimalNumber(percentM) + ""%). "");

        double percentB = (double) this.correct[1] * 100.0 / (double) this.count[1];
        System.out.println(""Prediction for 'B (benign)' => (Correct/total): ""
                + this.correct[1] + ""/"" + count[1] + ""("" + formatDecimalNumber(percentB) + ""%). "");
    }"
neuroph,org.neuroph.samples.brestCancer.BrestCancerSample,handleLearningEvent,,11,20,12,3,0.3333,0.1605,1,3,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation) event.getSource();
        if (event.getEventType().equals(LearningEvent.Type.LEARNING_STOPPED)) {
            double error = bp.getTotalNetworkError();
            System.out.println(""Training completed in "" + bp.getCurrentIteration() + "" iterations, "");
            System.out.println(""With total error: "" + formatDecimalNumber(error));
        } else {
            System.out.println(""Iteration: "" + bp.getCurrentIteration() + "" | Network error: "" + bp.getTotalNetworkError());
        }
    }"
neuroph,org.neuroph.samples.brestCancer.BrestCancerSample,maxOutput,,16,31,17,3,0.35,0.1705,0,4,4,0,1,"//Metod determines the maximum output. Maximum output is network prediction for one row. 
    public static int maxOutput(double[] array) {
        double max = array[0];
        int index = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                index = i;
                max = array[i];
            }
        }
        //If maximum is less than 0.5, that prediction will not count. 
        if (max < 0.5) {
            return -1;
        }
        return index;
    }"
neuroph,org.neuroph.samples.brestCancer.BrestCancerSample,keepScore,,12,30,24,4,0.2222,0.0714,0,2,3,0,1,"//Colecting data to evaluate network. 
    public void keepScore(int prediction, int ideal) {
        count[ideal]++;
        count[2]++;

        if (prediction == ideal) {
            correct[ideal]++;
            correct[2]++;
        }
        if (prediction == -1) {
            unpredicted++;
        }
    }"
neuroph,org.neuroph.samples.convolution.SimpleLearningExample,testLearningOneLayer,,48,161,132,8,0.1182,0.0743,0.461538462,7,1,0,1,"public static void testLearningOneLayer() {
        Dimension2D inputDimension = new Dimension2D(5, 5);

        Dimension2D convolutionKernel = new Dimension2D(3, 3);

        ConvolutionalNetwork convolutionNet = new ConvolutionalNetwork.Builder()
                .withInputLayer(5, 5, 1)
                .withConvolutionLayer(3, 3, 2)
                .withFullConnectedLayer(2)
                .build();
        

        // CREATE DATA SET

        DataSet dataSet = new DataSet(25, 2);
        dataSet.addRow(new double[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                new double[]{1, 0});
        dataSet.addRow(new double[]{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0},
                new double[]{0, 1});

        // TRAIN NETWORK

        convolutionNet.getLearningRule().setMaxError(0.00001);
        convolutionNet.learn(dataSet);
                
        System.out.println(""Done training!"");
        
        FeatureMapLayer featureMap1 = ((FeatureMapsLayer)convolutionNet.getLayerAt(1)).getFeatureMap(0);
        FeatureMapLayer featureMap2 = ((FeatureMapsLayer)convolutionNet.getLayerAt(1)).getFeatureMap(1);
        
//        WeightVisualiser visualiser1 = new WeightVisualiser(featureMap1, convolutionKernel);
//        visualiser1.displayWeights();
//
//        WeightVisualiser visualiser2 = new WeightVisualiser(featureMap2, convolutionKernel);
//        visualiser2.displayWeights();

        
        // CREATE TEST SET

        DataSet testSet = new DataSet(25, 2);
        testSet.addRow(new double[]{0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                new double[]{1, 0});
        testSet.addRow(new double[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                new double[]{1, 0});
        testSet.addRow(new double[]{0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0},
                new double[]{0, 1});

    }"
neuroph,org.neuroph.samples.convolution.mnist.MNISTDataSet,createDataSet,,45,385,274,2,0.1021,0.1573,0.428571429,15,7,0,1,"// TODO; remove sampleCount param its ame as  list count
    private static DataSet createDataSet(List<MNISTImage> imageList, int sampleCount) {

        int pixelCount = imageList.get(0).getSize();
        int totalSize = 1024;
        DataSet dataSet = new DataSet(totalSize, 10);

        for (int i = 0; i < sampleCount; i++) {
            MNISTImage dImage = imageList.get(i);
            double[] input = new double[totalSize];
            double[] output = new double[10];
            for (int j = 0; j < 10; j++) {
                output[j] = 0;
            }

            for (int j = 0; j < totalSize; j++) {
                input[j] = 0;
            }

            output[dImage.getLabel()] = 1;
            byte[] imageData = dImage.getData();
            int k = 66;
            for (int j = 0; j < pixelCount; j++) {
                if ((imageData[j] & 0xff) > 0)
                    input[k++] = 255;
                else
                    k++;
                if (j % 28 == 27)
                    k += 4;
            }
            DataSetRow row = new DataSetRow(input, output);
            dataSet.addRow(row);
        }
        dataSet.setColumnName(1024, ""0"");
        dataSet.setColumnName(1025, ""1"");
        dataSet.setColumnName(1026, ""2"");
        dataSet.setColumnName(1027, ""3"");
        dataSet.setColumnName(1028, ""4"");
        dataSet.setColumnName(1029, ""5"");
        dataSet.setColumnName(1030, ""6"");
        dataSet.setColumnName(1031, ""7"");
        dataSet.setColumnName(1032, ""8"");
        dataSet.setColumnName(1033, ""9"");
        
        return dataSet;
    }"
neuroph,org.neuroph.samples.convolution.util.LayerVisialize,displayWeight,,21,52,26,1,0.1748,0.1526,0.5,6,1,0,1,"private void displayWeight(List<Double> currentKernel) {

        JFrame frame = new JFrame(""Weight Visualiser: "");
        frame.setSize(400, 400);

        JLabel label = new JLabel();
        Dimension d = new Dimension(mapDimensions.getWidth() * RATIO, mapDimensions.getHeight() * RATIO);
        label.setSize(d);
        label.setPreferredSize(d);

        frame.getContentPane().add(label, BorderLayout.CENTER);
        frame.pack();
        frame.setVisible(true);

        BufferedImage image = new BufferedImage(mapDimensions.getWidth(), mapDimensions.getHeight(), BufferedImage.TYPE_BYTE_GRAY);

        int[] rgb = convertWeightToRGB(currentKernel);
        image.setRGB(0, 0, mapDimensions.getWidth(), mapDimensions.getHeight(), rgb, 0, mapDimensions.getWidth());
        label.setIcon(new ImageIcon(image.getScaledInstance(mapDimensions.getWidth() * RATIO, mapDimensions.getHeight() * RATIO, Image.SCALE_SMOOTH)));

    }"
neuroph,org.neuroph.samples.convolution.util.LayerVisialize,convertWeightToRGB,,10,30,24,4,0.2037,0.0786,0.5,5,2,0,1,"private int[] convertWeightToRGB(List<Double> pixels) {
        normalizeWeights(pixels);
        int[] data = new int[mapDimensions.getWidth() * mapDimensions.getHeight()];
        int i = 0;
        for (Double weight : pixels) {
            int val = (int) (weight * 255);
            data[i++] = new Color(val, val, val).getRGB();
        }
        return data;
    }"
neuroph,org.neuroph.samples.convolution.util.LayerVisialize,normalizeWeights,,13,32,19,3,0.2571,0.0951,0,6,3,0,1,"private void normalizeWeights(List<Double> weights) {
        double min = Double.MAX_VALUE;
        double max = Double.MIN_VALUE;
        for (Double weight : weights) {
            min = Math.min(min, weight);
            max = Math.max(max, weight);
        }

        for (int i = 0; i < weights.size(); i++) {
            double value = (weights.get(i) - min) / (max - min);
            weights.set(i, value);
        }
    }"
neuroph,org.neuroph.samples.convolution.util.WeightVisualiser,displayWeight,,21,52,26,1,0.1748,0.1526,0.5,6,1,0,1,"private void displayWeight(List<Double> currentKernel) {

		JFrame frame = new JFrame(""Weight Visualiser: "");
		frame.setSize(400, 400);

		JLabel label = new JLabel();
		Dimension d = new Dimension(kernel.getWidth() * RATIO, kernel.getHeight() * RATIO);
		label.setSize(d);
		label.setPreferredSize(d);

		frame.getContentPane().add(label, BorderLayout.CENTER);
		frame.pack();
		frame.setVisible(true);

		BufferedImage image = new BufferedImage(kernel.getWidth(), kernel.getHeight(), BufferedImage.TYPE_BYTE_GRAY);

		int[] rgb = convertWeightToRGB(currentKernel);
		image.setRGB(0, 0, kernel.getWidth(), kernel.getHeight(), rgb, 0, kernel.getWidth());
		label.setIcon(new ImageIcon(image.getScaledInstance(kernel.getWidth() * RATIO, kernel.getHeight() * RATIO, Image.SCALE_SMOOTH)));

	}"
neuroph,org.neuroph.samples.convolution.util.WeightVisualiser,convertWeightToRGB,,10,30,24,4,0.2037,0.0786,0.5,5,2,0,1,"private int[] convertWeightToRGB(List<Double> weights) {
		normalizeWeights(weights);
		int[] data = new int[kernel.getWidth() * kernel.getHeight()];
		int i = 0;
		for (Double weight : weights) {
			int val = (int) (weight * 255);
			data[i++] = new Color(val, val, val).getRGB();
		}
		return data;
	}"
neuroph,org.neuroph.samples.convolution.util.WeightVisualiser,normalizeWeights,,13,32,19,3,0.2571,0.0951,0,6,3,0,1,"private void normalizeWeights(List<Double> weights) {
		double min = Double.MAX_VALUE;
		double max = Double.MIN_VALUE;
		for (Double weight : weights) {
			min = Math.min(min, weight);
			max = Math.max(max, weight);
		}

		for (int i = 0; i < weights.size(); i++) {
			double value = (weights.get(i) - min) / (max - min);
			weights.set(i, value);
		}
	}"
neuroph,org.neuroph.samples.diabetes.DiabetesSample,run,,43,245,214,7,0.0952,0.048,0.666666667,10,1,0,1,"public void run() {

        System.out.println(""Creating training and test set from file..."");
        String trainingSetFileName = ""data_sets/diabetes.txt"";
        int inputsCount = 8;
        int outputsCount = 2;

        //Create data set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","");
        dataSet.shuffle();
        
        //Normalizing data set
        Normalizer normalizer = new MaxNormalizer();
        normalizer.normalize(dataSet);

        //Creatinig training set (70%) and test set (30%)
        DataSet[] trainingAndTestSet = dataSet.createTrainingAndTestSubsets(70, 30);
        DataSet trainingSet = trainingAndTestSet[0];
        DataSet testSet = trainingAndTestSet[1];
//        for (int i = 0; i < 21; i++) {
        System.out.println(""Creating neural network..."");
        //Create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 20, 10, outputsCount);
//            System.out.println(""HIDDEN COUNT: "" + i);
        //attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        learningRule.setLearningRate(0.05);
        learningRule.setMaxError(0.01);
        learningRule.setMaxIterations(100000);

        System.out.println(""Training network..."");
        //train the network with training set
        neuralNet.learn(trainingSet);

        System.out.println(""Testing network...\n\n"");
        testNeuralNetwork(neuralNet, testSet);

        System.out.println(""Done."");
        System.out.println(""**************************************************"");
//        }
    }"
neuroph,org.neuroph.samples.diabetes.DiabetesSample,testNeuralNetwork,,39,175,119,3,0.1364,0.0974,0.5,24,2,1,1,"public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        System.out.println(""**************************************************"");
        System.out.println(""**********************RESULT**********************"");
        System.out.println(""**************************************************"");
        for (DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();

            //Finding network output
            double[] networkOutput = neuralNet.getOutput();
            int predicted = maxOutput(networkOutput);

            //Finding actual output
            double[] networkDesiredOutput = testSetRow.getDesiredOutput();
            int ideal = maxOutput(networkDesiredOutput);

            //Colecting data for network evaluation
            keepScore(predicted, ideal);
        }

        System.out.println(""Total cases: "" + this.count[2] + "". "");
        System.out.println(""Correctly predicted cases: "" + this.correct[2] + "". "");
        System.out.println(""Incorrectly predicted cases: "" + (this.count[2] - this.correct[2] - unpredicted) + "". "");
        System.out.println(""Unrecognized cases: "" + unpredicted + "". "");
        double percentTotal = (double) this.correct[2] * 100 / (double) this.count[2];
        System.out.println(""Predicted correctly: "" + formatDecimalNumber(percentTotal) + ""%. "");

        double percentM = (double) this.correct[0] * 100.0 / (double) this.count[0];
        System.out.println(""Prediction for 'tested positive' => (Correct/total): ""
                + this.correct[0] + ""/"" + count[0] + ""("" + formatDecimalNumber(percentM) + ""%). "");

        double percentB = (double) this.correct[1] * 100.0 / (double) this.count[1];
        System.out.println(""Prediction for 'tested negative' => (Correct/total): ""
                + this.correct[1] + ""/"" + count[1] + ""("" + formatDecimalNumber(percentB) + ""%). "");
        this.count = new int[3];
        this.correct = new int[3];
        unpredicted = 0;
    }"
neuroph,org.neuroph.samples.diabetes.DiabetesSample,handleLearningEvent,,11,20,12,3,0.3333,0.1605,1,3,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation) event.getSource();
        if (event.getEventType().equals(LearningEvent.Type.LEARNING_STOPPED)) {
            double error = bp.getTotalNetworkError();
            System.out.println(""Training completed in "" + bp.getCurrentIteration() + "" iterations, "");
            System.out.println(""With total error: "" + formatDecimalNumber(error));
        } else {
            System.out.println(""Iteration: "" + bp.getCurrentIteration() + "" | Network error: "" + bp.getTotalNetworkError());
        }
    }"
neuroph,org.neuroph.samples.diabetes.DiabetesSample,maxOutput,,16,31,17,3,0.35,0.1705,0,4,4,0,1,"//Metod determines the maximum output. Maximum output is network prediction for one row. 
    public static int maxOutput(double[] array) {
        double max = array[0];
        int index = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                index = i;
                max = array[i];
            }
        }
        //If maximum is less than 0.5, that prediction will not count. 
        if (max < 0.5) {
            return -1;
        }
        return index;
    }"
neuroph,org.neuroph.samples.diabetes.DiabetesSample,keepScore,,12,30,24,4,0.2222,0.0714,0,2,3,0,1,"//Colecting data to evaluate network.
    public void keepScore(int prediction, int ideal) {
        count[ideal]++;
        count[2]++;

        if (prediction == ideal) {
            correct[ideal]++;
            correct[2]++;
        }
        if (prediction == -1) {
            unpredicted++;
        }
    }"
neuroph,org.neuroph.samples.forestCover.TrainNetwork,createNeuralNetwork,,11,19,10,3,0.3333,0.216,0.454545455,2,1,0,1,"//Creating and saving neural network to file
    public void createNeuralNetwork() {
        System.out.println(""Creating neural network... "");
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(config.getInputCount(), config.getFirstHiddenLayerCount(), config.getSecondHiddenLayerCount(), config.getOutputCount());
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.setLearningRate(0.01);
        learningRule.setMaxError(0.1);
        learningRule.setMaxIterations(1000);
        System.out.println(""Saving neural network to file... "");
        neuralNet.save(config.getTrainedNetworkFileName());
        System.out.println(""Neural network successfully saved!"");
    }"
neuroph,org.neuroph.samples.forestCover.TrainNetwork,handleLearningEvent,,12,20,12,3,0.3333,0.1605,1,3,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation) event.getSource();
        if (event.getEventType().equals(LearningEvent.Type.LEARNING_STOPPED)) {
            double error = bp.getTotalNetworkError();
            System.out.println(""Training completed in "" + bp.getCurrentIteration() + "" iterations, "");
            System.out.println(""With total error: "" + formatDecimalNumber(error));
        } else {
            System.out.println(""Iteration: "" + bp.getCurrentIteration() + "" | Network error: "" + bp.getTotalNetworkError());

        }
    }"
neuroph,org.neuroph.samples.forestCover.GenerateData,createTrainingAndTestSet,,36,196,161,7,0.1263,0.0746,0.5,7,1,0,1,"public void createTrainingAndTestSet() {
        //Creating data set from file
        DataSet dataSet = createDataSet();
        dataSet.shuffle();

        //Splitting main data set to training set (75%) and test set (25%)
        DataSet[] trainingAndTestSet = dataSet.createTrainingAndTestSubsets(75, 25);

        //Saving training set to file
        DataSet trainingSet = trainingAndTestSet[0];
        System.out.println(""Saving training set to file..."");
        trainingSet.save(config.getTrainingFileName());

        System.out.println(""Training set successfully saved!"");

        //Normalizing test set
        DataSet testSet = trainingAndTestSet[1];
        System.out.println(""Normalizing test set..."");

        Normalizer nor = new MaxNormalizer();
        nor.normalize(testSet);

        System.out.println(""Saving normalized test set to file..."");
        testSet.shuffle();
        testSet.save(config.getTestFileName());
        System.out.println(""Normalized test set successfully saved!"");
        System.out.println(""Training set size: "" + trainingSet.getRows().size() + "" rows. "");
        System.out.println(""Test set size: "" + testSet.getRows().size() + "" rows. "");
        System.out.println(""-----------------------------------------------"");

        double percentTraining = (double) trainingSet.getRows().size() * 100.0 / (double) dataSet.getRows().size();
        double percentTest = (double) testSet.getRows().size() * 100.0 / (double) dataSet.getRows().size();
        System.out.println(""Training set takes "" + formatDecimalNumber(percentTraining) + ""% of main data set. "");
        System.out.println(""Test set takes "" + formatDecimalNumber(percentTest) + ""% of main data set. "");

    }"
neuroph,org.neuroph.samples.forestCover.GenerateData,createBalancedTrainingSet,,87,1101,977,5,0.0837,0.062,0.375,15,18,1,1,"//Creating balanced training set with defined maximum sample of each type od tree 
    public void createBalancedTrainingSet(int count) {
        //Creating empety data set
        DataSet balanced = new DataSet(54, 7);
        //Declare counter for all seven type of tree
        int firstType = 0;
        int secondType = 0;
        int thirdType = 0;
        int fourthType = 0;
        int fifthType = 0;
        int sixthType = 0;
        int seventhType = 0;

        DataSet trainingSet = DataSet.load(config.getTrainingFileName());
        List<DataSetRow> rows = trainingSet.getRows();
        System.out.println(""Test set size: "" + rows.size() + "" rows. "");

        for (DataSetRow row : rows) {
            //Taking desired output vector from loaded file
            double[] DesiredOutput = row.getDesiredOutput();
            int index = -1;
            //Find index of number one in output vector. 
            for (int i = 0; i < DesiredOutput.length; i++) {
                if (DesiredOutput[i] == 1.0) {
                    index = i;
                    break;
                }
            }
            //Add row to balanced data set if number of that type of tree is less than maximum
            switch (index + 1) {
                case 1:
                    if (firstType < count) {
                        balanced.addRow(row);
                        firstType++;
                    }
                    break;
                case 2:
                    if (secondType < count) {
                        balanced.addRow(row);
                        secondType++;
                    }
                    break;
                case 3:
                    if (thirdType < count) {
                        balanced.addRow(row);
                        thirdType++;
                    }
                    break;
                case 4:
                    if (fourthType < count) {
                        balanced.addRow(row);
                        fourthType++;
                    }
                    break;
                case 5:
                    if (fifthType < count) {
                        balanced.addRow(row);
                        fifthType++;
                    }
                    break;
                case 6:
                    if (sixthType < count) {
                        balanced.addRow(row);
                        sixthType++;
                    }
                    break;
                case 7:
                    if (seventhType < count) {
                        balanced.addRow(row);
                        seventhType++;
                    }
                    break;
                default:
                    System.out.println(""Error with output vector size! "");
            }
        }
        System.out.println(""Balanced test set size: "" + balanced.getRows().size() + "" rows. "");
        System.out.println(""Samples per tree: "");
        System.out.println(""First type: "" + firstType + "" samples. "");
        System.out.println(""Second type: "" + secondType + "" samples. "");
        System.out.println(""Third type: "" + thirdType + "" samples. "");
        System.out.println(""Fourth type: "" + fourthType + "" samples. "");
        System.out.println(""Fifth type: "" + fifthType + "" samples. "");
        System.out.println(""Sixth type: "" + sixthType + "" samples. "");
        System.out.println(""Seventh type: "" + seventhType + "" samples. "");

        balanced.save(config.getBalancedFileName());
    }"
neuroph,org.neuroph.samples.forestCover.GenerateData,normalizeBalancedTrainingSet,,12,17,6,3,0.3125,0.2006,0.571428571,2,1,0,1,"public void normalizeBalancedTrainingSet() {
        //Normalizing balanced training set with MaxNormalizer
        DataSet dataSet = DataSet.load(config.getBalancedFileName());
        Normalizer normalizer = new MaxNormalizer();
        normalizer.normalize(dataSet);

        System.out.println(""Saving normalized training data set to file... "");
        dataSet.shuffle();
        dataSet.shuffle();
        dataSet.save(config.getNormalizedBalancedFileName());
        System.out.println(""Normalized training data set successfully saved!"");
    }"
neuroph,org.neuroph.samples.forestCover.Evaluate,testNeuralNetwork,,33,107,78,3,0.1569,0.0806,0.5,19,3,1,1,"//Testing neural network
    public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        for (DataSetRow testSetRow : testSet.getRows()) {

            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();

            //Finding network output
            double[] networkOutput = neuralNet.getOutput();
            int predicted = maxOutput(networkOutput);

            //Finding actual output
            double[] networkDesiredOutput = testSetRow.getDesiredOutput();
            int ideal = maxOutput(networkDesiredOutput);

            //Colecting data for network evaluation
            keepScore(predicted, ideal);
        }

        System.out.println(""Total cases: "" + this.count[7] + "". "");
        System.out.println(""Correct cases: "" + this.correct[7] + "". "");
        System.out.println(""Incorrectly predicted cases: "" + (this.count[7] - this.correct[7] - unpredicted) + "". "");
        System.out.println(""Unrecognized cases: "" + unpredicted + "". "");

        double percentTotal = (double) this.correct[7] * 100 / (double) this.count[7];
        System.out.println(""Predicted correctly: "" + formatDecimalNumber(percentTotal) + ""%. "");

        for (int i = 0; i < correct.length - 1; i++) {
            double p = (double) this.correct[i] * 100.0 / (double) this.count[i];
            System.out.println(""Tree type: "" + (i + 1) + "" - Correct/total: ""
                    + this.correct[i] + ""/"" + count[i] + ""("" + formatDecimalNumber(p) + ""%). "");
        }
    }"
neuroph,org.neuroph.samples.forestCover.Evaluate,maxOutput,,16,31,17,3,0.35,0.1705,0,4,4,0,1,"//Metod determines the maximum output. Maximum output is network prediction for one row. 
    public static int maxOutput(double[] array) {
        double max = array[0];
        int index = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                index = i;
                max = array[i];
            }
        }
        //If maximum is less than 0.5, that prediction will not count.
        if (max < 0.5) {
            return -1;
        }
        return index;
    }"
neuroph,org.neuroph.samples.forestCover.Evaluate,keepScore,,12,30,24,4,0.2222,0.0714,0,2,3,0,1,"//Colecting data to evaluate network.
    public void keepScore(int actual, int ideal) {
        count[ideal]++;
        count[7]++;

        if (actual == ideal) {
            correct[ideal]++;
            correct[7]++;
        }
        if (actual == -1) {
            unpredicted++;
        }
    }"
neuroph,org.neuroph.samples.forestCover.ForestCoverType,generateDataSets,,14,60,54,9,0.2083,0.1184,0.25,2,1,0,1,"public static void generateDataSets(Config config) {
        GenerateData generate = new GenerateData(config);
        System.out.println(""***************************************************"");
        System.out.println(""STEP 1: Generate training (75%) and test (25%) files: "");
        generate.createTrainingAndTestSet();

        System.out.println(""***************************************************"");
        System.out.println(""STEP 2: Balancing training data set to have the same number (3000) of each tree: "");
        generate.createBalancedTrainingSet(3000);

        System.out.println(""***************************************************"");
        System.out.println(""STEP 3: Normalizing balanced training data set: "");
        generate.normalizeBalancedTrainingSet();
    }"
neuroph,org.neuroph.samples.forestCover.ForestCoverType,trainNetwork,,8,24,20,5,0.3125,0.1136,0.333333333,2,1,0,1,"public static void trainNetwork(Config config) {
        TrainNetwork program = new TrainNetwork(config);
        System.out.println(""***************************************************"");
        System.out.println(""STEP 4: Creating and Training neural network: "");
        program.createNeuralNetwork();
        program.train();
        evaluateNetwork(config);
    }"
neuroph,org.neuroph.samples.germanCreditData.GermanCreditDataSample,run,,44,200,169,5,0.1039,0.0556,0.666666667,10,1,0,1,"public void run() {

        System.out.println(""Creating training and test set from file..."");
        String trainingSetFileName = ""data_sets/german credit data.txt"";
        int inputsCount = 24;
        int outputsCount = 2;

        //Create data set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "" "");
        dataSet.shuffle();

        //Normalizing data set
        Normalizer normalizer = new MaxNormalizer();
        normalizer.normalize(dataSet);

        //Creatinig training set (70%) and test set (30%)
        DataSet[] trainingAndTestSet = dataSet.createTrainingAndTestSubsets(70, 30);
        DataSet trainingSet = trainingAndTestSet[0];
        DataSet testSet = trainingAndTestSet[1];

        System.out.println(""Creating neural network..."");
        //Create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 12, 6, outputsCount);

        //attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        learningRule.setLearningRate(0.01);
        learningRule.setMaxError(0.001);
        learningRule.setMaxIterations(10000);

        System.out.println(""Training network..."");
        //train the network with training set
        neuralNet.learn(trainingSet);

        System.out.println(""Testing network...\n\n"");
        testNeuralNetwork(neuralNet, testSet);

        System.out.println(""Done."");

        System.out.println(""**************************************************"");

    }"
neuroph,org.neuroph.samples.germanCreditData.GermanCreditDataSample,testNeuralNetwork,,36,132,93,3,0.1498,0.0984,0.5,22,2,1,1,"public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        System.out.println(""**************************************************"");
        System.out.println(""**********************RESULT**********************"");
        System.out.println(""**************************************************"");
        for (DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();

            //Finding network output
            double[] networkOutput = neuralNet.getOutput();
            int predicted = maxOutput(networkOutput);

            //Finding actual output
            double[] networkDesiredOutput = testSetRow.getDesiredOutput();
            int ideal = maxOutput(networkDesiredOutput);

            //Colecting data for network evaluation
            keepScore(predicted, ideal);
        }

        System.out.println(""Total cases: "" + this.count[2] + "". "");
        System.out.println(""Correctly predicted cases: "" + this.correct[2] + "". "");
        System.out.println(""Incorrectly predicted cases: "" + (this.count[2] - this.correct[2] - unpredicted) + "". "");
        System.out.println(""Unrecognized cases: "" + unpredicted + "". "");
        double percentTotal = (double) this.correct[2] * 100 / (double) this.count[2];
        System.out.println(""Predicted correctly: "" + formatDecimalNumber(percentTotal) + ""%. "");

        double percentM = (double) this.correct[0] * 100.0 / (double) this.count[0];
        System.out.println(""Prediction for 'Good credit risk' => (Correct/total): ""
                + this.correct[0] + ""/"" + count[0] + ""("" + formatDecimalNumber(percentM) + ""%). "");

        double percentB = (double) this.correct[1] * 100.0 / (double) this.count[1];
        System.out.println(""Prediction for 'Bad credit risk' => (Correct/total): ""
                + this.correct[1] + ""/"" + count[1] + ""("" + formatDecimalNumber(percentB) + ""%). "");
    }"
neuroph,org.neuroph.samples.germanCreditData.GermanCreditDataSample,handleLearningEvent,,11,20,12,3,0.3333,0.1605,1,3,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation) event.getSource();
        if (event.getEventType().equals(LearningEvent.Type.LEARNING_STOPPED)) {
            double error = bp.getTotalNetworkError();
            System.out.println(""Training completed in "" + bp.getCurrentIteration() + "" iterations, "");
            System.out.println(""With total error: "" + formatDecimalNumber(error));
        } else {
            System.out.println(""Iteration: "" + bp.getCurrentIteration() + "" | Network error: "" + bp.getTotalNetworkError());
        }
    }"
neuroph,org.neuroph.samples.germanCreditData.GermanCreditDataSample,maxOutput,,16,31,17,3,0.35,0.1705,0,4,4,0,1,"//Metod determines the maximum output. Maximum output is network prediction for one row. 
    public static int maxOutput(double[] array) {
        double max = array[0];
        int index = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                index = i;
                max = array[i];
            }
        }
        //If maximum is less than 0.5, that prediction will not count. 
        if (max < 0.5) {
            return -1;
        }
        return index;
    }"
neuroph,org.neuroph.samples.germanCreditData.GermanCreditDataSample,keepScore,,12,30,24,4,0.2222,0.0714,0,2,3,0,1,"//Colecting data to evaluate network. 
    public void keepScore(int prediction, int ideal) {
        count[ideal]++;
        count[2]++;
        
        if (prediction == ideal) {
            correct[ideal]++;
            correct[2]++;
        }
        if (prediction == -1) {
            unpredicted++;
        }
    }"
neuroph,org.neuroph.samples.ionosphere.IonosphereSample,run,,43,245,214,7,0.0952,0.048,0.666666667,10,1,0,1,"public void run() {

        System.out.println(""Creating training and test set from file..."");
        String trainingSetFileName = ""data_sets/ionosphere.txt"";
        int inputsCount = 34;
        int outputsCount = 2;

        //Create data set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","");
        dataSet.shuffle();

        //Normalizing data set
        Normalizer normalizer = new MaxNormalizer();
        normalizer.normalize(dataSet);

        //Creatinig training set (70%) and test set (30%)
        DataSet[] trainingAndTestSet = dataSet.createTrainingAndTestSubsets(70, 30);
        DataSet trainingSet = trainingAndTestSet[0];
        DataSet testSet = trainingAndTestSet[1];
//        for (int i = 0; i < 21; i++) {
        System.out.println(""Creating neural network..."");
        //Create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 16, 8, outputsCount);
//            System.out.println(""HIDDEN COUNT: "" + i);
        //attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.001);
        learningRule.setMaxIterations(10000);

        System.out.println(""Training network..."");
        //train the network with training set
        neuralNet.learn(trainingSet);

        System.out.println(""Testing network...\n\n"");
        testNeuralNetwork(neuralNet, testSet);

        System.out.println(""Done."");
        System.out.println(""**************************************************"");
//        }
    }"
neuroph,org.neuroph.samples.ionosphere.IonosphereSample,testNeuralNetwork,,39,175,119,3,0.1364,0.0974,0.5,24,2,1,1,"public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        System.out.println(""**************************************************"");
        System.out.println(""**********************RESULT**********************"");
        System.out.println(""**************************************************"");
        for (DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();

            //Finding network output
            double[] networkOutput = neuralNet.getOutput();
            int predicted = maxOutput(networkOutput);

            //Finding actual output
            double[] networkDesiredOutput = testSetRow.getDesiredOutput();
            int ideal = maxOutput(networkDesiredOutput);

            //Colecting data for network evaluation
            keepScore(predicted, ideal);
        }

        System.out.println(""Total cases: "" + this.count[2] + "". "");
        System.out.println(""Correctly predicted cases: "" + this.correct[2] + "". "");
        System.out.println(""Incorrectly predicted cases: "" + (this.count[2] - this.correct[2] - unpredicted) + "". "");
        System.out.println(""Unrecognized cases: "" + unpredicted + "". "");
        double percentTotal = (double) this.correct[2] * 100 / (double) this.count[2];
        System.out.println(""Predicted correctly: "" + formatDecimalNumber(percentTotal) + ""%. "");

        double percentM = (double) this.correct[0] * 100.0 / (double) this.count[0];
        System.out.println(""Prediction for 'Good' => (Correct/total): ""
                + this.correct[0] + ""/"" + count[0] + ""("" + formatDecimalNumber(percentM) + ""%). "");

        double percentB = (double) this.correct[1] * 100.0 / (double) this.count[1];
        System.out.println(""Prediction for 'Bad' => (Correct/total): ""
                + this.correct[1] + ""/"" + count[1] + ""("" + formatDecimalNumber(percentB) + ""%). "");
        this.count = new int[3];
        this.correct = new int[3];
        unpredicted = 0;
    }"
neuroph,org.neuroph.samples.ionosphere.IonosphereSample,handleLearningEvent,,11,20,12,3,0.3333,0.1605,1,3,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation) event.getSource();
        if (event.getEventType().equals(LearningEvent.Type.LEARNING_STOPPED)) {
            double error = bp.getTotalNetworkError();
            System.out.println(""Training completed in "" + bp.getCurrentIteration() + "" iterations, "");
            System.out.println(""With total error: "" + formatDecimalNumber(error));
        } else {
            System.out.println(""Iteration: "" + bp.getCurrentIteration() + "" | Network error: "" + bp.getTotalNetworkError());
        }
    }"
neuroph,org.neuroph.samples.ionosphere.IonosphereSample,maxOutput,,16,31,17,3,0.35,0.1705,0,4,4,0,1,"//Metod determines the maximum output. Maximum output is network prediction for one row. 
    public static int maxOutput(double[] array) {
        double max = array[0];
        int index = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                index = i;
                max = array[i];
            }
        }
        //If maximum is less than 0.5, that prediction will not count. 
        if (max < 0.5) {
            return -1;
        }
        return index;
    }"
neuroph,org.neuroph.samples.ionosphere.IonosphereSample,keepScore,,12,30,24,4,0.2222,0.0714,0,2,3,0,1,"//Colecting data to evaluate network.
    public void keepScore(int prediction, int ideal) {
        count[ideal]++;
        count[2]++;

        if (prediction == ideal) {
            correct[ideal]++;
            correct[2]++;
        }
        if (prediction == -1) {
            unpredicted++;
        }
    }"
neuroph,org.neuroph.samples.mnist.master.FuNet1,FuNet1,,22,39,33,6,0.1833,0.1136,1,3,5,0,1,"public FuNet1() {

        try {
            for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
                if (""Nimbus"".equals(info.getName())) {
                    UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (Exception e) {
            // If Nimbus is not available, you can set the GUI to another look and feel.
        }
        try {
            network = network.load(new FileInputStream(""/home/mithquissir/Desktop/cnn/5-50-100/30.nnet""));
            testSet = MNISTDataSet.createFromFile(MNISTDataSet.TEST_LABEL_NAME, MNISTDataSet.TEST_IMAGE_NAME, 10000);

        } catch (Exception e) {
            e.printStackTrace();
        }

        initComponents();
    }"
neuroph,org.neuroph.samples.mnist.master.FuNet1,updateCanvas,,20,15,0,3,0.25,0.2169,0,1,3,0,1,"//this was moved from the overriden paintComponent()
    // instead it update the canvas BufferedImage and calls repaint()
    public void updateCanvas() {
        Graphics2D g2 = canvas.createGraphics();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g2.setPaint(getColor());

        if (tool == 1) {

            g2.fillOval(currentX - ((int) value / 2), currentY - ((int) value / 2), (int) value, (int) value);


        } else if (tool == 2) {
            g2.setStroke(new BasicStroke((float) value, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
            g2.drawLine(oldX, oldY, currentX, currentY);
            g2.setStroke(new BasicStroke(1.0f));
        }
        repaint();


    }"
neuroph,org.neuroph.samples.mnist.master.FuNet1,initComponents,,138,282,239,8,0.0627,0.0689,0,10,1,0,1,"// <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">
    private void initComponents() {

        canvas = new BufferedImage(320, 320, BufferedImage.TYPE_BYTE_GRAY);

        buttonGroup1 = new ButtonGroup();
        buttonGroup2 = new ButtonGroup();
        jPanel4 = new JPanel();
        jSlider2 = new JSlider();
        jLabel1 = new JLabel();
        jPanel2 = new JPanel(new GridBagLayout());
        JLabel canvasLabel = new JLabel(new ImageIcon(canvas));
        jPanel2.add(canvasLabel, null);

        jPanel3 = new JPanel();
        jRadioButton3 = new JRadioButton();
        jRadioButton4 = new JRadioButton();
        jRadioButton5 = new JRadioButton();
        jRadioButton6 = new JRadioButton();
        jRadioButton7 = new JRadioButton();
        jRadioButton8 = new JRadioButton();
        jButton1 = new JButton();

        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        setTitle(""FuNet1 --- powered by Neuroph"");

        jPanel4.setBorder(BorderFactory.createTitledBorder(""Line thickness""));


        jSlider2.setMajorTickSpacing(10);
        jSlider2.setMaximum(51);
        jSlider2.setMinimum(1);
        jSlider2.setMinorTickSpacing(5);
        jSlider2.setPaintTicks(true);
        jSlider2.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent evt) {
                jSlider2StateChanged(evt);
            }
        });

//        jLabel1.setText(""Stroke Size (Radius)"");

        GroupLayout jPanel4Layout = new GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
                jPanel4Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(jPanel4Layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.LEADING))
                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, 51, Short.MAX_VALUE)
                                .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.TRAILING)
                                        .addComponent(jLabel1)
                                        .addComponent(jSlider2, GroupLayout.PREFERRED_SIZE, 150, GroupLayout.PREFERRED_SIZE))
                                .addContainerGap())
        );

        label = new JLabel("""");
        Font labelFont = label.getFont();

        label.setFont(new Font(labelFont.getName(), Font.PLAIN, 30));


        jPanel4Layout.setVerticalGroup(
                jPanel4Layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.TRAILING)
                                        .addComponent(jSlider2, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                                        .addGroup(jPanel4Layout.createSequentialGroup()
                                                .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                                                        .addComponent(jLabel1))
                                                .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED))
                        ));

        jPanel2.setBackground(new Color(0, 0, 0));
        jPanel2.setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));
        // add the listeners to the label that contains the canvas buffered image
        canvasLabel.addMouseListener(new MouseAdapter() {
            public void mousePressed(MouseEvent evt) {
                jPanel2MousePressed(evt);
            }

            public void mouseReleased(MouseEvent evt) {
                jPanel2MouseReleased(evt);
            }
        });
        canvasLabel.addMouseMotionListener(new MouseMotionAdapter() {
            public void mouseDragged(MouseEvent evt) {
                jPanel2MouseDragged(evt);
            }
        });


        jButton1.setText(""Clear"");
        jButton1.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        GroupLayout layout = new GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                                        .addComponent(jPanel2, GroupLayout.Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addGroup(layout.createSequentialGroup()
                                                .addComponent(jPanel4, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
                                                .addComponent(jPanel3, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                                                        .addComponent(jButton1, GroupLayout.DEFAULT_SIZE, 112, Short.MAX_VALUE)
                                                        .addComponent(label, GroupLayout.DEFAULT_SIZE, 112, Short.MAX_VALUE))))
                                .addContainerGap())
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING, false)
                                        .addGroup(layout.createSequentialGroup()
                                                .addGap(4, 4, 4)
                                                .addComponent(jButton1, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)
                                                .addComponent(label, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE)

                                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED))
                                        .addComponent(jPanel4, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(jPanel3, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jPanel2, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addContainerGap())
        );

        Graphics g = canvas.getGraphics();
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());
        repaint();
        pack();
    }// </editor-fold>"
neuroph,org.neuroph.samples.mnist.master.FuNet1,jPanel2MouseDragged,,11,12,9,3,0.2667,0.0714,0,1,2,0,1,"private void jPanel2MouseDragged(MouseEvent evt) {
        currentX = evt.getX();
        currentY = evt.getY();
        updateCanvas();
        if (tool == 1) {
            oldX = currentX;
            oldY = currentY;

        }

    }"
neuroph,org.neuroph.samples.mnist.master.FuNet1,jPanel2MousePressed,,11,18,15,4,0.2041,0.0476,0,1,2,0,1,"private void jPanel2MousePressed(MouseEvent evt) {

        oldX = evt.getX();
        oldY = evt.getY();
        if (tool == 2) {
            currentX = oldX;
            currentY = oldY;
        }


    }"
neuroph,org.neuroph.samples.mnist.master.FuNet1,jPanel2MouseReleased,,49,315,279,6,0.0796,0.0476,0.428571429,10,3,0,1,"//mouse released//
    private void jPanel2MouseReleased(MouseEvent evt) {

        currentX = evt.getX();
        currentY = evt.getY();


        final double SCALE = 0.1;
        BufferedImage bi = new BufferedImage(32, 32, BufferedImage.TYPE_BYTE_GRAY);

        Graphics2D grph = (Graphics2D) bi.getGraphics();
        grph.scale(SCALE, SCALE);

        grph.drawImage(canvas, 0, 0, null);
        grph.dispose();

        newPix = new double[32 * 32];
        pixels = bi.getRGB(0, 0, 32, 32, pixels, 0, 32);

        for (int i = 0; i < pixels.length; i++) {
            newPix[i] = 255 - (pixels[i] & 0xff);
            newPix[i] /= 255;
        }


        long start = System.currentTimeMillis();
        network.setInput(newPix);
        network.calculate();
        System.out.println(""Execution time: "" + (System.currentTimeMillis() - start) + "" milliseconds"");

        try {
            ImageIO.write(bi, ""png"", new File(""number.png""));
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        double[] networkOutput = network.getOutput();
        int maxNeuronIdx = Utils.maxIdx(networkOutput);

        ClassificationResult max = new ClassificationResult(maxNeuronIdx, networkOutput[maxNeuronIdx]);


        System.out.println(""New calculation:"");
        System.out.println(""Class: "" + max.getClassIdx());
        System.out.println(""Probability: "" + max.getNeuronOutput());

        label.setText(String.valueOf(max.getClassIdx()));


    }"
neuroph,org.neuroph.samples.norm.ZeroMeanNormalizer,normalize,,17,16,0,1,0.2963,0.1759,0.428571429,8,4,0,1,"public void normalize(DataSet dataSet) {

		double[] maxInput = DataSetStatistics.calculateMaxByColumns(dataSet);
		double[] minInput = DataSetStatistics.calculateMinByColumns(dataSet);
		double[] meanInput = DataSetStatistics.calculateMean(dataSet);

		for (DataSetRow row : dataSet.getRows()) {
			double[] normalizedInput = row.getInput();

			for (int i = 0; i < dataSet.getInputSize(); i++) {
				double divider = maxInput[i] - minInput[i] == 0 ?  1 : maxInput[i] - minInput[i] ;
				normalizedInput[i] = (normalizedInput[i] - meanInput[i]) / divider;
			}
			row.setInput(normalizedInput);
		}

	}"
neuroph,org.neuroph.samples.norm.DataSetStatistics,calculateMean,,14,30,15,3,0.2667,0.1258,0.666666667,6,4,0,1,"public static double[] calculateMean(DataSet dataSet) {
		double[] mean = new double[dataSet.getInputSize()];

		for (DataSetRow row : dataSet) {
			double[] currentInput = row.getInput();
			for (int i = 0; i < dataSet.getInputSize(); i++) {
				mean[i] += currentInput[i];
			}
		}
		for (int i = 0; i < dataSet.getInputSize(); i++) {
			mean[i] /= dataSet.getRows().size();
		}
		return mean;
	}"
neuroph,org.neuroph.samples.norm.DataSetStatistics,calculateMaxByColumns,,18,31,17,2,0.225,0.1133,0.666666667,7,4,0,1,"public static double[] calculateMaxByColumns(DataSet dataSet) {

		int inputSize = dataSet.getInputSize();
		double[] maxColumnElements = new double[inputSize];

		for (int i = 0; i < inputSize; i++) {
			maxColumnElements[i] = Double.MIN_VALUE;
		}

		for (DataSetRow dataSetRow : dataSet.getRows()) {
			double[] input = dataSetRow.getInput();
			for (int i = 0; i < inputSize; i++) {
				maxColumnElements[i] = Math.max(maxColumnElements[i], input[i]);
			}
		}

		return maxColumnElements;
	}"
neuroph,org.neuroph.samples.norm.DataSetStatistics,calculateMinByColumns,,17,31,17,2,0.225,0.1133,0.666666667,7,4,0,1,"public static double[] calculateMinByColumns(DataSet dataSet) {

		int inputSize = dataSet.getInputSize();
		double[] minColumnElements = new double[inputSize];

		for (int i = 0; i < inputSize; i++) {
			minColumnElements[i] = Double.MAX_VALUE;
		}

		for (DataSetRow dataSetRow : dataSet.getRows()) {
			double[] input = dataSetRow.getInput();
			for (int i = 0; i < inputSize; i++) {
				minColumnElements[i] = Math.min(minColumnElements[i], input[i]);
			}
		}
		return minColumnElements;
	}"
neuroph,org.neuroph.samples.segmentChallenge.SegmentChallengeSample,run,,50,318,258,6,0.1126,0.0711,0.666666667,9,1,0,1,"public void run() {

        System.out.println(""Creating training and test set from file..."");
        String trainingSetFileName = ""data_sets/segment challenge.txt"";
        String testSetFileName = ""data_sets/segment test.txt"";
        int inputsCount = 19;
        int outputsCount = 7;

        //Create training data set from file
        DataSet trainingSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","");
        System.out.println(""Training set size: "" + trainingSet.getRows().size());
        trainingSet.shuffle();
        trainingSet.shuffle();

        //Normalizing training data set
        Normalizer normalizer = new MaxNormalizer();
        normalizer.normalize(trainingSet);

        //Create test data set from file
        DataSet testSet = DataSet.createFromFile(testSetFileName, inputsCount, outputsCount, "","");
        System.out.println(""Test set size: "" + testSet.getRows().size());
        System.out.println(""--------------------------------------------------"");
        testSet.shuffle();
        testSet.shuffle();

        //Normalizing training data set
        normalizer.normalize(testSet);

        System.out.println(""Creating neural network..."");
        //Create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 17, 10, outputsCount);
        //attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        learningRule.setLearningRate(0.01);
        learningRule.setMaxError(0.001);
        learningRule.setMaxIterations(12000);

        System.out.println(""Training network..."");
        //train the network with training set
        neuralNet.learn(trainingSet);

        System.out.println(""Testing network...\n\n"");
        testNeuralNetwork(neuralNet, testSet);

        System.out.println(""Done."");
        System.out.println(""**************************************************"");
//        }
    }"
neuroph,org.neuroph.samples.segmentChallenge.SegmentChallengeSample,testNeuralNetwork,,38,165,120,3,0.127,0.0761,0.5,21,3,1,1,"public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        System.out.println(""**************************************************"");
        System.out.println(""**********************RESULT**********************"");
        System.out.println(""**************************************************"");
        for (DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();

            //Finding network output
            double[] networkOutput = neuralNet.getOutput();
            int predicted = maxOutput(networkOutput);

            //Finding actual output
            double[] networkDesiredOutput = testSetRow.getDesiredOutput();
            int ideal = maxOutput(networkDesiredOutput);

            //Colecting data for network evaluation
            keepScore(predicted, ideal);
        }

        System.out.println(""Total cases: "" + this.count[7] + "". "");
        System.out.println(""Correctly predicted cases: "" + this.correct[7] + "". "");
        System.out.println(""Incorrectly predicted cases: "" + (this.count[7] - this.correct[7] - unpredicted) + "". "");
        System.out.println(""Unrecognized cases: "" + unpredicted + "". "");
        double percentTotal = (double) this.correct[7] * 100 / (double) this.count[7];
        System.out.println(""Predicted correctly: "" + formatDecimalNumber(percentTotal) + ""%. "");

        for (int i = 0; i < correct.length - 1; i++) {
            double p = (double) this.correct[i] * 100.0 / (double) this.count[i];
            System.out.println(""Segment class: "" + getClasificationClass(i + 1) + "" - Correct/total: ""
                    + this.correct[i] + ""/"" + count[i] + ""("" + formatDecimalNumber(p) + ""%). "");
        }

        this.count = new int[8];
        this.correct = new int[8];
        unpredicted = 0;
    }"
neuroph,org.neuroph.samples.segmentChallenge.SegmentChallengeSample,handleLearningEvent,,11,20,12,3,0.3333,0.1605,1,3,2,0,1,"@Override
    public void handleLearningEvent(LearningEvent event) {
        BackPropagation bp = (BackPropagation) event.getSource();
        if (event.getEventType().equals(LearningEvent.Type.LEARNING_STOPPED)) {
            double error = bp.getTotalNetworkError();
            System.out.println(""Training completed in "" + bp.getCurrentIteration() + "" iterations, "");
            System.out.println(""With total error: "" + formatDecimalNumber(error));
        } else {
            System.out.println(""Iteration: "" + bp.getCurrentIteration() + "" | Network error: "" + bp.getTotalNetworkError());
        }
    }"
neuroph,org.neuroph.samples.segmentChallenge.SegmentChallengeSample,maxOutput,,16,31,17,3,0.35,0.1705,0,4,4,0,1,"//Metod determines the maximum output. Maximum output is network prediction for one row. 
    public static int maxOutput(double[] array) {
        double max = array[0];
        int index = 0;

        for (int i = 0; i < array.length; i++) {
            if (array[i] > max) {
                index = i;
                max = array[i];
            }
        }
        //If maximum is less than 0.5, that prediction will not count. 
        if (max < 0.5) {
            return -1;
        }
        return index;
    }"
neuroph,org.neuroph.samples.segmentChallenge.SegmentChallengeSample,keepScore,,12,30,24,4,0.2222,0.0714,0,2,3,0,1,"//Colecting data to evaluate network.
    public void keepScore(int prediction, int ideal) {
        count[ideal]++;
        count[7]++;

        if (prediction == ideal) {
            correct[ideal]++;
            correct[7]++;
        }
        if (prediction == -1) {
            unpredicted++;
        }
    }"
neuroph,org.neuroph.samples.uci.LensesClassificationSample,run,,40,129,105,7,0.142,0.0657,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        
        String trainingSetFileName = ""data_sets/lenses_data.txt"";
        int inputsCount = 9;
        int outputsCount = 3;

        System.out.println(""Creating training set..."");
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "" "", false);


        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 16, outputsCount);


        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetLenses.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.PredictingPokerHandsSample,run,,39,112,88,6,0.1503,0.072,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        
        String trainingSetFileName = ""data_sets/predicting_poker_hands_data.txt"";
        int inputsCount = 85;
        int outputsCount = 9;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, ""\t"", false);

        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 65, outputsCount);


        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetPokerHands.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.ShuttleLandingControlSample,run,,40,112,88,6,0.1503,0.072,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");

        String trainingSetFileName = ""data_sets/shuttle_landing_control_data.txt"";
        int inputsCount = 15;
        int outputsCount = 2;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","", false);


        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 16, outputsCount);


        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetShuttle.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.BalanceScaleSample,run,,39,129,105,7,0.142,0.0657,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        String trainingSetFileName = ""data_sets/balance_scale_data.txt"";
        int inputsCount = 20;
        int outputsCount = 3;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, ""\t"", false);
        
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount);

        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetBalanceScale.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.ConcreteStrenghtTestSample,run,,39,129,105,7,0.142,0.0657,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        String trainingSetFileName = ""data_sets/concrete_strenght_test_data.txt"";
        int inputsCount = 8;
        int outputsCount = 1;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","", false);
       
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount);
       
        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralConcreteStrenght.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.CarEvaluationSample,run,,39,129,105,7,0.142,0.0657,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        String trainingSetFileName = ""data_sets/car_evaluation_data.txt"";
        int inputsCount = 21;
        int outputsCount = 4;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, ""\t"", false);
       
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount);
       
        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetCarEvaluation.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.ConceptLearningAndClassificationSample,run,,41,162,134,8,0.1333,0.0714,0.777777778,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        String trainingSetFileName = ""data_sets/concept_learning_and_classification_data_1.txt"";
        int inputsCount = 15;
        int outputsCount = 3;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","", false);
       //dataSet.normalize();

        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 10, outputsCount);


        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMomentum(0.7);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetConceptLearning.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.AnimalsClassificationSample,run,,39,129,105,7,0.142,0.0657,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        String trainingSetFileName = ""data_sets/animals_data.txt"";
        int inputsCount = 20;
        int outputsCount = 7;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, ""\t"", true);
        
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount);

        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetAnimals.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.GlassIdentificationSample,run,,40,129,105,7,0.142,0.0657,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");

        String trainingSetFileName = ""data_sets/glass_identification_data.txt"";
        int inputsCount = 9;
        int outputsCount = 7;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, ""\t"", false);
        //dataSet.normalize();
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount);
       
        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.1);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralGlassIdentification.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.WineClassificationSample,run,,40,112,88,6,0.1503,0.072,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        // get path to training set
        String trainingSetFileName = ""data_sets/wine_classification_data.txt"";
        int inputsCount = 13;
        int outputsCount = 3;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, ""\t"", false);
       
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount);
       
        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetWineClassification.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.PredictingTheReligionSample,run,,40,112,88,6,0.1503,0.072,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        // get path to training set
        String trainingSetFileName = ""data_sets/religion_data.txt"";
        int inputsCount = 54;
        int outputsCount = 5;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, ""\t"", false);
       
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 22, outputsCount);
       
        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetReligion.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.PredictingPerformanceOfCPUSample,run,,41,162,134,7,0.13,0.0594,0.8,7,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");
        String trainingSetFileName = ""data_sets/cpu_data.txt"";
        int inputsCount = 7;
        int outputsCount = 1;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","", false);
        Normalizer normalizer = new MaxNormalizer();
        normalizer.normalize(dataSet);


        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 16, outputsCount);


        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetCPU.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.ForestFiresSample,run,,40,112,88,6,0.1503,0.072,0.75,6,1,0,1,"public void run() {

        System.out.println(""Creating training set..."");

        String trainingSetFileName = ""data_sets/forest_fires_data.txt"";
        int inputsCount = 29;
        int outputsCount = 1;

        // create training set from file
        DataSet dataSet = DataSet.createFromFile(trainingSetFileName, inputsCount, outputsCount, "","", false);
       
        
        System.out.println(""Creating neural network..."");
        // create MultiLayerPerceptron neural network
        MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(inputsCount, 25, outputsCount);
       
        
        // attach listener to learning rule
        MomentumBackpropagation learningRule = (MomentumBackpropagation) neuralNet.getLearningRule();
        learningRule.addListener(this);

        // set learning rate and max error
        learningRule.setLearningRate(0.2);
        learningRule.setMaxError(0.01);

        System.out.println(""Training network..."");
        // train the network with training set
        neuralNet.learn(dataSet);

        System.out.println(""Training completed."");
        System.out.println(""Testing network..."");

        testNeuralNetwork(neuralNet, dataSet);

        System.out.println(""Saving network"");
        // save neural network to file
        neuralNet.save(""MyNeuralNetForestFires.nnet"");

        System.out.println(""Done."");
    }"
neuroph,org.neuroph.samples.uci.ForestFiresSample,testNeuralNetwork,,11,14,7,2,0.3214,0.1508,0.6,4,2,0,1,"public void testNeuralNetwork(NeuralNetwork neuralNet, DataSet testSet) {

        for (DataSetRow testSetRow : testSet.getRows()) {
            neuralNet.setInput(testSetRow.getInput());
            neuralNet.calculate();
            double[] networkOutput = neuralNet.getOutput();

            System.out.print(""Input: "" + Arrays.toString(testSetRow.getInput()));
            System.out.println("" Output: "" + Arrays.toString(networkOutput));
        }
    }"
neuroph,org.neuroph.util.ConnectionFactory,fullConnect,,12,22,8,3,0.25,0.1057,0.5,8,4,0,1,"/**
	 * Creates full connectivity within layer - each neuron with all other
	 * within the same layer with the specified weight and delay values for all
	 * conections.
	 */
	public static void fullConnect(Layer layer, double weightVal, int delay) {
		int neuronNum = layer.getNeuronsCount();
		for (int i = 0; i < neuronNum; i++) {
			for (int j = 0; j < neuronNum; j++) {
				if (j == i)
					continue;
				Neuron from = layer.getNeuronAt(i);
				Neuron to = layer.getNeuronAt(j);
				createConnection(from, to, weightVal, delay);
			} // j
		} // i
	}"
neuroph,org.neuroph.util.ConnectionFactory,forwardConnect,,7,10,5,3,0.3333,0.1155,0.5,5,2,0,1,"/**
	 * Creates forward connection pattern between specified layers
	 * 
	 * @param fromLayer
	 *            layer to connect
	 * @param toLayer
	 *            layer to connect to
	 */
	public static void forwardConnect(Layer fromLayer, Layer toLayer) {
		for(int i=0; i<fromLayer.getNeuronsCount(); i++) {
			Neuron fromNeuron = fromLayer.getNeuronAt(i);
			Neuron toNeuron = toLayer.getNeuronAt(i);
			createConnection(fromNeuron, toNeuron, 1);
		}		
	}"
neuroph,org.neuroph.util.NeuralNetworkCODEC,network2array,,12,23,18,3,0.2143,0.0586,1,7,4,0,1,"/**
	 * Encode a network to an array.
	 * @param network The network to encode.
	 */
	public static void network2array(NeuralNetwork network, double[] array) {
		int index = 0;

                 List<Layer> layers = network.getLayers();
		for (Layer layer : layers) {
			for (Neuron neuron : layer.getNeurons()) {
				for (Connection connection : neuron.getOutConnections()) {
					array[index++] = connection.getWeight().getValue();
				}
			}
		}
	}"
neuroph,org.neuroph.util.NeuralNetworkCODEC,array2network,,13,31,26,4,0.1905,0.048,1,7,4,0,1,"/**
	 * Decode a network from an array.
	 * @param array The array used to decode.
	 * @param network The network to decode into.
	 */
	public static void array2network(double[] array, NeuralNetwork network) {
		int index = 0;
                
                List<Layer> layers = network.getLayers();
                for (Layer layer : layers) {
			for (Neuron neuron : layer.getNeurons()) {
				for (Connection connection : neuron.getOutConnections()) {
					connection.getWeight().setValue(array[index++]);
					//connection.getWeight().setPreviousValue(array[index++]);
				}
			}
		}
	}"
neuroph,org.neuroph.util.NeuralNetworkCODEC,determineArraySize,,11,22,16,3,0.25,0.1111,1,5,3,0,1,"/**
	 * Determine the array size for the given neural network.
	 * @param network The neural network to determine for.
	 * @return The size of the array necessary to hold that network.
	 */
	public static int determineArraySize(NeuralNetwork network) {
		int result = 0;

                List<Layer> layers = network.getLayers();
		for (Layer layer : layers) {
			for (Neuron neuron : layer.getNeurons()) {
				result+=neuron.getOutConnections().size();
			}
		}
		return result;
	}"
neuroph,org.neuroph.util.VectorParser,parseInteger,,9,21,14,3,0.25,0.1235,0,4,2,0,1,"/**
	 * This method parses input String and returns Integer vector
	 * 
	 * @param str
	 *            input String
	 * @return Integer vector
	 */
	static public ArrayList<Integer> parseInteger(String str) {
		StringTokenizer tok = new StringTokenizer(str);
		ArrayList<Integer> ret = new ArrayList<Integer>();
		while (tok.hasMoreTokens()) {
			Integer d = Integer.valueOf(tok.nextToken());
			ret.add(d);
		}
		return ret;
	}"
neuroph,org.neuroph.util.VectorParser,parseDoubleArray,,10,15,9,3,0.2857,0.1267,0,4,2,0,1,"/**
	 * This method parses input String and returns double array
         * 
	 * @param inputStr
	 *            input String
	 * @return double array
	 */
	static public double[] parseDoubleArray(String inputStr) {
		String[] inputsArrStr = inputStr.split("" "");

		double[] ret = new double[inputsArrStr.length];
		for (int i = 0; i < inputsArrStr.length; i++) {
			ret[i] = Double.parseDouble(inputsArrStr[i]);
		}

		return ret;
	}"
neuroph,org.neuroph.util.VectorParser,toDoubleArray,,7,11,7,3,0.3889,0.1667,0,3,2,0,1,"public static double[] toDoubleArray(List<Double> list) {
		double[] ret = new double[list.size()];
		for (int i = 0; i < list.size(); i++) {
			ret[i] = list.get(i).doubleValue();
		}
		return ret;
	}"
neuroph,org.neuroph.util.VectorParser,convertToVector,,9,11,7,3,0.3333,0.1667,0,3,2,0,1,"public static ArrayList<Double> convertToVector(double[] array) {
		ArrayList<Double> vector = new ArrayList<Double>(array.length);

		for (double val : array) {
			vector.add(val);
		}

		return vector;
	}"
neuroph,org.neuroph.util.NeuronProperties,NeuronProperties,,6,12,9,4,0.3333,0.1667,0,1,1,0,1,"public NeuronProperties(Class<? extends Neuron> neuronClass) {
        initKeys();
        this.setProperty(""inputFunction"", WeightedSum.class);
        this.setProperty(""transferFunction"", Linear.class);
        this.setProperty(""neuronType"", neuronClass);
    }"
neuroph,org.neuroph.util.NeuronProperties,NeuronProperties,,6,12,9,4,0.2778,0.1111,0,2,1,0,1,"public NeuronProperties(Class<? extends Neuron> neuronClass, Class<? extends TransferFunction> transferFunctionClass) {
        initKeys();
        this.setProperty(""inputFunction"", WeightedSum.class);
        this.setProperty(""transferFunction"", transferFunctionClass);
        this.setProperty(""neuronType"", neuronClass);
    }"
neuroph,org.neuroph.util.NeuronProperties,NeuronProperties,,6,12,9,4,0.2778,0.1111,1,2,1,0,1,"public NeuronProperties(Class<? extends Neuron> neuronClass, TransferFunctionType transferFunctionType) {
        initKeys();
        this.setProperty(""inputFunction"", WeightedSum.class);
        this.setProperty(""transferFunction"", transferFunctionType.getTypeClass());
        this.setProperty(""neuronType"", neuronClass);
    }"
neuroph,org.neuroph.util.NeuronProperties,NeuronProperties,,9,30,24,6,0.2222,0.1282,1,2,1,0,1,"public NeuronProperties(TransferFunctionType transferFunctionType, boolean useBias) {
        initKeys();
//		this.setProperty(""weightsFunction"", WeightedInput.class);
//		this.setProperty(""summingFunction"", Sum.class);
        this.setProperty(""inputFunction"", WeightedSum.class);
        this.setProperty(""transferFunction"", transferFunctionType.getTypeClass());
        this.setProperty(""useBias"", useBias);
        this.setProperty(""neuronType"", Neuron.class);
    }"
neuroph,org.neuroph.util.TrainingSetImport,importFromFile,,50,309,240,3,0.0966,0.1278,0.666666667,16,10,1,1,"public static DataSet importFromFile(String filePath, int inputsCount, int outputsCount, String separator)
    throws IOException, FileNotFoundException, NumberFormatException
  {

    FileReader fileReader = null;

    try {
     DataSet trainingSet = new DataSet(inputsCount, outputsCount);
     fileReader = new FileReader(new File(filePath));
     BufferedReader reader = new BufferedReader(fileReader);

     String line = """";
     // check if firs lin econtains column names and set datatset column names
      while((line = reader.readLine())!=null) {
        double[] inputs = new double[inputsCount];
        double[] outputs = new double[outputsCount];
        String[] values = line.split(separator);

        if (values[0].equals("""")) continue; // skip if line was empty

        for (int i = 0; i < inputsCount; i++)
          inputs[i] =  Double.parseDouble(values[i]);

           for (int i = 0; i < outputsCount; i++)
          outputs[i] = Double.parseDouble(values[inputsCount + i]);

        if (outputsCount>0) {
              trainingSet.addRow(new DataSetRow(inputs, outputs));
        } else {
              trainingSet.addRow(new DataSetRow(inputs));
        }
      }

      return trainingSet;
      
    } catch (FileNotFoundException ex) {
       ex.printStackTrace();
       throw ex;
    } catch(IOException ex) {
    	if(fileReader != null) {
    		fileReader.close();
    	}
    	ex.printStackTrace();
    	throw ex;
    } catch (NumberFormatException ex) {
       fileReader.close();
       ex.printStackTrace();
       throw ex;
    }
  }"
neuroph,org.neuroph.util.DataSetStats,calculateMaxByColumns,,18,31,17,2,0.225,0.1133,0.666666667,7,4,0,1,"/**
     *
     * @param dataSet Neuroph dataset
     * @return maximum value for each variable in data set
     */
	public static double[] calculateMaxByColumns(DataSet dataSet) {

		int inputSize = dataSet.getInputSize();
		double[] maxColumnElements = new double[inputSize];

		for (int i = 0; i < inputSize; i++) {
			maxColumnElements[i] = -Double.MAX_VALUE;
		}

		for (DataSetRow dataSetRow : dataSet.getRows()) {
			double[] input = dataSetRow.getInput();
			for (int i = 0; i < inputSize; i++) {
				maxColumnElements[i] = Math.max(maxColumnElements[i], input[i]);
			}
		}

		return maxColumnElements;
	}"
neuroph,org.neuroph.util.DataSetStats,calculateMinByColumns,,17,31,17,2,0.225,0.1133,0.666666667,7,4,0,1,"/**
     *
     * @param dataSet Neuroph dataset
     * @return minimum value for each variable in data set
     */
	public static double[] calculateMinByColumns(DataSet dataSet) {

		int inputSize = dataSet.getInputSize();
		double[] minColumnElements = new double[inputSize];

		for (int i = 0; i < inputSize; i++) {
			minColumnElements[i] = Double.MAX_VALUE;
		}

		for (DataSetRow dataSetRow : dataSet.getRows()) {
			double[] input = dataSetRow.getInput();
			for (int i = 0; i < inputSize; i++) {
				minColumnElements[i] = Math.min(minColumnElements[i], input[i]);
			}
		}
		return minColumnElements;
	}"
neuroph,org.neuroph.util.NeuronFactory,createNeuron,,57,447,333,5,0.1294,0.146,0.625,15,11,1,1,"/**
	 * Creates and returns neuron instance according to the given specification in neuronProperties.
	 * 
	 * @param neuronProperties
	 *            specification of neuron properties
	 * @return returns instance of neuron with specified properties
	 */
	public static Neuron createNeuron(NeuronProperties neuronProperties) {

                InputFunction inputFunction = null;
                Class inputFunctionClass = neuronProperties.getInputFunction();
                
                if ( inputFunctionClass != null) {
                    inputFunction = createInputFunction(inputFunctionClass);
                }

		TransferFunction transferFunction = createTransferFunction(neuronProperties.getTransferFunctionProperties());

		Neuron neuron = null;
		Class neuronClass = neuronProperties.getNeuronType();

                // use two param constructor to create neuron
                    try {
                        Class[] paramTypes = {InputFunction.class, TransferFunction.class};
                        Constructor con = neuronClass.getConstructor(paramTypes);

                        Object[] paramList = new Object[2];
                        paramList[0] = inputFunction;
                        paramList[1] = transferFunction;
                        
                        neuron = (Neuron) con.newInstance(paramList);

                    }  catch (NoSuchMethodException e) {
                    //    throw new NeurophException(""NoSuchMethod while creating Neuron!"", e);
                    } catch (InstantiationException e) {
                         throw new NeurophException(""InstantiationException while creating Neuron!"", e);
                    } catch (IllegalAccessException e) {
                        throw new NeurophException(""IllegalAccessException while creating Neuron!"", e);
                    } catch (InvocationTargetException e) {
                        throw new NeurophException(""InvocationTargetException while creating Neuron!"", e);
                    }

                    if (neuron == null) {
                        // use constructor without params to create neuron
                        try {
                            neuron = (Neuron) neuronClass.newInstance();
                        } catch(IllegalAccessException e) {
                            System.err.println(""InstantiationException while creating Neuron!"");
                            e.printStackTrace();
                        } catch (InstantiationException e) {
                            System.err.println(""InstantiationException while creating Neuron!"");
                            e.printStackTrace();
                        }
                    }
                
                    if  (neuronProperties.hasProperty(""thresh"")) {
                        ((ThresholdNeuron)neuron).setThresh((Double)neuronProperties.getProperty(""thresh""));
                    } else if  (neuronProperties.hasProperty(""bias"")) {
                        ((InputOutputNeuron)neuron).setBias((Double)neuronProperties.getProperty(""bias""));
                    }

                     return neuron;                    

	}"
neuroph,org.neuroph.util.NeuronFactory,createInputFunction,,13,27,18,4,0.2963,0.2286,1,4,3,0,1,"private static InputFunction createInputFunction(Class inputFunctionClass) {
            InputFunction inputFunction = null;

            try {
                inputFunction = (InputFunction) inputFunctionClass.newInstance();
            } catch (InstantiationException e) {
                throw new NeurophException(""InstantiationException while creating InputFunction!"", e);                
            } catch (IllegalAccessException e) {
                throw new NeurophException(""IllegalAccessException while creating InputFunction!"", e);     
            }

            return inputFunction;
        }"
neuroph,org.neuroph.util.NeuronFactory,createTransferFunction,,46,407,349,8,0.1147,0.1004,1,13,9,0,1,"/**
	 * Creates and returns instance of transfer function
	 * 
	 * @param tfProperties
	 *            transfer function properties
	 * @return returns transfer function
	 */
	private static TransferFunction createTransferFunction(Properties tfProperties) {
		TransferFunction transferFunction = null;

		Class  tfClass = (Class)tfProperties.getProperty(""transferFunction"");

                    try {
                        Class[] paramTypes = null;

                        Constructor[] cons = tfClass.getConstructors();
                        for (int i=0; i<cons.length; i++) {
                             paramTypes = cons[i].getParameterTypes();

                            // use constructor with one parameter of Properties type
                            if ((paramTypes.length == 1) && (paramTypes[0] == Properties.class)) {
                                Class[] argTypes = new Class[1];
                                argTypes[0] = Properties.class;
                                Constructor ct = tfClass.getConstructor(argTypes);

                                Object[] argList = new Object[1];
                                argList[0] = tfProperties;
                                transferFunction = (TransferFunction) ct.newInstance(argList);
                                break;
                            } else if(paramTypes.length == 0) { // use constructor without params
                                transferFunction = (TransferFunction) tfClass.newInstance();
                                break;
                            }
                        }

                        return transferFunction;
                        
                    } catch (NoSuchMethodException e) {
                        System.err.println(""getConstructor() couldn't find the constructor while creating TransferFunction!"");
                        e.printStackTrace();
                    } catch (InstantiationException e) {
                        System.err.println(""InstantiationException while creating TransferFunction!"");
                        e.printStackTrace();
                    } catch (IllegalAccessException e) {
                        System.err.println(""No permission to invoke method while creating TransferFunction!"");
                        e.printStackTrace();
                    } catch (InvocationTargetException e) {
                        System.err.println(""Method threw an: "" + e.getTargetException() + "" while creating TransferFunction!"");
                        e.printStackTrace();
                    }

                    return transferFunction;
	}"
neuroph,org.neuroph.util.LayerFactory,createLayer,,10,16,11,3,0.2571,0.125,0.666666667,4,2,0,1,"public static Layer createLayer(List<NeuronProperties> neuronPropertiesVector) {
		Layer layer = new Layer();
		
		for(NeuronProperties neuronProperties : neuronPropertiesVector) {
			Neuron neuron = NeuronFactory.createNeuron(neuronProperties);
			layer.addNeuron(neuron);
		}
		
		return layer;
	}"
neuroph,org.neuroph.util.NeuralNetworkFactory,createPerceptron,,11,21,14,4,0.1806,0.0858,1,5,3,0,1,"/**
	 * Creates  and returns a new instance of Perceptron network
	 * @param inputNeuronsCount number of neurons in input layer
         * @param outputNeuronsCount number of neurons in output layer
         * @param transferFunctionType type of transfer function to use
         * @param learningRule learning rule class
	 * @return instance of Perceptron network
	 */
	public static Perceptron createPerceptron(int inputNeuronsCount, int outputNeuronsCount, TransferFunctionType transferFunctionType, Class learningRule) {
		Perceptron nnet = new Perceptron(inputNeuronsCount, outputNeuronsCount, transferFunctionType);

                if (learningRule.getName().equals(PerceptronLearning.class.getName()))  {
                    nnet.setLearningRule(new PerceptronLearning());
                } else if (learningRule.getName().equals(BinaryDeltaRule.class.getName())) {
                    nnet.setLearningRule(new BinaryDeltaRule());
                }

		return nnet;
	}"
neuroph,org.neuroph.util.NeuralNetworkFactory,createMLPerceptron,,23,79,53,5,0.1083,0.0968,0.888888889,8,6,0,1,"/**
	 * Creates and returns a new instance of Multi Layer Perceptron
	 * @param layersStr space separated number of neurons in layers
	 * @param transferFunctionType transfer function type for neurons
	 * @return instance of Multi Layer Perceptron
	 */
	public static MultiLayerPerceptron createMLPerceptron(String layersStr, TransferFunctionType transferFunctionType, Class learningRule,  boolean useBias, boolean connectIO) {
		ArrayList<Integer> layerSizes = VectorParser.parseInteger(layersStr);
                NeuronProperties neuronProperties = new NeuronProperties(transferFunctionType, useBias);
		MultiLayerPerceptron nnet = new MultiLayerPerceptron(layerSizes, neuronProperties);
                
                // set learning rule - TODO: use reflection here
                if (learningRule.getName().equals(BackPropagation.class.getName()))  {
                    nnet.setLearningRule(new BackPropagation());
                } else if (learningRule.getName().equals(MomentumBackpropagation.class.getName())) {
                    nnet.setLearningRule(new MomentumBackpropagation());
                } else if (learningRule.getName().equals(DynamicBackPropagation.class.getName())) {
                    nnet.setLearningRule(new DynamicBackPropagation());
                } else if (learningRule.getName().equals(ResilientPropagation.class.getName())) {
                    nnet.setLearningRule(new ResilientPropagation());
                } 

                // connect io
                if (connectIO) {
                    nnet.connectInputsToOutputs();
                }

		return nnet;
	}"
neuroph,org.neuroph.util.NeuralNetworkFactory,createSupervisedHebbian,,6,2,1,2,0.4,0.0667,1,4,1,0,1,"/**
	 * Creates and returns a new instance of Hebbian network
	 * @param inputNeuronsCount number of neurons in input layer
	 * @param outputNeuronsCount number of neurons in output layer
	 * @param transferFunctionType neuron's transfer function type
	 * @return instance of Hebbian network
	 */
	public static SupervisedHebbianNetwork createSupervisedHebbian(int inputNeuronsCount,
			int outputNeuronsCount, TransferFunctionType transferFunctionType) {
		SupervisedHebbianNetwork nnet = new SupervisedHebbianNetwork(inputNeuronsCount,
				outputNeuronsCount, transferFunctionType);
		return nnet;
	}"
neuroph,org.neuroph.util.NeuralNetworkFactory,createUnsupervisedHebbian,,6,2,1,2,0.4,0.0667,1,4,1,0,1,"/**
	 * Creates and returns a new instance of Unsupervised Hebbian Network
	 * @param inputNeuronsCount number of neurons in input layer
	 * @param outputNeuronsCount number of neurons in output layer
	 * @param transferFunctionType neuron's transfer function type
	 * @return instance of Unsupervised Hebbian Network
	 */
	public static UnsupervisedHebbianNetwork createUnsupervisedHebbian(int inputNeuronsCount,
			int outputNeuronsCount, TransferFunctionType transferFunctionType) {
		UnsupervisedHebbianNetwork nnet = new UnsupervisedHebbianNetwork(inputNeuronsCount,
				outputNeuronsCount, transferFunctionType);
		return nnet;
	}"
neuroph,org.neuroph.util.NeuralNetworkFactory,createRbfNetwork,,6,2,1,2,0.4,0.0667,1,4,1,0,1,"/**
	 * Creates and returns a new instance of RBF network
	 * @param inputNeuronsCount number of neurons in input layer
	 * @param rbfNeuronsCount number of neurons in RBF layer
	 * @param outputNeuronsCount number of neurons in output layer
	 * @return instance of RBF network
	 */
	public static RBFNetwork createRbfNetwork(int inputNeuronsCount,
			int rbfNeuronsCount, int outputNeuronsCount) {
		RBFNetwork nnet = new RBFNetwork(inputNeuronsCount, rbfNeuronsCount,
				outputNeuronsCount);
		return nnet;
	}"
neuroph,org.neuroph.util.DataSetStatistics,DataSetStatistics,,13,47,16,4,0.1657,0.1721,0.333333333,18,1,0,1,"public DataSetStatistics(DataSet dataSet) {
        this.dataSet = dataSet;
        this.rowSize = dataSet.getInputSize() + dataSet.getOutputSize();
        this.rowCount = dataSet.getRows().size();
        this.mean = new double[this.rowSize];
        this.max = new double[this.rowSize];
        this.min = new double[this.rowSize];
        this.sum = new double[this.rowSize];
        this.var = new double[this.rowSize];
        this.stdDev = new double[this.rowSize];
        this.frequency = new double[this.rowSize];
        this.setDefaultValues();
    }"
neuroph,org.neuroph.util.DataSetStatistics,resetValues,,7,9,3,3,0.2667,0.1429,0,5,2,0,1,"/**
     * Resets statistics values to default.
     */
    private void resetValues() {
        for (int i = 0; i < this.rowSize; i++) {
            this.sum[i] = 0;
            this.var[i] = 0;
            this.frequency[i] = -0.0;
        }
    }"
neuroph,org.neuroph.util.DataSetStatistics,calculateStatistics,,35,211,146,3,0.1155,0.0635,0.666666667,34,9,1,1,"/**
     * Calculates basic statistics by columns of the dataset.
     */
    public void calculateStatistics() {
        this.resetValues();
        DataSetColumnType[] columnTypes = this.dataSet.getColumnTypes();
        for (DataSetRow dataSetRow : this.dataSet.getRows()) {
            double[] row = dataSetRow.toArray();
            for (int i = 0; i < this.rowSize; i++) {
                this.max[i] = Math.max(this.max[i], row[i]);
                this.min[i] = Math.min(this.min[i], row[i]);
                this.sum[i] += row[i];
                if (columnTypes[i] == DataSetColumnType.NOMINAL) {
                    this.frequency[i] += row[i];
                }
            }
        }

        for (int i = 0; i < this.rowSize; i++) {
            this.mean[i] = this.sum[i] / (double) this.rowCount;
            if (columnTypes[i] == DataSetColumnType.NOMINAL) {
                this.frequency[i] /= (double) this.rowCount;
            }
        }

        for (DataSetRow dataSetRow : this.dataSet.getRows()) {
            double[] row = dataSetRow.toArray();
            for (int i = 0; i < this.rowSize; i++) {
                double delta = row[i] - this.mean[i];
                this.var[i] += delta * delta;
            }
        }

        for (int i = 0; i < this.rowSize; i++) {
            this.var[i] /= (double) this.rowCount;
            this.stdDev[i] = Math.sqrt(this.var[i]);
        }
    }"
neuroph,org.neuroph.util.benchmark.MyBenchmarkTask,prepareTest,,26,69,47,3,0.1345,0.0499,0.833333333,10,4,0,1,"/**
     * Benchmrk preparation consists of training set and neural networ creatiion.
     * This method generates training set with 100 rows, where every row has 10 input and 5 output elements
     * Neural network has two hiddden layers with 8 and 7 neurons, and runs learning rule for 2000 iterations
     */
    @Override
    public void prepareTest() {
        int trainingSetSize = 100;
        int inputSize = 10;
        int outputSize = 5;
        
        this.trainingSet = new DataSet(inputSize, outputSize);
        
        for (int i = 0; i < trainingSetSize; i++) {
            double[] input = new double[inputSize];
            for( int j=0; j<inputSize; j++)
                input[j] = Math.random();

            double[] output = new double[outputSize];
            for( int j=0; j<outputSize; j++)
                output[j] = Math.random();            
            
            DataSetRow trainingSetRow = new DataSetRow(input, output);
            trainingSet.addRow(trainingSetRow);
        }
        
        
        network = new MultiLayerPerceptron(inputSize, 8, 7, outputSize);
        ((MomentumBackpropagation)network.getLearningRule()).setMaxIterations(2000);
        
    }"
neuroph,org.neuroph.util.benchmark.Benchmark,runTask,,29,119,67,3,0.1842,0.2304,0.230769231,5,3,0,1,"/**
     * Runs specified benchmark tasks, the basic benchmarking workflow.
     * Prepares benchmark, run warming up iterations, measures the execution
     * time for specified number of benchmarking iterations, and gets the benchmarking results
     * @param task 
     */
    public static void runTask(BenchmarkTask task) {
        System.out.println(""Preparing task "" + task.getName());
        task.prepareTest();
        
        System.out.println(""Warming up "" + task.getName());
        for (int i = 0; i < task.getWarmupIterations(); i++) {
            task.runTest();
        }

        System.out.println(""Runing "" + task.getName());
        //task.prepare(); // ovde mozda poziv nekoj reset ili init metodi koja bi randomizovala mrezu, u osnovnoj klasi da neradi nista tako da moze da se redefinise i ne mora
        
        Stopwatch timer = new Stopwatch();
        BenchmarkTaskResults results = new BenchmarkTaskResults(task.getTestIterations());
        
        for (int i = 0; i < task.getTestIterations(); i++) {
            timer.reset();
            
            timer.start();            
            task.runTest();
            timer.stop();
            
            results.addElapsedTime(timer.getElapsedTime());
        }   
        
        results.calculateStatistics(); 
        System.out.println(task.getName() + "" results"");
        System.out.println(results); // could be sent to file
    }"
neuroph,org.neuroph.util.benchmark.BenchmarkTaskResults,calculateStatistics,,27,58,11,2,0.2182,0.1549,0,8,5,1,1,"public void calculateStatistics() {

        this.minTestTime = elapsedTimes[0];
        this.maxTestTime = elapsedTimes[0];
        long sum = 0;

        for (int i = 0; i < timesCounter; i++) {
            sum += elapsedTimes[i];
            if (elapsedTimes[i] < minTestTime) {
                minTestTime = elapsedTimes[i];
            }
            if (elapsedTimes[i] > maxTestTime) {
                maxTestTime = elapsedTimes[i];
            }
        }

        this.averageTestTime = sum / (double) timesCounter;
        
        //  std. deviation
        long sqrSum = 0;
        
        for(int i = 0; i< timesCounter; i++) {
            sqrSum += (elapsedTimes[i] - averageTestTime) * (elapsedTimes[i] - averageTestTime);
        }

        this.standardDeviation = Math.sqrt(sqrSum / (double)timesCounter);
    }"
neuroph,org.neuroph.util.data.norm.MaxNormalizer,normalize,,16,4,0,1,0.3611,0.2689,0.333333333,4,3,0,1,"@Override
   public void normalize(DataSet dataSet) {

        findMaxVectors(dataSet);

        for (DataSetRow row : dataSet.getRows()) {
            double[] normalizedInput = normalizeMax(row.getInput(), maxIn);
            row.setInput(normalizedInput);
            
            if (dataSet.isSupervised()) {
                double[] normalizedOutput = normalizeMax(row.getDesiredOutput(), maxOut);
                row.setDesiredOutput(normalizedOutput);
            }
        }

    }"
neuroph,org.neuroph.util.data.norm.MaxNormalizer,findMaxVectors,,30,114,75,3,0.1667,0.0794,0.4,10,8,1,1,"/**
    * Finds max values for columns in input and output vector for given data set
    * @param dataSet  
    */
    private void findMaxVectors(DataSet dataSet) {
        int inputSize = dataSet.getInputSize();
        int outputSize = dataSet.getOutputSize();
        
        maxIn = new double[inputSize];    
        for(int i=0; i<inputSize; i++) {
            maxIn[i] = Double.MIN_VALUE;
        }
        
        maxOut = new double[outputSize];
        for(int i=0; i<outputSize; i++)
            maxOut[i] = Double.MIN_VALUE;        
    
        for (DataSetRow dataSetRow : dataSet.getRows()) {
            double[] input = dataSetRow.getInput();
            for (int i = 0; i < inputSize; i++) {
                if (input[i] > maxIn[i]) {
                    maxIn[i] = input[i];
                }
             }
            
            double[] output = dataSetRow.getDesiredOutput();
            for (int i = 0; i < outputSize; i++) {
                if (output[i] > maxOut[i]) {
                    maxOut[i] = output[i];
                }
            }            
                                    
        }         
    }"
neuroph,org.neuroph.util.data.norm.MaxNormalizer,normalizeMax,,9,11,7,3,0.3333,0.1429,0,4,2,0,1,"public double[] normalizeMax(double[] vector, double[] max) {
        double[] normalizedVector = new double[vector.length];
        
        for(int i = 0; i < vector.length; i++) {
                normalizedVector[i] = vector[i] / max[i];
        }
        
        return normalizedVector;
    }"
neuroph,org.neuroph.util.data.norm.RangeNormalizer,normalize,,16,15,2,2,0.25,0.1765,0.333333333,4,3,0,1,"@Override
    public void normalize(DataSet dataSet) {
        findMaxAndMinVectors(dataSet);
       
        for (DataSetRow row : dataSet.getRows()) {
            double[] normalizedInput = normalizeToRange(row.getInput(), minIn, maxIn);
            row.setInput(normalizedInput);
            
            if (dataSet.isSupervised()) {
                double[] normalizedOutput = normalizeToRange(row.getDesiredOutput(), minOut, maxOut);
                row.setDesiredOutput(normalizedOutput);
            }
            
        }
        
    }"
neuroph,org.neuroph.util.data.norm.RangeNormalizer,normalizeToRange,,9,11,7,3,0.2619,0.1122,0,5,2,0,1,"private double[] normalizeToRange(double[] vector, double[] min, double[] max) {
        double[] normalizedVector = new double[vector.length];

        for (int i = 0; i < vector.length; i++) {
            normalizedVector[i] = ((vector[i] - min[i]) / (max[i] - min[i])) * (highLimit - lowLimit) + lowLimit ;
        }

        return normalizedVector;             
    }"
neuroph,org.neuroph.util.data.norm.RangeNormalizer,findMaxAndMinVectors,,43,267,183,3,0.1531,0.0783,0.4,10,10,1,1,"private void findMaxAndMinVectors(DataSet dataSet) {
        int inputSize = dataSet.getInputSize();
        int outputSize = dataSet.getOutputSize();
        
        maxIn = new double[inputSize];
        minIn = new double[inputSize];
        
        for(int i=0; i<inputSize; i++) {
            maxIn[i] = Double.MIN_VALUE;
            minIn[i] = Double.MAX_VALUE;
        }
        
        maxOut = new double[outputSize];
        minOut = new double[outputSize];   
        
        for(int i=0; i<outputSize; i++) {
            maxOut[i] = Double.MIN_VALUE;
            minOut[i] = Double.MAX_VALUE;
        }        

        for (DataSetRow dataSetRow : dataSet.getRows()) {
            double[] input = dataSetRow.getInput();
            for (int i = 0; i < inputSize; i++) {
                if (input[i] > maxIn[i]) {
                    maxIn[i] = input[i];
                }
                if (input[i] < minIn[i]) {
                    minIn[i] = input[i];
                }
            }
            
            double[] output = dataSetRow.getDesiredOutput();
            for (int i = 0; i < outputSize; i++) {
                if (output[i] > maxOut[i]) {
                    maxOut[i] = output[i];
                }
                if (output[i] < minOut[i]) {
                    minOut[i] = output[i];
                }
            }            
                                    
        }        
    }"
neuroph,org.neuroph.util.data.norm.ZeroMeanNormalizer,normalize,,17,16,0,1,0.2963,0.1759,0.428571429,8,4,0,1,"public void normalize(DataSet dataSet) {

        double[] maxInput = DataSetStats.calculateMaxByColumns(dataSet);
        double[] minInput = DataSetStats.calculateMinByColumns(dataSet);
        double[] meanInput = DataSetStats.calculateMeanByColumns(dataSet);

        for (DataSetRow row : dataSet.getRows()) {
            double[] normalizedInput = row.getInput();

            for (int i = 0; i < dataSet.getInputSize(); i++) {
                double divider = maxInput[i] - minInput[i] == 0 ? 1 : maxInput[i] - minInput[i];
                normalizedInput[i] = (normalizedInput[i] - meanInput[i]) / divider; // should we delete with std ?
            }
            row.setInput(normalizedInput);
        }

    }"
neuroph,org.neuroph.util.data.norm.MaxMinNormalizer,normalize,,16,4,0,1,0.3125,0.2295,0.333333333,4,3,0,1,"@Override
    public void normalize(DataSet dataSet) {
        // find min i max vectors
        findMaxAndMinVectors(dataSet);
       
        for (DataSetRow row : dataSet.getRows()) {
           double[] normalizedInput = normalizeMaxMin(row.getInput(), minIn, maxIn);
           row.setInput(normalizedInput);
            
           if (dataSet.isSupervised()) {
                double[] normalizedOutput = normalizeMaxMin(row.getDesiredOutput(), minOut, maxOut);
                row.setDesiredOutput(normalizedOutput);
           }
        }

    }"
neuroph,org.neuroph.util.data.norm.MaxMinNormalizer,findMaxAndMinVectors,,43,267,183,3,0.1531,0.0783,0.4,10,10,1,1,"private void findMaxAndMinVectors(DataSet dataSet) {
        int inputSize = dataSet.getInputSize();
        int outputSize = dataSet.getOutputSize();
        
        maxIn = new double[inputSize];
        minIn = new double[inputSize];
        
        for(int i=0; i<inputSize; i++) {
            maxIn[i] = Double.MIN_VALUE;
            minIn[i] = Double.MAX_VALUE;
        }
        
        maxOut = new double[outputSize];
        minOut = new double[outputSize];   
        
        for(int i=0; i<outputSize; i++) {
            maxOut[i] = Double.MIN_VALUE;
            minOut[i] = Double.MAX_VALUE;
        }        

        for (DataSetRow dataSetRow : dataSet.getRows()) {
            double[] input = dataSetRow.getInput();
            for (int i = 0; i < inputSize; i++) {
                if (input[i] > maxIn[i]) {
                    maxIn[i] = input[i];
                }
                if (input[i] < minIn[i]) {
                    minIn[i] = input[i];
                }
            }
            
            double[] output = dataSetRow.getDesiredOutput();
            for (int i = 0; i < outputSize; i++) {
                if (output[i] > maxOut[i]) {
                    maxOut[i] = output[i];
                }
                if (output[i] < minOut[i]) {
                    minOut[i] = output[i];
                }
            }            
                                    
        }        
    }"
neuroph,org.neuroph.util.data.norm.MaxMinNormalizer,normalizeMaxMin,,9,11,7,3,0.3,0.1286,0,5,2,0,1,"private double[] normalizeMaxMin(double[] vector, double[] min, double[] max) {
        double[] normalizedVector = new double[vector.length];

        for (int i = 0; i < vector.length; i++) {
            normalizedVector[i] = (vector[i] - min[i]) / (max[i] - min[i]);
        }

        return normalizedVector;             
    }"
neuroph,org.neuroph.util.data.norm.DecimalScaleNormalizer,normalize,,15,32,19,4,0.2333,0.1317,0.333333333,4,3,0,1,"@Override
    public void normalize(DataSet dataSet) {
        findMaxVectors(dataSet);
        findScaleVectors();

        for (DataSetRow dataSetRow : dataSet.getRows()) {
            double[] normalizedInput = normalizeScale(dataSetRow.getInput(), scaleFactorIn);
            dataSetRow.setInput(normalizedInput);

            if (dataSet.isSupervised()) {
                double[] normalizedOutput = normalizeScale(dataSetRow.getDesiredOutput(), scaleFactorOut);
                dataSetRow.setDesiredOutput(normalizedOutput);
            }
        }
    }"
neuroph,org.neuroph.util.data.norm.DecimalScaleNormalizer,findMaxVectors,,31,130,89,3,0.1619,0.0745,0.4,10,8,0,1,"/**
     * Finds max values for all columns in dataset (inputs and outputs)
     * Sets max column values to maxIn and maxOut fields
     * @param dataSet 
     */
    private void findMaxVectors(DataSet dataSet) {
        int inputSize = dataSet.getInputSize();
        int outputSize = dataSet.getOutputSize();

        maxIn = new double[inputSize];
        for (int i = 0; i < inputSize; i++) {
            maxIn[i] = Double.MIN_VALUE;
        }

        maxOut = new double[outputSize];
        for (int i = 0; i < outputSize; i++) {
            maxOut[i] = Double.MIN_VALUE;
        }

        for (DataSetRow dataSetRow : dataSet.getRows()) {
            double[] input = dataSetRow.getInput();
            for (int i = 0; i < inputSize; i++) {
                if (input[i] > maxIn[i]) {
                    maxIn[i] = input[i];
                }
            }

            double[] output = dataSetRow.getDesiredOutput();
            for (int i = 0; i < outputSize; i++) {
                if (output[i] > maxOut[i]) {
                    maxOut[i] = output[i];
                }
            }

        }
    }"
neuroph,org.neuroph.util.data.norm.DecimalScaleNormalizer,findScaleVectors,,27,74,43,2,0.2222,0.1384,0,4,7,1,1,"public void findScaleVectors() {
        scaleFactorIn = new double[maxIn.length];
        for (int i = 0; i < scaleFactorIn.length; i++) {
            scaleFactorIn[i] = 1;
        }

        for (int i = 0; i < maxIn.length; i++) {
            while (maxIn[i] > 1) {
                maxIn[i] = maxIn[i] / 10.0;
                scaleFactorIn[i] = scaleFactorIn[i] * 10;
            }
        }

        scaleFactorOut = new double[maxOut.length];
        for (int i = 0; i < scaleFactorOut.length; i++) {
            scaleFactorOut[i] = 1;
        }

        for (int i = 0; i < maxOut.length; i++) {
            while (maxOut[i] > 1) {
                maxOut[i] = maxOut[i] / 10.0;
                scaleFactorOut[i] = scaleFactorOut[i] * 10;
            }
        }


    }"
neuroph,org.neuroph.util.data.norm.DecimalScaleNormalizer,normalizeScale,,7,11,7,3,0.3333,0.1429,0,4,2,0,1,"private double[] normalizeScale(double[] vector, double[] scaleFactor) {
        double[] normalizedVector = new double[vector.length];
        for (int i = 0; i < vector.length; i++) {
            normalizedVector[i] = vector[i] / scaleFactor[i];
        }
        return normalizedVector;
    }"
neuroph,org.neuroph.util.io.InputStreamAdapter,readInput,,13,23,18,4,0.225,0.0895,1,3,3,0,1,"@Override
    public double[] readInput() {    
        try {
            String inputLine = bufferedReader.readLine();        
            if (inputLine != null) {
               double[] inputBuffer = VectorParser.parseDoubleArray(inputLine);        
               return inputBuffer;
            }
            return null;
        } catch (IOException ex) {
             throw new NeurophInputException(""Error reading input from stream!"", ex);
        }
    }"
neuroph,org.neuroph.util.io.InputStreamAdapter,close,,9,9,8,4,0.3,0.1111,1,1,3,0,1,"@Override
    public void close() {
        try {
            if (bufferedReader != null)
                bufferedReader.close();
        } catch (IOException ex) {
            throw new NeurophInputException(""Error closing stream!"", ex);
        }
    }"
neuroph,org.neuroph.util.io.JDBCInputAdapter,JDBCInputAdapter,,11,30,24,4,0.1728,0.0714,1,5,2,0,1,"public JDBCInputAdapter(Connection connection, String sql) {   
        try {
            Statement stmt = connection.createStatement(); // Get a statement from the connection
            resultSet = stmt.executeQuery(sql);  // Execute the query  
            ResultSetMetaData rsmd = resultSet.getMetaData();
            inputSize = rsmd.getColumnCount();
        } catch (SQLException ex) {
            Logger.getLogger(JDBCInputAdapter.class.getName()).log(Level.SEVERE, null, ex);
            throw new NeurophInputException(""Error executing query at JdbcInputAdapter"", ex);
        }
    }"
neuroph,org.neuroph.util.io.JDBCInputAdapter,readInput,,16,30,24,4,0.2222,0.0929,1,3,4,0,1,"/**
     * Reads next row from result set and returns input for neural network as array of doubles.
     * @return neural network input as array of doubles
     */    
    @Override
    public double[] readInput() {
        try {
            while (resultSet.next()) {
                double[] inputBuffer = new double[inputSize];
                for (int i = 1; i <= inputSize; i++) {
                    inputBuffer[i - 1] = resultSet.getDouble(i);
                }
                return inputBuffer;
            }
        } catch (SQLException ex) {
            throw new NeurophInputException(""Error reading input value from the result set!"", ex);
        }

        return null;
    }"
neuroph,org.neuroph.util.io.JDBCInputAdapter,close,,9,9,8,4,0.3,0.1111,1,1,3,0,1,"/**
     * Closes result set used as data source.
     */
    @Override
    public void close() {
        try {
             if (resultSet != null)
                  resultSet.close();
        } catch (SQLException ex) {
            throw new NeurophInputException(""Error closing database connection!"", ex);
        }
    }"
neuroph,org.neuroph.util.io.JDBCOutputAdapter,writeOutput,,36,202,173,10,0.1136,0.0708,1,6,5,0,1,"/**
     * Writes specified output to table in database
     * @param output 
     */
    @Override
    public void writeOutput(double[] output) {
        try {
            String sql = ""INSERT "" + tableName + "" VALUES("";
            for (int i = 0; i < output.length; i++) {
                sql += ""?"";
                if (i < (output.length - 1)) {  // add coma if not last
                    sql = "", "";
                }
            }
            sql += "")"";            
            
//            for (int i = 0; i < output.length; i++) {
//                sql += output[i];
//                if (i < (output.length - 1)) {
//                    sql = "", "";
//                }
//            }


//            Statement stmt = connection.createStatement();

            PreparedStatement stmt = connection.prepareStatement(sql);
            for (int i = 0; i < output.length; i++) {
                stmt.setDouble(i, output[i]);
            }

            stmt.executeUpdate(sql);
            stmt.close();

        } catch (SQLException ex) {
            Logger.getLogger(JDBCOutputAdapter.class.getName()).log(Level.SEVERE, null, ex);
            throw new NeurophInputException(""Error executing query at JDBCOutputAdapter"", ex);
        }

    }"
neuroph,org.neuroph.util.io.IOHelper,process,,13,27,18,2,0.2667,0.1111,0.428571429,5,2,0,1,"/**
     * Feeds specified neural network with data from InputAdapter and writes
     * output using OutputAdapter
     * @param neuralNet neural network
     * @param in input data source
     * @param out output data target  
     */
    public static void process(NeuralNetwork neuralNet, InputAdapter in, OutputAdapter out) {
       
        double[] input;
        while( (input = in.readInput()) != null) {
            neuralNet.setInput(input);
            neuralNet.calculate();  
            double[] output = neuralNet.getOutput();
            out.writeOutput(output);
        }
        
        in.close();
        out.close();         
    }"
neuroph,org.neuroph.util.io.OutputStreamAdapter,writeOutput,,14,28,20,4,0.2222,0.1333,1,4,3,0,1,"/**
     * Writes specified output to output stream
     * @param output output vector to write
     */
    @Override
    public void writeOutput(double[] output) {
        try {
            StringBuilder outputLine = new StringBuilder();
            for (int i = 0; i < output.length; i++) {
                outputLine.append(output[i]).append(' ').append(outputLine);
            }
            outputLine.append(System.lineSeparator());
            
            bufferedWriter.write(outputLine.toString());
        } catch (IOException ex) {
            throw new NeurophOutputException(""Error writing output to stream!"", ex);
        }
    }"
neuroph,org.neuroph.util.io.OutputStreamAdapter,close,,8,9,8,4,0.3,0.1111,1,1,2,0,1,"/**
     * Closes output stream.
     */
    @Override
    public void close() {
        try {
            bufferedWriter.close();
        } catch (IOException ex) {
            throw new NeurophOutputException(""Error closing output stream!"", ex);
        }
    }"
neuroph,org.neuroph.util.random.DistortRandomizer,randomize,,7,7,4,3,0.4,0.1852,0.75,3,2,0,1,"/**
     * Iterate all layers, neurons and connection weight and apply distort randomization
     * @param neuron
     */
    @Override
    protected void randomize(Neuron neuron) {
            for (Connection connection : neuron.getInputConnections()) {
                    double weight = connection.getWeight().getValue();
                    connection.getWeight().setValue(distort(weight));
            }
    }"
neuroph,org.neuroph.util.random.GaussianRandomizer,boxMuller,,22,74,43,4,0.1867,0.1139,0,11,3,0,1,"/**
     * Compute a Gaussian random number.
     * 
     * @param mean
     *            The mean.
     * @param std
     *            The standard deviation.
     * @return The random number.
     */
     private double boxMuller(double mean, double std) {
        double x1, x2, w, y1;

        // use value from previous call
        if (this.useLast) {
            y1 = this.y2;
            this.useLast = false;
        } else {
            do {
                x1 = 2.0 * randomGen.nextDouble() - 1.0;
                x2 = 2.0 * randomGen.nextDouble() - 1.0;
                w = x1 * x1 + x2 * x2;
            } while (w >= 1.0);

            w = Math.sqrt((-2.0 * Math.log(w)) / w);
            y1 = x1 * w;
            this.y2 = x2 * w;
            this.useLast = true;
        }

        return (mean + y1 * std);
    }"
neuroph,org.neuroph.util.random.WeightsRandomizer,randomize,,12,12,9,3,0.2667,0.0774,1,4,3,0,1,"/**
     * Iterates and randomizes all connection weights in specified neuron
     * 
     * @param neuron neuron to randomize
     */
    protected void randomize(Neuron neuron) {
        int numberOfInputConnections = neuron.getInputConnections().size();
        double coefficient = 1d / Math.sqrt(numberOfInputConnections);
        coefficient = coefficient == 0 ? 1 : coefficient;
        for (Connection connection : neuron.getInputConnections()) {
//            connection.getWeight().setValue(coefficient * nextRandomWeight());
            connection.getWeight().setValue(nextRandomWeight());

        }
        
        
    }"
neuroph,org.neuroph.util.random.NguyenWidrowRandomizer,randomize,,36,155,120,2,0.13,0.0648,0.5,14,7,1,1,"@Override
    public void randomize(NeuralNetwork neuralNetwork) {
        super.randomize(neuralNetwork);

        int inputNeuronsCount = neuralNetwork.getInputNeurons().size();
        int hiddenNeuronsCount = 0;

        for (int i = 1; i < neuralNetwork.getLayersCount() - 1; i++) {
            hiddenNeuronsCount += neuralNetwork.getLayerAt(i).getNeuronsCount();
        }

        double beta = 0.7 * Math.pow(hiddenNeuronsCount, 1.0 / inputNeuronsCount); // should we use the total number of hidden neurons or different norm for each layer

        List<Layer> layers = neuralNetwork.getLayers();
        for (Layer layer : layers) {
            // Calculate the Euclidean Norm for the weights: norm += value * value - suma vadrata tezina u layeru
            double norm = 0.0;
            for (Neuron neuron : layer.getNeurons()) {
                for (Connection connection : neuron.getInputConnections()) {
                    double weight = connection.getWeight().getValue();
                    norm += weight * weight;
                }
            }
            norm = Math.sqrt(norm);

            // Rescale the weights using beta and the norm: beta * value / norm            
            for (Neuron neuron : layer.getNeurons()) {
                for (Connection connection : neuron.getInputConnections()) {
                    double weight = connection.getWeight().getValue();
                    weight = beta * weight / norm;
                    connection.getWeight().setValue(weight);
                }
            }
        }

    }"
xdman,xdman.Config,save,,55,206,0,4,0.0665,0.3445,1,42,6,0,1,"public void save() {
		FileWriter fw = null;
		try {
			File file = new File(System.getProperty(""user.home""), "".xdman/config.txt"");
			fw = new FileWriter(file);

			String newLine = ""\n"";

			fw.write(""monitoring:"" + this.monitoring + newLine);
			fw.write(""downloadFolder:"" + this.downloadFolder + newLine);
			fw.write(""maxDownloads:"" + this.maxDownloads + newLine);
			fw.write(""maxSegments:"" + this.maxSegments + newLine);
			fw.write(""networkTimeout:"" + this.networkTimeout + newLine);
			fw.write(""tcpWindowSize:"" + this.tcpWindowSize + newLine);
			fw.write(""minSegmentSize:"" + this.minSegmentSize + newLine);
			fw.write(""minVidSize:"" + this.minVidSize + newLine);
			fw.write(""duplicateAction:"" + this.duplicateAction + newLine);
			fw.write(""speedLimit:"" + this.speedLimit + newLine);
			fw.write(""showDownloadWindow:"" + this.showDownloadWindow + newLine);
			fw.write(""showDownloadCompleteWindow:"" + this.showDownloadCompleteWindow + newLine);
			fw.write(""blockedHosts:"" + XDMUtils.appendArray2Str(this.blockedHosts) + newLine);
			fw.write(""vidUrls:"" + XDMUtils.appendArray2Str(this.vidUrls) + newLine);
			fw.write(""fileExts:"" + XDMUtils.appendArray2Str(this.fileExts) + newLine);
			fw.write(""vidExts:"" + XDMUtils.appendArray2Str(this.vidExts) + newLine);

			fw.write(""proxyMode:"" + this.proxyMode + newLine);
			fw.write(""proxyPac:"" + this.proxyPac + newLine);
			fw.write(""proxyHost:"" + this.proxyHost + newLine);
			fw.write(""proxyPort:"" + this.proxyPort + newLine);
			fw.write(""socksHost:"" + this.socksHost + newLine);
			fw.write(""socksPort:"" + this.socksPort + newLine);
			fw.write(""proxyUser:"" + this.proxyUser + newLine);
			fw.write(""proxyPass:"" + this.proxyPass + newLine);
			fw.write(""autoShutdown:"" + this.autoShutdown + newLine);
			fw.write(""keepAwake:"" + this.keepAwake + newLine);
			fw.write(""execCmd:"" + this.execCmd + newLine);
			fw.write(""execAntivir:"" + this.execAntivir + newLine);
			fw.write(""version:"" + XDMApp.APP_VERSION + newLine);
			fw.write(""autoStart:"" + this.autoStart + newLine);
			fw.write(""language:"" + this.language + newLine);
			if (!StringUtils.isNullOrEmptyOrBlank(this.antivirExe))
				fw.write(""antivirExe:"" + this.antivirExe + newLine);
			if (!StringUtils.isNullOrEmptyOrBlank(this.antivirCmd))
				fw.write(""antivirCmd:"" + this.antivirCmd + newLine);
			if (!StringUtils.isNullOrEmptyOrBlank(this.customCmd))
				fw.write(""customCmd:"" + this.customCmd + newLine);
			fw.write(""showVideoNotification:"" + this.showVideoNotification + newLine);

		} catch (Exception e) {
		}
		try {
			fw.close();
		} catch (Exception e) {
		}
	}"
xdman,xdman.Config,load,,100,876,212,5,0.0408,0.1339,1,44,43,0,1,"public void load() {
		BufferedReader br = null;
		try {
			File file = new File(System.getProperty(""user.home""), "".xdman/config.txt"");
			if (!file.exists()) {
				return;
			}
			FileReader r = new FileReader(file);
			br = new BufferedReader(r);
			while (true) {
				String ln = br.readLine();
				if (ln == null)
					break;
				if (ln.startsWith(""#""))
					continue;
				int index = ln.indexOf("":"");
				if (index < 1)
					continue;
				String key = ln.substring(0, index);
				String val = ln.substring(index + 1);
				if (key.equals(""monitoring"")) {
					this.monitoring = val.equals(""true"");
				} else if (key.equals(""downloadFolder"")) {
					this.downloadFolder = val;
				} else if (key.equals(""maxSegments"")) {
					this.maxSegments = Integer.parseInt(val);
				} else if (key.equals(""minSegmentSize"")) {
					this.minSegmentSize = Integer.parseInt(val);
				} else if (key.equals(""networkTimeout"")) {
					this.networkTimeout = Integer.parseInt(val);
				} else if (key.equals(""tcpWindowSize"")) {
					this.tcpWindowSize = Integer.parseInt(val);
				} else if (key.equals(""duplicateAction"")) {
					this.duplicateAction = Integer.parseInt(val);
				} else if (key.equals(""speedLimit"")) {
					this.speedLimit = Integer.parseInt(val);
				} else if (key.equals(""showDownloadWindow"")) {
					this.showDownloadWindow = val.equals(""true"");
				} else if (key.equals(""showDownloadCompleteWindow"")) {
					this.showDownloadCompleteWindow = val.equals(""true"");
				} else if (key.equals(""minVidSize"")) {
					this.minVidSize = Integer.parseInt(val);
				} else if (key.equals(""maxDownloads"")) {
					this.maxDownloads = Integer.parseInt(val);
				} else if (key.equals(""blockedHosts"")) {
					this.blockedHosts = val.split("","");
				} else if (key.equals(""vidUrls"")) {
					this.vidUrls = val.split("","");
				} else if (key.equals(""fileExts"")) {
					this.fileExts = val.split("","");
				} else if (key.equals(""vidExts"")) {
					this.vidExts = val.split("","");
				} else if (key.equals(""proxyMode"")) {
					this.proxyMode = Integer.parseInt(val);
				} else if (key.equals(""proxyPort"")) {
					this.proxyPort = Integer.parseInt(val);
				} else if (key.equals(""socksPort"")) {
					this.socksPort = Integer.parseInt(val);
				} else if (key.equals(""proxyPac"")) {
					this.proxyPac = val;
				} else if (key.equals(""proxyHost"")) {
					this.proxyHost = val;
				} else if (key.equals(""socksHost"")) {
					this.socksHost = val;
				} else if (key.equals(""proxyUser"")) {
					this.proxyUser = val;
				} else if (key.equals(""proxyPass"")) {
					this.proxyPass = val;
				} else if (key.equals(""showVideoNotification"")) {
					this.showVideoNotification = ""true"".equals(val);
				} else if (key.equals(""keepAwake"")) {
					this.keepAwake = ""true"".equals(val);
				} else if (key.equals(""autoStart"")) {
					this.autoStart = ""true"".equals(val);
				} else if (key.equals(""execAntivir"")) {
					this.execAntivir = ""true"".equals(val);
				} else if (key.equals(""execCmd"")) {
					this.execCmd = ""true"".equals(val);
				} else if (key.equals(""antivirExe"")) {
					this.antivirExe = val;
				} else if (key.equals(""antivirCmd"")) {
					this.antivirCmd = val;
				} else if (key.equals(""customCmd"")) {
					this.customCmd = val;
				} else if (key.equals(""autoShutdown"")) {
					this.autoShutdown = ""true"".equals(val);
				} else if (key.equals(""version"")) {
					this.firstRun = !XDMApp.APP_VERSION.equals(val);
				} else if (key.equals(""language"")) {
					this.language = val;
				}
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		try {
			br.close();
		} catch (Exception e) {
		}
	}"
xdman,xdman.Config,Config,,49,748,676,25,0.0377,0.0584,1,32,5,0,1,"private Config() {
		File f = new File(System.getProperty(""user.home""), "".xdman"");
		if (!f.exists()) {
			f.mkdirs();
		}
		dataFolder = f.getAbsolutePath();
		f = new File(dataFolder, ""metadata"");
		if (!f.exists()) {
			f.mkdir();
		}
		this.metadataFolder = f.getAbsolutePath();
		f = new File(dataFolder, ""temp"");
		if (!f.exists()) {
			f.mkdir();
		}
		this.temporaryFolder = f.getAbsolutePath();
		this.downloadFolder = XDMUtils.getDownloadsFolder();
		if (!new File(this.downloadFolder).exists()) {
			this.downloadFolder = System.getProperty(""user.home"");
		}

		this.monitoring = true;
		this.showDownloadWindow = true;
		this.setMaxSegments(8);
		this.setMinSegmentSize(64 * 1024);
		this.maxDownloads = 100;
		this.minVidSize = 1 * 1024 * 1024;
		this.defaultFileTypes = new String[] { ""3GP"", ""7Z"", ""AVI"", ""BZ2"", ""DEB"", ""DOC"", ""DOCX"", ""EXE"", ""GZ"", ""ISO"",
				""MSI"", ""PDF"", ""PPT"", ""PPTX"", ""RAR"", ""RPM"", ""XLS"", ""XLSX"", ""SIT"", ""SITX"", ""TAR"", ""JAR"", ""ZIP"" };
		this.fileExts = defaultFileTypes;
		this.autoShutdown = false;
		this.blockedHosts = new String[] { ""update.microsoft.com"", ""windowsupdate.com"", ""thwawte.com"" };
		this.defaultVideoTypes = new String[] { ""MP4"", ""M3U8"", ""F4M"", ""WEBM"", ""OGG"", ""MP3"", ""AAC"", ""FLV"", ""MKV"", ""DIVX"",
				""MOV"", ""MPG"", ""MPEG"", ""OPUS"" };
		this.vidExts = defaultVideoTypes;
		this.vidUrls = new String[] { "".facebook.com|pagelet"", ""player.vimeo.com/"", ""instagram.com/p/"" };
		this.networkTimeout = 60;
		this.tcpWindowSize = 8;
		this.speedLimit = 0;

		this.proxyMode = 0;
		this.proxyPort = 0;
		this.socksPort = 0;
		this.proxyPac = this.proxyHost = this.proxyUser = this.proxyPass = this.socksHost = """";
		this.showVideoNotification = true;
		this.showDownloadCompleteWindow = true;
		this.firstRun = true;
		this.language = ""en"";
	}"
xdman,xdman.QueueManager,loadQueues,,60,542,343,5,0.0725,0.0875,0.333333333,17,12,0,1,"private void loadQueues() {
		File file = new File(Config.getInstance().getDataFolder(), ""queues.txt"");

		DownloadQueue defaultQ = new DownloadQueue("""",
				StringResource.get(""DEF_QUEUE""));
		queueList.add(defaultQ);
		if (!file.exists()) {
			return;
		}

		SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyy-MM-dd"");

		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new InputStreamReader(
					new FileInputStream(file), Charset.forName(""UTF-8"")));
			int count = Integer.parseInt(reader.readLine().trim());
			for (int i = 0; i < count; i++) {
				String id = reader.readLine().trim();
				String name = reader.readLine().trim();
				DownloadQueue queue = null;
				if ("""".equals(id)) {
					queue = defaultQ;
				} else {
					queue = new DownloadQueue(id, name);
				}
				int c = Integer.parseInt(reader.readLine().trim());
				for (int j = 0; j < c; j++) {
					queue.getQueuedItems().add(reader.readLine().trim());
				}
				boolean hasStartTime = Integer.parseInt(reader.readLine()) == 1;
				if (hasStartTime) {
					queue.setStartTime(Long.parseLong(reader.readLine()));
					boolean hasEndTime = Integer.parseInt(reader.readLine()) == 1;
					if (hasEndTime) {
						queue.setEndTime(Long.parseLong(reader.readLine()));
					}
					boolean isPeriodic = Integer.parseInt(reader.readLine()) == 1;
					queue.setPeriodic(isPeriodic);
					if (isPeriodic) {
						queue.setDayMask(Integer.parseInt(reader.readLine()));
					} else {
						if (Integer.parseInt(reader.readLine()) == 1) {
							String ln = reader.readLine();
							queue.setExecDate(dateFormatter.parse(ln));
						}
					}
				}
				if (queue.getQueueId().length() > 0) {
					queueList.add(queue);
				}
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		try {
			reader.close();
		} catch (Exception e1) {
		}
	}"
xdman,xdman.QueueManager,saveQueues,,55,422,141,4,0.1155,0.1998,0.272727273,11,11,1,1,"public void saveQueues() {
		int count = queueList.size();
		File file = new File(Config.getInstance().getDataFolder(), ""queues.txt"");
		BufferedWriter writer = null;
		String newLine = System.getProperty(""line.separator"");
		SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyy-MM-dd"");
		try {
			writer = new BufferedWriter(new OutputStreamWriter(
					new FileOutputStream(file), Charset.forName(""UTF-8"")));
			writer.write(count + newLine);
			for (int i = 0; i < count; i++) {
				DownloadQueue queue = queueList.get(i);
				writer.write(queue.getQueueId() + newLine);
				writer.write(queue.getName() + newLine);
				ArrayList<String> queuedItems = queue.getQueuedItems();
				writer.write(queuedItems.size() + newLine);
				for (int j = 0; j < queuedItems.size(); j++) {
					writer.write(queuedItems.get(j) + newLine);
				}
				if (queue.getStartTime() != -1) {
					writer.write(""1"" + newLine);
					writer.write(queue.getStartTime() + newLine);
					if (queue.getEndTime() != -1) {
						writer.write(""1"" + newLine);
						writer.write(queue.getEndTime() + newLine);
					} else {
						writer.write(""0"" + newLine);
					}
					writer.write((queue.isPeriodic() ? 1 : 0) + newLine);
					if (queue.isPeriodic()) {
						writer.write(queue.getDayMask() + newLine);
					} else {
						if (queue.getExecDate() != null) {
							writer.write(""1"" + newLine);
							writer.write(dateFormatter.format(queue
									.getExecDate()) + newLine);
						} else {
							writer.write(""0"" + newLine);
						}
					}
				} else {
					writer.write(""0"" + newLine);
				}
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		if (writer != null) {
			try {
				writer.close();
			} catch (IOException e) {
				Logger.log(e);
			}
		}
	}"
xdman,xdman.QueueManager,removeQueue,,16,41,16,3,0.2024,0.1928,0.5,5,5,0,1,"public void removeQueue(String queueId) {
		DownloadQueue q = getQueueById(queueId);
		if (q == null)
			return;
		if (q.isRunning()) {
			q.stop();
		}
		for (int i = 0; i < q.getQueuedItems().size(); i++) {
			String id = q.getQueuedItems().get(i);
			DownloadEntry ent = XDMApp.getInstance().getEntry(id);
			if (ent != null) {
				ent.setQueueId("""");
			}
		}
		queueList.remove(q);
	}"
xdman,xdman.QueueManager,createNewQueue,,24,105,90,5,0.1389,0.0684,0.5,6,6,0,1,"public void createNewQueue() {
		int counter = 1;
		String name = """";
		String qw = StringResource.get(""Q_WORD"");
		while (true) {
			boolean found = false;
			counter++;
			for (DownloadQueue qi : queueList) {
				if ("""".equals(qi.getQueueId()))
					continue;
				if ((qw + "" "" + counter).equals(qi.getName())) {
					found = true;
					break;
				}
			}
			if (!found) {
				name = qw + "" "" + counter;
				break;
			}
		}
		DownloadQueue q = new DownloadQueue(UUID.randomUUID().toString(), name);
		queueList.add(q);
		saveQueues();
	}"
xdman,xdman.QueueManager,fixCorruptEntries,,23,130,107,3,0.1389,0.0556,0.75,11,7,0,1,"// check and remove invalid entries from queued item list (invalid entries
	// might appear from corrupt download list
	public void fixCorruptEntries(Iterator<String> ids, XDMApp app) {
		DownloadQueue dfq = getDefaultQueue();
		while (ids.hasNext()) {
			String id = ids.next();
			DownloadEntry ent = app.getEntry(id);
			String qId = ent.getQueueId();
			if (qId == null || getQueueById(qId) == null) {
				dfq.getQueuedItems().add(id);
				ent.setQueueId("""");
			}
		}
		for (int i = 0; i < queueList.size(); i++) {
			DownloadQueue q = queueList.get(i);
			ArrayList<String> corruptIds = new ArrayList<String>();
			for (int k = 0; k < q.getQueuedItems().size(); k++) {
				String id = q.getQueuedItems().get(k);
				if (app.getEntry(id) == null) {
					corruptIds.add(id);
				}
			}
			q.getQueuedItems().removeAll(corruptIds);
		}
	}"
xdman,xdman.XDMApp,instanceStarted,,27,6,6,4,0.25,0,0.571428571,1,4,0,1,"// notification is stored in this
											// variable

	public static void instanceStarted() {
		Logger.log(""instance starting..."");
		final XDMApp app = XDMApp.getInstance();
		EventQueue.invokeLater(new Runnable() {
			@Override
			public void run() {
				if (!paramMap.containsKey(""background"")) {
					Logger.log(""showing main window."");
					app.showMainWindow();
				}
				TrayHandler.createTray();
				// if (XDMUtils.detectOS() != XDMUtils.LINUX) {
				// TrayHandler.createTray();
				// }
			}
		});
		if (Config.getInstance().isFirstRun()) {
			if (XDMUtils.detectOS() == XDMUtils.WINDOWS) {
				if (!XDMUtils.isAlreadyAutoStart()) {
					XDMUtils.addToStartup();
				}
			} else {
				XDMUtils.addToStartup();
			}
		}
		Logger.log(""instance started."");
	}"
xdman,xdman.XDMApp,downloadFinished,,33,241,206,9,0.1204,0.0656,0.4,4,10,0,1,"public void downloadFinished(String id) {
		DownloadEntry ent = downloads.get(id);
		ent.setState(XDMConstants.FINISHED);
		Downloader d = downloaders.remove(id);
		if (d != null && d.getSize() < 0) {
			ent.setSize(d.getDownloaded());
		}
		DownloadWindow wnd = downloadWindows.get(id);
		if (wnd != null) {
			wnd.close(XDMConstants.FINISHED, 0);
			downloadWindows.remove(id);
			if (ent.isStartedByUser()) {
				new DownloadCompleteWnd(ent.getFile(), ent.getFolder()).setVisible(true);
			}
		}
		notifyListeners(null);
		saveDownloadList();
		if (Config.getInstance().isExecAntivir()) {
			if (!StringUtils.isNullOrEmptyOrBlank(Config.getInstance().getAntivirExe())) {
				execAntivir();
			}
		}

		processNextItem(id);
		if (isAllFinished()) {
			if (Config.getInstance().isAutoShutdown()) {
				initShutdown();
			}
			if (Config.getInstance().isExecCmd()) {
				execCmd();
			}
		}
	}"
xdman,xdman.XDMApp,downloadFailed,,20,91,62,5,0.1641,0.1191,1,4,3,0,1,"public void downloadFailed(String id) {
		Downloader d = downloaders.remove(id);
		if (id == null) {
			Logger.log(""Download failed, id null"");
			return;
		}
		DownloadWindow wnd = downloadWindows.get(id);
		if (wnd != null) {
			wnd.close(XDMConstants.FAILED, d.getErrorCode());
			downloadWindows.remove(id);
		} else {
			Logger.log(""Wnd is null!!!"");
		}
		DownloadEntry ent = downloads.get(id);
		ent.setState(XDMConstants.PAUSED);
		notifyListeners(id);
		saveDownloadList();
		Logger.log(""removed"");
		processNextItem(id);
	}"
xdman,xdman.XDMApp,downloadStopped,,13,47,28,4,0.2083,0.1315,1,3,2,0,1,"public void downloadStopped(String id) {
		downloaders.remove(id);
		DownloadWindow wnd = downloadWindows.get(id);
		if (wnd != null) {
			wnd.close(XDMConstants.PAUSED, 0);
			downloadWindows.remove(id);
		}
		DownloadEntry ent = downloads.get(id);
		ent.setState(XDMConstants.PAUSED);
		notifyListeners(id);
		saveDownloadList();
		processNextItem(id);
	}"
xdman,xdman.XDMApp,downloadConfirmed,,17,68,31,4,0.1852,0.1342,0.5,4,3,0,1,"public void downloadConfirmed(String id) {
		Logger.log(""confirmed "" + id);
		Downloader d = downloaders.get(id);
		DownloadEntry ent = downloads.get(id);
		ent.setSize(d.getSize());
		if (d.isFileNameChanged()) {
			ent.setFile(d.getNewFile());
			ent.setCategory(XDMUtils.findCategory(d.getNewFile()));
			updateFileName(ent);
		}
		DownloadWindow wnd = downloadWindows.get(id);
		if (wnd != null) {
			wnd.update(d, ent.getFile());
		}
		notifyListeners(id);
		saveDownloadList();
	}"
xdman,xdman.XDMApp,downloadUpdated,,21,115,77,6,0.1611,0.1213,0.363636364,5,5,0,1,"public void downloadUpdated(String id) {
		DownloadEntry ent = downloads.get(id);
		Downloader d = downloaders.get(id);
		if (d == null) {
			Logger.log(""################# sync error ##############"");
		}
		ent.setSize(d.getSize());
		ent.setDownloaded(d.getDownloaded());
		ent.setProgress(d.getProgress());
		ent.setState(d.isAssembling() ? XDMConstants.ASSEMBLING : XDMConstants.DOWNLOADING);
		DownloadWindow wnd = downloadWindows.get(id);
		if (wnd != null) {
			wnd.update(d, ent.getFile());
		}
		notifyListeners(id);
		long now = System.currentTimeMillis();
		if (now - lastSaved > 5000) {
			saveDownloadList();
			lastSaved = now;
		}
	}"
xdman,xdman.XDMApp,addVideo,,13,5,4,3,0.375,0.1,1,2,3,0,1,"public void addVideo(final HttpMetadata metadata, final String file) {
		if (refreshCallback != null) {
			if (refreshCallback.isValidLink(metadata)) {
				return;
			}
		}
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				new VideoDownloadWindow(metadata, file).setVisible(true);
			}
		});
	}"
xdman,xdman.XDMApp,createDownload,,27,172,91,5,0.1204,0.1323,0.375,9,5,0,1,"public void createDownload(String file, String folder, HttpMetadata metadata, boolean now, String queueId,
			int formatIndex, int streamIndex) {
		metadata.save();
		DownloadEntry ent = new DownloadEntry();
		ent.setId(metadata.getId());
		ent.setOutputFormatIndex(formatIndex);
		ent.setState(XDMConstants.PAUSED);
		ent.setFile(file);
		ent.setFolder(folder);
		ent.setCategory(XDMUtils.findCategory(file));
		ent.setDate(System.currentTimeMillis());
		putInQueue(queueId, ent);
		ent.setStartedByUser(now);
		downloads.put(metadata.getId(), ent);
		saveDownloadList();
		if (!now) {
			DownloadQueue q = qMgr.getQueueById(queueId);
			if (q != null && q.isRunning()) {
				Logger.log(""Queue is running, if no pending download pickup next available download"");
				q.next();
			}
		}
		if (now) {
			startDownload(metadata.getId(), metadata, ent, streamIndex);
		}
		notifyListeners(null);
	}"
xdman,xdman.XDMApp,startDownload,,49,404,247,3,0.1046,0.0969,0.647058824,9,9,0,1,"// could be new or resume
	private void startDownload(String id, HttpMetadata metadata, DownloadEntry ent, int streams) {
		if (!checkAndBufferRequests(id)) {
			Logger.log(""starting "" + id + "" with: "" + metadata + "" is dash: "" + (metadata instanceof DashMetadata));
			Downloader d = null;

			if (metadata instanceof DashMetadata) {
				Logger.log(""Dash download with stream: "" + streams);
				if (streams == 1) {
					DashMetadata dm = (DashMetadata) metadata;
					dm.setUrl(dm.getUrl2());// set video url as main url
					dm.setUrl2(null);
				} else if (streams == 2) {
					DashMetadata dm = (DashMetadata) metadata;
					dm.setUrl2(null);
				} else {
					Logger.log(""Dash download created"");

					// create dash downloader
					DashMetadata dm = (DashMetadata) metadata;
					d = new DashDownloader(id, Config.getInstance().getTemporaryFolder(), dm);
				}
			}
			if (metadata instanceof HlsMetadata) {
				Logger.log(""Hls download created"");
				d = new HlsDownloader(id, Config.getInstance().getTemporaryFolder(), (HlsMetadata) metadata);
			}
			if (metadata instanceof HdsMetadata) {
				Logger.log(""Hls download created"");
				d = new HdsDownloader(id, Config.getInstance().getTemporaryFolder(), (HdsMetadata) metadata);
			}
			if (d == null) {
				d = new HttpDownloader(id, Config.getInstance().getTemporaryFolder(), metadata);
			}

			d.setOuputMediaFormat(ent.getOutputFormatIndex());
			downloaders.put(id, d);
			d.registerListener(this);
			ent.setState(XDMConstants.DOWNLOADING);
			d.start();

			if (Config.getInstance().showDownloadWindow()) {
				DownloadWindow wnd = new DownloadWindow(id, this);
				downloadWindows.put(id, wnd);
				wnd.setVisible(true);
			}
		} else {
			Logger.log(id + "": Maximum download limit reached, queueing request"");
		}
	}"
xdman,xdman.XDMApp,pauseDownload,,7,9,3,3,0.3333,0.2857,0.5,2,2,0,1,"public void pauseDownload(String id) {
		Downloader d = downloaders.get(id);
		if (d != null) {
			d.stop();
			d.unregisterListener();
		}
	}"
xdman,xdman.XDMApp,resumeDownload,,43,368,175,4,0.1074,0.1083,0.55,9,10,0,1,"public void resumeDownload(String id, boolean startedByUser) {
		DownloadEntry ent = downloads.get(id);
		ent.setStartedByUser(startedByUser);
		if (ent.getState() == XDMConstants.PAUSED || ent.getState() == XDMConstants.FAILED) {
			if (!checkAndBufferRequests(id)) {
				ent.setState(XDMConstants.DOWNLOADING);
				HttpMetadata metadata = HttpMetadata.load(id);
				if (Config.getInstance().showDownloadWindow() && ent.isStartedByUser()) {
					DownloadWindow wnd = new DownloadWindow(id, this);
					downloadWindows.put(id, wnd);
					wnd.setVisible(true);
				}
				Downloader d = null;
				if (metadata instanceof DashMetadata) {
					DashMetadata dm = (DashMetadata) metadata;
					Logger.log(""Dash download- url1: "" + dm.getUrl() + "" url2: "" + dm.getUrl2());
					d = new DashDownloader(id, Config.getInstance().getTemporaryFolder(), dm);
				}
				if (metadata instanceof HlsMetadata) {
					HlsMetadata hm = (HlsMetadata) metadata;
					Logger.log(""HLS download- url1: "" + hm.getUrl());
					d = new HlsDownloader(id, Config.getInstance().getTemporaryFolder(), hm);
				}
				if (metadata instanceof HdsMetadata) {
					HdsMetadata hm = (HdsMetadata) metadata;
					Logger.log(""HLS download- url1: "" + hm.getUrl());
					d = new HdsDownloader(id, Config.getInstance().getTemporaryFolder(), hm);
				}
				if (d == null) {
					Logger.log(""normal download"");
					d = new HttpDownloader(id, Config.getInstance().getTemporaryFolder(), metadata);
				}
				downloaders.put(id, d);
				d.setOuputMediaFormat(ent.getOutputFormatIndex());
				d.registerListener(this);
				d.resume();

			} else {
				Logger.log(id + "": Maximum download limit reached, queueing request"");
			}
			notifyListeners(null);
		}
	}"
xdman,xdman.XDMApp,restartDownload,,11,15,9,3,0.3333,0.1667,0.5,2,4,0,1,"public void restartDownload(String id) {
		DownloadEntry ent = downloads.get(id);
		if (ent.getState() == XDMConstants.PAUSED || ent.getState() == XDMConstants.FAILED
				|| ent.getState() == XDMConstants.FINISHED) {
			ent.setState(XDMConstants.PAUSED);
			clearData(id);
			resumeDownload(id, true);
		} else {
			return;
		}
	}"
xdman,xdman.XDMApp,notifyListeners,,9,7,4,3,0.4667,0.1852,0.5,2,4,0,1,"private void notifyListeners(String id) {
		if (listChangeListeners != null) {
			for (int i = 0; i < listChangeListeners.size(); i++)
				if (id != null)
					listChangeListeners.get(i).listItemUpdated(id);
				else
					listChangeListeners.get(i).listChanged();
		}
	}"
xdman,xdman.XDMApp,clearData,,10,25,22,3,0.2083,0.0909,0.5,4,3,0,1,"private void clearData(String id) {
		File folder = new File(Config.getInstance().getTemporaryFolder(), id);
		File[] files = folder.listFiles();
		if (files != null) {
			for (int i = 0; i < files.length; i++) {
				files[i].delete();
			}
		}
		folder.delete();
	}"
xdman,xdman.XDMApp,loadDownloadList,,65,748,506,5,0.088,0.1349,0.142857143,15,19,0,1,"public void loadDownloadList(File file) {
		if (!file.exists()) {
			return;
		}
		SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), Charset.forName(""UTF-8"")));
			int count = Integer.parseInt(reader.readLine().trim());
			for (int i = 0; i < count; i++) {
				int fieldCount = Integer.parseInt(reader.readLine().trim());
				DownloadEntry ent = new DownloadEntry();
				for (int j = 0; j < fieldCount; j++) {
					String ln = reader.readLine();
					int index = ln.indexOf("":"");
					if (index > 0) {
						String key = ln.substring(0, index).trim();
						String val = ln.substring(index + 1).trim();
						if (key.equals(""id"")) {
							ent.setId(val);
						}
						if (key.equals(""file"")) {
							ent.setFile(val);
						}
						if (key.equals(""category"")) {
							ent.setCategory(Integer.parseInt(val));
						}
						if (key.equals(""state"")) {
							int state = Integer.parseInt(val);
							ent.setState(state == XDMConstants.FINISHED ? state : XDMConstants.PAUSED);
						}
						if (key.equals(""folder"")) {
							ent.setFolder(val);
						}
						if (key.equals(""date"")) {
							ent.setDate(dateFormat.parse(val).getTime());
						}
						if (key.equals(""downloaded"")) {
							ent.setDownloaded(Long.parseLong(val));
						}
						if (key.equals(""size"")) {
							ent.setSize(Long.parseLong(val));
						}
						if (key.equals(""progress"")) {
							ent.setProgress(Integer.parseInt(val));
						}
						if (key.equals(""queueid"")) {
							ent.setQueueId(val);
						}
						if (key.equals(""formatIndex"")) {
							ent.setOutputFormatIndex(Integer.parseInt(val));
						}
					}
				}
				downloads.put(ent.getId(), ent);
			}
			reader.close();
		} catch (Exception e) {
			Logger.log(e);
		}
		try {
			reader.close();
		} catch (Exception e1) {
		}
	}"
xdman,xdman.XDMApp,saveDownloadList,,52,748,506,5,0.0944,0.1557,0.166666667,12,5,1,1,"public void saveDownloadList(File file) {
		int count = downloads.size();
		BufferedWriter writer = null;
		SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
		String newLine = System.getProperty(""line.separator"");
		try {
			writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), Charset.forName(""UTF-8"")));
			writer.write(count + """");
			writer.newLine();
			Iterator<String> keyIterator = downloads.keySet().iterator();
			while (keyIterator.hasNext()) {
				String key = keyIterator.next();
				DownloadEntry ent = downloads.get(key);
				int c = 0;
				StringBuffer sb = new StringBuffer();
				sb.append(""id: "" + ent.getId() + newLine);
				c++;
				sb.append(""file: "" + ent.getFile() + newLine);
				c++;
				sb.append(""category: "" + ent.getCategory() + newLine);
				c++;
				sb.append(""state: "" + ent.getState() + newLine);
				c++;
				sb.append(""folder: "" + ent.getFolder() + newLine);
				c++;
				sb.append(""date: "" + dateFormat.format(new Date(ent.getDate())) + newLine);
				c++;
				sb.append(""downloaded: "" + ent.getDownloaded() + newLine);
				c++;
				sb.append(""size: "" + ent.getSize() + newLine);
				c++;
				sb.append(""progress: "" + ent.getProgress() + newLine);
				c++;
				if (ent.getQueueId() != null) {
					sb.append(""queueid: "" + ent.getQueueId() + newLine);
					c++;
				}
				sb.append(""formatIndex: "" + ent.getOutputFormatIndex() + newLine);
				c++;
				writer.write(c + newLine);
				writer.write(sb.toString());

			}
			writer.close();
		} catch (Exception e) {
			Logger.log(e);
			try {
				writer.close();
			} catch (Exception e1) {
			}
		}
	}"
xdman,xdman.XDMApp,checkAndBufferRequests,,11,14,7,3,0.3429,0.1575,0.666666667,2,4,0,1,"private synchronized boolean checkAndBufferRequests(String id) {
		int actCount = getActiveDownloadCount();
		if (Config.getInstance().getMaxDownloads() > 0 && actCount >= Config.getInstance().getMaxDownloads()) {
			Logger.log(""active: "" + actCount + "" max: "" + Config.getInstance().getMaxDownloads());
			if (!pendingDownloads.contains(id)) {
				pendingDownloads.add(id);
			}
			return true;
		}
		return false;
	}"
xdman,xdman.XDMApp,processNextItem,,18,49,32,4,0.2708,0.1521,0.6,3,6,0,1,"private synchronized void processNextItem(String lastId) {
		processPendingRequests();
		if (lastId == null)
			return;
		DownloadEntry ent = getEntry(lastId);
		if (ent == null) {
			return;
		}
		DownloadQueue queue = null;
		if ("""".equals(ent.getQueueId())) {
			queue = qMgr.getDefaultQueue();
		} else {
			queue = qMgr.getQueueById(ent.getQueueId());
		}
		if (queue != null && queue.isRunning()) {
			queue.next();
		}
	}"
xdman,xdman.XDMApp,processPendingRequests,,21,87,54,3,0.1667,0.0932,0.666666667,8,6,0,1,"private void processPendingRequests() {
		int activeCount = getActiveDownloadCount();
		int maxDownloadCount = Config.getInstance().getMaxDownloads();
		List<String> tobeStartedIds = new ArrayList<String>();
		if (maxDownloadCount - activeCount > 0) {
			for (int i = 0; i < Math.min(maxDownloadCount, pendingDownloads.size()); i++) {
				String ent = pendingDownloads.get(i);
				tobeStartedIds.add(ent);
			}
		}
		if (tobeStartedIds.size() > 0) {
			for (int i = 0; i < tobeStartedIds.size(); i++) {
				String id = tobeStartedIds.get(i);
				pendingDownloads.remove(id);
				DownloadEntry ent = getEntry(id);
				if (ent != null) {
					resumeDownload(id, ent.isStartedByUser());
				}
			}
		}
	}"
xdman,xdman.XDMApp,queueItemPending,,14,15,9,2,0.2857,0.1206,1,4,6,0,1,"public boolean queueItemPending(String queueId) {
		if (queueId == null)
			return false;
		for (int i = 0; i < pendingDownloads.size(); i++) {
			String id = pendingDownloads.get(i);
			DownloadEntry ent = getEntry(id);
			if (ent == null || ent.getQueueId() == null)
				continue;
			if (ent.getQueueId().equals(queueId)) {
				return true;
			}
		}
		return false;
	}"
xdman,xdman.XDMApp,putInQueue,,19,63,35,3,0.2232,0.1148,0.428571429,6,4,0,1,"private void putInQueue(String queueId, DownloadEntry ent) {
		DownloadQueue q = getQueueById(queueId);
		String id = ent.getId();
		if (q == null) {
			Logger.log(""No queue found for: '"" + queueId + ""'"");
			return;
		}
		String qid = ent.getQueueId();
		DownloadQueue oldQ = getQueueById(qid);
		Logger.log(""Adding to: '"" + queueId + ""'"");
		if (!q.getQueueId().equals(qid)) {
			if (oldQ != null) {
				// remove from previous queue
				oldQ.removeFromQueue(id);
			}
			ent.setQueueId(queueId);
			q.addToQueue(id);
		}
	}"
xdman,xdman.XDMApp,compare,,16,15,9,3,0.2857,0.1333,1,4,5,0,1,"@Override
	public int compare(String key1, String key2) {
		DownloadEntry ent1 = getEntry(key1);
		DownloadEntry ent2 = getEntry(key2);
		if (ent1 == null)
			return -1;
		if (ent2 == null)
			return 1;
		if (ent1.getDate() > ent2.getDate()) {
			return 1;
		} else if (ent1.getDate() < ent2.getDate()) {
			return -1;
		} else {
			return 0;
		}
	}"
xdman,xdman.XDMApp,isAllFinished,,15,19,17,5,0.25,0.0556,0.666666667,2,5,0,1,"public boolean isAllFinished() {
		if (getActiveDownloadCount() != 0) {
			return false;
		}
		if (pendingDownloads.size() != 0) {
			return false;
		}
		for (int i = 0; i < QueueManager.getInstance().getQueueList().size(); i++) {
			DownloadQueue q = QueueManager.getInstance().getQueueList().get(i);
			if (q.hasPendingItems()) {
				return false;
			}
		}
		return true;
	}"
xdman,xdman.XDMApp,deleteDownloads,,30,169,107,5,0.157,0.1086,0.5,8,10,0,1,"public int deleteDownloads(ArrayList<String> ids) {
		int c = 0;
		for (int i = 0; i < ids.size(); i++) {
			String id = ids.get(i);
			DownloadEntry ent = getEntry(id);
			if (ent != null) {
				if (ent.getState() == XDMConstants.FINISHED || ent.getState() == XDMConstants.PAUSED
						|| ent.getState() == XDMConstants.FAILED) {
					this.downloads.remove(id);
					if (pendingDownloads.contains(id)) {
						pendingDownloads.remove(id);
					}
					String qId = ent.getQueueId();
					if (qId != null) {
						DownloadQueue q = getQueueById(qId);
						if (q != null) {
							if (q.getQueueId().length() > 0) {
								q.removeFromQueue(id);
							}
						}
					}
					deleteFiles(id);
					c++;
				}
			}
		}
		saveDownloadList();
		notifyListeners(null);
		return ids.size() - c;
	}"
xdman,xdman.XDMApp,deleteFiles,,16,56,21,3,0.2653,0.1528,0.5,6,4,0,1,"private void deleteFiles(String id) {
		Logger.log(""Deleting metadata for "" + id);
		File mf = new File(Config.getInstance().getMetadataFolder(), id);
		boolean deleted = mf.delete();
		Logger.log(""Deleted manifest "" + id + "" "" + deleted);
		File df = new File(Config.getInstance().getTemporaryFolder(), id);
		File[] files = df.listFiles();
		if (files != null && files.length > 0) {
			for (File f : files) {
				deleted = f.delete();
				Logger.log(""Deleted tmp file "" + id + "" "" + deleted);
			}
		}
		deleted = df.delete();
		Logger.log(""Deleted tmp folder "" + id + "" "" + deleted);
	}"
xdman,xdman.XDMApp,deleteCompleted,,12,32,19,3,0.2667,0.0962,1,4,3,0,1,"public void deleteCompleted() {
		Iterator<String> allIds = downloads.keySet().iterator();
		ArrayList<String> idList = new ArrayList<String>();
		while (allIds.hasNext()) {
			String id = allIds.next();
			DownloadEntry ent = downloads.get(id);
			if (ent.getState() == XDMConstants.FINISHED) {
				idList.add(id);
			}
		}
		deleteDownloads(idList);
	}"
xdman,xdman.XDMApp,promptCredential,,21,56,34,4,0.1692,0.1108,0.571428571,5,6,0,1,"public boolean promptCredential(String id, String msg, boolean proxy) {
		DownloadEntry ent = getEntry(id);
		if (ent == null)
			return false;
		if (!ent.isStartedByUser())
			return false;
		PasswordAuthentication pauth = getCredential(msg, proxy);
		if (pauth == null) {
			return false;
		}
		if (proxy) {
			Config.getInstance().setProxyUser(pauth.getUserName());
			if (pauth.getPassword() != null) {
				Config.getInstance().setProxyPass(new String(pauth.getPassword()));
			}
		} else {
			Logger.log(""saving password for: "" + msg);
			CredentialManager.getInstance().addCredentialForHost(msg, pauth);
		}
		return true;
	}"
xdman,xdman.XDMApp,updateFileName,,17,72,39,3,0.2074,0.104,0.5,6,3,0,1,"private void updateFileName(DownloadEntry ent) {
		Logger.log(""checking for same named file on disk..."");
		String id = ent.getId();
		File f = new File(getOutputFolder(id), ent.getFile());
		int c = 1;
		while (f.exists()) {
			String ext = XDMUtils.getExtension(f.getAbsolutePath());
			if (ext == null) {
				ext = """";
			}
			String f2 = XDMUtils.getFileNameWithoutExtension(ent.getFile());
			f = new File(getOutputFolder(id), f2 + ""_"" + c + ext);
			c++;
		}
		Logger.log(""Updating file name- old: "" + ent.getFile() + "" new: "" + f.getName());
		ent.setFile(f.getName());
	}"
xdman,xdman.QueueScheduler,run,,102,1517,1381,10,0.0517,0.0366,0.35,21,25,1,1,"@Override
	public void run() {
		long lastUpdateChecked = 0;
		try {
			Calendar cal = Calendar.getInstance();

			while (!stop) {
				try {
					long currentTime = System.currentTimeMillis();
					if (currentTime - lastKeepAwakePing > 3000) {
						if (!XDMApp.getInstance().isAllFinished()) {
							XDMUtils.keepAwakePing();
							lastKeepAwakePing = currentTime;
						}
					}

					ArrayList<DownloadQueue> queues = QueueManager.getInstance().getQueueList();
					for (int i = 0; i < queues.size(); i++) {
						DownloadQueue queue = queues.get(i);
						if (queue.isRunning() || queue.getStartTime() == -1) {
							continue;
						}
						Date now = new Date();
						cal.setTime(now);
						Date onlyDate = DateTimeUtils.getDatePart(cal);
						long seconds = DateTimeUtils.getTimePart(now);

						if (seconds > queue.getStartTime()) {
							if (queue.getEndTime() > 0) {
								if (queue.getEndTime() < seconds) {
									continue;
								}
							}
						} else {
							continue;
						}

						if (queue.isPeriodic()) {
							int day = cal.get(Calendar.DAY_OF_WEEK);
							int mask = 0x01 << (day - 1);

							if ((queue.getDayMask() & mask) != mask) {
								continue;
							}
						} else {
							Date execDate = queue.getExecDate();
							if (execDate == null) {
								continue;
							}
							cal.setTime(execDate);
							Date onlyDate2 = DateTimeUtils.getDatePart(cal);
							if (onlyDate.compareTo(onlyDate2) < 0) {
								continue;
							}
						}
						queue.start();
					}

					for (int i = 0; i < queues.size(); i++) {
						DownloadQueue queue = queues.get(i);
						if (!queue.isRunning()) {
							continue;
						}
						if (queue.getEndTime() < 1) {
							continue;
						}
						Date now = new Date();
						long seconds = DateTimeUtils.getTimePart(now);
						if (queue.getEndTime() < seconds) {
							queue.stop();
						}
					}
					Thread.sleep(1000);
				} catch (Exception e2) {
					Logger.log(""error in scheduler: "" + e2);
					Logger.log(e2);
				}

				long now = System.currentTimeMillis();
				if (now - lastUpdateChecked > 3600 * 1000) {
					int stat = UpdateChecker.getUpdateStat();
					switch (stat) {
					case UpdateChecker.NO_UPDATE_AVAILABLE:
						break;
					case UpdateChecker.APP_UPDATE_AVAILABLE:
						XDMApp.getInstance().notifyAppUpdate();
						break;
					case UpdateChecker.COMP_NOT_INSTALLED:
						XDMApp.getInstance().notifyComponentInstall();
						break;
					case UpdateChecker.COMP_UPDATE_AVAILABLE:
						XDMApp.getInstance().notifyComponentUpdate();
						break;
					}
				}
				lastUpdateChecked = now;
			}
		} catch (Exception e) {
			Logger.log(""error in scheduler: "" + e);
			Logger.log(e);
		}
	}"
xdman,xdman.CredentialManager,load,,34,167,144,5,0.1091,0.0731,0.75,7,10,0,1,"private void load() {
		BufferedReader br = null;
		try {
			File f = new File(Config.getInstance().getDataFolder(), "".credentials"");
			if (!f.exists()) {
				Logger.log(""No saved credentials"");
				return;
			}
			br = new BufferedReader(new InputStreamReader(new FileInputStream(f)));
			if (!savedCredentials.isEmpty())
				savedCredentials.clear();
			while (true) {
				String ln = br.readLine();
				if (ln == null)
					break;
				String str = new String(Base64.decode(ln));
				String[] arr = str.split(""\n"");
				if (arr.length < 2)
					continue;
				savedCredentials.put(arr[0],
						new PasswordAuthentication(arr[1], arr.length == 3 ? arr[2].toCharArray() : new char[0]));
			}
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				if (br != null) {
					br.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}"
xdman,xdman.CredentialManager,save,,27,145,119,4,0.1128,0.0721,0.75,10,5,0,1,"public void save() {
		StringBuilder buf = new StringBuilder();
		Iterator<String> savedKeyIterator = savedCredentials.keySet().iterator();
		while (savedKeyIterator.hasNext()) {
			String key = savedKeyIterator.next();
			PasswordAuthentication pauth = savedCredentials.get(key);
			String str = key + ""\n"" + pauth.getUserName() + ""\n"" + new String(pauth.getPassword());
			String str64 = Base64.encode(str.getBytes());
			buf.append(str64 + ""\n"");
		}
		OutputStream out = null;
		try {
			File f = new File(Config.getInstance().getDataFolder(), "".credentials"");
			out = new FileOutputStream(f);
			out.write(buf.toString().getBytes());
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				if (out != null) {
					out.close();
				}
			} catch (Exception e) {

			}
		}
	}"
xdman,xdman.DownloadQueue,start,,7,9,8,4,0.3,0.1111,0,0,2,0,1,"public void start() {
		if (running)
			return;
		index = 0;
		running = true;
		next();
	}"
xdman,xdman.DownloadQueue,stop,,14,37,29,4,0.2,0.0708,0.5,5,5,0,1,"public void stop() {
		running = false;
		XDMApp app = XDMApp.getInstance();
		for (int i = 0; i < queuedItems.size(); i++) {
			String id = queuedItems.get(i);
			DownloadEntry ent = app.getEntry(id);
			int state = ent.getState();
			if (state == XDMConstants.FAILED || state == XDMConstants.FINISHED || state == XDMConstants.PAUSED) {
				continue;
			} else {
				app.pauseDownload(id);
			}
		}
	}"
xdman,xdman.DownloadQueue,next,,43,356,277,4,0.1262,0.0808,0.428571429,7,14,1,1,"public synchronized void next() {
		Logger.log(queueId + "" attmpting to process next item"");
		if (!running)
			return;
		int c = 0;
		XDMApp app = XDMApp.getInstance();
		if (queuedItems == null)
			return;
		if (app.queueItemPending(queueId)) {
			Logger.log(queueId + "" not processing as has already pending download"");
			return;
		}
		if (currentItemId != null) {
			DownloadEntry ent = app.getEntry(currentItemId);
			if (ent != null) {
				int state = ent.getState();
				if (!(state == XDMConstants.FAILED || state == XDMConstants.PAUSED || state == XDMConstants.FINISHED)) {
					Logger.log(queueId + "" not processing as has already active download"");
					return;
				}
			}
		}
		Logger.log(queueId + "" total queued "" + queuedItems.size());
		if (!(index < queuedItems.size())) {
			index = 0;
		}
		for (; index < queuedItems.size();) {
			String id = queuedItems.get(index);
			DownloadEntry ent = app.getEntry(id);
			if (ent != null) {
				int state = ent.getState();
				if (state == XDMConstants.FAILED || state == XDMConstants.PAUSED) {
					Logger.log(""index: "" + index + "" c: "" + c);
					currentItemId = id;
					index++;
					ent.setStartedByUser(false);
					XDMApp.getInstance().resumeDownload(id, false);
					return;
				}
			}
			index++;
		}
	}"
xdman,xdman.DownloadQueue,removeFromQueue,,22,91,62,4,0.1687,0.0845,0.6,5,6,0,1,"public void removeFromQueue(String id) {
		int c = 0;
		XDMApp app = XDMApp.getInstance();
		for (int i = 0; i < queuedItems.size(); i++) {
			if (queuedItems.get(i).equals(id)) {
				c = i;
				if (c <= index) {
					index--;
				}
				queuedItems.remove(i);
				if (id.equals(currentItemId)) {
					currentItemId = null;
				}
				DownloadEntry ent = app.getEntry(id);
				if (ent != null) {
					ent.setQueueId("""");
				}
				QueueManager.getInstance().saveQueues();
				return;
			}
		}
	}"
xdman,xdman.DownloadQueue,addToQueue,,11,24,12,4,0.2381,0.1129,0.666666667,2,3,0,1,"public void addToQueue(String id) {
		if (!queuedItems.contains(id)) {
			Logger.log(id + "" added to "" + queueId);
			queuedItems.add(id);
			DownloadEntry ent = XDMApp.getInstance().getEntry(id);
			if (ent != null) {
				ent.setQueueId(queueId);
			}
		}
		QueueManager.getInstance().saveQueues();
	}"
xdman,xdman.DownloadQueue,reorderItems,,6,8,6,3,0.35,0.1019,0,4,2,0,1,"public final synchronized void reorderItems(ArrayList<String> newOrder) {
		this.queuedItems.clear();
		for (String s : newOrder) {
			this.queuedItems.add(s);
		}
	}"
xdman,xdman.DownloadQueue,hasPendingItems,,14,17,13,4,0.2286,0.0958,0.666666667,2,5,0,1,"public boolean hasPendingItems() {
		if (!running) {
			return false;
		}
		for (String id : queuedItems) {
			DownloadEntry ent = XDMApp.getInstance().getEntry(id);
			if (ent != null) {
				if (ent.getState() != XDMConstants.FINISHED) {
					return true;
				}
			}
		}
		return false;
	}"
xdman,xdman.downloaders.SegmentComparator,compare,,10,3,3,3,0.3333,0,1,2,3,0,1,"@Override
	public int compare(Segment c1, Segment c2) {
		if (c1.getStartOffset() > c2.getStartOffset()) {
			return 1;
		} else if (c1.getStartOffset() < c2.getStartOffset()) {
			return -1;
		} else {
			return 0;
		}
	}"
xdman,xdman.downloaders.AbstractChannel,connect,,19,43,31,5,0.2182,0.1186,0.5,2,4,0,1,"private boolean connect() {
		try {
			chunk.getChunkListener().synchronize();
		} catch (NullPointerException e) {
			Logger.log(""stopped chunk "" + chunk);
			return false;
		}
		if (connectImpl()) {
			in = getInputStreamImpl();
			long length = getLengthImpl();
			if (chunk.getLength() < 0) {
				Logger.log(""Setting length of "" + chunk.getId() + "" to: "" + length);
				chunk.setLength(length);
			}
			return true;
		} else {
			return false;
		}
	}"
xdman,xdman.downloaders.AbstractChannel,run,,30,104,88,6,0.1875,0.1091,0.5,1,9,0,1,"@Override
	public void run() {
		try {
			while (!stop) {
				if (!connect()) {
					if (!stop) {
						chunk.transferFailed(errorMessage);
					}
					close();
					break;
				}
				chunk.transferInitiated();
				// do not proceed if chunk is stoppped
				if (chunk == null) {
					continue;
				}
				if (((chunk.getLength() > 0) ? copyStream1() : copyStream2())) {
					break;
				}
			}
		} catch (Exception e) {
			Logger.log(""Internal problem: "" + e);
			Logger.log(e);
			if (!stop) {
				chunk.transferFailed(errorMessage);
			}
		} finally {
			close();
		}
	}"
xdman,xdman.downloaders.AbstractChannel,stop,,7,13,11,4,0.2778,0.1333,0,2,2,0,1,"public void stop() {
		stop = true;
		this.chunk = null;
		if (this.t != null) {
			t.interrupt();
		}
	}"
xdman,xdman.downloaders.AbstractChannel,copyStream1,,55,484,440,14,0.0854,0.0529,0.4,4,12,0,1,"private boolean copyStream1() {
		try {
			while (!stop) {
				chunk.getChunkListener().synchronize();
				long rem = chunk.getLength() - chunk.getDownloaded();
				if (rem == 0) {
					if (this instanceof HttpChannel) {
						if (((HttpChannel) this).isFinished()) {
							close();
						}
					} else {
						close();
					}
					if (chunk.transferComplete()) {
						Logger.log(chunk + "" complete and closing "" + chunk.getDownloaded() + "" "" + chunk.getLength());
						return true;
					}
				}
				if (stop) {
					return false;
				}

				// if (this.socketDataRemaining == 0) {
				// // reuse socket and connect again as this connection has
				// // consumed all data
				// Logger.log(chunk + "" length not satisfieble resending..."");
				// return false;
				// }

				int diff = (int) (rem > buf.length ? buf.length : rem);
				// if (diff > this.socketDataRemaining) {
				// diff = (int) this.socketDataRemaining;
				// }

				int x = in.read(buf, 0, diff);
				if (stop)
					return false;
				if (x == -1) {
					throw new Exception(""Unexpected eof"");
				}
				chunk.getOutStream().write(buf, 0, x);
				if (stop)
					return false;
				chunk.setDownloaded(chunk.getDownloaded() + x);
				// this.socketDataRemaining -= x;
				chunk.transferring();
			}
			return false;
		} catch (Exception e) {
			Logger.log(e);
			return false;
		} finally {
			close();
		}
	}"
xdman,xdman.downloaders.AbstractChannel,copyStream2,,24,73,55,6,0.1905,0.1259,0.285714286,2,6,0,1,"private boolean copyStream2() {
		try {
			while (!stop) {
				chunk.getChunkListener().synchronize();
				int x = in.read(buf, 0, buf.length);
				if (stop)
					return false;
				if (x == -1) {
					chunk.transferComplete();
					return true;
				}
				chunk.getOutStream().write(buf, 0, x);
				if (stop)
					return false;
				chunk.setDownloaded(chunk.getDownloaded() + x);
				chunk.transferring();
			}
			return false;
		} catch (Exception e) {
			return false;
		} finally {
			close();
		}
	}"
xdman,xdman.downloaders.Downloader,retryFailedChunks,,23,75,45,4,0.1905,0.1619,1,4,6,0,1,"protected synchronized int retryFailedChunks(int rem) throws IOException {
		if (stopFlag)
			return 0;
		int count = 0;
		int totalInactive = findTotalInactiveChunk();
		Logger.log(""Total inactive chunks: "" + totalInactive);

		if (totalInactive > rem) {
			totalInactive = rem;
		}
		if (totalInactive > 0) {
			for (; totalInactive > 0; totalInactive--) {
				Segment c = findInactiveChunk();
				if (c != null) {
					c.download(this);
					count++;
				} else {
					Logger.log(""$$$ debug rem:"" + rem);
				}
			}
		}
		return count;
	}"
xdman,xdman.downloaders.Downloader,findInactiveChunk,,11,11,7,3,0.3333,0.1556,0.5,2,5,0,1,"protected Segment findInactiveChunk() {
		if (stopFlag)
			return null;
		for (int i = 0; i < chunks.size(); i++) {
			Segment c = chunks.get(i);
			if (c.isFinished() || c.isActive())
				continue;
			return c;
		}
		return null;
	}"
xdman,xdman.downloaders.Downloader,findTotalInactiveChunk,,10,23,18,4,0.2813,0.1481,0.5,3,4,0,1,"protected int findTotalInactiveChunk() {
		int count = 0;
		for (int i = 0; i < chunks.size(); i++) {
			Segment c = chunks.get(i);
			if (c.isFinished() || c.isActive())
				continue;
			count++;
		}
		return count;
	}"
xdman,xdman.downloaders.Downloader,allFinished,,13,9,3,3,0.4444,0.2143,1,2,4,0,1,"protected boolean allFinished() {
		if (chunks.size() > 0) {
			for (int i = 0; i < chunks.size(); i++) {
				Segment chunk = chunks.get(i);
				if (!chunk.isFinished()) {
					return false;
				}
			}
			return true;
		} else {
			return false;
		}
	}"
xdman,xdman.downloaders.Downloader,cleanup,,8,18,15,3,0.2286,0.0667,1,3,2,0,1,"public void cleanup() {
		File dir = new File(folder);
		File[] files = dir.listFiles();
		for (int i = 0; i < files.length; i++) {
			Logger.log(""Delete: "" + files[i] + "" ["" + files[i].length() + ""] "" + files[i].delete());
		}
		new File(folder).delete();
	}"
xdman,xdman.downloaders.Downloader,chunkFailed,,37,142,94,4,0.1308,0.1257,0.75,12,9,0,1,"@Override
	public synchronized void chunkFailed(String id, String reason) {
		if (stopFlag)
			return;
		int err = 0;
		for (int i = 0; i < chunks.size(); i++) {
			Segment chunk = chunks.get(i);
			if (chunk.isActive()) {
				return;
			}
			if (chunk.getErrorCode() != 0) {
				err = chunk.getErrorCode();
			}
		}

		if (err == XDMConstants.ERR_INVALID_RESP) {
			if (downloaded > 0) {
				if (length > 0) {
					if (chunks.size() > 1) {
						this.errorCode = XDMConstants.ERR_SESSION_FAILED;
					} else {
						this.errorCode = XDMConstants.ERR_NO_RESUME;
					}
				} else {
					this.errorCode = XDMConstants.ERR_NO_RESUME;
				}
			} else {
				this.errorCode = XDMConstants.ERR_INVALID_RESP;
			}
		} else {
			Logger.log(""Setting final error code: "" + err);
			this.errorCode = err;
		}

		this.listener.downloadFailed(this.id);
		Logger.log(""failed"");
	}"
xdman,xdman.downloaders.SegmentDownloader,start,,21,78,51,5,0.1481,0.1405,0.555555556,4,3,0,1,"public void start() {
		Logger.log(""creating folder "" + folder);
		new File(folder).mkdirs();
		chunks = new ArrayList<Segment>();
		try {
			Segment c1 = new SegmentImpl(this, folder);
			// handle case of single dash stream
			if (getMetadata() instanceof DashMetadata) {
				c1.setTag(""T1"");
			}
			c1.setLength(-1);
			c1.setStartOffset(0);
			c1.setDownloaded(0);
			chunks.add(c1);
			c1.download(this);
		} catch (IOException e) {
			this.errorCode = XDMConstants.RESUME_FAILED;
			this.listener.downloadFailed(id);
		}

	}"
xdman,xdman.downloaders.SegmentDownloader,resume,,39,311,271,13,0.0895,0.085,0.8,9,7,0,1,"@Override
	public void resume() {
		try {
			stopFlag = false;
			Logger.log(""Resuming"");
			if (!restoreState()) {
				Logger.log(""Starting from beginning"");
				start();
				return;
			}
			this.lastDownloaded = downloaded;
			this.prevTime = System.currentTimeMillis();
			Logger.log(""Restore success"");
			init = true;
			Segment c1 = findInactiveChunk();
			if (c1 != null) {
				try {
					c1.download(this);
				} catch (Exception e) {
					Logger.log(e);
					if (!stopFlag) {
						Logger.log(e);
						this.errorCode = XDMConstants.RESUME_FAILED;
						listener.downloadFailed(this.id);
						return;
					}
				}
			} else if (allFinished()) {
				assembleAsync();
			} else {
				Logger.log(""Internal error: no inactive/incomplete chunk found while resuming!"");
			}
		} catch (Exception e) {
			Logger.log(e);
			this.errorCode = XDMConstants.RESUME_FAILED;
			listener.downloadFailed(this.id);
			return;
		}
	}"
xdman,xdman.downloaders.SegmentDownloader,createChunk,,24,67,43,3,0.1786,0.1111,0.75,4,5,0,1,"private synchronized void createChunk() throws IOException {
		if (stopFlag)
			return;
		int activeCount = getActiveChunkCount();
		Logger.log(""active count:"" + activeCount);
		if (activeCount == MAX_COUNT) {
			return;
		}

		int rem = MAX_COUNT - activeCount;
		// Logger.log(""rem:"" + rem);

		rem -= retryFailedChunks(rem);

		if (rem > 0) {
			Segment c1 = findMaxChunk();
			Segment c = splitChunk(c1);
			if (c != null) {
				Logger.log(""creating chunk "" + c);
				chunks.add(c);
				c.download(this);
			}
		}
	}"
xdman,xdman.downloaders.SegmentDownloader,findMaxChunk,,19,45,24,2,0.2381,0.1394,0.4,5,6,0,1,"private Segment findMaxChunk() {
		if (stopFlag)
			return null;
		long size = -1;
		String id = null;
		for (int i = 0; i < chunks.size(); i++) {
			Segment c = chunks.get(i);
			if (c.isActive()) {
				long rem = c.getLength() - c.getDownloaded();
				if (rem > size) {
					id = c.getId();
					size = rem;
				}
			}
		}
		if (size < MIN_CHUNK_SIZE)
			return null;
		return getById(id);
	}"
xdman,xdman.downloaders.SegmentDownloader,splitChunk,,17,52,26,3,0.2115,0.1569,0.444444444,5,4,0,1,"private Segment splitChunk(Segment c) throws IOException {
		if (c == null || stopFlag)
			return null;
		long rem = c.getLength() - c.getDownloaded();
		long offset = c.getStartOffset() + c.getLength() - rem / 2;
		long len = rem / 2;
		Logger.log(""Changing length from: "" + c.getLength() + "" to "" + (c.getLength() - rem / 2));
		c.setLength(c.getLength() - rem / 2);
		Segment c2 = new SegmentImpl(this, folder);
		// handle case of single dash stream
		if (getMetadata() instanceof DashMetadata) {
			c2.setTag(""T1"");
		}
		c2.setLength(len);
		c2.setStartOffset(offset);
		return c2;
	}"
xdman,xdman.downloaders.SegmentDownloader,findNextNeedyChunk,,16,16,4,2,0.3,0.2411,0.25,4,6,0,1,"private Segment findNextNeedyChunk(Segment chunk) {
		if (stopFlag)
			return null;
		long offset = chunk.getStartOffset() + chunk.getLength();
		for (int i = 0; i < chunks.size(); i++) {
			Segment c = chunks.get(i);
			if (c.getDownloaded() == 0) {
				if (!c.isFinished()) {
					if (c.getStartOffset() == offset) {
						return c;
					}
				}
			}
		}
		return null;
	}"
xdman,xdman.downloaders.SegmentDownloader,onComplete,,37,309,267,9,0.101,0.065,0.444444444,7,6,0,1,"private synchronized boolean onComplete(String id) throws IOException {
		if (allFinished() || length < 0) {
			// finish
			finished = true;
			updateStatus();
			try {
				assemble();
				Logger.log(""********Download finished*********"");
				updateStatus();
				listener.downloadFinished(this.id);
			} catch (Exception e) {
				if (!stopFlag) {
					Logger.log(e);
					this.errorCode = XDMConstants.ERR_ASM_FAILED;
					listener.downloadFailed(this.id);
				}
			}

			listener = null;
			return true;
		}
		Segment chunk = getById(id);
		Logger.log(""Complete: "" + chunk + "" "" + chunk.getDownloaded() + "" "" + chunk.getLength());
		Segment nextNeedyChunk = findNextNeedyChunk(chunk);
		if (nextNeedyChunk != null) {
			Logger.log(""****************Needy chunk found!!!"");
			Logger.log(""Stopping: "" + nextNeedyChunk);
			nextNeedyChunk.stop();
			chunks.remove(nextNeedyChunk);
			nextNeedyChunk.dispose();
			mergeChunk(chunk, nextNeedyChunk);
			createChunk();
			return false;
		}
		createChunk();
		return true;
	}"
xdman,xdman.downloaders.SegmentDownloader,chunkInitiated,,18,46,37,5,0.1688,0.0946,1,5,4,0,1,"@Override
	public synchronized void chunkInitiated(String id) throws IOException {
		if (stopFlag)
			return;
		if (!init) {
			Segment c = getById(id);
			this.length = c.getLength();
			init = true;
			Logger.log(""size: "" + this.length);
			super.getLastModifiedDate(c);
			saveState();
			chunkConfirmed(c);
			listener.downloadConfirmed(this.id);
		}
		if (length > 0) {
			createChunk();
		}
	}"
xdman,xdman.downloaders.SegmentDownloader,chunkComplete,,14,6,6,4,0.25,0,0,1,3,0,1,"@Override
	public synchronized boolean chunkComplete(String id) throws IOException {
		if (finished) {
			return true;
		}

		if (stopFlag) {
			return true;
		}

		saveState();

		return onComplete(id);
	}"
xdman,xdman.downloaders.SegmentDownloader,chunkUpdated,,27,133,113,9,0.125,0.0754,0.666666667,5,6,0,1,"@Override
	public void chunkUpdated(String id) {
		if (stopFlag)
			return;
		long now = System.currentTimeMillis();
		if (now - lastSaved > 5000) {
			synchronized (this) {
				saveState();
			}
			lastSaved = now;
		}
		if (now - lastUpdated > 1000) {
			updateStatus();
			lastUpdated = now;
			synchronized (this) {
				int activeCount = getActiveChunkCount();
				if (activeCount < MAX_COUNT) {
					int rem = MAX_COUNT - activeCount;
					try {
						retryFailedChunks(rem);
					} catch (Exception e) {
						Logger.log(e);
					}
				}
			}
		}
	}"
xdman,xdman.downloaders.SegmentDownloader,assemble,,74,872,798,10,0.0528,0.0377,0.571428571,13,18,1,1,"private void assemble() throws IOException {
		InputStream in = null;
		OutputStream out = null;
		totalAssembled = 0L;
		assembling = true;
		assembleFinished = false;
		File outFile = new File(getOutputFolder(), getOutputFileName(true));
		try {
			if (stopFlag)
				return;
			byte buf[] = new byte[8192 * 8];
			Logger.log(""assembling... "");
			Collections.sort(chunks, new SegmentComparator());
			// chunks.sort(new SegmentComparator());
			out = new FileOutputStream(outFile);
			for (int i = 0; i < chunks.size(); i++) {
				Logger.log(""chunk "" + i + "" "" + stopFlag);
				Segment c = chunks.get(i);
				in = new FileInputStream(new File(folder, c.getId()));
				long rem = c.getLength();
				while (true) {
					int x = (int) (rem > 0 ? (rem > buf.length ? buf.length : rem) : buf.length);
					int r = in.read(buf, 0, x);
					if (stopFlag) {
						return;
					}

					if (r == -1) {
						if (length > 0) {
							throw new IllegalArgumentException(""Assemble EOF"");
						} else {
							break;
						}
					}

					out.write(buf, 0, r);
					if (stopFlag) {
						return;
					}
					if (length > 0) {
						rem -= r;
						if (rem == 0)
							break;
					}
					totalAssembled += r;
					long now = System.currentTimeMillis();
					if (now - lastUpdated > 1000) {
						updateStatus();
						lastUpdated = now;
					}
				}
				in.close();
			}
			out.close();
			setLastModifiedDate(outFile);
			assembleFinished = true;
		} catch (Exception e) {
			Logger.log(e);
			throw new IOException(e);
		} finally {
			if (in != null) {
				try {
					in.close();
				} catch (Exception e2) {
				}
			}
			if (out != null) {
				try {
					out.close();
				} catch (Exception e2) {
				}
			}
		}
	}"
xdman,xdman.downloaders.SegmentDownloader,stop,,9,26,24,6,0.2,0.06,1,1,2,0,1,"public void stop() {
		stopFlag = true;
		saveState();
		for (int i = 0; i < chunks.size(); i++) {
			chunks.get(i).stop();
		}
		listener.downloadStopped(id);
		listener = null;
	}"
xdman,xdman.downloaders.SegmentDownloader,saveState,,29,167,103,3,0.1266,0.1194,0.5,9,5,0,1,"private void saveState() {
		if (length < 0)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(this.length + ""\n"");
		sb.append(downloaded + ""\n"");
		sb.append(chunks.size() + ""\n"");
		for (int i = 0; i < chunks.size(); i++) {
			Segment seg = chunks.get(i);
			sb.append(seg.getId() + ""\n"");
			sb.append(seg.getLength() + ""\n"");
			sb.append(seg.getStartOffset() + ""\n"");
			sb.append(seg.getDownloaded() + ""\n"");
		}
		if (!StringUtils.isNullOrEmptyOrBlank(lastModified)) {
			sb.append(this.lastModified + ""\n"");
		}
		try {
			File tmp = new File(folder, System.currentTimeMillis() + "".tmp"");
			File out = new File(folder, ""state.txt"");
			FileOutputStream fs = new FileOutputStream(tmp);
			fs.write(sb.toString().getBytes());
			fs.close();
			out.delete();
			tmp.renameTo(out);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.SegmentDownloader,restoreState,,45,310,214,4,0.0931,0.087,0.444444444,14,8,0,1,"private boolean restoreState() {
		BufferedReader br = null;
		chunks = new ArrayList<Segment>();
		File file = new File(folder, ""state.txt"");
		if (!file.exists()) {
			file = getBackupFile(folder);
			if (file == null) {
				return false;
			}
		}
		try {
			br = new BufferedReader(new FileReader(file));
			this.length = Long.parseLong(br.readLine());
			this.downloaded = Long.parseLong(br.readLine());
			int chunkCount = Integer.parseInt(br.readLine());
			for (int i = 0; i < chunkCount; i++) {
				String cid = br.readLine();
				long len = Long.parseLong(br.readLine());
				long off = Long.parseLong(br.readLine());
				long dwn = Long.parseLong(br.readLine());
				Segment seg = new SegmentImpl(folder, cid, off, len, dwn);
				// handle case of single dash stream
				if (getMetadata() instanceof DashMetadata) {
					seg.setTag(""T1"");
				}

				Logger.log(""id: "" + seg.getId() + ""\nlength: "" + seg.getLength() + ""\noffset: "" + seg.getStartOffset()
						+ ""\ndownload: "" + seg.getDownloaded());
				chunks.add(seg);
			}
			this.lastModified = br.readLine();
			return true;
		} catch (Exception e) {
			Logger.log(""Failed to load saved state"");
			Logger.log(e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
				}
			}
		}
		return false;
	}"
xdman,xdman.downloaders.SegmentDownloader,updateStatus,,49,607,511,5,0.0779,0.0498,0.4,15,11,0,1,"private void updateStatus() {
		try {
			long now = System.currentTimeMillis();
			if (this.assembling) {
				long len = length > 0 ? length : downloaded;
				progress = (int) ((totalAssembled * 100) / len);
			} else {
				long downloaded2 = 0;
				if (segDet == null) {
					segDet = new SegmentDetails();
				}
				if (segDet.getCapacity() < chunks.size()) {
					segDet.extend(chunks.size() - segDet.getCapacity());
				}
				segDet.setChunkCount(chunks.size());
				downloadSpeed = 0;
				for (int i = 0; i < chunks.size(); i++) {
					Segment s = chunks.get(i);
					downloaded2 += s.getDownloaded();
					SegmentInfo info = segDet.getChunkUpdates().get(i);
					info.setDownloaded(s.getDownloaded());
					info.setStart(s.getStartOffset());
					info.setLength(s.getLength());
					downloadSpeed += s.getTransferRate();
				}
				this.downloaded = downloaded2;
				if (length > 0) {
					progress = (int) ((downloaded * 100) / length);
					long diff = downloaded - lastDownloaded;
					long timeSpend = now - prevTime;
					if (timeSpend > 0) {
						float rate = ((float) diff / timeSpend) * 1000;
						if (rate > downloadSpeed) {
							downloadSpeed = rate;
						}
						this.eta = FormatUtilities.getETA(length - downloaded, rate);
						if (this.eta == null) {
							this.eta = ""---"";
						}
						lastDownloaded = downloaded;
						prevTime = now;
					}
				}
			}
			listener.downloadUpdated(id);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.SegmentImpl,SegmentImpl,,13,50,45,7,0.1169,0.0256,1,7,1,0,1,"public SegmentImpl(SegmentListener cl, String folder) throws IOException {
		id = UUID.randomUUID().toString();
		this.cl = cl;
		this.folder = folder;
		this.time1 = System.currentTimeMillis();
		this.time2 = time1;
		this.config = Config.getInstance();
		outStream = new RandomAccessFile(new File(folder, id), ""rw"");// new
		// FileOutputStream(new
		// File(folder,
		// id));
		Logger.log(""File opened "" + id);
	}"
xdman,xdman.downloaders.SegmentImpl,SegmentImpl,,24,186,162,7,0.0816,0.0466,1,17,3,0,1,"public SegmentImpl(String folder, String id, long off, long len, long dwn) throws IOException {
		this.id = id;
		this.id = id;
		this.startOffset = off;
		this.folder = folder;
		this.length = len;
		this.downloaded = dwn;
		this.time1 = System.currentTimeMillis();
		this.time2 = time1;
		this.bytesRead1 = dwn;
		this.bytesRead2 = dwn;
		try {
			outStream = new RandomAccessFile(new File(folder, id), ""rw"");
			outStream.seek(dwn);
			Logger.log(""File opened "" + id);
		} catch (IOException e) {
			Logger.log(e);
			if (outStream != null) {
				outStream.close();
			}
			throw new IOException(e);
		}
		this.config = Config.getInstance();
	}"
xdman,xdman.downloaders.SegmentImpl,transferComplete,,22,50,45,7,0.1313,0.0545,0.5,1,6,0,1,"@Override
	public boolean transferComplete() throws IOException {
		if (stop)
			return true;
		if (length < 0) {
			length = downloaded;
		}
		if (cl.chunkComplete(id)) {
			try {
				outStream.close();
			} catch (IOException e) {
				Logger.log(e);
			}
			channel = null;
			if (cl.shouldCleanup()) {
				cl.cleanup();
			}
			return true;
		} else {
			return false;
		}
	}"
xdman,xdman.downloaders.SegmentImpl,transferFailed,,18,56,46,4,0.1574,0.0813,1,5,4,0,1,"@Override
	public void transferFailed(String reason) {
		if (stop)
			return;
		if (outStream != null) {
			try {
				outStream.close();
				outStream = null;
			} catch (IOException e) {
				Logger.log(e);
			}
		}
		this.errorCode = channel.getErrorCode();
		Logger.log(id + "" notifying failure "" + this.channel);
		this.channel = null;
		cl.chunkFailed(id, reason);
		cl = null;
	}"
xdman,xdman.downloaders.SegmentImpl,dispose,,14,33,30,6,0.1778,0.0714,1,1,4,0,1,"@Override
	public void dispose() {
		cl = null;
		if (channel != null) {
			channel.stop();
		}
		if (outStream != null) {
			try {
				outStream.close();
			} catch (IOException e) {
				Logger.log(e);
			}
		}
	}"
xdman,xdman.downloaders.SegmentImpl,transferring,,9,10,10,5,0.2,0,1,0,2,0,1,"@Override
	public void transferring() {
		if (stop)
			return;
		cl.chunkUpdated(id);
		calculateTransferRate();
		throttle();
		// applyThrottling();
	}"
xdman,xdman.downloaders.SegmentImpl,calculateTransferRate,,10,27,18,3,0.254,0.1067,0,5,3,0,1,"private void calculateTransferRate() {
		long now = System.currentTimeMillis();
		long timeDiff = now - time1;
		long bytesDiff = this.downloaded - bytesRead1;
		if (timeDiff > 1000 && bytesDiff > 0) {
			transferRate = ((float) bytesDiff / timeDiff) * 1000;
			bytesRead1 = this.downloaded;
			time1 = now;
		}
	}"
xdman,xdman.downloaders.SegmentImpl,throttle,,23,119,102,5,0.1218,0.0489,1,7,6,0,1,"private void throttle() {
		try {
			if (config.getSpeedLimit() < 1)
				return;
			if (cl.getActiveChunkCount() < 1)
				return;
			long maxBpms = (config.getSpeedLimit() * 1024) / (cl.getActiveChunkCount() * 1000);
			long now = System.currentTimeMillis();
			long timeSpentInReal = now - time2;
			if (timeSpentInReal > 0) {
				time2 = now;
				long bytesDownloaded = downloaded - bytesRead2;
				bytesRead2 = downloaded;
				long timeShouldRequired = bytesDownloaded / maxBpms;
				if (timeShouldRequired > timeSpentInReal) {
					long timeNeedToSleep = timeShouldRequired - timeSpentInReal;
					Thread.sleep(timeNeedToSleep);
				}
			}
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.SegmentImpl,reopenStream,,16,40,25,3,0.1818,0.1438,1,1,4,0,1,"public void reopenStream() throws IOException {
		if (outStream != null) {
			return;
		}
		try {
			outStream = new RandomAccessFile(new File(folder, id), ""rw"");
			outStream.seek(downloaded);
			Logger.log(""File opened "" + id);
		} catch (IOException e) {
			Logger.log(e);
			if (outStream != null) {
				outStream.close();
			}
			throw new IOException(e);
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,start,,28,218,160,7,0.1042,0.1074,0.5,7,2,0,1,"public void start() {
		Logger.log(""creating folder "" + folder);
		new File(folder).mkdirs();
		this.lastDownloaded = downloaded;
		this.prevTime = System.currentTimeMillis();
		chunks = new ArrayList<Segment>();
		try {
			Segment c1 = new SegmentImpl(this, folder);
			c1.setTag(""T1"");
			c1.setLength(-1);
			c1.setStartOffset(0);
			c1.setDownloaded(0);
			chunks.add(c1);

			Segment c2 = new SegmentImpl(this, folder);
			c2.setTag(""T2"");
			c2.setLength(-1);
			c2.setStartOffset(0);
			c2.setDownloaded(0);
			chunks.add(c2);

			c1.download(this);
			c2.download(this);
		} catch (IOException e) {
			this.errorCode = XDMConstants.RESUME_FAILED;
			this.listener.downloadFailed(id);
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,createChannel,,7,7,4,3,0.4,0.1667,0.5,3,4,0,1,"public AbstractChannel createChannel(Segment segment) {
		long len = ""T1"".equals(segment.getTag()) ? metadata.getLen1() : metadata.getLen2();
		String url = ""T1"".equals(segment.getTag()) ? metadata.getUrl() : metadata.getUrl2();
		return new HttpChannel(segment, url,
				""T1"".equals(segment.getTag()) ? metadata.getHeaders() : metadata.getHeaders2(), len,
				isJavaClientRequired);
	}"
xdman,xdman.downloaders.dash.DashDownloader,chunkInitiated,,32,114,38,6,0.1857,0.2558,0.75,10,13,0,1,"@Override
	public synchronized void chunkInitiated(String id) throws IOException {
		if (stopFlag)
			return;
		Segment c = getById(id);
		if (c == null) {
			Logger.log(id + "" is no longer valid chunk"");
		}
		// int code = dc.getCode();
		// Logger.log(id + "" code: "" + code + "" len: "" + c.getLength());
		if (isFirstChunk(c)) {
			//HttpChannel dc = (HttpChannel) c.getChannel();
			super.getLastModifiedDate(c);
			if (c.getTag().equals(""T1"")) {
				this.len1 = c.getLength();
			} else if (c.getTag().equals(""T2"")) {
				this.len2 = c.getLength();
			}
			saveState();
		}

		if (this.length < 1 && this.len1 > 0 && this.len2 > 0) {
			this.length = len1 + len2;
		}

		if (c.getTag().equals(""T1"") && this.len1 > 0) {
			createChunk((String) c.getTag());
		}
		if (c.getTag().equals(""T2"") && this.len2 > 0) {
			createChunk((String) c.getTag());
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,onComplete,,39,354,302,9,0.1034,0.0701,0.4,7,5,0,1,"private synchronized boolean onComplete(String id) throws IOException {
		if (allFinished()) {
			// finish
			finished = true;
			updateStatus();
			try {
				assembleFinished = false;
				initAssemble();
				assembleFinished = true;
				Logger.log(""********Download finished*********"");
				updateStatus();
				listener.downloadFinished(this.id);
			} catch (Exception e) {
				if (!stopFlag) {
					Logger.log(e);
					this.errorCode = XDMConstants.ERR_ASM_FAILED;
					listener.downloadFailed(this.id);
				}
			}

			listener = null;
			return true;
		}
		Segment chunk = getById(id);
		Logger.log(""Complete: "" + chunk + "" "" + chunk.getDownloaded() + "" "" + chunk.getLength());
		Segment nextNeedyChunk = findNextNeedyChunk(chunk);
		if (nextNeedyChunk != null) {
			Logger.log(""****************Needy chunk found!!!"");
			Logger.log(""Stopping: "" + nextNeedyChunk);
			nextNeedyChunk.stop();
			chunks.remove(nextNeedyChunk);
			nextNeedyChunk.dispose();
			mergeChunk(chunk, nextNeedyChunk);
			createChunk((String) chunk.getTag());
			return false;
		}
		createChunk((String) chunk.getTag());
		return true;
	}"
xdman,xdman.downloaders.dash.DashDownloader,chunkComplete,,14,6,6,4,0.25,0,0,1,3,0,1,"@Override
	public synchronized boolean chunkComplete(String id) throws IOException {
		if (finished) {
			return true;
		}

		if (stopFlag) {
			return true;
		}

		saveState();

		return onComplete(id);
	}"
xdman,xdman.downloaders.dash.DashDownloader,chunkUpdated,,27,133,113,9,0.125,0.0754,0.666666667,5,6,0,1,"@Override
	public void chunkUpdated(String id) {
		if (stopFlag)
			return;
		long now = System.currentTimeMillis();
		if (now - lastSaved > 5000) {
			synchronized (this) {
				saveState();
			}
			lastSaved = now;
		}
		if (now - lastUpdated > 1000) {
			updateStatus();
			lastUpdated = now;
			synchronized (this) {
				int activeCount = getActiveChunkCount();
				if (activeCount < MAX_COUNT) {
					int rem = MAX_COUNT - activeCount;
					try {
						retryFailedChunks(rem);
					} catch (IOException e) {
						Logger.log(e);
					}
				}
			}
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,updateStatus,,62,901,767,7,0.0708,0.0493,0.375,17,15,0,1,"private void updateStatus() {
		try {
			long now = System.currentTimeMillis();
			if (converting) {
				progress = this.convertPrg;
			} else if (assembling) {
				long len = length > 0 ? length : downloaded;
				progress = (int) ((totalAssembled * 100) / len);
			} else {
				long downloaded2 = 0;
				if (length > 0) {
					if (segDet == null) {
						segDet = new SegmentDetails();
					}
					if (segDet.getCapacity() < chunks.size()) {
						segDet.extend(chunks.size() - segDet.getCapacity());
					}
					segDet.setChunkCount(chunks.size());
				}
				downloadSpeed = 0;
				for (int i = 0; i < chunks.size(); i++) {
					Segment s = chunks.get(i);
					downloaded2 += s.getDownloaded();
					if (length > 0) {
						long off = 0;
						if (s.getTag().equals(""T2"")) {
							off = len1;
						}
						SegmentInfo info = segDet.getChunkUpdates().get(i);
						info.setDownloaded(s.getDownloaded());
						info.setStart(s.getStartOffset() + off);
						info.setLength(s.getLength());
					}
					downloadSpeed += s.getTransferRate();
				}
				this.downloaded = downloaded2;
				this.downloaded = downloaded2;
				if (length > 0) {
					progress = (int) ((downloaded * 100) / length);
					long diff = downloaded - lastDownloaded;
					long timeSpend = now - prevTime;
					if (timeSpend > 0) {
						float rate = ((float) diff / timeSpend) * 1000;
						if (rate > downloadSpeed) {
							downloadSpeed = rate;
						}
						this.eta = FormatUtilities.getETA(length - downloaded, rate);
						if (this.eta == null) {
							this.eta = ""---"";
						}
						lastDownloaded = downloaded;
						prevTime = now;
					}
				}
			}

			listener.downloadUpdated(id);
		} catch (Exception e) {
			Logger.log(e);
		}

	}"
xdman,xdman.downloaders.dash.DashDownloader,assemble,,77,991,901,13,0.0536,0.0413,0.75,14,18,0,1,"private void assemble(String file, ArrayList<Segment> list) throws IOException {
		InputStream in = null;
		OutputStream out = null;
		totalAssembled = 0L;
		assembling = true;
		Logger.log(""Combining "" + file + "" "" + list.size());
		try {
			if (stopFlag)
				return;
			byte buf[] = new byte[8192 * 8];
			Logger.log(""assembling... "" + stopFlag);
			Collections.sort(list, new SegmentComparator());
			// list.sort(new SegmentComparator());
			out = new FileOutputStream(new File(folder, file));
			for (int i = 0; i < list.size(); i++) {
				Logger.log(""chunk "" + i + "" "" + stopFlag);
				Segment c = list.get(i);
				in = new FileInputStream(new File(folder, c.getId()));
				long rem = c.getLength();
				while (true) {
					int x = (int) (rem > 0 ? (rem > buf.length ? buf.length : rem) : buf.length);
					int r = in.read(buf, 0, x);
					if (stopFlag) {
						// closeStream(in, out);
						return;
					}

					if (r == -1) {
						if (length > 0) {
							in.close();
							out.close();
							throw new IllegalArgumentException(""Assemble EOF"");
						} else {
							break;
						}
					}

					out.write(buf, 0, r);
					if (stopFlag) {
						// closeStream(in, out);
						return;
					}
					if (length > 0) {
						rem -= r;
						if (rem == 0)
							break;
					}
					totalAssembled += r;
					long now = System.currentTimeMillis();
					if (now - lastUpdated > 1000) {
						updateStatus();
						lastUpdated = now;
					}
				}
				in.close();
			}
			out.close();
			// assembleFinished = true;
			// listener.downloadFinished(id);
		} catch (Exception e) {
			Logger.log(e);
			throw new IOException(e);
		} finally {
			if (in != null) {
				try {
					in.close();
				} catch (Exception e2) {
				}
			}
			if (out != null) {
				try {
					out.close();
				} catch (Exception e2) {
				}
			}
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,isFirstChunk,,9,17,13,4,0.2857,0.175,1,3,3,0,1,"private boolean isFirstChunk(Segment s) {
		int c = 0;
		for (Segment ss : chunks) {
			if (ss.getTag().equals(s.getTag())) {
				c++;
			}
		}
		return c == 1;
	}"
xdman,xdman.downloaders.dash.DashDownloader,stop,,13,42,39,7,0.1571,0.0476,1,3,3,0,1,"@Override
	public void stop() {
		stopFlag = true;
		saveState();
		for (int i = 0; i < chunks.size(); i++) {
			chunks.get(i).stop();
		}
		if (this.ffmpeg != null) {
			this.ffmpeg.stop();
		}
		listener.downloadStopped(id);
		listener = null;
	}"
xdman,xdman.downloaders.dash.DashDownloader,resume,,67,631,559,13,0.0743,0.0596,0.571428571,13,18,0,1,"@Override
	public void resume() {
		try {
			stopFlag = false;
			Logger.log(""Resuming"");
			if (!restoreState()) {
				Logger.log(""Starting from beginning"");
				start();
				return;
			}
			Logger.log(""Restore success"");
			this.lastDownloaded = downloaded;
			this.prevTime = System.currentTimeMillis();

			if (allFinished()) {
				assembleAsync();
				return;
			}

			Segment c1 = null;
			for (int i = 0; i < chunks.size(); i++) {
				Segment c = chunks.get(i);
				if (c.isFinished() || c.isActive())
					continue;
				if (c.getTag().equals(""T1"")) {
					c1 = c;
					break;
				}
			}

			Segment c2 = null;
			for (int i = 0; i < chunks.size(); i++) {
				Segment c = chunks.get(i);
				if (c.isFinished() || c.isActive())
					continue;
				if (c.getTag().equals(""T2"")) {
					c2 = c;
					break;
				}
			}

			if (c1 != null) {
				try {
					c1.download(this);
				} catch (IOException e) {
					Logger.log(e);
				}
			}

			if (c2 != null) {
				try {
					c2.download(this);
				} catch (IOException e) {
					Logger.log(e);
				}
			}

			if (c1 == null && c2 == null) {
				Logger.log(""Internal error: no inactive/incomplete chunk found while resuming!"");
			}
		} catch (Exception e) {
			Logger.log(e);
			this.errorCode = XDMConstants.RESUME_FAILED;
			listener.downloadFailed(this.id);
			return;
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,saveState,,32,224,123,3,0.1106,0.1333,0.428571429,11,5,0,1,"private void saveState() {
		if (chunks.size() < 0)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(this.length + ""\n"");
		sb.append(downloaded + ""\n"");
		sb.append(this.len1 + ""\n"");
		sb.append(this.len2 + ""\n"");
		sb.append(chunks.size() + ""\n"");
		for (int i = 0; i < chunks.size(); i++) {
			Segment seg = chunks.get(i);
			sb.append(seg.getId() + ""\n"");
			sb.append(seg.getLength() + ""\n"");
			sb.append(seg.getStartOffset() + ""\n"");
			sb.append(seg.getDownloaded() + ""\n"");
			sb.append(seg.getTag() + ""\n"");
		}
		if (!StringUtils.isNullOrEmptyOrBlank(lastModified)) {
			sb.append(this.lastModified + ""\n"");
		}
		try {
			File tmp = new File(folder, System.currentTimeMillis() + "".tmp"");
			File out = new File(folder, ""state.txt"");
			FileOutputStream fs = new FileOutputStream(tmp);
			fs.write(sb.toString().getBytes());
			fs.close();
			out.delete();
			tmp.renameTo(out);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,restoreState,,44,329,193,3,0.0884,0.1048,0.5,17,7,0,1,"private boolean restoreState() {
		BufferedReader br = null;
		chunks = new ArrayList<Segment>();
		File file = new File(folder, ""state.txt"");
		if (!file.exists()) {
			file = getBackupFile(folder);
			if (file == null) {
				return false;
			}
		}
		try {
			br = new BufferedReader(new FileReader(file));
			this.length = Long.parseLong(br.readLine());
			this.downloaded = Long.parseLong(br.readLine());
			this.len1 = Long.parseLong(br.readLine());
			this.len2 = Long.parseLong(br.readLine());
			int chunkCount = Integer.parseInt(br.readLine());
			for (int i = 0; i < chunkCount; i++) {
				String cid = br.readLine();
				long len = Long.parseLong(br.readLine());
				long off = Long.parseLong(br.readLine());
				long dwn = Long.parseLong(br.readLine());
				String tag = br.readLine();
				Segment seg = new SegmentImpl(folder, cid, off, len, dwn);
				seg.setTag(tag);
				Logger.log(""id: "" + seg.getId() + ""\nlength: "" + seg.getLength() + ""\noffset: "" + seg.getStartOffset()
						+ ""\ndownload: "" + seg.getDownloaded());
				chunks.add(seg);
			}
			this.lastModified = br.readLine();
			return true;
		} catch (Exception e) {
			Logger.log(""Failed to load saved state"");
			Logger.log(e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
				}
			}
		}
		return false;
	}"
xdman,xdman.downloaders.dash.DashDownloader,createChunk,,24,67,43,3,0.1786,0.1111,0.75,5,5,0,1,"private synchronized void createChunk(String tag) throws IOException {
		if (stopFlag)
			return;
		int activeCount = getActiveChunkCount();
		Logger.log(""active count:"" + activeCount);
		if (activeCount == MAX_COUNT) {
			return;
		}

		int rem = MAX_COUNT - activeCount;
		// Logger.log(""rem:"" + rem);

		rem -= retryFailedChunks(rem);

		if (rem > 0) {
			Segment c1 = findMaxChunk();
			Segment c = splitChunk(c1);
			if (c != null) {
				Logger.log(""creating chunk "" + c);
				chunks.add(c);
				c.download(this);
			}
		}
	}"
xdman,xdman.downloaders.dash.DashDownloader,findMaxChunk,,19,45,24,2,0.2381,0.1394,0.4,5,6,0,1,"private Segment findMaxChunk() {
		if (stopFlag)
			return null;
		long size = -1;
		String id = null;
		for (int i = 0; i < chunks.size(); i++) {
			Segment c = chunks.get(i);
			if (c.isActive()) {
				long rem = c.getLength() - c.getDownloaded();
				if (rem > size) {
					id = c.getId();
					size = rem;
				}
			}
		}
		if (size < MIN_CHUNK_SIZE)
			return null;
		return getById(id);
	}"
xdman,xdman.downloaders.dash.DashDownloader,splitChunk,,14,35,4,2,0.2396,0.1944,0.333333333,5,3,0,1,"private Segment splitChunk(Segment c) throws IOException {
		if (c == null || stopFlag)
			return null;
		long rem = c.getLength() - c.getDownloaded();
		long offset = c.getStartOffset() + c.getLength() - rem / 2;
		long len = rem / 2;
		Logger.log(""Changing length from: "" + c.getLength() + "" to "" + (c.getLength() - rem / 2));
		c.setLength(c.getLength() - rem / 2);
		Segment c2 = new SegmentImpl(this, folder);
		c2.setTag(c.getTag());
		c2.setLength(len);
		c2.setStartOffset(offset);
		return c2;
	}"
xdman,xdman.downloaders.dash.DashDownloader,findNextNeedyChunk,,16,16,4,2,0.325,0.2333,0.2,4,7,0,1,"private Segment findNextNeedyChunk(Segment chunk) {
		if (stopFlag)
			return null;
		long offset = chunk.getStartOffset() + chunk.getLength();
		for (int i = 0; i < chunks.size(); i++) {
			Segment c = chunks.get(i);
			if (c.getDownloaded() == 0) {
				if (!c.isFinished()) {
					if (c.getStartOffset() == offset && chunk.getTag().equals(c.getTag())) {
						return c;
					}
				}
			}
		}
		return null;
	}"
xdman,xdman.downloaders.dash.DashDownloader,progress,,9,18,15,5,0.2143,0.1111,0,3,2,0,1,"@Override
	public void progress(int progress) {
		this.convertPrg = progress;
		long now = System.currentTimeMillis();
		if (now - lastUpdated > 1000) {
			updateStatus();
			lastUpdated = now;
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,start,,19,94,68,7,0.1146,0.1312,0.5,5,2,0,1,"public void start() {
		Logger.log(""creating folder "" + folder);
		new File(folder).mkdirs();

		this.lastDownloaded = downloaded;
		this.prevTime = System.currentTimeMillis();
		try {
			manifestSegment = new SegmentImpl(this, folder);
			manifestSegment.setTag(""MF"");
			manifestSegment.setLength(-1);
			manifestSegment.setStartOffset(0);
			manifestSegment.setDownloaded(0);
			manifestSegment.setTag(""HLS"");
			manifestSegment.download(this);
		} catch (IOException e) {
			this.errorCode = XDMConstants.RESUME_FAILED;
			this.listener.downloadFailed(id);
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,chunkComplete,,62,445,362,11,0.0956,0.0796,0.4,12,12,0,1,"@Override
	public boolean chunkComplete(String id) {
		if (finished) {
			return true;
		}

		if (stopFlag) {
			return true;
		}
		if (id.equals(manifestSegment.getId())) {
			if (initOrUpdateSegments()) {
				listener.downloadConfirmed(this.id);
			} else {
				if (!stopFlag) {
					this.errorCode = XDMConstants.ERR_INVALID_RESP;
					listener.downloadFailed(this.id);
					return true;
				}
			}
		} else {
			Segment s = getById(id);
			if (s.getLength() < 0) {
				s.setLength(s.getDownloaded());
			}

			if (allFinished()) {

				finished = true;
				long len = 0L;
				for (Segment ss : chunks) {
					len += ss.getLength();
				}
				if (len > 0) {
					this.length = len;
				}

				saveState();

				updateStatus();

				try {
					assembleFinished = false;
					assemble();
					Logger.log(""********Download finished*********"");
					updateStatus();
					assembleFinished = true;
					listener.downloadFinished(this.id);
				} catch (Exception e) {
					if (!stopFlag) {
						Logger.log(e);
						this.errorCode = XDMConstants.ERR_ASM_FAILED;
						listener.downloadFailed(this.id);
					}
				}
				listener = null;
				return true;
			}
		}

		processSegments();
		return true;
	}"
xdman,xdman.downloaders.hds.HdsDownloader,chunkUpdated,,19,68,58,9,0.1795,0.1267,0,2,4,0,1,"@Override
	public void chunkUpdated(String id) {
		if (stopFlag)
			return;
		long now = System.currentTimeMillis();
		if (now - lastSaved > 5000) {
			synchronized (this) {
				saveState();
			}
			lastSaved = now;
		}
		if (now - lastUpdated > 1000) {
			updateStatus();
			lastUpdated = now;
			synchronized (this) {
				processSegments();
			}
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,createChannel,,13,32,19,4,0.225,0.0939,0.571428571,3,3,0,1,"@Override
	public AbstractChannel createChannel(Segment segment) {
		for (int i = 0; i < chunks.size(); i++) {
			if (segment == chunks.get(i)) {
				HdsMetadata md = new HdsMetadata();
				md.setUrl(urlList.get(i));
				md.setHeaders(metadata.getHeaders());
				return new HttpChannel(segment, md.getUrl(), md.getHeaders(), -1, isJavaClientRequired);
			}
		}
		Logger.log(""Create manifest channel"");
		return new HttpChannel(segment, metadata.getUrl(), metadata.getHeaders(), -1, isJavaClientRequired);
	}"
xdman,xdman.downloaders.hds.HdsDownloader,initOrUpdateSegments,,53,341,247,2,0.1,0.0865,0.583333333,9,11,0,1,"private boolean initOrUpdateSegments() {
		try {
			F4MManifest mf = new F4MManifest(metadata.getUrl(),
					new File(folder, manifestSegment.getId()).getAbsolutePath());
			mf.setSelectedBitRate(metadata.getBitRate());
			this.totalDuration = mf.getDuration();
			Logger.log(""Total duration "" + totalDuration);
			ArrayList<String> urls = mf.getMediaUrls();
			if (urls.size() < 1) {
				Logger.log(""Manifest contains no media"");
				return false;
			}
			if (urlList.size() > 0 && urlList.size() != urls.size()) {
				Logger.log(""Manifest media count mismatch- expected: "" + urlList.size() + "" got: "" + urls.size());
				return false;
			}
			if (urlList.size() > 0) {
				urlList.clear();
			}
			urlList.addAll(urls);

			String newExtension = null;

			if (chunks.size() < 1) {
				for (int i = 0; i < urlList.size(); i++) {
					if (newExtension == null && outputFormat == 0) {
						newExtension = findExtension(urlList.get(i));
						Logger.log(""HDS: found new extension: "" + newExtension);
						if (newExtension != null) {
							this.newFileName = getOutputFileName(false).replace("".flv"", newExtension);

						} else {
							newExtension = "".flv"";// just to skip the whole file
													// ext extraction
						}
					}

					Logger.log(""HDS: Newfile name: "" + this.newFileName);

					Segment s2 = new SegmentImpl(this, folder);
					s2.setTag(""HLS"");
					s2.setLength(-1);
					Logger.log(""Adding chunk: "" + s2);
					chunks.add(s2);
				}
			}
			return true;
		} catch (Exception e) {
			Logger.log(e);
			return false;
		}

	}"
xdman,xdman.downloaders.hds.HdsDownloader,processSegments,,12,27,18,3,0.2444,0.1167,0.666666667,3,3,0,1,"private synchronized void processSegments() {
		int activeCount = getActiveChunkCount();
		Logger.log(""active: "" + activeCount);
		if (activeCount < MAX_COUNT) {
			int rem = MAX_COUNT - activeCount;
			try {
				retryFailedChunks(rem);
			} catch (IOException e) {
				Logger.log(e);
			}
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,updateStatus,,68,1066,907,7,0.0618,0.0458,0.4,20,16,0,1,"private void updateStatus() {
		try {
			long now = System.currentTimeMillis();
			if (this.eta == null) {
				this.eta = ""---"";
			}
			if (converting) {
				progress = this.convertPrg;
			} else if (assembling) {
				long len = length > 0 ? length : downloaded;
				progress = (int) ((totalAssembled * 100) / len);
			} else {
				long downloaded2 = 0;
				int processedSegments = 0;
				int partPrg = 0;
				downloadSpeed = 0;
				for (int i = 0; i < chunks.size(); i++) {
					Segment s = chunks.get(i);
					downloaded2 += s.getDownloaded();
					downloadSpeed += s.getTransferRate();
					if (s.isFinished()) {
						processedSegments++;
					} else if (s.getDownloaded() > 0 && s.getLength() > 0) {
						int prg2 = (int) ((s.getDownloaded() * 100) / s.getLength());
						partPrg += prg2;
					}
				}
				this.downloaded = downloaded2;
				if (chunks.size() > 0) {
					progress = (int) ((processedSegments * 100) / chunks.size());
					progress += (partPrg / chunks.size());
					if (segDet == null) {
						segDet = new SegmentDetails();
						if (segDet.getCapacity() < chunks.size()) {
							segDet.extend(chunks.size() - segDet.getCapacity());
						}
						segDet.setChunkCount(chunks.size());
					}
					SegmentInfo info = segDet.getChunkUpdates().get(0);
					info.setDownloaded(progress);
					info.setLength(100);
					info.setStart(0);
					long diff = downloaded - lastDownloaded;
					long timeSpend = now - prevTime;
					if (timeSpend > 0) {
						float rate = ((float) diff / timeSpend) * 1000;
						if (rate > downloadSpeed) {
							downloadSpeed = rate;
						}

						int prgDiff = progress - lastProgress;
						if (prgDiff > 0) {
							long eta = (timeSpend * (100 - progress) / 1000 * prgDiff);// prgDiff
							lastProgress = progress;
							this.eta = FormatUtilities.hms((int) eta);
						}

						prevTime = now;
						lastDownloaded = downloaded;
					}
				}
			}

			listener.downloadUpdated(id);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,stop,,14,42,39,7,0.1571,0.0476,1,3,3,0,1,"@Override
	public void stop() {
		stopFlag = true;
		saveState();
		for (int i = 0; i < chunks.size(); i++) {
			chunks.get(i).stop();
		}
		if (this.ffmpeg != null) {
			this.ffmpeg.stop();
		}

		listener.downloadStopped(id);
		listener = null;
	}"
xdman,xdman.downloaders.hds.HdsDownloader,resume,,27,160,149,13,0.0766,0.0567,1,7,4,0,1,"@Override
	public void resume() {
		try {
			stopFlag = false;
			Logger.log(""Resuming"");
			if (!restoreState()) {
				Logger.log(""Starting from beginning"");
				start();
				return;
			}
			Logger.log(""Restore success"");
			this.lastDownloaded = downloaded;
			this.lastProgress = this.progress;
			this.prevTime = System.currentTimeMillis();
			if (allFinished()) {
				assembleAsync();
			} else {
				Logger.log(""Starting"");
				start();
			}
		} catch (Exception e) {
			Logger.log(e);
			this.errorCode = XDMConstants.RESUME_FAILED;
			listener.downloadFailed(this.id);
			return;
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,saveState,,41,341,186,3,0.099,0.1393,0.428571429,12,7,0,1,"private void saveState() {
		if (chunks.size() < 0)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(this.length + ""\n"");
		sb.append(downloaded + ""\n"");
		sb.append(((long) this.totalDuration) + ""\n"");
		sb.append(urlList.size() + ""\n"");
		for (int i = 0; i < urlList.size(); i++) {
			String url = urlList.get(i);
			sb.append(url + ""\n"");
		}
		sb.append(chunks.size() + ""\n"");
		for (int i = 0; i < chunks.size(); i++) {
			Segment seg = chunks.get(i);
			sb.append(seg.getId() + ""\n"");
			if (seg.isFinished()) {
				sb.append(seg.getLength() + ""\n"");
				sb.append(seg.getStartOffset() + ""\n"");
				sb.append(seg.getDownloaded() + ""\n"");
			} else {
				sb.append(""-1\n"");
				sb.append(seg.getStartOffset() + ""\n"");
				sb.append(seg.getDownloaded() + ""\n"");
			}
		}
		if (!StringUtils.isNullOrEmptyOrBlank(lastModified)) {
			sb.append(this.lastModified + ""\n"");
		}
		try {
			File tmp = new File(folder, System.currentTimeMillis() + "".tmp"");
			File out = new File(folder, ""state.txt"");
			FileOutputStream fs = new FileOutputStream(tmp);
			fs.write(sb.toString().getBytes());
			fs.close();
			out.delete();
			tmp.renameTo(out);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,restoreState,,47,391,254,3,0.08,0.0906,0.5,18,8,0,1,"private boolean restoreState() {
		BufferedReader br = null;
		chunks = new ArrayList<Segment>();
		File file = new File(folder, ""state.txt"");
		if (!file.exists()) {
			file = getBackupFile(folder);
			if (file == null) {
				return false;
			}
		}
		try {
			br = new BufferedReader(new FileReader(file));
			this.length = Long.parseLong(br.readLine());
			this.downloaded = Long.parseLong(br.readLine());
			this.totalDuration = Long.parseLong(br.readLine());
			int urlCount = Integer.parseInt(br.readLine());
			for (int i = 0; i < urlCount; i++) {
				String url = br.readLine();
				urlList.add(url);
			}
			int chunkCount = Integer.parseInt(br.readLine());
			for (int i = 0; i < chunkCount; i++) {
				String cid = br.readLine();
				long len = Long.parseLong(br.readLine());
				long off = Long.parseLong(br.readLine());
				long dwn = Long.parseLong(br.readLine());
				Segment seg = new SegmentImpl(folder, cid, off, len, dwn);
				seg.setTag(""HLS"");
				Logger.log(""id: "" + seg.getId() + ""\nlength: "" + seg.getLength() + ""\noffset: "" + seg.getStartOffset()
						+ ""\ndownload: "" + seg.getDownloaded());
				chunks.add(seg);
			}
			this.lastModified = br.readLine();
			return true;
		} catch (Exception e) {
			Logger.log(""Failed to load saved state"");
			Logger.log(e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
				}
			}
		}
		return false;
	}"
xdman,xdman.downloaders.hds.HdsDownloader,findExtension,,17,53,28,4,0.2308,0.1563,0.75,4,6,0,1,"private String findExtension(String urlStr) {
		String newExtension = null;
		String fileName = XDMUtils.getFileName(urlStr);
		if (!StringUtils.isNullOrEmptyOrBlank(fileName)) {
			String ext = XDMUtils.getExtension(fileName);
			if ((!StringUtils.isNullOrEmptyOrBlank(ext)) && ext.length() > 1) {
				if (!ext.toLowerCase().contains(""ts"")) {
					newExtension = ext;
					if (newExtension.contains(""m4s"")) {
						Logger.log(""HLS extension: MP4"");
						newExtension = "".mp4"";
					}
				}
			}
		}
		return newExtension;
	}"
xdman,xdman.downloaders.hds.HdsDownloader,assemble,,76,1108,991,10,0.0513,0.0434,0.75,16,16,1,1,"private void assemble() throws IOException {
		InputStream in = null;
		OutputStream out = null;
		totalAssembled = 0L;
		assembling = true;
		assembleFinished = false;

		File outFile = new File(outputFormat == 0 ? getOutputFolder() : folder, getOutputFileName(true));

		try {
			if (stopFlag)
				return;
			Logger.log(""assembling... "");
			out = new FileOutputStream(outFile);
			out.write(flv_sig);
			for (Segment s : chunks) {
				File inFile = new File(folder, s.getId());
				in = new FileInputStream(inFile);
				long streamPos = 0, streamLen = inFile.length();
				while (streamPos < streamLen) {
					if (stopFlag) {
						return;
					}

					long boxsize = readInt32(in);
					streamPos += 4;
					String box_type = readStringBytes(in, 4);
					streamPos += 4;
					if (boxsize == 1) {
						boxsize = readInt64(in) - 16;
						streamPos += 8;
					} else {
						boxsize -= 8;
					}
					if (box_type.equals(""mdat"")) {
						long boxsz = boxsize;
						while (boxsz > 0) {
							if (stopFlag)
								return;
							int c = (int) (boxsz > b.length ? b.length : boxsz);
							int x = in.read(b, 0, c);
							if (x == -1)
								throw new IOException(""Unexpected EOF"");
							out.write(b, 0, x);
							boxsz -= x;
							totalAssembled += x;
							long now = System.currentTimeMillis();
							if (now - lastUpdated > 1000) {
								updateStatus();
								lastUpdated = now;
							}
						}
					} else {
						in.skip(boxsize);
					}

					streamPos += boxsize;
				}
				in.close();
			}

			Logger.log(""Output format: "" + outputFormat);
			assembleFinished = true;
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				out.close();
			} catch (Exception e2) {
			}
			try {
				in.close();
			} catch (Exception e2) {
			}
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,copyBytes,,12,20,12,3,0.2321,0.0975,0,5,5,0,1,"private void copyBytes(InputStream src, OutputStream dest, long len) throws IOException {
		while (len > 0) {
			if (stopFlag)
				return;
			int c = (int) (len > b.length ? b.length : len);
			int x = src.read(b, 0, c);
			if (x == -1)
				throw new IOException(""Unexpected EOF"");
			dest.write(b, 0, x);
			len -= x;
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,progress,,9,18,15,5,0.2143,0.1111,0,3,2,0,1,"@Override
	public void progress(int progress) {
		this.convertPrg = progress;
		long now = System.currentTimeMillis();
		if (now - lastUpdated > 1000) {
			updateStatus();
			lastUpdated = now;
		}
	}"
xdman,xdman.downloaders.hds.HdsDownloader,readInt32,,10,27,18,4,0.2444,0.101,0,5,2,0,1,"private long readInt32(InputStream s) throws IOException {
		byte[] bytesData = new byte[4];
		if (s.read(bytesData, 0, bytesData.length) != bytesData.length) {
			throw new IOException(""Invalid F4F box"");
		}
		long iValLo = (long) ((bytesData[3] & 0xff) + ((long) (bytesData[2] & 0xff) * 256));
		long iValHi = (long) ((bytesData[1] & 0xff) + ((long) (bytesData[0] & 0xff) * 256));
		long iVal = iValLo + (iValHi * 65536);
		return iVal;
	}"
xdman,xdman.downloaders.hds.HdsDownloader,readStringBytes,,7,12,9,4,0.25,0.1429,0,4,2,0,1,"private String readStringBytes(InputStream s, long len) throws IOException {
		StringBuilder resultValue = new StringBuilder(4);
		for (int i = 0; i < len; i++) {
			resultValue.append((char) s.read());
		}
		return resultValue.toString();
	}"
xdman,xdman.downloaders.hls.HlsDownloader,start,,19,94,68,7,0.1146,0.1312,0.5,5,2,0,1,"public void start() {
		Logger.log(""creating folder "" + folder);
		new File(folder).mkdirs();

		this.lastDownloaded = downloaded;
		this.prevTime = System.currentTimeMillis();
		try {
			manifestSegment = new SegmentImpl(this, folder);
			manifestSegment.setTag(""MF"");
			manifestSegment.setLength(-1);
			manifestSegment.setStartOffset(0);
			manifestSegment.setDownloaded(0);
			manifestSegment.setTag(""HLS"");
			manifestSegment.download(this);
		} catch (IOException e) {
			this.errorCode = XDMConstants.RESUME_FAILED;
			this.listener.downloadFailed(id);
		}
	}"
xdman,xdman.downloaders.hls.HlsDownloader,chunkComplete,,51,313,248,11,0.1179,0.0934,0.4,9,10,0,1,"@Override
	public boolean chunkComplete(String id) {
		if (finished) {
			return true;
		}

		if (stopFlag) {
			return true;
		}
		if (id.equals(manifestSegment.getId())) {
			if (initOrUpdateSegments()) {
				listener.downloadConfirmed(this.id);
			} else {
				if (!stopFlag) {
					this.errorCode = XDMConstants.ERR_INVALID_RESP;
					listener.downloadFailed(this.id);
					return true;
				}
			}
		} else {
			Segment s = getById(id);
			if (s.getLength() < 0) {
				s.setLength(s.getDownloaded());
			}

			if (allFinished()) {
				saveState();
				finished = true;
				updateStatus();
				try {
					assembleFinished = false;
					assemble();
					Logger.log(""********Download finished*********"");
					updateStatus();
					assembleFinished = true;
					listener.downloadFinished(this.id);
				} catch (Exception e) {
					if (!stopFlag) {
						Logger.log(e);
						this.errorCode = XDMConstants.ERR_ASM_FAILED;
						listener.downloadFailed(this.id);
					}
				}
				listener = null;
				return true;
			}
		}

		processSegments();
		return true;
	}"
xdman,xdman.downloaders.hls.HlsDownloader,chunkUpdated,,19,68,58,9,0.1795,0.1267,0,2,4,0,1,"@Override
	public void chunkUpdated(String id) {
		if (stopFlag)
			return;
		long now = System.currentTimeMillis();
		if (now - lastSaved > 5000) {
			synchronized (this) {
				saveState();
			}
			lastSaved = now;
		}
		if (now - lastUpdated > 1000) {
			updateStatus();
			lastUpdated = now;
			synchronized (this) {
				processSegments();
			}
		}
	}"
xdman,xdman.downloaders.hls.HlsDownloader,createChannel,,13,32,19,4,0.225,0.0939,0.571428571,3,3,0,1,"@Override
	public AbstractChannel createChannel(Segment segment) {
		for (int i = 0; i < chunks.size(); i++) {
			if (segment == chunks.get(i)) {
				HlsMetadata md = new HlsMetadata();
				md.setUrl(urlList.get(i));
				md.setHeaders(metadata.getHeaders());
				return new HttpChannel(segment, md.getUrl(), md.getHeaders(), -1, isJavaClientRequired);
			}
		}
		Logger.log(""Create manifest channel"");
		return new HttpChannel(segment, metadata.getUrl(), metadata.getHeaders(), -1, isJavaClientRequired);
	}"
xdman,xdman.downloaders.hls.HlsDownloader,initOrUpdateSegments,,52,316,226,2,0.1034,0.0927,0.6,9,11,0,1,"private boolean initOrUpdateSegments() {
		try {
			M3U8Manifest mf = new M3U8Manifest(new File(folder, manifestSegment.getId()).getAbsolutePath(),
					metadata.getUrl());
			this.totalDuration = mf.getDuration();
			Logger.log(""Total duration"");
			ArrayList<String> urls = mf.getMediaUrls();
			if (urls.size() < 1) {
				Logger.log(""Manifest contains no media"");
				return false;
			}
			if (urlList.size() > 0 && urlList.size() != urls.size()) {
				Logger.log(""Manifest media count mismatch- expected: "" + urlList.size() + "" got: "" + urls.size());
				return false;
			}
			if (urlList.size() > 0) {
				urlList.clear();
			}
			urlList.addAll(urls);

			String newExtension = null;

			if (chunks.size() < 1) {
				for (int i = 0; i < urlList.size(); i++) {
					if (newExtension == null && outputFormat == 0) {
						newExtension = findExtension(urlList.get(i));
						Logger.log(""HLS: found new extension: "" + newExtension);
						if (newExtension != null) {
							this.newFileName = getOutputFileName(true).replace("".ts"", newExtension);

						} else {
							newExtension = "".ts"";// just to skip the whole file
													// ext extraction
						}
					}

					Logger.log(""HLS: Newfile name: "" + this.newFileName);

					Segment s2 = new SegmentImpl(this, folder);
					s2.setTag(""HLS"");
					s2.setLength(-1);
					Logger.log(""Adding chunk: "" + s2);
					chunks.add(s2);
				}
			}
			return true;
		} catch (Exception e) {
			Logger.log(e);
			return false;
		}

	}"
xdman,xdman.downloaders.hls.HlsDownloader,processSegments,,12,27,18,3,0.2444,0.1167,0.666666667,3,3,0,1,"private synchronized void processSegments() {
		int activeCount = getActiveChunkCount();
		Logger.log(""active: "" + activeCount);
		if (activeCount < MAX_COUNT) {
			int rem = MAX_COUNT - activeCount;
			try {
				retryFailedChunks(rem);
			} catch (IOException e) {
				Logger.log(e);
			}
		}
	}"
xdman,xdman.downloaders.hls.HlsDownloader,updateStatus,,68,1066,907,7,0.0618,0.0458,0.4,20,16,1,1,"private void updateStatus() {
		try {
			long now = System.currentTimeMillis();
			if (this.eta == null) {
				this.eta = ""---"";
			}
			if (converting) {
				progress = this.convertPrg;
			} else if (assembling) {
				long len = length > 0 ? length : downloaded;
				progress = (int) ((totalAssembled * 100) / len);
			} else {
				long downloaded2 = 0;
				int processedSegments = 0;
				int partPrg = 0;
				downloadSpeed = 0;
				for (int i = 0; i < chunks.size(); i++) {
					Segment s = chunks.get(i);
					downloaded2 += s.getDownloaded();
					downloadSpeed += s.getTransferRate();
					if (s.isFinished()) {
						processedSegments++;
					} else if (s.getDownloaded() > 0 && s.getLength() > 0) {
						int prg2 = (int) ((s.getDownloaded() * 100) / s.getLength());
						partPrg += prg2;
					}
				}
				this.downloaded = downloaded2;
				if (chunks.size() > 0) {
					progress = (int) ((processedSegments * 100) / chunks.size());
					progress += (partPrg / chunks.size());
					if (segDet == null) {
						segDet = new SegmentDetails();
						if (segDet.getCapacity() < chunks.size()) {
							segDet.extend(chunks.size() - segDet.getCapacity());
						}
						segDet.setChunkCount(chunks.size());
					}
					SegmentInfo info = segDet.getChunkUpdates().get(0);
					info.setDownloaded(progress);
					info.setLength(100);
					info.setStart(0);
					long diff = downloaded - lastDownloaded;
					long timeSpend = now - prevTime;
					if (timeSpend > 0) {
						float rate = ((float) diff / timeSpend) * 1000;
						if (rate > downloadSpeed) {
							downloadSpeed = rate;
						}

						int prgDiff = progress - lastProgress;
						if (prgDiff > 0) {
							long eta = (timeSpend * (100 - progress) / 1000 * prgDiff);// prgDiff
							lastProgress = progress;
							this.eta = FormatUtilities.hms((int) eta);
						}

						prevTime = now;
						lastDownloaded = downloaded;
					}
				}
			}

			listener.downloadUpdated(id);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.hls.HlsDownloader,stop,,14,42,39,7,0.1571,0.0476,1,3,3,0,1,"@Override
	public void stop() {
		stopFlag = true;
		saveState();
		for (int i = 0; i < chunks.size(); i++) {
			chunks.get(i).stop();
		}
		if (this.ffmpeg != null) {
			this.ffmpeg.stop();
		}

		listener.downloadStopped(id);
		listener = null;
	}"
xdman,xdman.downloaders.hls.HlsDownloader,resume,,27,160,149,13,0.0766,0.0567,1,7,4,0,1,"@Override
	public void resume() {
		try {
			stopFlag = false;
			Logger.log(""Resuming"");
			if (!restoreState()) {
				Logger.log(""Starting from beginning"");
				start();
				return;
			}
			Logger.log(""Restore success"");
			this.lastDownloaded = downloaded;
			this.lastProgress = this.progress;
			this.prevTime = System.currentTimeMillis();
			if (allFinished()) {
				assembleAsync();
			} else {
				Logger.log(""Starting"");
				start();
			}
		} catch (Exception e) {
			Logger.log(e);
			this.errorCode = XDMConstants.RESUME_FAILED;
			listener.downloadFailed(this.id);
			return;
		}
	}"
xdman,xdman.downloaders.hls.HlsDownloader,saveState,,41,341,186,3,0.099,0.1393,0.428571429,12,7,0,1,"private void saveState() {
		if (chunks.size() < 0)
			return;
		StringBuffer sb = new StringBuffer();
		sb.append(this.length + ""\n"");
		sb.append(downloaded + ""\n"");
		sb.append(((long) this.totalDuration) + ""\n"");
		sb.append(urlList.size() + ""\n"");
		for (int i = 0; i < urlList.size(); i++) {
			String url = urlList.get(i);
			sb.append(url + ""\n"");
		}
		sb.append(chunks.size() + ""\n"");
		for (int i = 0; i < chunks.size(); i++) {
			Segment seg = chunks.get(i);
			sb.append(seg.getId() + ""\n"");
			if (seg.isFinished()) {
				sb.append(seg.getLength() + ""\n"");
				sb.append(seg.getStartOffset() + ""\n"");
				sb.append(seg.getDownloaded() + ""\n"");
			} else {
				sb.append(""-1\n"");
				sb.append(seg.getStartOffset() + ""\n"");
				sb.append(seg.getDownloaded() + ""\n"");
			}
		}
		if (!StringUtils.isNullOrEmptyOrBlank(lastModified)) {
			sb.append(this.lastModified + ""\n"");
		}
		try {
			File tmp = new File(folder, System.currentTimeMillis() + "".tmp"");
			File out = new File(folder, ""state.txt"");
			FileOutputStream fs = new FileOutputStream(tmp);
			fs.write(sb.toString().getBytes());
			fs.close();
			out.delete();
			tmp.renameTo(out);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.downloaders.hls.HlsDownloader,restoreState,,47,391,254,3,0.08,0.0906,0.5,18,8,0,1,"private boolean restoreState() {
		BufferedReader br = null;
		chunks = new ArrayList<Segment>();
		File file = new File(folder, ""state.txt"");
		if (!file.exists()) {
			file = getBackupFile(folder);
			if (file == null) {
				return false;
			}
		}
		try {
			br = new BufferedReader(new FileReader(file));
			this.length = Long.parseLong(br.readLine());
			this.downloaded = Long.parseLong(br.readLine());
			this.totalDuration = Long.parseLong(br.readLine());
			int urlCount = Integer.parseInt(br.readLine());
			for (int i = 0; i < urlCount; i++) {
				String url = br.readLine();
				urlList.add(url);
			}
			int chunkCount = Integer.parseInt(br.readLine());
			for (int i = 0; i < chunkCount; i++) {
				String cid = br.readLine();
				long len = Long.parseLong(br.readLine());
				long off = Long.parseLong(br.readLine());
				long dwn = Long.parseLong(br.readLine());
				Segment seg = new SegmentImpl(folder, cid, off, len, dwn);
				seg.setTag(""HLS"");
				Logger.log(""id: "" + seg.getId() + ""\nlength: "" + seg.getLength() + ""\noffset: "" + seg.getStartOffset()
						+ ""\ndownload: "" + seg.getDownloaded());
				chunks.add(seg);
			}
			this.lastModified = br.readLine();
			return true;
		} catch (Exception e) {
			Logger.log(""Failed to load saved state"");
			Logger.log(e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
				}
			}
		}
		return false;
	}"
xdman,xdman.downloaders.hls.HlsDownloader,findExtension,,17,53,28,4,0.2308,0.1563,0.75,4,6,0,1,"private String findExtension(String urlStr) {
		String newExtension = null;
		String fileName = XDMUtils.getFileName(urlStr);
		if (!StringUtils.isNullOrEmptyOrBlank(fileName)) {
			String ext = XDMUtils.getExtension(fileName);
			if ((!StringUtils.isNullOrEmptyOrBlank(ext)) && ext.length() > 1) {
				if (!ext.toLowerCase().contains(""ts"")) {
					newExtension = ext;
					if (newExtension.contains(""m4s"")) {
						Logger.log(""HLS extension: MP4"");
						newExtension = "".mp4"";
					}
				}
			}
		}
		return newExtension;
	}"
xdman,xdman.downloaders.hls.HlsDownloader,assemble,,38,264,228,6,0.0821,0.0513,0.555555556,12,6,0,1,"private void assemble() throws IOException {
		StringBuffer sb = new StringBuffer();
		for (Segment s : chunks) {
			sb.append(""file '"" + new File(folder, s.getId()) + ""'\r\n"");
		}
		OutputStream outFile = null;
		File hlsFile = new File(folder, id + ""-hls.txt"");

		try {
			outFile = new FileOutputStream(hlsFile);
			outFile.write(sb.toString().getBytes());
			outFile.close();
		} catch (Exception e) {
			try {
				outFile.close();
			} catch (Exception e2) {
			}
		}
		this.converting = true;
		List<String> inputFiles = new ArrayList<String>();
		inputFiles.add(hlsFile.getAbsolutePath());
		this.ffmpeg = new FFmpeg(inputFiles, new File(getOutputFolder(), getOutputFileName(true)).getAbsolutePath(),
				this, MediaFormats.getSupportedFormats()[outputFormat], outputFormat == 0);
		ffmpeg.setHls(true);
		ffmpeg.setHLSDuration(totalDuration);
		int ret = ffmpeg.convert();
		Logger.log(""FFmpeg exit code: "" + ret);

		if (ret != 0) {
			throw new IOException(""FFmpeg failed"");
		} else {
			long length = new File(getOutputFolder(), getOutputFileName(false)).length();
			if (length > 0) {
				this.length = length;
			}
		}

	}"
xdman,xdman.downloaders.hls.HlsDownloader,progress,,9,18,15,5,0.2143,0.1111,0,3,2,0,1,"@Override
	public void progress(int progress) {
		this.convertPrg = progress;
		long now = System.currentTimeMillis();
		if (now - lastUpdated > 1000) {
			updateStatus();
			lastUpdated = now;
		}
	}"
xdman,xdman.downloaders.http.HttpDownloader,chunkConfirmed,,36,253,155,3,0.1282,0.128,0.545454545,10,10,0,1,"@Override
	protected void chunkConfirmed(Segment c) {
		HttpChannel hc = (HttpChannel) c.getChannel();
		this.isJavaClientRequired = hc.isJavaClientRequired();
		super.getLastModifiedDate(c);
		if (hc.isRedirected()) {
			metadata.setUrl(hc.getRedirectUrl());
			metadata.save();
			if (outputFormat == 0) {
				newFileName = XDMUtils.getFileName(metadata.getUrl());
				Logger.log(""set new filename: "" + newFileName);
				Logger.log(""new file name: "" + newFileName);
			}
		}
		String contentDispositionHeader = hc.getHeader(""content-disposition"");
		if (contentDispositionHeader != null) {
			if (outputFormat == 0) {
				String name = NetUtils.getNameFromContentDisposition(contentDispositionHeader);
				if (name != null) {
					this.newFileName = name;
					Logger.log(""set new filename: "" + newFileName);
				}
			}
		}
		if ((hc.getHeader(""content-type"") + """").contains(""/html"")) {
			if (this.newFileName != null) {
				String upperStr = this.newFileName.toUpperCase();
				if (!(upperStr.endsWith("".HTML"") || upperStr.endsWith("".HTM""))) {
					outputFormat = 0;
					this.newFileName += "".html"";
					Logger.log(""set new filename: "" + newFileName);
				}
			}
		}
		Logger.log(""new filename: "" + newFileName);
	}"
xdman,xdman.downloaders.http.HttpChannel,connectImpl,,223,7400,6672,13,0.0382,0.0422,0.416666667,22,51,0,1,"@Override
	protected boolean connectImpl() {
		int sleepInterval = 0;
		boolean isRedirect = false;
		if (stop) {
			closeImpl();
			return false;
		}

		if (!""HLS"".equals(chunk.getTag())) {
			if (chunk.getLength() < 0 && chunk.getDownloaded() > 0) {
				errorCode = XDMConstants.ERR_NO_RESUME;
				closeImpl();
				Logger.log(""server does not support resuming"");
				return false;
			}
			try {
				chunk.reopenStream();
			} catch (IOException e) {
				Logger.log(e);
				closeImpl();
				errorCode = XDMConstants.ERR_NO_RESUME;
				return false;
			}
		} else {
			try {
				chunk.reopenStream();
				chunk.resetStream();
				chunk.setDownloaded(0);
			} catch (IOException e) {
				Logger.log(""Stream rest failed"");
				Logger.log(e);
			}
		}
		while (!stop) {
			isRedirect = false;
			try {
				Logger.log(""Connecting to: "" + url + "" "" + chunk.getTag());
				WebProxy wp = ProxyResolver.resolve(url);
				if (wp != null) {
					javaClientRequired = true;
				}

				if (javaClientRequired) {
					hc = new JavaHttpClient(url);
				} else {
					// this.socketDataRemaining = -1;
					hc = new XDMHttpClient(url);
				}

				if (headers != null) {
					Iterator<HttpHeader> headerIt = headers.getAll();
					while (headerIt.hasNext()) {
						HttpHeader header = headerIt.next();
						hc.setHeader(header.getName(), header.getValue());
					}
				}

				long length = chunk.getLength();

				// hc.setHeader(""user-agent"", ""Mozilla/5.0 (Windows NT 10.0;
				// rv:51.0) Gecko/20100101 Firefox/51.0"");

				long startOff = chunk.getStartOffset() + chunk.getDownloaded();

				long endOff = startOff + length - chunk.getDownloaded();

				long expectedLength = endOff - startOff;

				if (length > 0 && expectedLength > 0) {
					Logger.log(chunk + "" requesting:- "" + ""Range:"" + ""bytes="" + startOff + ""-"" + (endOff - 1));
					hc.setHeader(""Range"", ""bytes="" + startOff + ""-"" + (endOff - 1));
				} else {
					hc.setHeader(""Range"", ""bytes=0-"");
				}

				hc.connect();

				if (stop) {
					closeImpl();
					return false;
				}

				int code = hc.getStatusCode();

				Logger.log(chunk + "": "" + code);

				if (code >= 300 && code < 400) {
					closeImpl();
					if (totalLength > 0) {
						errorCode = XDMConstants.ERR_INVALID_RESP;
						Logger.log(chunk + "" Redirecting twice"");
						return false;
					} else {
						url = hc.getResponseHeader(""location"");
						Logger.log(chunk + "" location: "" + url);
						if (!url.startsWith(""http"")) {
							if (!url.startsWith(""/"")) {
								url = ""/"" + url;
							}
							url = ""http://"" + hc.getHost() + url;
						}
						url = url.replace("" "", ""%20"");
						isRedirect = true;
						redirected = true;
						redirectUrl = url;
						throw new Exception(""Redirecting to: "" + url);
					}
				}

				if (code != 200 && code != 206 && code != 416 && code != 413 && code != 401 && code != 408
						&& code != 407 && code != 503) {
					errorCode = XDMConstants.ERR_INVALID_RESP;
					closeImpl();
					return false;
				}

				if (code == 407 || code == 401) {
					if (javaClientRequired) {
						Logger.log(""asking for password"");
						boolean proxy = code == 407;
						if (!chunk.promptCredential(hc.getHost(), proxy)) {
							errorCode = XDMConstants.ERR_INVALID_RESP;
							closeImpl();
							return false;
						}
					}
					throw new JavaClientRequiredException();
				}

				if (""T1"".equals(chunk.getTag()) || ""T2"".equals(chunk.getTag())) {
					if (""text/plain"".equals(hc.getResponseHeader(""content-type""))) {
						ByteArrayOutputStream bout = new ByteArrayOutputStream();
						InputStream inStr = hc.getInputStream();
						System.out.println(inStr);
						long len = hc.getContentLength();
						int read = 0;
						System.out.println(""reading url of length: "" + len);
						while (true) {
							if (len > 0 && read == len)
								break;
							int x = inStr.read();
							if (x == -1) {
								if (len > 0) {
									throw new IOException(""Unable to read url: unexpected EOF"");
								} else {
									break;
								}
							}
							read++;
							System.out.print((char) x);
							bout.write(x);
						}
						byte[] buf = bout.toByteArray();
						url = new String(buf, Charset.forName(""ASCII""));
						isRedirect = true;
						throw new Exception(""Youtube text redirect to: "" + url);
					}
				}

				if (((chunk.getDownloaded() + chunk.getStartOffset()) > 0) && code != 206) {
					closeImpl();
					errorCode = XDMConstants.ERR_NO_RESUME;
					return false;
				}

				// first length will be used if this is the first thread
				// otherwise its value will be lost
				if (""HLS"".equals(chunk.getTag())) {
					firstLength = -1;
				} else {
					firstLength = hc.getContentLength();
				}
				// this.socketDataRemaining = firstLength;
				// we should check content range header instead of this
				if (length > 0) {
					if (firstLength != expectedLength)
					// if (chunk.getStartOffset() + chunk.getDownloaded()
					// + firstLength != totalLength)
					{
						Logger.log(chunk + "" length mismatch: expected: "" + expectedLength + "" got: "" + firstLength);
						errorCode = XDMConstants.ERR_NO_RESUME;
						closeImpl();
						return false;
					}
				}
				if (hc.getContentLength() > 0 && XDMUtils.getFreeSpace(null) < hc.getContentLength()) {
					Logger.log(""Disk is full"");
					errorCode = XDMConstants.DISK_FAIURE;
					closeImpl();
					return false;
				}

				in = hc.getInputStream();
				Logger.log(""Connection success"");
				return true;

			} catch (JavaClientRequiredException e) {
				Logger.log(""java client required"");
				javaClientRequired = true;
				sleepInterval = 0;
			} catch (Exception e) {
				Logger.log(chunk);
				Logger.log(e);
				if (isRedirect) {
					closeImpl();
					continue;
				}
				sleepInterval = 5000;
			}

			closeImpl();

			try {
				Thread.sleep(sleepInterval);
			} catch (Exception e) {
			}
		}

		Logger.log(""return as "" + errorCode);

		return false;
	}"
xdman,xdman.downloaders.metadata.HttpMetadata,load,,98,1477,1001,3,0.0645,0.1009,0.5,16,25,1,1,"// public void load(BufferedReader br) throws IOException {
	// url = br.readLine();
	// headers = new HeaderCollection();
	// while (true) {
	// String ln = br.readLine();
	// if (ln == null)
	// break;
	// HttpHeader header = HttpHeader.parse(ln);
	// if (header != null) {
	// headers.addHeader(header);
	// }
	// }
	// }

	public static HttpMetadata load(String id) {
		Logger.log(""loading metadata: ""+id);
		BufferedReader br = null;
		HttpMetadata metadata = null;
		int type;
		try {
			br = new BufferedReader(new FileReader(new File(Config.getInstance().getMetadataFolder(), id)));
			String ln = br.readLine();
			if (ln == null) {
				Logger.log(""invalid metadata, file is empty"");
				return null;
			}
			int index = ln.indexOf("":"");
			if (index < 0) {
				Logger.log(""invalid metadata file starting with: "" + ln);
				return null;
			}
			String key = ln.substring(0, index).trim().toLowerCase();
			String val = ln.substring(index + 1).trim();
			if (key.equals(""type"")) {
				type = Integer.parseInt(val);
				if (type == XDMConstants.HTTP) {
					metadata = new HttpMetadata(id);
				} else if (type == XDMConstants.HLS) {
					metadata = new HlsMetadata(id);
				} else if (type == XDMConstants.HDS) {
					metadata = new HdsMetadata(id);
				} else if (type == XDMConstants.DASH) {
					metadata = new DashMetadata(id);
				}
			} else {
				Logger.log(""invalid metadata file starting with: "" + ln);
				return null;
			}
			while (true) {
				ln = br.readLine();
				if (ln == null)
					break;
				index = ln.indexOf("":"");
				if (index < 0)
					continue;
				key = ln.substring(0, index).trim().toLowerCase();
				val = ln.substring(index + 1).trim();
				if (key.equals(""url"")) {
					metadata.setUrl(val);
				}
				if (key.equals(""size"")) {
					metadata.setSize(Long.parseLong(val));
				}
				if (key.equals(""header"")) {
					int index2 = val.indexOf("":"");
					if (index2 < 0) {
						continue;
					}
					String key1 = val.substring(0, index2).trim();
					String val1 = val.substring(index2 + 1).trim();
					metadata.headers.addHeader(key1, val1);
				}
				if (key.equals(""header2"")) {
					int index2 = val.indexOf("":"");
					if (index2 < 0) {
						continue;
					}
					String key1 = val.substring(0, index2).trim();
					String val1 = val.substring(index2 + 1).trim();
					((DashMetadata) metadata).getHeaders2().addHeader(key1, val1);
				}
				if (key.equals(""url2"")) {
					((DashMetadata) metadata).setUrl2(val);
				}
				if (key.equals(""len1"")) {
					((DashMetadata) metadata).setLen1(Long.parseLong(val));
				}
				if (key.equals(""len2"")) {
					((DashMetadata) metadata).setLen2(Long.parseLong(val));
				}
				if (key.equals(""bitrate"")) {
					((HdsMetadata) metadata).setBitRate(Integer.parseInt(val));
				}
				if (key.equals(""ydlurl"")) {
					Logger.log(""ydurl: ""+val);
					metadata.ydlUrl = val;
				}
			}
			br.close();
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (Exception ex) {
				}
			}
		}
		return metadata;

	}"
xdman,xdman.downloaders.metadata.HttpMetadata,save,,54,594,485,5,0.0748,0.0757,0.583333333,10,13,0,1,"public void save() {
		FileOutputStream fw = null;
		try {
			StringBuilder sb = new StringBuilder();
			if (url == null)
				throw new NullPointerException(""url is null"");
			sb.append(""type: "" + getType() + ""\n"");
			sb.append(""url: "" + url + ""\n"");
			sb.append(""size: "" + size + ""\n"");
			if (headers != null) {
				Iterator<HttpHeader> headerIterator = headers.getAll();
				while (headerIterator.hasNext()) {
					HttpHeader header = headerIterator.next();
					sb.append(""header: "" + header.getName() + "":"" + header.getValue() + ""\n"");
				}
			}
			if (getType() == XDMConstants.HDS) {
				sb.append(""bitrate: "" + ((HdsMetadata) this).getBitRate() + ""\n"");
			}
			if (getType() == XDMConstants.DASH) {
				sb.append(""url2: "" + ((DashMetadata) this).getUrl2() + ""\n"");
				sb.append(""len1: "" + ((DashMetadata) this).getLen1() + ""\n"");
				sb.append(""len2: "" + ((DashMetadata) this).getLen2() + ""\n"");
				if (((DashMetadata) this).getHeaders2() != null) {
					Iterator<HttpHeader> headerIterator = ((DashMetadata) this).getHeaders2().getAll();
					while (headerIterator.hasNext()) {
						HttpHeader header = headerIterator.next();
						sb.append(""header2: "" + header.getName() + "":"" + header.getValue() + ""\n"");
					}
				}

			}
			if (!StringUtils.isNullOrEmptyOrBlank(ydlUrl)) {
				sb.append(""ydlUrl: "" + ydlUrl);
			}

			File metadataFolder = new File(Config.getInstance().getMetadataFolder());
			if (!metadataFolder.exists()) {
				metadataFolder.mkdirs();
			}
			File file = new File(metadataFolder, id);
			fw = new FileOutputStream(file);
			fw.write(sb.toString().getBytes());
			fw.close();
		} catch (Exception e) {
			Logger.log(e);
			if (fw != null) {
				try {
					fw.close();
				} catch (Exception ex) {
				}
			}
		}
	}"
xdman,xdman.downloaders.metadata.manifests.M3U8Manifest,makeMediaUrls,,26,117,63,3,0.1498,0.1116,1,10,8,0,1,"private void makeMediaUrls(ArrayList<String> list) throws Exception {
		String base_url = """";
		URI uri = null;
		for (int i = 0; i < list.size(); i++) {
			String item = list.get(i);
			String item_url = null;
			if (item.startsWith(""/"")) {
				if (StringUtils.isNullOrEmpty(base_url)) {
					if (uri == null) {
						uri = new URI(this.playlistUrl);
					}
					base_url = uri.getScheme() + ""://"" + uri.getHost() + """"
							+ (uri.getPort() > 0 ? "":"" + uri.getPort() : """");
				}
				item_url = base_url + item;
			} else if (item.startsWith(""http://"")
					|| item.startsWith(""https://"")) {
				item_url = item;
			} else {
				int index = this.playlistUrl.lastIndexOf('/');
				item_url = this.playlistUrl.substring(0, index) + ""/"";
				item_url += item;
			}
			mediaUrls.add(item_url);
		}
	}"
xdman,xdman.downloaders.metadata.manifests.M3U8Manifest,parseManifest,,61,592,518,9,0.0662,0.0878,1,12,14,0,1,"private ArrayList<String> parseManifest(String file) throws IOException {
		ArrayList<String> urlList = new ArrayList<String>();
		BufferedReader r = null;
		try {
			r = new BufferedReader(new InputStreamReader(new FileInputStream(
					file)));
			boolean expect = false;
			while (true) {
				String line = r.readLine();
				if (line == null)
					break;
				String highline = line.toUpperCase().trim();
				if (highline.length() < 1)
					continue;

				if (highline.startsWith(""#EXT-X-KEY"")) {
					encrypted = true;
					break;
				}
				if (expect) {
					urlList.add(line.trim());
					expect = false;
				}
				if (highline.startsWith(""#EXT-X-STREAM-INF"")) {
					masterPlaylist = true;
					expect = true;
					String[] arr = highline.split("":"");
					if (arr.length > 1) {
						mediaProperties.add(M3U8MediaInfo.parse(arr[1].trim()));
					}
				}
				if (highline.startsWith(""#EXTINF"")) {
					masterPlaylist = false;
					expect = true;
					try {
						String[] arr = highline.split("":"");
						if (arr.length > 1) {
							mediaProperties.add(M3U8MediaInfo.parse(arr[1]
									.trim()));
							String str = arr[1].trim().split("","")[0];
							duration += Float.parseFloat(str);
						}
					} catch (Exception e) {
						Logger.log(e);
					}

				}
			}
		} catch (Exception e) {
			Logger.log(e);
			throw new IOException(""Unable to parse menifest"");
		} finally {
			try {
				if (r != null)
					r.close();
			} catch (Exception e) {
			}
		}

		return urlList;
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,parseDoc,,106,2099,1920,9,0.0426,0.033,0.4,27,18,0,1,"private void parseDoc(Document doc, String surl) throws XPathExpressionException {
		if (xpath == null) {
			initXPath();
		}

		baseUrl = xpath.evaluate(""/ns:manifest/ns:baseURL"", doc);
		if (StringUtils.isNullOrEmptyOrBlank(baseUrl)) {
			try {
				URL url = new URL(surl);
				StringBuilder sb = new StringBuilder();
				sb.append(url.getProtocol());
				sb.append(""://"");
				sb.append(url.getHost());
				int port = url.getPort();
				if (port < 1) {
					port = url.getDefaultPort();
				}
				sb.append(port == 80 ? """" : port);
				String path = url.getPath();
				String[] arr = path.split(""/"");
				for (int i = 0; i < arr.length - 1; i++) {
					if (arr[i].length() > 0) {
						sb.append(""/"" + arr[i]);
					}
				}
				baseUrl = sb.toString();
				System.out.println(""*** URL: "" + baseUrl);
			} catch (Exception e) {
			}
		}

		pv = xpath.evaluate(""/ns:manifest/ns:pv-2.0"", doc);

		NodeList mediaNodeList = (NodeList) xpath.evaluate(""/ns:manifest/ns:media"", doc, XPathConstants.NODESET);

		F4MMedia media = null;

		for (int i = 0; i < mediaNodeList.getLength(); i++) {
			Node mediaNode = mediaNodeList.item(i);
			NamedNodeMap attrMap = mediaNode.getAttributes();
			Node bitRateAttr = attrMap.getNamedItem(""bitrate"");
			long bitRate = 0;
			if (bitRateAttr != null) {
				bitRate = Long.parseLong(bitRateAttr.getNodeValue());
			}
			boolean mediaFound = false;
			if (this.selectedBitRate > 0) {
				if (this.selectedBitRate == bitRate) {
					mediaFound = true;
				}
			} else {
				mediaFound = true;
			}

			if (mediaFound) {
				media = new F4MMedia();
				media.setBaseUrl(baseUrl);
				media.setBitRate(bitRate);
				media.setUrl(attrMap.getNamedItem(""url"").getNodeValue());
				Node bootstrapInfoIdNode = attrMap.getNamedItem(""bootstrapInfoId"");

				String bootstrapInfoStr = null;

				if (bootstrapInfoIdNode != null) {
					String bootstrapInfoId = bootstrapInfoIdNode.getNodeValue();
					bootstrapInfoStr = xpath.evaluate(""/ns:manifest/ns:bootstrapInfo[@id='"" + bootstrapInfoId + ""']"",
							doc);
				} else {
					bootstrapInfoStr = xpath.evaluate(""/ns:manifest/ns:bootstrapInfo"", doc);
				}

				media.setBootstrap(Base64.decode(bootstrapInfoStr));
				break;
			}
		}

		if (media == null) {
			Logger.log(""Could not find media"");
			return;
		}

		int pos = 0;

		BufferPointer ptr = new BufferPointer();
		ptr.setBuf(media.getBootstrap());
		ptr.setPos(pos);

		BoxInfo boxInfo = readBoxHeader(ptr);

		pos = ptr.getPos();
		long boxSize = boxInfo.getBoxSize();
		String boxType = boxInfo.getBoxType();

		if (boxType.equals(""abst""))
			parseBootstrapBox(media.bootstrap, pos);
		if (fragsPerSeg == 0)
			fragsPerSeg = fragCount;
		if (live) {
			fromTimestamp = -1;
			Logger.log(""F4M Parser: [Live stream]"");
		} else {
			Logger.log(""F4M Parser: [Not Live stream]"");
		}
		Logger.log(""F4M Parser: Start- "" + start);
		selectedMedia = media;
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,loadDoc,,21,79,67,6,0.1234,0.0713,1,7,4,0,1,"private Document loadDoc(String fileName) {
		FileReader r = null;
		try {
			r = new FileReader(fileName);
			DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
			domFactory.setNamespaceAware(true);
			DocumentBuilder builder = domFactory.newDocumentBuilder();
			Document doc = builder.parse(new InputSource(r));
			return doc;
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			if (r != null) {
				try {
					r.close();
				} catch (Exception ee) {
				}
			}
		}
		return null;
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,parseBootstrapBox,,83,1300,889,8,0.0504,0.0796,0.428571429,29,9,0,1,"private void parseBootstrapBox(byte[] bootstrapInfo, int pos) {
		System.out.println(""parsing abst"");
		live = false;
		isMetadata = true;
		int version = readByte(bootstrapInfo, pos);
		int flags = (int) readInt24(bootstrapInfo, pos + 1);
		int bootstrapVersion = (int) readInt32(bootstrapInfo, pos + 4);
		// Console.WriteLine(""bootstrapVersion: "" + bootstrapVersion);
		int b = readByte(bootstrapInfo, pos + 8);
		int profile = (b & 0xC0) >> 6;
		int update = (b & 0x10) >> 4;
		if (((b & 0x20) >> 5) > 0) {
			live = true;
			isMetadata = false;
		}
		if (update == 0) {
			segTable.clear();
			fragTable.clear();
		}
		int timescale = (int) readInt32(bootstrapInfo, pos + 9);
		long currentMediaTime = readInt64(bootstrapInfo, 13);
		long smpteTimeCodeOffset = readInt64(bootstrapInfo, 21);
		pos += 29;

		BufferPointer bPtr = new BufferPointer();
		bPtr.setBuf(bootstrapInfo);
		bPtr.setPos(pos);

		String movieIdentifier = readString(bPtr);
		Logger.log(""[F4M Parser- movieIdentifier: "" + movieIdentifier);
		pos = bPtr.getPos();

		int serverEntryCount = readByte(bootstrapInfo, pos++);
		bPtr.setPos(pos);

		for (int i = 0; i < serverEntryCount; i++)
			readString(bPtr);

		int qualityEntryCount = readByte(bootstrapInfo, pos++);
		bPtr.setPos(pos);

		for (int i = 0; i < qualityEntryCount; i++)
			readString(bPtr);
		String drmData = readString(bPtr);
		String smetadata = readString(bPtr);
		pos = bPtr.getPos();
		int segRunTableCount = readByte(bootstrapInfo, pos++);

		long boxSize = 0;

		BufferPointer ptr = new BufferPointer();
		ptr.setBuf(bootstrapInfo);

		for (int i = 0; i < segRunTableCount; i++) {
			ptr.setPos(pos);
			String boxType = """";

			BoxInfo boxInfo = readBoxHeader(ptr);
			boxSize = boxInfo.getBoxSize();
			boxType = boxInfo.getBoxType();
			pos = ptr.getPos();

			if (boxType.equals(""asrt""))
				parseAsrtBox(bootstrapInfo, pos);
			pos += boxSize;
		}

		int fragRunTableCount = readByte(bootstrapInfo, pos++);

		for (int i = 0; i < fragRunTableCount; i++) {
			ptr.setPos(pos);
			BoxInfo boxInfo = readBoxHeader(ptr);
			pos = ptr.getPos();
			boxSize = boxInfo.getBoxSize();
			String boxType = boxInfo.getBoxType();
			Logger.log(""555 "" + boxType + "" "" + boxSize);
			if (boxType.equals(""afrt""))
				parseAfrtBox(bootstrapInfo, pos);
			pos += (int) boxSize;
		}

		parseSegAndFragTable();
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,parseSegAndFragTable,,61,423,318,5,0.1212,0.0695,1,8,18,0,1,"private void parseSegAndFragTable() {
		Logger.log(""parseSegAndFragTable called"");
		if ((segTable.size() == 0) || (fragTable.size() == 0)) {
			System.out.println(""return as zero "" + segTable.size() + "" "" + fragTable.size());
			return;
		}
		Segment firstSegment = segTable.get(0);
		Segment lastSegment = segTable.get(segTable.size() - 1);
		Fragment firstFragment = fragTable.get(0);
		Fragment lastFragment = fragTable.get(fragTable.size() - 1);

		// Check if live stream is still live
		if ((lastFragment.fragmentDuration == 0) && (lastFragment.discontinuityIndicator == 0)) {
			live = false;
			if (fragTable.size() > 0)
				fragTable.remove(fragTable.size() - 1);
			if (fragTable.size() > 0)
				lastFragment = fragTable.get(fragTable.size() - 1);
		}

		// Count total fragments by adding all entries in compactly coded
		// segment table
		boolean invalidFragCount = false;
		Segment prev = segTable.get(0);
		fragCount = prev.fragmentsPerSegment;
		for (int i = 0; i < segTable.size(); i++) {
			Segment current = segTable.get(i);
			fragCount += (current.firstSegment - prev.firstSegment - 1) * prev.fragmentsPerSegment;
			fragCount += current.fragmentsPerSegment;
			prev = current;
		}
		if ((fragCount & 0x80000000) == 0)
			fragCount += firstFragment.firstFragment - 1;
		if ((fragCount & 0x80000000) != 0) {
			fragCount = 0;
			invalidFragCount = true;
		}
		if (fragCount < lastFragment.firstFragment)
			fragCount = lastFragment.firstFragment;
		// Console.WriteLine(""fragCount: "" + fragCount.ToString());

		// Determine starting segment and fragment
		if (segStart < 0) {
			if (live)
				segStart = lastSegment.firstSegment;
			else
				segStart = firstSegment.firstSegment;
			if (segStart < 1)
				segStart = 1;
		}
		if (fragStart < 0) {
			if (live && !invalidFragCount)
				fragStart = fragCount - 2;
			else
				fragStart = firstFragment.firstFragment - 1;
			if (fragStart < 0)
				fragStart = 0;
		}
		// Console.WriteLine(""segStart : "" + segStart.ToString());
		// Console.WriteLine(""fragStart: "" + fragStart.ToString());
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,parseAsrtBox,,28,167,81,2,0.1304,0.1298,0.4,11,4,0,1,"private void parseAsrtBox(byte[] asrt, int pos) {
		System.out.println(""parsing asrt"");
		int version = readByte(asrt, (int) pos);
		int flags = (int) readInt24(asrt, pos + 1);
		int qualityEntryCount = readByte(asrt, pos + 4);
		segTable.clear();
		pos += 5;
		BufferPointer bPtr = new BufferPointer();
		for (int i = 0; i < qualityEntryCount; i++) {
			bPtr.setBuf(asrt);
			bPtr.setPos(pos);
			readString(bPtr);
			pos = bPtr.getPos();
		}
		int segCount = (int) readInt32(asrt, pos);
		pos += 4;
		System.out.println(""segcount: "" + segCount);
		for (int i = 0; i < segCount; i++) {
			int firstSegment = (int) readInt32(asrt, pos);
			Segment segEntry = new Segment();
			segEntry.firstSegment = firstSegment;
			segEntry.fragmentsPerSegment = (int) readInt32(asrt, pos + 4);
			if ((segEntry.fragmentsPerSegment & 0x80000000) > 0)
				segEntry.fragmentsPerSegment = 0;
			pos += 8;
			segTable.add(segEntry);
		}
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,parseAfrtBox,,35,231,84,3,0.1037,0.1373,0.4,12,7,0,1,"private void parseAfrtBox(byte[] afrt, int pos) {
		System.out.println(""Parse afrt"");
		fragTable.clear();
		int version = readByte(afrt, pos);
		int flags = (int) readInt24(afrt, pos + 1);
		int timescale = (int) readInt32(afrt, pos + 4);
		int qualityEntryCount = readByte(afrt, pos + 8);
		pos += 9;
		BufferPointer args = new BufferPointer();
		for (int i = 0; i < qualityEntryCount; i++) {
			args.setBuf(afrt);
			args.setPos(pos);
			readString(args);
			pos = args.getPos();
		}
		int fragEntries = (int) readInt32(afrt, pos);
		pos += 4;
		for (int i = 0; i < fragEntries; i++) {
			int firstFragment = (int) readInt32(afrt, pos);
			Fragment fragEntry = new Fragment();
			fragEntry.firstFragment = firstFragment;
			fragEntry.firstFragmentTimestamp = readInt64(afrt, pos + 4);
			fragEntry.fragmentDuration = (int) readInt32(afrt, pos + 12);
			duration += fragEntry.fragmentDuration;
			fragEntry.discontinuityIndicator = 0;
			pos += 16;
			if (fragEntry.fragmentDuration == 0)
				fragEntry.discontinuityIndicator = readByte(afrt, pos++);
			fragTable.add(fragEntry);
			if ((fromTimestamp > 0) && (fragEntry.firstFragmentTimestamp > 0)
					&& (fragEntry.firstFragmentTimestamp < fromTimestamp))
				start = fragEntry.firstFragment + 1;
			// start = i + 1;
		}
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,readBoxHeader,,20,104,55,3,0.2014,0.1365,0.333333333,6,2,0,1,"private BoxInfo readBoxHeader(BufferPointer ptr) {
		int pos = ptr.getPos();
		byte[] bytesData = ptr.getBuf();
		StringBuilder boxType = new StringBuilder();
		long boxSize = 0;
		boxSize = readInt32(bytesData, pos);
		boxType.append(readStringBytes(bytesData, pos + 4, 4));
		if (boxSize == 1) {
			boxSize = readInt64(bytesData, pos + 8) - 16;
			pos += 16;
		} else {
			boxSize -= 8;
			pos += 8;
		}
		ptr.setPos(pos);
		BoxInfo boxInfo = new BoxInfo();
		boxInfo.setBoxSize(boxSize);
		boxInfo.setBoxType(boxType.toString());
		return boxInfo;
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,readStringBytes,,7,11,7,3,0.2667,0.1214,0,5,2,0,1,"private String readStringBytes(byte[] bytesData, int pos, long len) {
		StringBuilder resultValue = new StringBuilder();
		for (int i = 0; i < len; i++) {
			resultValue.append((char) bytesData[pos + i]);
		}
		return resultValue.toString();
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,readString,,13,43,20,3,0.2833,0.1538,0.333333333,5,3,0,1,"private String readString(BufferPointer bufPtr) {
		byte[] bytesData = bufPtr.getBuf();
		int pos = bufPtr.getPos();
		StringBuilder resultValue = new StringBuilder();
		int bytesCount = bytesData.length;
		while ((pos < bytesCount) && (bytesData[pos] != 0)) {
			resultValue.append((char) bytesData[pos]);
			pos++;
		}
		pos++;
		bufPtr.setPos(pos);
		return resultValue.toString();
	}"
xdman,xdman.downloaders.metadata.manifests.F4MManifest,findFragmentInTable,,8,7,4,3,0.35,0.1389,0,3,3,0,1,"private int findFragmentInTable(int needle) {
		for (int i = 0; i < fragTable.size(); i++) {
			if (fragTable.get(i).firstFragment == needle) {
				return i;
			}
		}
		return -1;
	}"
xdman,xdman.mediaconversion.MediaFormat,toString,,10,18,15,5,0.2381,0.0667,1,0,3,0,1,"@Override
	public String toString() {
		if (width < 0) {
			return StringResource.get(""VID_FMT_ORIG"");
		}
		if (audioOnly) {
			return format + "" "" + description + "" "" + width + ""kbps "";
		}
		return format + "" "" + description + "" ("" + width + ""x"" + height + "") "";
	}"
xdman,xdman.mediaconversion.FFmpeg,convert,,80,862,596,8,0.0598,0.1574,0.5,10,16,1,1,"public int convert() {
		try {

			Logger.log(""Outformat: "" + outformat + "" audio: "" + outformat.isAudioOnly());

			File ffFile = new File(Config.getInstance().getDataFolder(),
					System.getProperty(""os.name"").toLowerCase().contains(""windows"") ? ""ffmpeg.exe"" : ""ffmpeg"");
			if (!ffFile.exists()) {
				return FF_NOT_FOUND;
			}

			List<String> args = new ArrayList<String>();
			args.add(ffFile.getAbsolutePath());

			if (hls) {
				args.add(""-f"");
				args.add(""concat"");
				args.add(""-safe"");
				args.add(""0"");
			}

			for (int i = 0; i < inputFiles.size(); i++) {
				args.add(""-i"");
				args.add(inputFiles.get(i));
			}

			if (outformat.isAudioOnly()) {
				if (outformat.getWidth() > 0) {
					args.add(""-b:a"");
					args.add(outformat.getWidth() + ""k"");
				} else if (copy) {
					args.add(""-acodec"");
					args.add(""copy"");
				}
			} else {
				if (outformat.getWidth() > 0) {
					args.add(""-vf"");
					args.add(""scale="" + outformat.getWidth() + "":"" + outformat.getHeight());
					// args.add(""scale=w="" + outformat.getWidth() + "":h="" +
					// outformat.getHeight()
					// + "":force_original_aspect_ratio=decrease"");
				} else if (copy) {
					args.add(""-acodec"");
					args.add(""copy"");
					args.add(""-vcodec"");
					args.add(""copy"");
				}
			}

			args.add(outputFile);
			args.add(""-y"");

			for (String s : args) {
				Logger.log(""@ffmpeg_args: "" + s);
			}

			ProcessBuilder pb = new ProcessBuilder(args);
			pb.redirectErrorStream(true);
			proc = pb.start();

			BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()), 1024);
			while (true) {
				String ln = br.readLine();
				if (ln == null) {
					break;
				}
				try {
					String text = ln.trim();
					processOutput(text);
				} catch (Exception e) {
					Logger.log(e);
				}
			}

			ffExitCode = proc.waitFor();
			return ffExitCode == 0 ? FF_SUCCESS : FF_CONVERSION_FAILED;
		} catch (Exception e) {
			return FF_LAUNCH_ERROR;
		}
	}"
xdman,xdman.mediaconversion.FFmpeg,parseDuration,,17,54,17,3,0.2857,0.2185,1,4,4,0,1,"private long parseDuration(String dur) {
		long duration = 0;
		String[] arr = dur.split("":"");
		String s = arr[0].trim();
		if (!StringUtils.isNullOrEmpty(s)) {
			duration = Integer.parseInt(s, 10) * 3600;
		}
		s = arr[1].trim();
		if (!StringUtils.isNullOrEmpty(s)) {
			duration += Integer.parseInt(arr[1].trim(), 10) * 60;
		}
		s = arr[2].split(""\\."")[0].trim();
		if (!StringUtils.isNullOrEmpty(s)) {
			duration += Integer.parseInt(s, 10);
		}
		return duration;
	}"
xdman,xdman.mediaconversion.FFmpeg,processOutput,,36,244,137,3,0.125,0.1128,1,10,8,0,1,"private void processOutput(String text) {
		if (StringUtils.isNullOrEmpty(text)) {
			return;
		}
		if (totalDuration > 0) {
			if (text.startsWith(""frame="") && text.contains(""time="")) {
				int index1 = text.indexOf(""time"");
				index1 = text.indexOf('=', index1);
				int index2 = text.indexOf(""bitrate="");
				String dur = text.substring(index1 + 1, index2).trim();
				Logger.log(""Parsing duration: "" + dur);
				long t = parseDuration(dur);
				Logger.log(""Duration: "" + t + "" Total duration: "" + totalDuration);
				int prg = (int) ((t * 100) / totalDuration);
				Logger.log(""ffmpeg prg: "" + prg);
				listener.progress(prg);
			}
		}

		if (totalDuration == 0) {
			if (text.startsWith(""Duration:"")) {
				try {
					int index1 = text.indexOf(""Duration"");
					index1 = text.indexOf(':', index1);
					int index2 = text.indexOf("","", index1);
					String dur = text.substring(index1 + 1, index2).trim();
					Logger.log(""Parsing duration: "" + dur);
					totalDuration = parseDuration(dur);
					Logger.log(""Total duration: "" + totalDuration);
				} catch (Exception e) {
					Logger.log(e);
					totalDuration = -1;
				}
			}
		}
	}"
xdman,xdman.monitoring.ParsedHookData,parse,,56,558,336,5,0.1039,0.1168,0.375,15,16,1,1,"public static ParsedHookData parse(byte[] b) throws UnsupportedEncodingException {
		ParsedHookData data = new ParsedHookData();
		data.requestHeaders = new HeaderCollection();
		data.responseHeaders = new HeaderCollection();
		String strBuf = new String(b, ""utf-8"");
		String[] arr = strBuf.split(""\r\n"");
		for (int i = 0; i < arr.length; i++) {
			String str = arr[i];
			if (!str.contains(""="")) {
				continue;
			}
			String ln = str;
			int index = ln.indexOf(""="");
			String key = ln.substring(0, index).trim().toLowerCase();
			String val = ln.substring(index + 1).trim();
			if (key.equals(""url"")) {
				data.setUrl(val);
			} else if (key.equals(""file"")) {
				val = XDMUtils.getFileName(val);
				data.setFile(val);
			} else if (key.equals(""req"")) {
				index = val.indexOf("":"");
				if (index > 0) {
					String headerName = val.substring(0, index).trim().toLowerCase();
					String headerValue = val.substring(index + 1).trim();
					if (headerName.equals(""range"") && (!headerValue.startsWith(""bytes=0-""))) {
						data.setPartialResponse(true);
					}
					if (!isBlockedHeader(headerName)) {
						data.requestHeaders.addHeader(headerName, headerValue);
					}
					System.out.println(ln);
				}
			} else if (key.equals(""res"")) {
				index = val.indexOf("":"");
				if (index > 0) {
					String headerName = val.substring(0, index).trim().toLowerCase();
					String headerValue = val.substring(index + 1).trim();
					data.responseHeaders.addHeader(headerName, headerValue);
				}
			}
		}
		if (data.responseHeaders.containsHeader(""content-length"")
				|| data.responseHeaders.containsHeader(""content-range"")) {
			data.contentLength = NetUtils.getContentLength(data.responseHeaders);
		}
		if (data.responseHeaders.containsHeader(""content-type"")) {
			data.contentType = NetUtils.getCleanContentType(data.responseHeaders.getValue(""content-type""));
		}

		try {
			data.setExt(XDMUtils.getExtension(XDMUtils.getFileName(data.getUrl())));
		} catch (Exception e) {
		}
		return data;
	}"
xdman,xdman.monitoring.FBHandler,handle,,64,972,816,5,0.0707,0.046,0.545454545,23,12,1,1,"//	public static void main(String[] args) {
//		handle(new File(""C:\\Users\\dasgupts\\Downloads\\LitestandTailLoadPagelet""), null);
//	}

	public static boolean handle(File tempFile, ParsedHookData data) {
		try {
			StringBuffer buf = new StringBuffer();
			InputStream in = new FileInputStream(tempFile);
			BufferedReader r = new BufferedReader(new InputStreamReader(in));
			while (true) {
				String ln = r.readLine();
				if (ln == null) {
					break;
				}
				buf.append(ln + ""\n"");
			}
			in.close();
			Logger.log(""Parsing facebook page..."");
			ArrayList<String> sdUrls1 = findURL(""sd_src"", buf);
			ArrayList<String> sdUrls2 = findURL(""sd_src_no_ratelimit"", buf);
			ArrayList<String> hdUrls1 = findURL(""hd_src"", buf);
			ArrayList<String> hdUrls2 = findURL(""hd_src_no_ratelimit"", buf);
			for (int i = 0; i < sdUrls1.size(); i++) {
				HttpMetadata metadata = new HttpMetadata();
				metadata.setUrl(sdUrls1.get(i));
				metadata.setHeaders(data.getRequestHeaders());
				String file = data.getFile();
				if (StringUtils.isNullOrEmptyOrBlank(file)) {
					file = XDMUtils.getFileName(data.getUrl());
				}
				XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 LOW"");
			}
			for (int i = 0; i < sdUrls2.size(); i++) {
				HttpMetadata metadata = new HttpMetadata();
				metadata.setUrl(sdUrls2.get(i));
				metadata.setHeaders(data.getRequestHeaders());
				String file = data.getFile();
				if (StringUtils.isNullOrEmptyOrBlank(file)) {
					file = XDMUtils.getFileName(data.getUrl());
				}
				XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 MEDIUM"");
			}
			for (int i = 0; i < hdUrls1.size(); i++) {
				HttpMetadata metadata = new HttpMetadata();
				metadata.setUrl(hdUrls1.get(i));
				metadata.setHeaders(data.getRequestHeaders());
				String file = data.getFile();
				if (StringUtils.isNullOrEmptyOrBlank(file)) {
					file = XDMUtils.getFileName(data.getUrl());
				}
				XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 HD"");
			}
			for (int i = 0; i < hdUrls2.size(); i++) {
				HttpMetadata metadata = new HttpMetadata();
				metadata.setUrl(hdUrls2.get(i));
				metadata.setHeaders(data.getRequestHeaders());
				String file = data.getFile();
				if (StringUtils.isNullOrEmptyOrBlank(file)) {
					file = XDMUtils.getFileName(data.getUrl());
				}
				XDMApp.getInstance().addMedia(metadata, file + "".mp4"", ""MP4 HQ"");
			}
			return true;
		} catch (Exception e) {
			Logger.log(e);
			return false;
		}
	}"
xdman,xdman.monitoring.FBHandler,findURL,,72,1028,928,30,0.0677,0.059,1,11,10,0,1,"private static ArrayList<String> findURL(String keyword, StringBuffer buf) {
		int index1 = 0;
		int index = 0;
		ArrayList<String> urlList = new ArrayList<String>();
		String urlStart = "":"";// ""\""https"";
		while (true) {
			index = buf.indexOf(keyword, index);
			if (index < 0)
				break;
			index += keyword.length();
			index = buf.indexOf("":"", index);
			if (index < 0) {
				break;
			}
			index += 1;
			int collonIndex = index;

			while (true) {
				char ch = buf.charAt(index);
				if (ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t')
					index++;
				else
					break;
			}

			char ch = buf.charAt(index);
			if (ch == '""') {
				index++;
				int index3 = buf.indexOf(""\"""", index);
				String url = decodeJSONEscape(buf.substring(index, index3).trim().replace(""\"""", """"));
				Logger.log(keyword + "": "" + url);
				urlList.add(url);
			}

			// if (buf.indexOf(""null"", index) == index) {
			// index += 5;
			// } else
			//
			// while (true) {
			// char ch = buf.charAt(index);
			// if (ch == ',' || ch == '}' || ch == ']')
			// break;
			// else
			// index++;
			// }
			//
			// String url = decodeJSONEscape(buf.substring(collonIndex,
			// index).trim().replace(""\"""", """"));
			// Logger.log(keyword + "": "" + url);
			// if (!url.equals(""null"")) {
			// urlList.add(url);
			// }

			// int idx=buf.indexOf(""null"", fromIndex)
			//
			// index1 = buf.indexOf(keyword, index1);// (""\""sd_src\"""");
			// if (index1 < 0)
			// break;
			// index1 += keyword.length();
			// int index2 = buf.indexOf(urlStart, index1);
			// if (index2 > 0) {
			// int index3 = buf.indexOf(""\"""", index2 + urlStart.length());
			// int end = buf.indexOf(""\"""", index3 + 1);
			// String url = decodeJSONEscape(buf.substring(index3 + 1, end));
			// Logger.log(keyword + "": "" + url);
			// if (!url.equals(""null"")) {
			// urlList.add(url);
			// }
			// }
		}
		return urlList;
	}"
xdman,xdman.monitoring.FBHandler,decodeJSONEscape,,20,62,19,3,0.2222,0.1742,0,6,4,0,1,"private static String decodeJSONEscape(String json) {
		StringBuffer buf = new StringBuffer();
		int pos = 0;
		while (true) {
			int index = json.indexOf(""\\u"", pos);
			if (index < 0) {
				if (pos < json.length()) {
					buf.append(json.substring(pos));
				}
				break;
			}
			buf.append(json.substring(pos, index));
			pos = index;
			String code = json.substring(pos + 2, pos + 2 + 4);
			int char_code = Integer.parseInt(code, 16);
			buf.append((char) char_code);
			pos += 6;
		}
		return buf.toString().replace(""\\"", """");
	}"
xdman,xdman.monitoring.Response,write,,14,48,30,3,0.2222,0.1205,0.5,2,7,0,1,"public void write(OutputStream out) throws IOException {
		StringBuffer buf = new StringBuffer();
		buf.append(""HTTP/1.1 "" + code + "" "" + message + ""\r\n"");
		if (code != 204) {
			headers.addHeader(""Content-Length"", (body == null || body.length < 0) ? ""0"" : body.length + """");
		}
		headers.appendToBuffer(buf);
		buf.append(""\r\n"");
		out.write(buf.toString().getBytes());
		if (body != null && body.length > 0) {
			out.write(body);
		}
		out.flush();
	}"
xdman,xdman.monitoring.BrowserMonitor,run,,20,75,59,5,0.1429,0.0926,0.6,5,4,0,1,"public void run() {
		ServerSocket serverSock = null;
		try {
			serverSock = new ServerSocket();
			serverSock.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 9614));
			XDMApp.instanceStarted();
			while (true) {
				Socket sock = serverSock.accept();
				MonitoringSession session = new MonitoringSession(sock);
				session.start();
			}
		} catch (Exception e) {
			Logger.log(e);
			XDMApp.instanceAlreadyRunning();
		}
		try {
			serverSock.close();
		} catch (Exception e) {
		}
	}"
xdman,xdman.monitoring.VimeoHandler,handle,,53,344,93,5,0.1122,0.2355,1,12,11,0,1,"// public static void main(String[] args) {
	// handle(new File(""C:\\Users\\subhro\\Desktop\\video.htm.txt""), null);
	// }

	public static boolean handle(File tempFile, ParsedHookData data) {
		try {
			StringBuffer buf = new StringBuffer();
			InputStream in = new FileInputStream(tempFile);
			BufferedReader r = new BufferedReader(new InputStreamReader(in));
			while (true) {
				String ln = r.readLine();
				if (ln == null) {
					break;
				}
				buf.append(ln + ""\n"");
			}
			in.close();
			String keyword = ""\""progressive\"""";
			int index = buf.indexOf(keyword);
			if (index < 0) {
				return false;
			}
			index += keyword.length();
			index = buf.indexOf("":"", index);
			if (index < 0) {
				return false;
			}
			index++;
			index = buf.indexOf(""["", index);
			if (index < 0) {
				return false;
			}
			index++;
			int start = index;
			index = buf.indexOf(""]"", index);
			if (index < 0) {
				return false;
			}
			String str = buf.substring(start, index);
			index = 0;
			while (index != -1) {
				index = str.indexOf(""{"", index);
				if (index > -1) {
					index++;
					start = index;
					index = str.indexOf(""}"", index);
					if (index > -1) {
						String s = str.substring(start, index);
						processString(s, data);
					}
				}
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		return false;
	}"
xdman,xdman.monitoring.VimeoHandler,processString,,37,363,291,3,0.102,0.0709,0.545454545,13,9,0,1,"private static void processString(String str, ParsedHookData data) {
		String quality = """", type = """", url = """";
		String[] arr = str.split("","");
		for (int i = 0; i < arr.length; i++) {
			int index = arr[i].indexOf("":"");
			if (index > 0) {
				String key = arr[i].substring(0, index).replace(""\"""", """");
				String val = arr[i].substring(index + 1).replace(""\"""", """");
				if (key.equals(""url"")) {
					url = val;
					Logger.log(url);
				}
				if (key.equals(""quality"")) {
					quality = val;
					Logger.log(quality);
				}
				if (key.equals(""mime"")) {
					type = val;
					Logger.log(type);
				}
			}
		}
		String ext = ""mp4"";
		if (type.contains(""video/mp4"")) {
			ext = ""mp4"";
		} else if (type.contains(""video/webm"")) {
			ext = ""webm"";
		}
		HttpMetadata metadata = new HttpMetadata();
		metadata.setUrl(url);
		metadata.setHeaders(data.getRequestHeaders());
		String file = data.getFile();
		if (StringUtils.isNullOrEmptyOrBlank(file)) {
			file = XDMUtils.getFileName(data.getUrl());
		}
		XDMApp.getInstance().addMedia(metadata, file + ""."" + ext, ext.toUpperCase() + "" "" + quality);
	}"
xdman,xdman.monitoring.Request,read,,29,239,202,5,0.1012,0.0594,0.5,10,8,0,1,"public void read(InputStream in) throws IOException {
		String reqLine = NetUtils.readLine(in);
		//System.out.println(reqLine);
		if (reqLine == null || reqLine.length() < 1) {
			throw new IOException(""Invalid request line: "" + reqLine);
		}
		String[] arr = reqLine.split("" "");
		if (arr.length != 3) {
			throw new IOException(""Invalid request: "" + reqLine);
		}
		this.url = arr[1];
		this.method = arr[0].toLowerCase().equals(""post"") ? 1 : 2;
		this.headers = new HeaderCollection();
		headers.loadFromStream(in);
		String header = headers.getValue(""Content-Length"");
		if (header != null) {
			long len = Long.parseLong(header);
			body = new byte[(int) len];
			int off = 0;
			while (len > 0) {
				int x = in.read(body, off, body.length - off);
				if (x == -1) {
					throw new IOException(""Unexpected EOF"");
				}
				len -= x;
				off += x;
			}
		}
	}"
xdman,xdman.monitoring.InstagramHandler,handle,,44,398,331,4,0.0829,0.0495,0.5,14,8,0,1,"public static boolean handle(File tempFile, ParsedHookData data) {
		try {
			StringBuffer buf = new StringBuffer();
			InputStream in = new FileInputStream(tempFile);
			BufferedReader r = new BufferedReader(new InputStreamReader(in));
			while (true) {
				String ln = r.readLine();
				if (ln == null) {
					break;
				}
				buf.append(ln + ""\n"");
			}
			in.close();
			Logger.log(""Parsing instagram page..."");
			if (pattern == null) {
				pattern = Pattern.compile(""\""video\\_url\""\\s*:\\s*\""(.*?)\"""");
			}
			Matcher matcher = pattern.matcher(buf);
			if (matcher.find()) {
				int start = matcher.start();
				int end = matcher.end();
				String url = matcher.group(1);
				Logger.log(""Url: "" + url);
				HttpMetadata metadata = new HttpMetadata();
				metadata.setUrl(url);
				metadata.setHeaders(data.getRequestHeaders());
				String file = data.getFile();
				if (StringUtils.isNullOrEmptyOrBlank(file)) {
					file = XDMUtils.getFileName(data.getUrl());
				}
				String ext = XDMUtils.getExtension(XDMUtils.getFileName(url));
				if (ext != null) {
					ext = ext.replace(""."", """").toUpperCase();
				} else {
					ext = """";
				}
				XDMApp.getInstance().addMedia(metadata, file + ""."" + ext, ext);
			}
			return true;
		} catch (Exception e) {
			Logger.log(e);
			return false;
		}
	}"
xdman,xdman.monitoring.MonitoringSession,onDownload,,17,66,41,5,0.1571,0.1212,0.384615385,6,3,0,1,"private void onDownload(Request request, Response res) throws UnsupportedEncodingException {
		try {
			Logger.log(new String(request.getBody()));
			byte[] b = request.getBody();
			ParsedHookData data = ParsedHookData.parse(b);
			if (data.getUrl() != null && data.getUrl().length() > 0) {
				HttpMetadata metadata = new HttpMetadata();
				metadata.setUrl(data.getUrl());
				metadata.setHeaders(data.getRequestHeaders());
				metadata.setSize(data.getContentLength());
				String file = data.getFile();
				XDMApp.getInstance().addDownload(metadata, file);
			}
		} finally {
			setResponseOk(res);
		}
	}"
xdman,xdman.monitoring.MonitoringSession,onVideo,,24,74,57,6,0.1429,0.0985,0.571428571,5,12,0,1,"private void onVideo(Request request, Response res) throws UnsupportedEncodingException {
		try {
			Logger.log(new String(request.getBody()));
			if (!Config.getInstance().isShowVideoNotification()) {
				return;
			}
			byte[] b = request.getBody();
			ParsedHookData data = ParsedHookData.parse(b);
			String type = data.getContentType();
			if (type == null) {
				type = """";
			}
			if (type.contains(""f4f"") || type.contains(""m4s"") || type.contains(""mp2t"") || data.getUrl().contains(""fcs"")
					|| data.getUrl().contains(""abst"") || data.getUrl().contains(""f4x"")
					|| data.getUrl().contains("".fbcdn"")) {
				return;
			}
			if (!(processDashSegment(data) || processVideoManifest(data))) {
				processNormalVideo(data);
			}
		} finally {
			setResponseOk(res);
		}
	}"
xdman,xdman.monitoring.MonitoringSession,onCmd,,24,145,119,5,0.1158,0.0549,0.571428571,12,6,0,1,"private void onCmd(Request request, Response res) {
		byte[] data = request.getBody();
		if (data == null || data.length < 1) {
			XDMApp.getInstance().showMainWindow();
		} else {
			String[] arr = new String(data).split(""\n"");
			for (int i = 0; i < arr.length; i++) {
				String str = arr[i];
				int index = str.indexOf("":"");
				if (index < 1)
					continue;
				String key = str.substring(0, index).trim();
				String val = str.substring(index + 1).trim();
				if (key.equals(""url"")) {
					String url = val;
					HttpMetadata metadata = new HttpMetadata();
					metadata.setUrl(url);
					String file = XDMUtils.getFileName(url);
					XDMApp.getInstance().addDownload(metadata, file);
				}
			}
		}
		setResponseOk(res);
	}"
xdman,xdman.monitoring.MonitoringSession,onSync,,29,174,23,3,0.2179,0.3287,0.25,5,1,0,1,"private void onSync(Request request, Response res) {
		StringBuffer json = new StringBuffer();
		json.append(""{\n\""enabled\"": "");
		json.append(Config.getInstance().isBrowserMonitoringEnabled());
		json.append("",\n\""blockedHosts\"": ["");
		appendArray(Config.getInstance().getBlockedHosts(), json);
		json.append(""],"");
		json.append(""\n\""videoUrls\"": ["");
		appendArray(Config.getInstance().getVidUrls(), json);
		json.append(""],"");
		json.append(""\n\""fileExts\"": ["");
		appendArray(Config.getInstance().getFileExts(), json);
		json.append(""],"");
		json.append(""\n\""vidExts\"": ["");
		appendArray(Config.getInstance().getVidExts(), json);
		json.append(""]"");
		json.append(""\n}"");

		byte[] b = json.toString().getBytes();

		res.setCode(200);
		res.setMessage(""OK"");

		HeaderCollection headers = new HeaderCollection();
		headers.addHeader(""Content-Length"", b.length + """");
		headers.addHeader(""Content-Type"", ""application/json"");
		res.setHeaders(headers);
		res.setBody(b);
	}"
xdman,xdman.monitoring.MonitoringSession,appendArray,,13,26,16,3,0.3056,0.1405,0,4,5,0,1,"private void appendArray(String[] arr, StringBuffer buf) {
		boolean insertComma = false;
		if (arr != null && arr.length > 0) {
			for (int i = 0; i < arr.length; i++) {
				if (insertComma) {
					buf.append("","");
				} else {
					insertComma = true;
				}
				buf.append(""\"""" + arr[i] + ""\"""");
			}
		}
	}"
xdman,xdman.monitoring.MonitoringSession,serviceRequest,,14,38,31,5,0.2,0.0603,1,5,3,0,1,"private void serviceRequest() {
		try {
			inStream = sock.getInputStream();
			outStream = sock.getOutputStream();
			while (true) {
				this.request.read(inStream);
				this.processRequest(this.request, this.response);
				this.response.write(outStream);
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		cleanup();
	}"
xdman,xdman.monitoring.MonitoringSession,cleanup,,16,25,22,6,0.1875,0.1111,0,3,4,0,1,"private void cleanup() {
		try {
			inStream.close();
		} catch (Exception e) {
		}

		try {
			outStream.close();
		} catch (Exception e) {
		}

		try {
			sock.close();
		} catch (Exception e) {
		}
	}"
xdman,xdman.monitoring.MonitoringSession,processDashSegment,,126,2510,1939,3,0.063,0.055,0.384615385,27,37,1,1,"private boolean processDashSegment(ParsedHookData data) {
		try {
			URL url = new URL(data.getUrl());
			String host = url.getHost();
			if (!(host.contains(""youtube.com"") || host.contains(""googlevideo.com""))) {
				Logger.log(""non yt host"");
				return false;
			}
			String type = data.getContentType();
			if (type == null) {
				type = """";
			}
			if (!(type.contains(""audio/"") || type.contains(""video/"") || type.contains(""application/octet""))) {
				Logger.log(""non yt type"");
				return false;
			}
			String low_path = data.getUrl().toLowerCase();
			if (low_path.indexOf(""videoplayback"") >= 0 && low_path.indexOf(""itag"") >= 0) {
				// found DASH audio/video stream
				if (StringUtils.isNullOrEmptyOrBlank(url.getQuery())) {
					return false;
				}

				int index = data.getUrl().indexOf(""?"");

				String path = data.getUrl().substring(0, index);
				String query = data.getUrl().substring(index + 1);

				String arr[] = query.split(""&"");
				StringBuilder yt_url = new StringBuilder();
				yt_url.append(path + ""?"");
				int itag = 0;
				long clen = 0;
				String id = """";
				String mime = """";

				for (int i = 0; i < arr.length; i++) {
					String str = arr[i];
					index = str.indexOf(""="");
					if (index > 0) {
						String key = str.substring(0, index).trim();
						String val = str.substring(index + 1).trim();
						if (key.startsWith(""range"")) {
							continue;
						}
						if (key.equals(""itag"")) {
							itag = Integer.parseInt(val);
						}
						if (key.equals(""clen"")) {
							clen = Integer.parseInt(val);
						}
						if (key.startsWith(""mime"")) {
							mime = URLDecoder.decode(val, ""UTF-8"");
						}
						if (str.startsWith(""id"")) {
							id = val;
						}
					}
					yt_url.append(str);
					if (i < arr.length - 1) {
						yt_url.append(""&"");
					}
				}
				if (itag != 0) {
					if (YtUtil.isNormalVideo(itag)) {
						Logger.log(""Normal vid"");
						return false;
					}
				}

				DASH_INFO info = new DASH_INFO();
				info.url = yt_url.toString();
				info.clen = clen;
				info.video = mime.startsWith(""video"");
				info.itag = itag;
				info.id = id;
				info.mime = mime;
				info.headers = data.getRequestHeaders();

				Logger.log(""processing yt mime: "" + mime + "" id: "" + id + "" clen: "" + clen + "" itag: "" + itag);

				if (YtUtil.addToQueue(info)) {
					DASH_INFO di = YtUtil.getDASHPair(info);

					if (di != null) {
						DashMetadata dm = new DashMetadata();
						dm.setUrl(info.video ? info.url : di.url);
						dm.setUrl2(info.video ? di.url : info.url);
						dm.setLen1(info.video ? info.clen : di.clen);
						dm.setLen2(info.video ? di.clen : info.clen);
						dm.setHeaders(info.video ? info.headers : di.headers);
						dm.setHeaders2(info.video ? di.headers : info.headers);
						String file = data.getFile();
						if (StringUtils.isNullOrEmptyOrBlank(file)) {
							file = XDMUtils.getFileName(data.getUrl());
						}
						Logger.log(""file: "" + file + "" url1: "" + dm.getUrl() + "" url2: "" + dm.getUrl2() + "" len1: ""
								+ dm.getLen1() + "" len2: "" + dm.getLen2());

						String szStr = null;
						if (info.clen > 0 && di.clen > 0) {
							szStr = FormatUtilities.formatSize(info.clen + di.clen);
						}

						String videoContentType = info.video ? info.mime : di.mime;
						String audioContentType = di.video ? di.mime : info.mime;

						String ext = getYtDashFormat(videoContentType, audioContentType);
						file += ""."" + ext;

						if (info.video) {

						}

						XDMApp.getInstance().addMedia(dm, file, YtUtil.getInfoFromITAG(info.video ? info.itag : di.itag)
								+ (szStr == null ? """" : "" "" + szStr));
						return true;
					}
				}
				return true;
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		return false;
	}"
xdman,xdman.monitoring.MonitoringSession,processVideoManifest,,45,339,182,5,0.1183,0.1645,0.727272727,7,13,0,1,"private boolean processVideoManifest(ParsedHookData data) {
		String url = data.getUrl();
		String file = data.getFile();
		String contentType = data.getContentType();
		if (contentType == null) {
			contentType = """";
		}
		String ext = XDMUtils.getExtension(XDMUtils.getFileName(data.getUrl()));
		File manifestfile = null;

		try {
			if (contentType.contains(""mpegurl"") || "".m3u8"".equalsIgnoreCase(ext)) {
				Logger.log(""Downloading m3u8 manifest"");
				manifestfile = downloadMenifest(data);
				return M3U8Handler.handle(manifestfile, data);
			}
			if (contentType.contains(""f4m"") || "".f4m"".equalsIgnoreCase(ext)) {
				Logger.log(""Downloading f4m manifest"");
				manifestfile = downloadMenifest(data);
				return F4mHandler.handle(manifestfile, data);
			}
			if (url.contains("".facebook.com"") && url.toLowerCase().contains(""pagelet"")) {
				Logger.log(""Downloading fb manifest"");
				manifestfile = downloadMenifest(data);
				return FBHandler.handle(manifestfile, data);
			}
			if (url.contains(""player.vimeo.com"") && contentType.toLowerCase().contains(""json"")) {
				Logger.log(""Downloading video manifest"");
				manifestfile = downloadMenifest(data);
				return VimeoHandler.handle(manifestfile, data);
			}
			if (url.contains(""instagram.com/p/"")) {
				Logger.log(""Downloading video manifest"");
				manifestfile = downloadMenifest(data);
				return InstagramHandler.handle(manifestfile, data);
			}
		} catch (Exception e) {
		} finally {
			if (manifestfile != null) {
				manifestfile.delete();
			}
		}

		return false;
	}"
xdman,xdman.monitoring.MonitoringSession,processNormalVideo,,51,403,278,4,0.1119,0.1438,0.444444444,7,17,0,1,"private void processNormalVideo(ParsedHookData data) {
		String file = data.getFile();
		String type = data.getContentType();
		if (type == null) {
			type = """";
		}
		if (StringUtils.isNullOrEmptyOrBlank(file)) {
			file = XDMUtils.getFileName(data.getUrl());
		}
		String ext = """";
		if (type.contains(""video/mp4"")) {
			ext = ""mp4"";
		} else if (type.contains(""video/x-flv"")) {
			ext = ""flv"";
		} else if (type.contains(""video/webm"")) {
			ext = ""mkv"";
		} else if (type.contains(""matroska"") || type.contains(""mkv"")) {
			ext = ""mkv"";
		} else if (type.equals(""audio/mpeg"") || type.contains(""audio/mp3"")) {
			ext = ""mp3"";
		} else if (type.contains(""audio/aac"")) {
			ext = ""aac"";
		} else if (type.contains(""audio/mp4"")) {
			ext = ""m4a"";
		} else {
			return;
		}
		file += ""."" + ext;

		if (data.getContentLength() < Config.getInstance().getMinVidSize()) {
			Logger.log(""video less than min size"");
			return;
		}

		HttpMetadata metadata = new HttpMetadata();
		metadata.setUrl(data.getUrl());
		metadata.setHeaders(data.getRequestHeaders());
		metadata.setSize(data.getContentLength());
		long size = data.getContentLength();
		if (size > 0) {
			if (data.isPartialResponse()) {
				size = -1;
			}
		}
		String sz = (size > 0 ? FormatUtilities.formatSize(size) : """");
		if (ext.length() > 0) {
			sz += "" "" + ext.toUpperCase();
		}

		XDMApp.getInstance().addMedia(metadata, file, sz);
	}"
xdman,xdman.monitoring.MonitoringSession,downloadMenifest,,37,269,213,3,0.1071,0.0817,0.5,12,7,0,1,"private File downloadMenifest(ParsedHookData data) {
		JavaHttpClient client = null;
		OutputStream out = null;
		try {
			client = new JavaHttpClient(data.getUrl());
			Iterator<HttpHeader> headers = data.getRequestHeaders().getAll();
			while (headers.hasNext()) {
				HttpHeader header = headers.next();
				client.addHeader(header.getName(), header.getValue());
			}
			client.connect();
			int resp = client.getStatusCode();
			Logger.log(""manifest download response: "" + resp);
			if (resp == 206 || resp == 200) {
				InputStream in = client.getInputStream();
				File tmpFile = new File(Config.getInstance().getTemporaryFolder(), UUID.randomUUID().toString());
				long len = client.getContentLength();
				out = new FileOutputStream(tmpFile);
				XDMUtils.copyStream(in, out, len);
				Logger.log(""manifest download successfull"");

				return tmpFile;
			}
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				out.close();
			} catch (Exception e) {
			}
			try {
				client.dispose();
			} catch (Exception e) {
			}
		}
		return null;
	}"
xdman,xdman.monitoring.M3U8Handler,handle,,47,330,195,3,0.1441,0.1057,0.470588235,13,11,0,1,"public static boolean handle(File m3u8file, ParsedHookData data) {
		try {
			M3U8Manifest manifest = new M3U8Manifest(m3u8file.getAbsolutePath(), data.getUrl());
			if (manifest.isEncrypted()) {
				return true;
			}
			if (!manifest.isMasterPlaylist()) {
				HlsMetadata metadata = new HlsMetadata();
				metadata.setUrl(data.getUrl());
				metadata.setHeaders(data.getRequestHeaders());
				String file = data.getFile();
				if (StringUtils.isNullOrEmptyOrBlank(file)) {
					file = XDMUtils.getFileName(data.getUrl());
				}
				XDMApp.getInstance().addMedia(metadata, file + "".ts"", ""HLS"");
			} else {
				ArrayList<String> urls = manifest.getMediaUrls();
				if (urls != null) {
					for (int i = 0; i < urls.size(); i++) {
						String url = urls.get(i);
						M3U8MediaInfo info = manifest.getMediaProperty(i);
						HlsMetadata metadata = new HlsMetadata();
						metadata.setUrl(url);
						metadata.setHeaders(data.getRequestHeaders());
						String file = data.getFile();
						if (StringUtils.isNullOrEmptyOrBlank(file)) {
							file = XDMUtils.getFileName(data.getUrl());
						}
						StringBuilder infoStr = new StringBuilder();
						if (!StringUtils.isNullOrEmptyOrBlank(info.getBandwidth())) {
							infoStr.append(info.getBandwidth());
						}
						if (infoStr.length() > 0) {
							infoStr.append("" "");
						}
						if (!StringUtils.isNullOrEmptyOrBlank(info.getResolution())) {
							infoStr.append(info.getResolution());
						}
						XDMApp.getInstance().addMedia(metadata, file + "".ts"", infoStr.toString());
					}
				}
			}
			return true;
		} catch (Exception e) {
		}
		return false;
	}"
xdman,xdman.monitoring.YtUtil,addToQueue,,36,134,78,4,0.1778,0.1287,1,5,10,0,1,"public static boolean addToQueue(DASH_INFO info) {
		synchronized (lockObject) {
			if(videoQueue.size()>32) {
				videoQueue.remove(0);
			}
			if(audioQueue.size()>32) {
				audioQueue.remove(0);
			}
			if (info.video) {
				for (int i = videoQueue.size() - 1; i >= 0; i--) {
					DASH_INFO di = videoQueue.get(i);
					if (di.clen == info.clen) {
						if (di.id.equals(info.id)) {
							return false;
						}
					}
				}
				videoQueue.add(info);
				Logger.log(""video added "" + videoQueue.size());

				return true;
			} else {
				for (int i = audioQueue.size() - 1; i >= 0; i--) {
					DASH_INFO di = audioQueue.get(i);
					if (di.clen == info.clen) {
						if (di.id.equals(info.id)) {
							return false;
						}
					}
				}
				audioQueue.add(info);
				Logger.log(""added added "" + audioQueue.size());
				return true;
			}
		}
	}"
xdman,xdman.monitoring.YtUtil,loadITAGs,,66,810,0,13,0.1166,0.7027,0,0,2,1,1,"static void loadITAGs() {
		if (itags != null) {
			return;
		}
		itags = new HashMap<Integer, String>();
		itags.put(5, ""320 x 240"");
		itags.put(6, ""450 x 270"");
		itags.put(13, ""Small"");
		itags.put(17, ""176 x 144"");
		itags.put(18, ""480 x 360"");
		itags.put(22, ""1280 x 720"");
		itags.put(34, ""480 x 360"");
		itags.put(35, ""640 x 480 "");
		itags.put(36, ""320 x 240"");
		itags.put(37, ""1920 x 1080"");
		itags.put(38, ""2048 x 1080"");
		itags.put(43, ""480 x 360"");
		itags.put(44, ""640 x 480"");
		itags.put(45, ""1280 x 720"");
		itags.put(46, ""1920 x 1080"");
		itags.put(59, ""854 x 480"");
		itags.put(78, ""854 x 480"");
		itags.put(82, ""480 x 360   3D"");
		itags.put(83, ""640 x 480   3D"");
		itags.put(84, ""1280 x 720   3D"");
		itags.put(85, ""1920 x 1080  3D"");
		itags.put(100, ""480 x 360   3D"");
		itags.put(101, ""640 x 480   3D"");
		itags.put(102, ""1280 x 720   3D"");
		itags.put(133, ""320 x 240"");
		itags.put(134, ""480 x 360"");
		itags.put(135, ""640 x 480"");
		itags.put(136, ""1280 x 720"");
		itags.put(137, ""1920 x 1080"");
		itags.put(139, ""Low bitrate"");
		itags.put(140, ""Med bitrate"");
		itags.put(141, ""Hi  bitrate"");
		itags.put(160, ""256 x 144"");
		itags.put(167, ""360p"");
		itags.put(168, ""480p"");
		itags.put(169, ""720p"");
		itags.put(170, ""1080p"");
		itags.put(171, ""Med bitrate"");
		itags.put(172, ""Hi  bitrate"");
		itags.put(218, ""480"");
		itags.put(219, ""480"");
		itags.put(242, ""320 x 240"");
		itags.put(243, ""480 x 360"");
		itags.put(244, ""640 x 480"");
		itags.put(245, ""640 x 480"");
		itags.put(246, ""640 x 480"");
		itags.put(247, ""1280 x 720"");
		itags.put(248, ""1920 x 1080"");
		itags.put(264, ""1440p"");
		itags.put(266, ""2160p"");
		itags.put(271, ""1440p"");
		itags.put(272, ""2160p"");
		itags.put(278, ""144p"");
		itags.put(298, ""720p"");
		itags.put(302, ""720p"");
		itags.put(303, ""1080p"");
		itags.put(308, ""1440p"");
		itags.put(313, ""2160p"");
		itags.put(315, ""2160p"");
		itags.put(299, ""2160p"");
	}"
xdman,xdman.monitoring.F4mHandler,handle,,50,373,311,5,0.087,0.0844,0.571428571,12,12,1,1,"public static boolean handle(File f4mfile, ParsedHookData data) {
		try {
			StringBuffer buf = new StringBuffer();
			InputStream in = new FileInputStream(f4mfile);
			BufferedReader r = new BufferedReader(new InputStreamReader(in));
			while (true) {
				String ln = r.readLine();
				if (ln == null) {
					break;
				}
				buf.append(ln + ""\n"");
			}
			in.close();
			Logger.log(""HDS manifest validating..."");
			if (buf.indexOf(""http://ns.adobe.com/f4m/1.0"") < 0) {
				Logger.log(""No namespace"");
				return false;
			}
			if (buf.indexOf(""manifest"") < 0) {
				Logger.log(""No manifest keyword"");
				return false;
			}
			if (buf.indexOf(""drmAdditional"") > 0) {
				Logger.log(""DRM"");
				return false;
			}
			if (buf.indexOf(""media"") == 0 || buf.indexOf(""href"") > 0 || buf.indexOf("".f4m"") > 0) {
				Logger.log(""Not a valid manifest"");
				return false;
			}

			F4MManifest manifest = new F4MManifest(data.getUrl(), f4mfile.getAbsolutePath());
			long[] bitRates = manifest.getBitRates();
			for (int i = 0; i < bitRates.length; i++) {
				HdsMetadata metadata = new HdsMetadata();
				metadata.setUrl(data.getUrl());
				metadata.setBitRate((int) bitRates[i]);
				metadata.setHeaders(data.getRequestHeaders());
				String file = data.getFile();
				if (StringUtils.isNullOrEmptyOrBlank(file)) {
					file = XDMUtils.getFileName(data.getUrl());
				}
				XDMApp.getInstance().addMedia(metadata, file + "".flv"", ""FLV "" + bitRates[i] + "" bps"");
			}
			return true;
		} catch (Exception e) {
			Logger.log(e);
			return false;
		}
	}"
xdman,xdman.network.FixedRangeInputStream,read,,20,40,14,4,0.2361,0.1968,0,4,7,0,1,"@Override
	public int read(byte[] b, int off, int len) throws IOException {
		if (rem == 0) {
			return -1;
		}
		if (rem > 0 && len > rem) {
			len = (int) rem;
		}
		int x = baseStream.read(b, off, len);
		if (x == -1) {
			if (rem > 0) {
				throw new IOException(""Unexpected eof"");
			} else
				return -1;
		}
		if (rem > 0) {
			rem -= x;
		}
		return x;
	}"
xdman,xdman.network.FixedRangeInputStream,read,,17,30,15,4,0.3333,0.2063,0,1,5,0,1,"@Override
	public int read() throws IOException {
		if (rem == 0) {
			return -1;
		}
		int x = baseStream.read();
		if (x == -1) {
			if (rem > 0) {
				throw new IOException(""Unexpected eof"");
			} else
				return -1;
		}
		if (rem > 0) {
			rem -= x;
		}
		return x;
	}"
xdman,xdman.network.KeepAliveConnectionCache,scavengeCache,,28,111,86,5,0.1497,0.0788,0.5,8,6,0,1,"private void scavengeCache() {

		ArrayList<Socket> sockets2Close = new ArrayList<Socket>();

		synchronized (_this) {
			for (int i = 0; i < socketList.size(); i++) {
				KeepAliveInfo info = socketList.get(i);
				long now = System.currentTimeMillis();
				if (now - info.getLastUsed() >= MAX_KEEP_ALIVE_INT) {
					socketList.remove(i);
					sockets2Close.add(info.getSocket());
				}
			}
		}

		for (int i = 0; i < socketList.size(); i++) {
			KeepAliveInfo info = socketList.get(i);
			long now = System.currentTimeMillis();
			if (now - info.getLastUsed() >= MAX_KEEP_ALIVE_INT) {
				socketList.remove(i);
				try {
					info.getSocket().close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}"
xdman,xdman.network.KeepAliveConnectionCache,run,,16,39,33,6,0.2,0.0694,0,3,4,0,1,"@Override
	public void run() {
		while (!stop) {
			long lastrun = System.currentTimeMillis();
			scavengeCache();
			long now = System.currentTimeMillis();

			if (now - lastrun < MAX_KEEP_ALIVE_INT) {
				try {
					Thread.sleep(MAX_KEEP_ALIVE_INT - (now - lastrun));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}"
xdman,xdman.network.ProxyResolver,resolve,,39,143,76,3,0.1571,0.1714,0.230769231,8,13,0,1,"public static WebProxy resolve(String url) {

		Config config = Config.getInstance();
		int proxyMode = config.getProxyMode();
		if (proxyMode == 1) {
			try {
				String pacUrl = config.getProxyPac();
				AutoProxyHandler pacHandler = AutoProxyHandler.getInstance();
				String pacUrl2 = pacHandler.getPacUrl();
				if (pacUrl2 == null || pacUrl2.compareTo(pacUrl) != 0) {
					pacHandler.setPacUrl(pacUrl);
				}
				return pacHandler.getProxyForUrl(url);
			} catch (Exception e) {
				return null;
			}
		}
		if (proxyMode == 2) {
			if (config.getProxyHost() == null || config.getProxyHost().length() < 1) {
				return null;
			}
			if (config.getProxyPort() < 1) {
				return null;
			}
			return new WebProxy(config.getProxyHost(), config.getProxyPort());
		}
		if (proxyMode == 3) {
			if (config.getSocksHost() == null || config.getSocksHost().length() < 1) {
				return null;
			}
			if (config.getSocksPort() < 1) {
				return null;
			}
			WebProxy wp = new WebProxy(config.getSocksHost(), config.getSocksPort());
			wp.setSocks(true);
			return wp;
		}
		return null;
	}"
xdman,xdman.network.SocketFactory,wrapSSL,,10,17,13,4,0.2381,0.09,0.666666667,5,2,0,1,"// private static SSLContext sslContext;

	public static SSLSocket wrapSSL(Socket socket, String host, int port) throws NetworkException {
		try {
			SSLSocket sock2 = (SSLSocket) (HttpContext.getInstance().getSSLContext().getSocketFactory())
					.createSocket(socket, host, port, true);
			sock2.startHandshake();
			return sock2;
		} catch (IOException e) {
			throw new NetworkException(""Https connection failed: "" + host + "":"" + port);
		}
	}"
xdman,xdman.network.SocketFactory,createSocket,,13,33,11,4,0.1948,0.2265,0.666666667,4,2,0,1,"public static Socket createSocket(String host, int port) throws HostUnreachableException {
		try {
			Socket sock = new Socket();
			sock.setSoTimeout(Config.getInstance().getNetworkTimeout()*1000);
			sock.setTcpNoDelay(true);
			sock.setReceiveBufferSize(tcpBufSize);
			sock.setSoLinger(false, 0);
			sock.connect(new InetSocketAddress(host, port));
			return sock;
		} catch (IOException e) {
			throw new HostUnreachableException(""Unable to connect to: "" + host + "":"" + port);
		}
	}"
xdman,xdman.network.AutoProxyHandler,findProxyForUrl,,12,30,24,5,0.1852,0.0894,0,4,4,0,1,"private ProxyInfo findProxyForUrl(String url, String host)
			throws NoSuchMethodException, ScriptException, IOException {
		if (!pacLoaded) {
			loadPac();
		}
		Object localObject = ((Invocable) engine).invokeFunction(""FindProxyForURL"", new Object[] { url, host });
		System.out.println(localObject);
		ProxyInfo[] arr = extractAutoProxySetting((String) localObject);
		if (arr == null || arr.length < 1)
			return null;
		return arr[0];
	}"
xdman,xdman.network.AutoProxyHandler,extractAutoProxySetting,,23,97,58,3,0.2279,0.1117,1,6,5,0,1,"private final ProxyInfo[] extractAutoProxySetting(String paramString) {
		if (paramString != null) {
			StringTokenizer localStringTokenizer = new StringTokenizer(paramString, "";"", false);
			ProxyInfo[] arrayOfProxyInfo = new ProxyInfo[localStringTokenizer.countTokens()];
			int i = 0;
			while (localStringTokenizer.hasMoreTokens()) {
				String str = localStringTokenizer.nextToken();
				int j = str.indexOf(""PROXY"");
				if (j != -1) {
					arrayOfProxyInfo[(i++)] = new ProxyInfo(str.substring(j + 6));
				} else {
					j = str.indexOf(""SOCKS"");
					if (j != -1) {
						arrayOfProxyInfo[(i++)] = new ProxyInfo(null, str.substring(j + 6));
					} else {
						arrayOfProxyInfo[(i++)] = new ProxyInfo(null, -1);
					}
				}
			}
			return arrayOfProxyInfo;
		}
		return new ProxyInfo[] { new ProxyInfo(null) };
	}"
xdman,xdman.network.AutoProxyHandler,loadPacScript,,15,45,35,4,0.2121,0.0815,1,4,3,0,1,"private String loadPacScript() throws IOException {
		Logger.log(""Loading PAC script"");
		InputStream pacStram = new URL(pacUrl).openStream();
		StringBuilder sb = new StringBuilder();
		byte[] buf = new byte[512];
		while (true) {
			int x = pacStram.read(buf);
			if (x == -1) {
				break;
			}
			sb.append(new String(buf, 0, x));
		}
		Logger.log(""Done loading PAC script"");
		return sb.toString();
	}"
xdman,xdman.network.AutoProxyHandler,loadPac,,9,27,26,5,0.1667,0.0278,0,1,2,0,1,"private void loadPac() throws IOException, ScriptException {
		if (!init) {
			init();
			init = true;
		}
		String pacScript = loadPacScript();
		engine.eval(pacScript);
		pacLoaded = true;
	}"
xdman,xdman.network.AutoProxyHandler,init,,47,336,111,5,0.1471,0.319,1,24,50,1,1,"private void init() throws ScriptException, IOException {
		Logger.log(""Initializing PAC Handler"");
		ScriptEngineManager mgr = new ScriptEngineManager(null);
		engine = mgr.getEngineByName(""js"");
		engine.put(""obj"", this);

		this.autoProxyScript = new StringBuffer();
		this.autoProxyScript.append(
				""var _mon = new Array('JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC');\nvar _day = new Array('SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT');\nfunction _isGmt(i) {\n return typeof i == 'string' && i == 'GMT'; }"");
		this.autoProxyScript.append(
				""function dnsDomainIs(host, domain) {\nif (domain != null && domain.charAt(0) != '.')\nreturn shExpMatch(host, domain);\nreturn shExpMatch(host, '*' + domain); }"");
		this.autoProxyScript.append(""function isPlainHostName(host){\nreturn (dnsDomainLevels(host) == 0); }"");
		this.autoProxyScript.append(
				""function convert_addr(ipchars) {\n    var bytes = ipchars.split('.');\n    var result = ((bytes[0] & 0xff) << 24) |\n                 ((bytes[1] & 0xff) << 16) |\n                 ((bytes[2] & 0xff) <<  8) |\n                  (bytes[3] & 0xff);\n    return result;\n}\n"");
		this.autoProxyScript.append(
				""function isInNet(ipaddr, pattern, maskstr) {\n    var ipPattern = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\n    var test = ipaddr.match(ipPattern);\n    if (test == null) {\n        ipaddr = dnsResolve(ipaddr);\n        if (ipaddr == null)\n            return false;\n    } else if ((test[1] > 255) || (test[2] > 255) || \n               (test[3] > 255) || (test[4] > 255) ) {\n        return false;\n    }\n    var host = convert_addr(ipaddr);\n    var pat  = convert_addr(pattern);\n    var mask = convert_addr(maskstr);\n    return ((host & mask) == (pat & mask));\n    \n}\n"");
		this.autoProxyScript.append(""function dnsResolve(host){\n return String(obj.dnsResolve(host));\n }"");
		this.autoProxyScript.append(""function isResolvable(host){\nreturn (dnsResolve(host) != ''); }"");
		this.autoProxyScript
				.append(""function localHostOrDomainIs(host, hostdom){\nreturn shExpMatch(hostdom, host + '*'); }"");
		this.autoProxyScript.append(
				""function dnsDomainLevels(host){\nvar s = host + '';\nfor (var i=0, j=0; i < s.length; i++)\nif (s.charAt(i) == '.')\nj++;\nreturn j; }"");
		this.autoProxyScript.append(""function myIpAddress(){\nreturn '"");
		try {
			InetAddress localInetAddress = InetAddress.getLocalHost();
			this.autoProxyScript.append(localInetAddress.getHostAddress());
		} catch (Throwable localThrowable) {
			localThrowable.printStackTrace();
			this.autoProxyScript.append(""127.0.0.1"");
		}
		this.autoProxyScript.append(""'; }"");
		this.autoProxyScript.append(
				""function shExpMatch(str, shexp){ \n if (typeof str != 'string' || typeof shexp != 'string') return false; \n if (shexp == '*') return true; \n if (str == '' && shexp == '') return true; \n str = str.toLowerCase();\n shexp = shexp.toLowerCase();\n var index = shexp.indexOf('*');\n if (index == -1) { return (str == shexp); } \n else if (index == 0) { \n for (var i=0; i <= str.length; i++) { \n if (shExpMatch(str.substring(i), shexp.substring(1))) return true; \n } return false; } \nelse { \nvar sub = null, sub2 = null; \nsub = shexp.substring(0, index);\nif (index <= str.length) sub2 = str.substring(0, index); \nif (sub != '' && sub2 != '' && sub == sub2) { \nreturn shExpMatch(str.substring(index), shexp.substring(index)); }\nelse { return false; }\n} }"");
		this.autoProxyScript.append(
				""function _dateRange(day1, month1, year1, day2, month2, year2, gmt){\nif (typeof day1 != 'number' || day1 <= 0 || typeof month1 != 'string' || typeof year1 != 'number' || year1 <= 0\n || typeof day2 != 'number' || day2 <= 0 || typeof month2 != 'string' || typeof year2 != 'number' || year2 <= 0\n || typeof gmt != 'boolean') return false; \nvar m1 = -1, m2 = -1;\nfor (var i=0; i < _mon.length; i++){\nif (_mon[i] == month1)\nm1 = i;\nif (_mon[i] == month2)\nm2 = i;\n}\nvar cur = new Date();\nvar d1 = new Date(year1, m1, day1, 0, 0, 0);\nvar d2 = new Date(year2, m2, day2, 23, 59, 59);\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);\nreturn ((d1.getTime() <= cur.getTime()) && (cur.getTime() <= d2.getTime()));\n}\nfunction dateRange(p1, p2, p3, p4, p5, p6, p7){\nvar cur = new Date();\nif (typeof p1 == 'undefined')\nreturn false;\nelse if (typeof p2 == 'undefined' || _isGmt(p2))\n{\nif ((typeof p1) == 'string')\nreturn _dateRange(1, p1, cur.getFullYear(), 31, p1, cur.getFullYear(), _isGmt(p2));\nelse if (typeof p1 == 'number' && p1 > 31)\nreturn _dateRange(1, 'JAN', p1, 31, 'DEC', p1, _isGmt(p2));\nelse {\nfor (var i=0; i < _mon.length; i++)\nif (_dateRange(p1, _mon[i], cur.getFullYear(), p1, _mon[i], cur.getFullYear(), _isGmt(p2)))\n return true;\nreturn false;\n}\n}\nelse if (typeof p3 == 'undefined' || _isGmt(p3))\n{\nif ((typeof p1) == 'string')\nreturn _dateRange(1, p1, cur.getFullYear(), 31, p2, cur.getFullYear(), _isGmt(p3));\nelse if (typeof p1 == 'number' && typeof p2 == 'number' && (p1 > 31 || p2 > 31))\nreturn _dateRange(1, 'JAN', p1, 31, 'DEC', p2, _isGmt(p3));\nelse \n{\nif ((typeof p2) == 'string')\n{\nreturn _dateRange(p1, p2, cur.getFullYear(), p1, p2, cur.getFullYear(), _isGmt(p3));\n}\nelse \n{\nfor (var i=0; i < _mon.length; i++)\nif (_dateRange(p1, _mon[i], cur.getFullYear(), p2, _mon[i], cur.getFullYear(), _isGmt(p3)))\nreturn true;\nreturn false;\n}\n}\n}\nelse if (typeof p4 == 'undefined' || _isGmt(p4))\nreturn _dateRange(p1, p2, p3, p1, p2, p3, _isGmt(p4));\nelse if (typeof p5 == 'undefined' || _isGmt(p5))\n{\nif (typeof p2 == 'number')\nreturn _dateRange(1, p1, p2, 31, p3, p4, _isGmt(p5));\nelse \nreturn _dateRange(p1, p2, cur.getFullYear(), p3, p4, cur.getFullYear(), _isGmt(p5))\n}\nelse if (typeof p6 == 'undefined')\nreturn false;\nelse \nreturn _dateRange(p1, p2, p3, p4, p5, p6, _isGmt(p7));\n}"");
		this.autoProxyScript.append(
				""function timeRange(p1, p2, p3, p4, p5, p6, p7) {\nif (typeof p1 == 'undefined')\nreturn false;\nelse if (typeof p2 == 'undefined' || _isGmt(p2))\nreturn _timeRange(p1, 0, 0, p1, 59, 59, _isGmt(p2));\nelse if (typeof p3 == 'undefined' || _isGmt(p3))\nreturn _timeRange(p1, 0, 0, p2, 0, 0, _isGmt(p3));\nelse if (typeof p4 == 'undefined')\nreturn false;\nelse if (typeof p5 == 'undefined' || _isGmt(p5))\nreturn _timeRange(p1, p2, 0, p3, p4, 0, _isGmt(p5));\nelse if (typeof p6 == 'undefined')\nreturn false;\nelse \nreturn _timeRange(p1, p2, p3, p4, p5, p6, _isGmt(p7));\n}\nfunction _timeRange(hour1, min1, sec1, hour2, min2, sec2, gmt) {\nif (typeof hour1 != 'number' || typeof min1 != 'number' || typeof sec1 != 'number' \n|| hour1 < 0 || min1 < 0 || sec1 < 0 \n|| typeof hour2 != 'number' || typeof min2 != 'number' || typeof sec2 != 'number' \n|| hour2 < 0 || min2 < 0 || sec2 < 0 \n|| typeof gmt != 'boolean')  return false; \nvar cur = new Date();\nvar d1 = new Date();\nvar d2 = new Date();\nd1.setHours(hour1);\nd1.setMinutes(min1);\nd1.setSeconds(sec1);\nd2.setHours(hour2);\nd2.setMinutes(min2);\nd2.setSeconds(sec2);\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);\nreturn ((d1.getTime() <= cur.getTime()) && (cur.getTime() <= d2.getTime()));\n}"");
		this.autoProxyScript.append(
				""function weekdayRange(wd1, wd2, gmt){\nif (typeof wd1 == 'undefined') \nreturn false;\nelse if (typeof wd2 == 'undefined' || _isGmt(wd2)) \nreturn _weekdayRange(wd1, wd1, _isGmt(wd2)); \nelse \nreturn _weekdayRange(wd1, wd2, _isGmt(gmt)); }\nfunction _weekdayRange(wd1, wd2, gmt) {\nif (typeof wd1 != 'string' || typeof wd2 != 'string' || typeof gmt != 'boolean') return false; \nvar w1 = -1, w2 = -1;\nfor (var i=0; i < _day.length; i++) {\nif (_day[i] == wd1)\nw1 = i;\nif (_day[i] == wd2)\nw2 = i; }\nvar cur = new Date();\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);\nvar w3 = cur.getDay();\nif (w1 > w2)\nw2 = w2 + 7;\nif (w1 > w3)\nw3 = w3 + 7;\nreturn (w1 <= w3 && w3 <= w2); }"");
		this.autoProxyScript.append("" function alert() {} "");
		Logger.log(""Executing builtin PAC functions"");
		engine.eval(this.autoProxyScript.toString());
		ScriptEngineFactory sef = engine.getFactory();
		System.out.println(sef.getMethodCallSyntax(""obj"", ""dnsResolve"", ""string""));
		engine.eval(""obj.dnsResolve('')"");
		Logger.log(""Done executing builtin PAC functions"");
	}"
xdman,xdman.network.AutoProxyHandler,dnsResolve,,9,12,9,4,0.2778,0.1389,0,3,2,0,1,"public String dnsResolve(String paramString) {
		String str = """";
		try {
			str = InetAddress.getByName(paramString).getHostAddress();
		} catch (UnknownHostException localUnknownHostException) {
			localUnknownHostException.printStackTrace();
		}
		return str;
	}"
xdman,xdman.network.ParsedURL,parse,,24,71,0,4,0.1869,0.1902,1,5,5,0,1,"public static ParsedURL parse(String urlString) {
		try {
			URL url = new URL(urlString);
			ParsedURL parsedURL = new ParsedURL();
			parsedURL._url = urlString;
			parsedURL.host = url.getHost();
			parsedURL.port = url.getPort();
			if (parsedURL.port < 0) {
				parsedURL.port = url.getDefaultPort();
			}
			parsedURL.protocol = url.getProtocol();
			parsedURL.pathAndQuery = url.getPath();
			if (StringUtils.isNullOrEmptyOrBlank(parsedURL.pathAndQuery)) {
				parsedURL.pathAndQuery = ""/"";
			}
			String query = url.getQuery();
			if (!StringUtils.isNullOrEmptyOrBlank(query)) {
				parsedURL.pathAndQuery += ""?"" + query;
			}
			return parsedURL;
		} catch (Exception e) {
			return null;
		}
	}"
xdman,xdman.network.ProxyInfo,ProxyInfo,,31,71,0,3,0.21,0.2809,0,11,10,0,1,"public ProxyInfo(String paramString1, String paramString2) {
		int i;
		if (paramString1 != null) {
			i = paramString1.indexOf(""//"");
			if (i >= 0) {
				paramString1 = paramString1.substring(i + 2);
			}
			i = paramString1.lastIndexOf(':');
			if (i >= 0) {
				this.proxy = paramString1.substring(0, i);
				try {
					this.port = Integer.parseInt(paramString1.substring(i + 1).trim());
				} catch (Exception localException1) {
				}
			} else if (!paramString1.equals("""")) {
				this.proxy = paramString1;
			}
		}
		if (paramString2 != null) {
			i = paramString2.lastIndexOf(':');
			if (i >= 0) {
				this.socksProxy = paramString2.substring(0, i);
				try {
					this.socksPort = Integer.parseInt(paramString2.substring(i + 1).trim());
				} catch (Exception localException2) {
				}
			} else if (!paramString2.equals("""")) {
				this.socksProxy = paramString2;
			}
		}
	}"
xdman,xdman.network.ProxyInfo,toString,,9,13,11,4,0.25,0.0714,0,6,3,0,1,"public String toString() {
		if (this.proxy != null) {
			return this.proxy + "":"" + this.port;
		}
		if (this.socksProxy != null) {
			return this.socksProxy + "":"" + this.socksPort;
		}
		return ""DIRECT"";
	}"
xdman,xdman.network.ProxyInfo,isDirect,,9,6,6,4,0.25,0,0,2,3,0,1,"public boolean isDirect() {
		if (this.proxy != null) {
			return false;
		}
		if (this.socksProxy != null) {
			return false;
		}
		return true;
	}"
xdman,xdman.network.http.HeaderCollection,containsHeader,,9,8,6,3,0.35,0.1019,1,3,3,0,1,"public boolean containsHeader(String name) {
		for (int i = 0; i < headers.size(); i++) {
			HttpHeader header = headers.get(i);
			if (header.getName().equalsIgnoreCase(name)) {
				return true;
			}
		}
		return false;
	}"
xdman,xdman.network.http.HeaderCollection,appendToBuffer,,6,8,6,3,0.35,0.1019,0.5,3,2,0,1,"public void appendToBuffer(StringBuffer buf) {
		for (int i = 0; i < headers.size(); i++) {
			HttpHeader header = headers.get(i);
			buf.append(header.getName() + "": "" + header.getValue() + ""\r\n"");
		}
	}"
xdman,xdman.network.http.HeaderCollection,loadFromStream,,14,29,13,3,0.2111,0.1205,1,6,4,0,1,"public void loadFromStream(InputStream inStream) throws IOException {
		while (true) {
			String ln = NetUtils.readLine(inStream);
			if (ln.length() < 1)
				break;
			int index = ln.indexOf("":"");
			if (index > 0) {
				String key = ln.substring(0, index).trim();
				String value = ln.substring(index + 1).trim();
				HttpHeader header = new HttpHeader(key, value);
				headers.add(header);
			}
		}
	}"
xdman,xdman.network.http.HttpContext,init,,107,1363,1348,44,0.0425,0.0157,0.5,20,4,0,1,"public void init() {
		if (!init) {
			Logger.log(""Context initialized"");
			System.setProperty(""http.auth.preference"", ""ntlm"");
			try {
				try {
					// sslContext = SSLContext.getInstance(""SSLv3"");
					sslContext = SSLContext.getInstance(""TLS"");
				} catch (Exception e) {
					e.printStackTrace();
					sslContext = SSLContext.getInstance(""SSL"");
				}

				TrustManager[] trustAllCerts = new TrustManager[] { new X509ExtendedTrustManager() {

					@Override
					public void checkClientTrusted(X509Certificate[] chain, String authType)
							throws CertificateException {
						// TODO Auto-generated method stub

					}

					@Override
					public void checkServerTrusted(X509Certificate[] chain, String authType)
							throws CertificateException {
						// TODO Auto-generated method stub

					}

					@Override
					public X509Certificate[] getAcceptedIssuers() {
						// TODO Auto-generated method stub
						return null;
					}

					@Override
					public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)
							throws CertificateException {
						// TODO Auto-generated method stub

					}

					@Override
					public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
							throws CertificateException {
						// TODO Auto-generated method stub

					}

					@Override
					public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)
							throws CertificateException {
						// TODO Auto-generated method stub

					}

					@Override
					public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
							throws CertificateException {
						// TODO Auto-generated method stub

					}
				} };

				// TrustManager[] trustAllCerts = new TrustManager[] { new
				// X509TrustManager() {
				// public java.security.cert.X509Certificate[]
				// getAcceptedIssuers() {
				// return new java.security.cert.X509Certificate[] {};
				// }
				//
				// public void checkClientTrusted(X509Certificate[] chain,
				// String authType)
				// throws CertificateException {
				// }
				//
				// public void checkServerTrusted(X509Certificate[] chain,
				// String authType)
				// throws CertificateException {
				// }
				// } };
				sslContext.init(null, trustAllCerts, new SecureRandom());
				HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
			} catch (Exception e) {
				Logger.log(e);
			}

			Authenticator.setDefault(new Authenticator() {
				protected PasswordAuthentication getPasswordAuthentication() {
					System.out.println(""Called on "" + getRequestorType() + "" scheme: "" + getRequestingScheme()
							+ "" host: "" + getRequestingHost() + "" url: "" + getRequestingURL() + "" prompt: ""
							+ getRequestingPrompt());
					if (getRequestorType() == RequestorType.SERVER) {

						PasswordAuthentication pauth = CredentialManager.getInstance()
								.getCredentialForHost(getRequestingHost());
						return pauth;
					} else {
						return CredentialManager.getInstance().getCredentialForProxy();
					} // return new
						// PasswordAuthentication(credentialMgr.getUser(),
						// credentialMgr.getPass().toCharArray());
				}
			});
			init = true;
		}
	}"
xdman,xdman.network.http.XDMHttpClient,isFinished,,7,6,6,4,0.25,0,1,1,2,0,1,"public boolean isFinished() {
		try {
			return (in.isStreamFinished() && keepAliveSupported);
		} catch (Exception e) {
		}
		return false;
	}"
xdman,xdman.network.http.XDMHttpClient,dispose,,19,26,24,6,0.1667,0.0741,1,3,6,0,1,"@Override
	public void dispose() {
		if (closed)
			return;
		closed = true;
		try {
			if (in.isStreamFinished() && keepAliveSupported) {
				releaseSocket();
				return;
			}
		} catch (Exception e) {

		}
		try {
			this.socket.close();
		} catch (Exception e) {

		}
	}"
xdman,xdman.network.http.XDMHttpClient,connect,,66,1035,942,9,0.0551,0.0387,0.5,17,9,1,1,"@Override
	public void connect() throws IOException {
		try {
			int port = _url.getPort();
			String portStr = (port == 80 || port == 443) ? """" : "":"" + port;
			requestHeaders.setValue(""host"", _url.getHost() + portStr);
			Socket sock = KeepAliveConnectionCache.getInstance().getReusableSocket(_url.getHost(), _url.getPort());
			boolean reusing = false;
			if (sock == null) {
				Logger.log(""Creating new socket"");
				this.socket = createSocket();
			} else {
				reusing = true;
				Logger.log(""Reusing existing socket"");
				this.socket = sock;
			}
			OutputStream sockOut = socket.getOutputStream();
			InputStream sockIn = socket.getInputStream();
			String reqLine = ""GET "" + _url.getPathAndQuery() + "" HTTP/1.1"";
			StringBuffer reqBuf = new StringBuffer();
			reqBuf.append(reqLine + ""\r\n"");
			requestHeaders.appendToBuffer(reqBuf);
			reqBuf.append(""\r\n"");

			Logger.log(""Sending request:\n"" + reqBuf);

			sockOut.write(StringUtils.getBytes(reqBuf));
			sockOut.flush();
			statusLine = NetUtils.readLine(sockIn);

			String[] arr = statusLine.split("" "");
			this.statusCode = Integer.parseInt(arr[1].trim());
			if (arr.length > 2) {
				this.statusMessage = arr[2].trim();
			} else {
				this.statusMessage = """";
			}

			Logger.log(statusLine);

			responseHeaders.loadFromStream(sockIn);
			length = NetUtils.getContentLength(responseHeaders);

			in = new FixedRangeInputStream(NetUtils.getInputStream(responseHeaders, socket.getInputStream()), length);

			StringBuffer b2 = new StringBuffer();
			responseHeaders.appendToBuffer(b2);
			if (reusing) {
				Logger.log(""Socket reuse successfull"");
			}
			Logger.log(b2);

			// if (statusCode == 401 || statusCode == 407) {
			// throw new JavaClientRequiredException();
			// }

			keepAliveSupported = !""close"".equals(responseHeaders.getValue(""connection""));

		} catch (HostUnreachableException e) {
			e.printStackTrace();
			throw new NetworkException(""Unable to connect to server"");
		} catch (Exception e) {
			e.printStackTrace();
			throw new NetworkException(e.getMessage());
		}
	}"
xdman,xdman.network.http.ChunkedInputStream,read,,23,80,69,7,0.1349,0.0569,0,4,7,0,1,"/**
	 * <p>
	 * Returns all the data in a chunked stream in coalesced form. A chunk is
	 * followed by a CRLF. The method returns -1 as soon as a chunksize of 0 is
	 * detected.
	 * </p>
	 * 
	 * <p>
	 * Trailer headers are read automatically at the end of the stream and can
	 * be obtained with the getResponseFooters() method.
	 * </p>
	 * 
	 * @return -1 of the end of the stream has been reached or the next data
	 *         byte
	 * @throws IOException
	 *             in case of an I/O error
	 */
	public int read() throws IOException {
		if (this.closed) {
			throw new IOException(""Attempted read from closed stream."");
		}
		if (this.eof) {
			
			return -1;
		}
		if (state != CHUNK_DATA) {
			nextChunk();
			if (this.eof) {
				return -1;
			}
		}
		int b = in.read();
		if (b != -1) {
			pos++;
			if (pos >= chunkSize) {
				state = CHUNK_CRLF;
			}
		}
		return b;
	}"
xdman,xdman.network.http.ChunkedInputStream,read,,30,69,47,4,0.1607,0.1021,0,4,7,0,1,"/**
	 * Read some bytes from the stream.
	 * 
	 * @param b
	 *            The byte array that will hold the contents from the stream.
	 * @param off
	 *            The offset into the byte array at which bytes will start to be
	 *            placed.
	 * @param len
	 *            the maximum number of bytes that can be returned.
	 * @return The number of bytes returned or -1 if the end of stream has been
	 *         reached.
	 * @throws IOException
	 *             in case of an I/O error
	 */
	public int read(byte[] b, int off, int len) throws IOException {

		if (closed) {
			throw new IOException(""Attempted read from closed stream."");
		}

		if (eof) {
			return -1;
		}
		if (state != CHUNK_DATA) {
			nextChunk();
			if (eof) {
				return -1;
			}
		}
		len = Math.min(len, chunkSize - pos);
		int bytesRead = in.read(b, off, len);
		if (bytesRead != -1) {
			pos += bytesRead;
			if (pos >= chunkSize) {
				state = CHUNK_CRLF;
			}
			return bytesRead;
		} else {
			eof = true;
			throw new IllegalArgumentException(""Truncated chunk ""
					+ ""( expected size: "" + chunkSize + ""; actual size: "" + pos
					+ "")"");
		}
	}"
xdman,xdman.network.http.ChunkedInputStream,nextChunk,,12,42,39,8,0.14,0.0769,0,0,3,0,1,"/**
	 * Read the next chunk.
	 * 
	 * @throws IOException
	 *             in case of an I/O error
	 */
	private void nextChunk() throws IOException {
		chunkSize = getChunkSize();
		if (chunkSize < 0) {
			throw new IllegalArgumentException(""Negative chunk size"");
		}
		state = CHUNK_DATA;
		pos = 0;
		if (chunkSize == 0) {
			eof = true;
			parseTrailerHeaders();
		}
	}"
xdman,xdman.network.http.ChunkedInputStream,parseTrailerHeaders,,11,11,7,3,0.3333,0.1429,0,2,4,0,1,"/**
	 * Reads and stores the Trailer headers.
	 * 
	 * @throws IOException
	 *             in case of an I/O error
	 */
	private void parseTrailerHeaders() throws IOException {
		while (true) {
			StringBuffer buf = new StringBuffer();
			int i = readLine(in, buf);
			if (i == -1)
				break;
			if (buf.length() < 1) {
				break;
			}
		}
	}"
xdman,xdman.network.http.ChunkedInputStream,close,,15,31,26,5,0.2593,0.1061,0,1,4,0,1,"/**
	 * Upon close, this reads the remainder of the chunked message, leaving the
	 * underlying socket at a position to start reading the next response
	 * without scanning.
	 * 
	 * @throws IOException
	 *             in case of an I/O error
	 */
	public void close() throws IOException {
		if (!closed) {
			try {
				if (!eof) {
					// read and discard the remainder of the message
					byte buffer[] = new byte[BUFFER_SIZE];
					while (read(buffer) >= 0) {
					}
				}
			} finally {
				eof = true;
				closed = true;
			}
		}
	}"
xdman,xdman.network.http.ChunkedInputStream,readLine,,21,43,20,3,0.2917,0.2026,0,4,8,0,1,"public static final int readLine(InputStream in, StringBuffer buf)
			throws IOException {
		boolean gotCR = false;
		while (true) {
			int x = in.read();
			if (x == -1)
				return (buf.length() > 0 ? buf.length() : -1);
			if (x == '\n') {
				if (gotCR) {
					return buf.length();
				}
			}
			if (x == '\r') {
				gotCR = true;
			} else {
				gotCR = false;
			}
			if (x != '\r')
				buf.append((char) x);
		}
	}"
xdman,xdman.network.http.JavaHttpClient,connect,,41,355,304,5,0.0733,0.0443,0.454545455,16,7,0,1,"public void connect() throws IOException {
		HttpContext.getInstance().init();
		WebProxy webproxy = ProxyResolver.resolve(_url);
		URL url = new URL(_url);
		this.realURL = url;
		if (webproxy != null) {
			Proxy proxy = new Proxy(webproxy.isSocks() ? Proxy.Type.SOCKS : Proxy.Type.HTTP,
					new InetSocketAddress(webproxy.getHost(), webproxy.getPort()));
			hc = (HttpURLConnection) url.openConnection(proxy);
		} else {
			hc = (HttpURLConnection) url.openConnection();
		}
		Iterator<HttpHeader> headers = requestHeaders.getAll();
		while (headers.hasNext()) {
			HttpHeader header = headers.next();
			hc.addRequestProperty(header.getName(), header.getValue());
		}
		hc.setInstanceFollowRedirects(false);

		// System.out
		// .println(hc.getResponseCode() + "" "" + hc.getResponseMessage());

		this.statusCode = hc.getResponseCode();
		this.statusMessage = hc.getResponseMessage();

		Map<String, List<String>> responseHeaderMap = hc.getHeaderFields();

		Iterator<String> headerIterator = responseHeaderMap.keySet().iterator();
		while (headerIterator.hasNext()) {
			String key = headerIterator.next();
			if (key == null)
				continue;
			List<String> headerValues = responseHeaderMap.get(key);
			Iterator<String> headerValueIterator = headerValues.iterator();
			while (headerValueIterator.hasNext()) {
				String value = headerValueIterator.next();
				HttpHeader header = new HttpHeader(key, value);
				this.responseHeaders.addHeader(header);
			}
		}
	}"
xdman,xdman.network.http.HttpHeader,parse,,8,13,5,3,0.3429,0.155,0,4,2,0,1,"public static HttpHeader parse(String str) {
		int index = str.indexOf("":"");
		if (index < 0)
			return null;
		String key = str.substring(0, index);
		String val = str.substring(index + 1);
		return new HttpHeader(key, val);
	}"
xdman,xdman.network.http.proxy.XDMAutoProxyHandler,dnsResolve,,9,12,9,4,0.2778,0.1389,0,3,2,0,1,"public String dnsResolve(String paramString) {
		String str = """";
		try {
			str = InetAddress.getByName(paramString).getHostAddress();
		} catch (UnknownHostException localUnknownHostException) {
			localUnknownHostException.printStackTrace();
		}
		return str;
	}"
xdman,xdman.network.http.proxy.AutoProxyResolver,init,,8,8,1,2,0.3333,0.2444,0.6,2,1,0,1,"private static void init(String pacURL) throws Exception {
		BrowserProxyInfo b = new BrowserProxyInfo();
		b.setType(2);
		b.setAutoConfigURL(pacURL);
		handler = new XDMAutoProxyHandler();
		handler.init(b);

	}"
xdman,xdman.network.http.proxy.ProxyInfo,ProxyInfo,,42,206,87,9,0.1615,0.1788,0,11,10,0,1,"public ProxyInfo(String paramString1, String paramString2)
  {
    int i;
    if (paramString1 != null)
    {
      i = paramString1.indexOf(""//"");
      if (i >= 0) {
        paramString1 = paramString1.substring(i + 2);
      }
      i = paramString1.lastIndexOf(':');
      if (i >= 0)
      {
        this.proxy = paramString1.substring(0, i);
        try
        {
          this.port = Integer.parseInt(paramString1.substring(i + 1).trim());
        }
        catch (Exception localException1) {}
      }
      else if (!paramString1.equals(""""))
      {
        this.proxy = paramString1;
      }
    }
    if (paramString2 != null)
    {
      i = paramString2.lastIndexOf(':');
      if (i >= 0)
      {
        this.socksProxy = paramString2.substring(0, i);
        try
        {
          this.socksPort = Integer.parseInt(paramString2.substring(i + 1).trim());
        }
        catch (Exception localException2) {}
      }
      else if (!paramString2.equals(""""))
      {
        this.socksProxy = paramString2;
      }
    }
  }"
xdman,xdman.network.http.proxy.ProxyInfo,toString,,10,13,11,4,0.25,0.0714,0,6,3,0,1,"public String toString()
  {
    if (this.proxy != null) {
      return this.proxy + "":"" + this.port;
    }
    if (this.socksProxy != null) {
      return this.socksProxy + "":"" + this.socksPort;
    }
    return ""DIRECT"";
  }"
xdman,xdman.network.http.proxy.AbstractAutoProxyHandler,init,,60,432,198,5,0.1351,0.2736,0.5,31,54,1,1,"public void init(BrowserProxyInfo paramBrowserProxyInfo) throws Exception {
		// Trace.msgNetPrintln(""net.proxy.loading.auto"");
		if (!isSupported(paramBrowserProxyInfo.getType())) {
			throw new Exception(""Unable to support proxy type: ""
					+ paramBrowserProxyInfo.getType());
		}
		this.bpi = paramBrowserProxyInfo;
		this.autoProxyScript = new StringBuffer();
		this.autoProxyScript
				.append(""var _mon = new Array('JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC');\nvar _day = new Array('SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT');\nfunction _isGmt(i) {\n return typeof i == 'string' && i == 'GMT'; }"");
		this.autoProxyScript
				.append(""function dnsDomainIs(host, domain) {\nif (domain != null && domain.charAt(0) != '.')\nreturn shExpMatch(host, domain);\nreturn shExpMatch(host, '*' + domain); }"");
		this.autoProxyScript
				.append(""function isPlainHostName(host){\nreturn (dnsDomainLevels(host) == 0); }"");
		this.autoProxyScript
				.append(""function convert_addr(ipchars) {\n    var bytes = ipchars.split('.');\n    var result = ((bytes[0] & 0xff) << 24) |\n                 ((bytes[1] & 0xff) << 16) |\n                 ((bytes[2] & 0xff) <<  8) |\n                  (bytes[3] & 0xff);\n    return result;\n}\n"");
		this.autoProxyScript
				.append(""function isInNet(ipaddr, pattern, maskstr) {\n    var ipPattern = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\n    var test = ipaddr.match(ipPattern);\n    if (test == null) {\n        ipaddr = dnsResolve(ipaddr);\n        if (ipaddr == null)\n            return false;\n    } else if ((test[1] > 255) || (test[2] > 255) || \n               (test[3] > 255) || (test[4] > 255) ) {\n        return false;\n    }\n    var host = convert_addr(ipaddr);\n    var pat  = convert_addr(pattern);\n    var mask = convert_addr(maskstr);\n    return ((host & mask) == (pat & mask));\n    \n}\n"");
		this.autoProxyScript.append(getBrowserSpecificAutoProxy());
		this.autoProxyScript
				.append(""function isResolvable(host){\nreturn (dnsResolve(host) != ''); }"");
		this.autoProxyScript
				.append(""function localHostOrDomainIs(host, hostdom){\nreturn shExpMatch(hostdom, host + '*'); }"");
		this.autoProxyScript
				.append(""function dnsDomainLevels(host){\nvar s = host + '';\nfor (var i=0, j=0; i < s.length; i++)\nif (s.charAt(i) == '.')\nj++;\nreturn j; }"");
		this.autoProxyScript.append(""function myIpAddress(){\nreturn '"");
		try {
			InetAddress localInetAddress = InetAddress.getLocalHost();
			this.autoProxyScript.append(localInetAddress.getHostAddress());
		} catch (Throwable localThrowable) {
			localThrowable.printStackTrace();
			this.autoProxyScript.append(""127.0.0.1"");
		}
		this.autoProxyScript.append(""'; }"");
		this.autoProxyScript
				.append(""function shExpMatch(str, shexp){ \n if (typeof str != 'string' || typeof shexp != 'string') return false; \n if (shexp == '*') return true; \n if (str == '' && shexp == '') return true; \n str = str.toLowerCase();\n shexp = shexp.toLowerCase();\n var index = shexp.indexOf('*');\n if (index == -1) { return (str == shexp); } \n else if (index == 0) { \n for (var i=0; i <= str.length; i++) { \n if (shExpMatch(str.substring(i), shexp.substring(1))) return true; \n } return false; } \nelse { \nvar sub = null, sub2 = null; \nsub = shexp.substring(0, index);\nif (index <= str.length) sub2 = str.substring(0, index); \nif (sub != '' && sub2 != '' && sub == sub2) { \nreturn shExpMatch(str.substring(index), shexp.substring(index)); }\nelse { return false; }\n} }"");
		this.autoProxyScript
				.append(""function _dateRange(day1, month1, year1, day2, month2, year2, gmt){\nif (typeof day1 != 'number' || day1 <= 0 || typeof month1 != 'string' || typeof year1 != 'number' || year1 <= 0\n || typeof day2 != 'number' || day2 <= 0 || typeof month2 != 'string' || typeof year2 != 'number' || year2 <= 0\n || typeof gmt != 'boolean') return false; \nvar m1 = -1, m2 = -1;\nfor (var i=0; i < _mon.length; i++){\nif (_mon[i] == month1)\nm1 = i;\nif (_mon[i] == month2)\nm2 = i;\n}\nvar cur = new Date();\nvar d1 = new Date(year1, m1, day1, 0, 0, 0);\nvar d2 = new Date(year2, m2, day2, 23, 59, 59);\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);\nreturn ((d1.getTime() <= cur.getTime()) && (cur.getTime() <= d2.getTime()));\n}\nfunction dateRange(p1, p2, p3, p4, p5, p6, p7){\nvar cur = new Date();\nif (typeof p1 == 'undefined')\nreturn false;\nelse if (typeof p2 == 'undefined' || _isGmt(p2))\n{\nif ((typeof p1) == 'string')\nreturn _dateRange(1, p1, cur.getFullYear(), 31, p1, cur.getFullYear(), _isGmt(p2));\nelse if (typeof p1 == 'number' && p1 > 31)\nreturn _dateRange(1, 'JAN', p1, 31, 'DEC', p1, _isGmt(p2));\nelse {\nfor (var i=0; i < _mon.length; i++)\nif (_dateRange(p1, _mon[i], cur.getFullYear(), p1, _mon[i], cur.getFullYear(), _isGmt(p2)))\n return true;\nreturn false;\n}\n}\nelse if (typeof p3 == 'undefined' || _isGmt(p3))\n{\nif ((typeof p1) == 'string')\nreturn _dateRange(1, p1, cur.getFullYear(), 31, p2, cur.getFullYear(), _isGmt(p3));\nelse if (typeof p1 == 'number' && typeof p2 == 'number' && (p1 > 31 || p2 > 31))\nreturn _dateRange(1, 'JAN', p1, 31, 'DEC', p2, _isGmt(p3));\nelse \n{\nif ((typeof p2) == 'string')\n{\nreturn _dateRange(p1, p2, cur.getFullYear(), p1, p2, cur.getFullYear(), _isGmt(p3));\n}\nelse \n{\nfor (var i=0; i < _mon.length; i++)\nif (_dateRange(p1, _mon[i], cur.getFullYear(), p2, _mon[i], cur.getFullYear(), _isGmt(p3)))\nreturn true;\nreturn false;\n}\n}\n}\nelse if (typeof p4 == 'undefined' || _isGmt(p4))\nreturn _dateRange(p1, p2, p3, p1, p2, p3, _isGmt(p4));\nelse if (typeof p5 == 'undefined' || _isGmt(p5))\n{\nif (typeof p2 == 'number')\nreturn _dateRange(1, p1, p2, 31, p3, p4, _isGmt(p5));\nelse \nreturn _dateRange(p1, p2, cur.getFullYear(), p3, p4, cur.getFullYear(), _isGmt(p5))\n}\nelse if (typeof p6 == 'undefined')\nreturn false;\nelse \nreturn _dateRange(p1, p2, p3, p4, p5, p6, _isGmt(p7));\n}"");
		this.autoProxyScript
				.append(""function timeRange(p1, p2, p3, p4, p5, p6, p7) {\nif (typeof p1 == 'undefined')\nreturn false;\nelse if (typeof p2 == 'undefined' || _isGmt(p2))\nreturn _timeRange(p1, 0, 0, p1, 59, 59, _isGmt(p2));\nelse if (typeof p3 == 'undefined' || _isGmt(p3))\nreturn _timeRange(p1, 0, 0, p2, 0, 0, _isGmt(p3));\nelse if (typeof p4 == 'undefined')\nreturn false;\nelse if (typeof p5 == 'undefined' || _isGmt(p5))\nreturn _timeRange(p1, p2, 0, p3, p4, 0, _isGmt(p5));\nelse if (typeof p6 == 'undefined')\nreturn false;\nelse \nreturn _timeRange(p1, p2, p3, p4, p5, p6, _isGmt(p7));\n}\nfunction _timeRange(hour1, min1, sec1, hour2, min2, sec2, gmt) {\nif (typeof hour1 != 'number' || typeof min1 != 'number' || typeof sec1 != 'number' \n|| hour1 < 0 || min1 < 0 || sec1 < 0 \n|| typeof hour2 != 'number' || typeof min2 != 'number' || typeof sec2 != 'number' \n|| hour2 < 0 || min2 < 0 || sec2 < 0 \n|| typeof gmt != 'boolean')  return false; \nvar cur = new Date();\nvar d1 = new Date();\nvar d2 = new Date();\nd1.setHours(hour1);\nd1.setMinutes(min1);\nd1.setSeconds(sec1);\nd2.setHours(hour2);\nd2.setMinutes(min2);\nd2.setSeconds(sec2);\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);\nreturn ((d1.getTime() <= cur.getTime()) && (cur.getTime() <= d2.getTime()));\n}"");
		this.autoProxyScript
				.append(""function weekdayRange(wd1, wd2, gmt){\nif (typeof wd1 == 'undefined') \nreturn false;\nelse if (typeof wd2 == 'undefined' || _isGmt(wd2)) \nreturn _weekdayRange(wd1, wd1, _isGmt(wd2)); \nelse \nreturn _weekdayRange(wd1, wd2, _isGmt(gmt)); }\nfunction _weekdayRange(wd1, wd2, gmt) {\nif (typeof wd1 != 'string' || typeof wd2 != 'string' || typeof gmt != 'boolean') return false; \nvar w1 = -1, w2 = -1;\nfor (var i=0; i < _day.length; i++) {\nif (_day[i] == wd1)\nw1 = i;\nif (_day[i] == wd2)\nw2 = i; }\nvar cur = new Date();\nif (gmt == true)\ncur = new Date(cur.getTime() - cur.getTimezoneOffset() * 60 * 1000);\nvar w3 = cur.getDay();\nif (w1 > w2)\nw2 = w2 + 7;\nif (w1 > w3)\nw3 = w3 + 7;\nreturn (w1 <= w3 && w3 <= w2); }"");
		this.autoProxyScript.append("" function alert() {} "");
		URL localURL1 = null;
		try {
			localURL1 = new URL(this.bpi.getAutoConfigURL());
		} catch (MalformedURLException localMalformedURLException) {
			throw new Exception(""Auto config URL is malformed"");
		}
		URLConnection localURLConnection = getDirectURLConnection(localURL1);
		if (localURLConnection != null) {
			if (isSupportedINSFile(localURLConnection) == true) {
				URL localURL2 = getAutoConfigURLFromINS(localURLConnection);
				localURLConnection = getDirectURLConnection(localURL2);
			}
			this.jsPacScript = getJSFileFromURL(localURLConnection);
			this.autoProxyScript.append(this.jsPacScript);
			// Trace.msgNetPrintln(""net.proxy.loading.done"");
		}
	}"
xdman,xdman.network.http.proxy.AbstractAutoProxyHandler,isSupportedINSFile,,11,33,21,3,0.3,0.1705,0,4,4,0,1,"private static boolean isSupportedINSFile(URLConnection paramURLConnection) {
		boolean bool = false;
		String str1 = paramURLConnection.getURL().getFile();
		if ((str1 != null) && (str1.toLowerCase().endsWith("".ins"") == true)) {
			bool = true;
		} else if (paramURLConnection != null) {
			String str2 = paramURLConnection.getContentType();
			bool = ""application/x-internet-signup"".equalsIgnoreCase(str2);
		}
		return bool;
	}"
xdman,xdman.network.http.proxy.AbstractAutoProxyHandler,extractAutoProxySetting,,27,132,93,5,0.1675,0.0833,1,6,5,0,1,"protected final ProxyInfo[] extractAutoProxySetting(String paramString) {
		if (paramString != null) {
			StringTokenizer localStringTokenizer = new StringTokenizer(
					paramString, "";"", false);
			ProxyInfo[] arrayOfProxyInfo = new ProxyInfo[localStringTokenizer
					.countTokens()];
			int i = 0;
			while (localStringTokenizer.hasMoreTokens()) {
				String str = localStringTokenizer.nextToken();
				int j = str.indexOf(""PROXY"");
				if (j != -1) {
					arrayOfProxyInfo[(i++)] = new ProxyInfo(str
							.substring(j + 6));
				} else {
					j = str.indexOf(""SOCKS"");
					if (j != -1) {
						arrayOfProxyInfo[(i++)] = new ProxyInfo(null, str
								.substring(j + 6));
					} else {
						arrayOfProxyInfo[(i++)] = new ProxyInfo(null, -1);
					}
				}
			}
			return arrayOfProxyInfo;
		}
		return new ProxyInfo[] { new ProxyInfo(null) };
	}"
xdman,xdman.ui.components.Page,Page,,31,213,173,12,0.0776,0.1278,1,8,1,0,1,"public Page(String title, int width, XDMFrame parent) {
		setOpaque(false);
		setLayout(null);
		this.title = title;
		this.width = width;
		this.parent = parent;
		bgColor = new Color(0, 0, 0, 200);
		MouseInputAdapter ma = new MouseInputAdapter() {
		};

		addMouseListener(ma);
		addMouseMotionListener(ma);

		jsp = new JScrollPane();
		jsp.setOpaque(false);
		jsp.setBorder(null);
		jsp.getViewport().setOpaque(false);

		DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
		jsp.setVerticalScrollBar(scrollBar);
		jsp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		jsp.getVerticalScrollBar().setUnitIncrement(10);
		jsp.getVerticalScrollBar().setBlockIncrement(25);

		add(jsp);

		registerMouseListener();

		init();

	}"
xdman,xdman.ui.components.Page,init,,36,19,2,2,0.2083,0.1537,1,2,1,0,1,"private void init() {
		y = 25;
		h = 40;

		btnNav = new JLabel(ImageResource.get(""back24.png""));
		btnNav.setFont(FontResource.getBiggerFont());
		btnNav.setForeground(ColorResource.getSelectionColor());
		btnNav.setBounds(15, y, 25, h);
		add(btnNav);

		btnNav.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent e) {
				close();
			}
		});

		titleLbl = new JLabel(title);
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(50, y, 200, h);
		add(titleLbl);

		y += h;
		y += 10;
		h = 2;

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, y, width, h);
		lineLbl.setOpaque(true);
		add(lineLbl);

		y += h;

	}"
xdman,xdman.ui.components.PropertiesPage,initUI,,138,6232,4714,3,0.0589,0.0965,1,11,1,0,1,"private void initUI() {
		int y = 0;
		int h = 0;
		JPanel panel = new JPanel();
		panel.setLayout(null);
		panel.setOpaque(false);
		y += 10;
		h = 30;
		JLabel lblFileTitle = new JLabel(StringResource.get(""ND_FILE""));
		lblFileTitle.setForeground(Color.WHITE);
		lblFileTitle.setFont(FontResource.getNormalFont());
		lblFileTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblFileTitle);
		y += h;
		h = 25;
		txtDefFile = new JTextField();
		txtDefFile.setBounds(15, y, 350 - 50, h);
		txtDefFile.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtDefFile.setEditable(false);
		txtDefFile.setForeground(Color.WHITE);
		txtDefFile.setOpaque(false);
		panel.add(txtDefFile);
		y += h;

		h = 30;
		JLabel lblFolderTitle = new JLabel(StringResource.get(""CD_LOC""));
		lblFolderTitle.setForeground(Color.WHITE);
		lblFolderTitle.setFont(FontResource.getNormalFont());
		lblFolderTitle.setBounds(15, y, 350 - 50, h);
		panel.add(lblFolderTitle);
		y += h;
		h = 25;
		txtDefFolder = new JTextField();
		txtDefFolder.setBounds(15, y, 350 - 50, h);
		txtDefFolder.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtDefFolder.setEditable(false);
		txtDefFolder.setForeground(Color.WHITE);
		txtDefFolder.setOpaque(false);
		panel.add(txtDefFolder);
		y += h;

		h = 30;
		JLabel lblUrlTitle = new JLabel(StringResource.get(""ND_ADDRESS""));
		lblUrlTitle.setForeground(Color.WHITE);
		lblUrlTitle.setFont(FontResource.getNormalFont());
		lblUrlTitle.setBounds(15, y, 350 - 50, h);
		panel.add(lblUrlTitle);
		y += h;
		h = 25;
		txtUrl = new JTextField();
		txtUrl.setBounds(15, y, 350 - 50, h);
		txtUrl.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtUrl.setEditable(false);
		txtUrl.setForeground(Color.WHITE);
		txtUrl.setOpaque(false);
		panel.add(txtUrl);
		y += h;

		h = 30;
		JLabel lblSizeLabel = new JLabel(StringResource.get(""PROP_SIZE""));
		lblSizeLabel.setForeground(Color.WHITE);
		lblSizeLabel.setFont(FontResource.getNormalFont());
		lblSizeLabel.setBounds(15, y, 100, h);
		panel.add(lblSizeLabel);

		lblSize = new JLabel();
		lblSize.setForeground(Color.WHITE);
		lblSize.setFont(FontResource.getNormalFont());
		lblSize.setBounds(115, y, 200, h);
		panel.add(lblSize);
		y += h;

		h = 30;
		JLabel lblDateLabel = new JLabel(StringResource.get(""PROP_DATE""));
		lblDateLabel.setForeground(Color.WHITE);
		lblDateLabel.setFont(FontResource.getNormalFont());
		lblDateLabel.setBounds(15, y, 100, h);
		panel.add(lblDateLabel);

		lblDate = new JLabel();
		lblDate.setForeground(Color.WHITE);
		lblDate.setFont(FontResource.getNormalFont());
		lblDate.setBounds(115, y, 200, h);
		panel.add(lblDate);
		y += h;

		h = 30;
		JLabel lblTypeLabel = new JLabel(StringResource.get(""PROP_TYPE""));
		lblTypeLabel.setForeground(Color.WHITE);
		lblTypeLabel.setFont(FontResource.getNormalFont());
		lblTypeLabel.setBounds(15, y, 100, h);
		panel.add(lblTypeLabel);

		lblType = new JLabel();
		lblType.setForeground(Color.WHITE);
		lblType.setFont(FontResource.getNormalFont());
		lblType.setBounds(115, y, 200, h);
		panel.add(lblType);
		y += h;

		h = 30;
		JLabel lblRefererLabel = new JLabel(StringResource.get(""PROP_REFERER""));
		lblRefererLabel.setForeground(Color.WHITE);
		lblRefererLabel.setFont(FontResource.getNormalFont());
		lblRefererLabel.setBounds(15, y, 100, h);
		panel.add(lblRefererLabel);

		lblReferer = new JLabel();
		lblReferer.setForeground(Color.WHITE);
		lblReferer.setFont(FontResource.getNormalFont());
		lblReferer.setBounds(115, y, 200, h);
		panel.add(lblReferer);
		y += h;
		h = 30;
		JLabel lblCookieTitle = new JLabel(StringResource.get(""PROP_COOKIE""));
		lblCookieTitle.setForeground(Color.WHITE);
		lblCookieTitle.setFont(FontResource.getNormalFont());
		lblCookieTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblCookieTitle);
		y += h;
		y += 10;
		h = 120;

		txtCookie = new JTextArea();
		txtCookie.setBounds(15, y, 350 - 50, h);
		txtCookie.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtCookie.setEditable(false);
		txtCookie.setForeground(Color.WHITE);
		txtCookie.setOpaque(false);
		panel.add(txtCookie);
		y += h;
		y += 50;

		panel.setPreferredSize(new Dimension(350, y));
		panel.setBounds(0, 0, 350, y);

		jsp.setViewportView(panel);
	}"
xdman,xdman.ui.components.MediaConversionWnd,progress,,18,64,50,4,0.1692,0.0779,1,5,5,0,1,"@Override
	public void progress(int progress) {
		if (progress >= prg.getMinimum() && progress <= prg.getMaximum()) {
			prg.setValue(progress);
		}

		int prgDiff = progress - lastProgress;
		long now = System.currentTimeMillis();
		long timeSpend = now - prevTime;
		if (timeSpend > 0) {
			if (prgDiff > 0) {
				long eta = (timeSpend * (100 - progress) / 1000 * prgDiff);// prgDiff
				lastProgress = progress;
				statLbl.setText(""ETA: "" + FormatUtilities.hms((int) eta));
			}
			prevTime = now;
		}
	}"
xdman,xdman.ui.components.MediaConversionWnd,actionPerformed,,15,26,16,5,0.3704,0.2424,0,2,5,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() instanceof JComponent) {
			String name = ((JComponent) e.getSource()).getName();
			if (name == null) {
				return;
			}
			if (name.equals(""CLOSE"")) {
				stop();
			}
			if (name.equals(""MIN"")) {
				this.setExtendedState(this.getExtendedState() | JFrame.ICONIFIED);
			}
		}
	}"
xdman,xdman.ui.components.MediaConversionWnd,init,,79,1664,1498,10,0.0516,0.0455,0.875,2,3,1,1,"private void init() {
		setUndecorated(true);

		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
					.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		} catch (Exception e) {
			Logger.log(e);
		}

		setIconImage(ImageResource.get(""icon.png"").getImage());
		setSize(350, 200);
		setLocationRelativeTo(null);
		setResizable(false);

		getContentPane().setLayout(null);
		getContentPane().setBackground(ColorResource.getDarkestBgColor());

		titlePanel = new TitlePanel(null, this);
		titlePanel.setOpaque(false);
		titlePanel.setBounds(0, 0, 350, 50);

		closeBtn = new CustomButton();
		closeBtn.setBounds(320, 5, 24, 24);
		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.setBackground(ColorResource.getDarkestBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""CLOSE"");
		closeBtn.addActionListener(this);

		minBtn = new CustomButton();
		minBtn.setBounds(296, 5, 24, 24);
		minBtn.setIcon(ImageResource.get(""min_btn.png""));
		minBtn.setBackground(ColorResource.getDarkestBgColor());
		minBtn.setBorderPainted(false);
		minBtn.setFocusPainted(false);
		minBtn.setName(""MIN"");
		minBtn.addActionListener(this);

		titleLbl = new JLabel(StringResource.get(""TITLE_CONVERT""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(25, 15, 250, 30);

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, 55, 400, 2);
		lineLbl.setOpaque(true);

		prg = new JProgressBar();
		prg.setBounds(20, 85, 350 - 40, 5);

		statLbl = new JLabel();
		statLbl.setForeground(Color.WHITE);
		statLbl.setBounds(20, 100, 350 - 40, 25);

		titlePanel.add(titleLbl);
		titlePanel.add(minBtn);
		titlePanel.add(closeBtn);

		add(lineLbl);
		add(titlePanel);
		add(prg);
		add(statLbl);

		panel = new JPanel(null);
		panel.setBounds(0, 150, 350, 50);
		panel.setBackground(Color.DARK_GRAY);

		btnCN = new CustomButton(StringResource.get(""MENU_PAUSE""));
		btnCN.setBounds(0, 1, 350, 50);
		btnCN.setName(""CLOSE"");
		applyStyle(btnCN);
		panel.add(btnCN);
		add(panel);
	}"
xdman,xdman.ui.components.MediaConversionWnd,finished,,9,20,19,6,0.1714,0.0185,1,1,2,0,1,"private void finished(int ret) {
		if (ret == 0) {
			dispose();
		} else {
			prg.setVisible(false);
			statLbl.setText(StringResource.get(""LBL_CONV_FAILED""));
			btnCN.setText(StringResource.get(""LBL_CLOSE""));
		}
	}"
xdman,xdman.ui.components.MediaConversionWnd,stop,,11,24,20,5,0.25,0.14,1,1,3,0,1,"private void stop() {
		try {
			if (ffmpeg != null) {
				ffmpeg.stop();
				ffmpeg=null;
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		dispose();
	}"
xdman,xdman.ui.components.SegmentPanel,paintComponent,,37,249,222,11,0.0929,0.0393,0.5,9,7,0,1,"public void paintComponent(Graphics g) {
		if (g == null)
			return;

		Graphics2D g2 = (Graphics2D) g;
		g2.setPaint(Color.GRAY);
		g2.fillRect(0, 0, getWidth(), getHeight());
		if (segDet == null || segDet.getChunkCount() < 1 || length < 0) {
			return;
		}

		g2.setPaint(ColorResource.getSelectionColor());

		float r = (float) getWidth() / length;
		// g2.setPaint(low);// g.setColor(Color.BLACK);
		// g2.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
		ArrayList<SegmentInfo> list = segDet.getChunkUpdates();
		// Logger.log(list.size()+"" r: ""+r+"" width: ""+getWidth()+"" length: ""+length);
		for (int i = 0; i < segDet.getChunkCount(); i++) {
			SegmentInfo info = list.get(i);
			int _start = (int) (info.getStart() * r);
			int _length = (int) (info.getLength() * r);
			int _dwnld = (int) (info.getDownloaded() * r);
			if (_dwnld > _length)
				_dwnld = _length;
			// g2.drawRect(_start, 0, _length, getHeight() - 1);
			g2.fillRect(_start, 0, _dwnld + 1, getHeight());
			// g2.setPaint(low);
			// g2.fillRect(_start, getHeight() / 2, _dwnld + 1, getHeight() -
			// 1);
			// g.setColor(Color.RED);
			// g.drawLine(_start, 0, _start, getHeight() - 1);
			// g.setColor(Color.BLACK);
		}
		// g2.setColor(Color.GRAY);
		// g2.drawRect(0, 0, getWidth() - 1, getHeight() - 1);
	}"
xdman,xdman.ui.components.DownloadCompleteWnd,initUI,,116,3599,3282,10,0.0449,0.0411,0.875,13,3,1,1,"private void initUI(String file, String folder) {
		setUndecorated(true);

		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
					.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		} catch (Exception e) {
			Logger.log(e);
		}

		setIconImage(ImageResource.get(""icon.png"").getImage());

		setSize(350, 210);
		setLocationRelativeTo(null);
		setAlwaysOnTop(true);
		getContentPane().setLayout(null);
		getContentPane().setBackground(ColorResource.getDarkestBgColor());

		JPanel titlePanel = new TitlePanel(null, this);
		titlePanel.setOpaque(false);
		titlePanel.setBounds(0, 0, 350, 50);
		add(titlePanel);

		JButton closeBtn = new CustomButton();
		closeBtn.setBounds(310, 5, 30, 30);
		closeBtn.setBackground(ColorResource.getDarkestBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""CLOSE"");
		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.addActionListener(this);
		titlePanel.add(closeBtn);

		JLabel titleLbl = new JLabel(StringResource.get(""CD_TITLE""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(25, 15, 200, 30);
		titlePanel.add(titleLbl);

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, 55, 350, 1);
		lineLbl.setOpaque(true);
		add(lineLbl);

		JLabel lblFile = new JLabel(StringResource.get(""ND_FILE""), JLabel.RIGHT);
		// lblFile.setVerticalTextPosition(JLabel.CENTER);//VerticalAlignment(JLabel.CENTER);
		lblFile.setBounds(0, 75, 70, 20);
		lblFile.setForeground(Color.WHITE);
		add(lblFile);

		JLabel lblSave = new JLabel(StringResource.get(""CD_LOC""), JLabel.RIGHT);
		lblSave.setBounds(0, 100, 70, 20);
		lblSave.setForeground(Color.WHITE);
		add(lblSave);

		txtFile = new JTextField();
		txtFile.setText(file);
		txtFile.setEditable(false);
		txtFile.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
		txtFile.setBackground(ColorResource.getDarkestBgColor());
		txtFile.setForeground(Color.WHITE);
		txtFile.setBounds(80, 75, 220, 20);
		txtFile.setCaretColor(ColorResource.getSelectionColor());
		add(txtFile);

		txtFolder = new JTextField();
		txtFolder.setText(folder);
		txtFolder.setEditable(false);
		txtFolder.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
		txtFolder.setBackground(ColorResource.getDarkestBgColor());
		txtFolder.setForeground(Color.WHITE);
		txtFolder.setBounds(80, 100, 220, 20);
		txtFolder.setCaretColor(ColorResource.getSelectionColor());
		add(txtFolder);

		chkDontShow = new JCheckBox(StringResource.get(""MSG_DONT_SHOW_AGAIN""));
		chkDontShow.setBackground(ColorResource.getDarkestBgColor());
		chkDontShow.setName(""MSG_DONT_SHOW_AGAIN"");
		chkDontShow.setForeground(Color.WHITE);
		chkDontShow.setFocusPainted(false);

		chkDontShow.setBounds(75, 125, 200, 20);
		chkDontShow.setIcon(ImageResource.get(""unchecked.png""));
		chkDontShow.setSelectedIcon(ImageResource.get(""checked.png""));
		chkDontShow.addActionListener(this);

		add(chkDontShow);

		JPanel panel = new JPanel(null);
		panel.setBounds(0, 155, 400, 55);
		panel.setBackground(Color.DARK_GRAY);
		add(panel);

		CustomButton btnMore = new CustomButton(StringResource.get(""CD_OPEN_FILE"")),
				btnDN = new CustomButton(StringResource.get(""CD_OPEN_FOLDER"")),
				btnCN = new CustomButton(StringResource.get(""ND_CANCEL""));

		btnMore.setBounds(0, 1, 100, 55);
		btnMore.setName(""CTX_OPEN_FILE"");
		styleButton(btnMore);
		panel.add(btnMore);

		btnDN.setBounds(101, 1, 148, 55);
		btnDN.setName(""CTX_OPEN_FOLDER"");
		styleButton(btnDN);
		panel.add(btnDN);

		btnCN.setBounds(250, 1, 100, 55);
		btnCN.setName(""CLOSE"");
		styleButton(btnCN);
		panel.add(btnCN);

	}"
xdman,xdman.ui.components.DownloadCompleteWnd,actionPerformed,,25,107,94,7,0.1458,0.0864,0.6,4,8,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() instanceof JComponent) {
			String name = ((JComponent) e.getSource()).getName();
			if (name.startsWith(""MSG_DONT_SHOW_AGAIN"")) {
				Config.getInstance().setShowDownloadCompleteWindow(!chkDontShow.isSelected());
			} else if (name.equals(""CLOSE"")) {
				dispose();
			} else if (name.equals(""CTX_OPEN_FILE"")) {
				try {
					XDMUtils.openFile(txtFile.getText(), txtFolder.getText());
					dispose();
				} catch (Exception e1) {
					Logger.log(e1);
				}
			} else if (name.equals(""CTX_OPEN_FOLDER"")) {
				try {
					XDMUtils.openFolder(txtFile.getText(), txtFolder.getText());
					dispose();
				} catch (Exception e1) {
					Logger.log(e1);
				}
			}
		}
	}"
xdman,xdman.ui.components.RefreshUrlPage,initUI,,48,343,221,2,0.1484,0.1363,0.8,5,1,0,1,"private void initUI() {
		int y = 0;
		int h = 0;
		JPanel panel = new JPanel();
		panel.setLayout(null);
		panel.setOpaque(false);
		y += 10;

		h = 40;
		JLabel lblMaxTitle = new JLabel(StringResource.get(""REF_WAITING_FOR_LINK""));
		lblMaxTitle.setForeground(Color.WHITE);
		lblMaxTitle.setFont(FontResource.getItemFont());
		lblMaxTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblMaxTitle);
		y += h;
		y += 10;

		h = 80;

		lblMonitoringTitle = new JTextArea();
		lblMonitoringTitle.setOpaque(false);
		lblMonitoringTitle.setWrapStyleWord(true);
		lblMonitoringTitle.setLineWrap(true);
		lblMonitoringTitle.setEditable(false);
		lblMonitoringTitle.setForeground(Color.WHITE);
		lblMonitoringTitle.setFont(FontResource.getNormalFont());
		lblMonitoringTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblMonitoringTitle);
		y += h;

		btnOpenPage = createButton1(""REF_OPEN_PAGE"", 15, y);
		btnOpenPage.setName(""REF_OPEN_PAGE"");
		panel.add(btnOpenPage);
		y += btnOpenPage.getHeight();
		btnOpenPage.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				if (!StringUtils.isNullOrEmptyOrBlank(md.getYdlUrl())) {
					openLink();
				}
			}
		});

		panel.setPreferredSize(new Dimension(350, y));
		panel.setBounds(0, 0, 350, y);

		jsp.setViewportView(panel);
	}"
xdman,xdman.ui.components.RefreshUrlPage,createButton1,,9,21,6,4,0.2037,0.1944,1,5,1,0,1,"private JButton createButton1(String name, int x, int y) {
		JButton btn = new JButton(StringResource.get(name));
		btn.setBackground(ColorResource.getDarkBtnColor());
		btn.setFont(FontResource.getNormalFont());
		Dimension d = btn.getPreferredSize();
		btn.setBounds(x, y, d.width, d.height);
		// btn.addActionListener(this);
		return btn;
	}"
xdman,xdman.ui.components.RefreshUrlPage,isValidLink,,55,512,321,4,0.1507,0.1385,0.266666667,8,11,1,1,"@Override
	public boolean isValidLink(HttpMetadata metadata) {
		Logger.log(""Checking refresh link with checking size "" + md.getSize());
		if (md.getType() == metadata.getType()) {
			if (md instanceof DashMetadata) {
				DashMetadata dm1 = (DashMetadata) md;
				DashMetadata dm2 = (DashMetadata) metadata;
				if (dm1.getLen1() == dm2.getLen1() && dm1.getLen2() == dm2.getLen2()) {
					dm1.setUrl(dm2.getUrl());
					dm1.setUrl2(dm2.getUrl2());
					dm1.setHeaders(dm2.getHeaders());
					dm1.setLen1(dm2.getLen1());
					dm1.setLen2(dm2.getLen2());
					dm1.save();
					showOkMsgAndClose();
					return true;
				}
			} else if (md instanceof HlsMetadata) {
				HlsMetadata hm1 = (HlsMetadata) md;
				HlsMetadata hm2 = (HlsMetadata) metadata;
				if (confirmUrl("""")) {
					hm1.setUrl(hm2.getUrl());
					hm1.setHeaders(hm2.getHeaders());
					hm1.save();
					showOkMsgAndClose();
					return true;
				}
			} else if (md instanceof HdsMetadata) {
				HdsMetadata hm1 = (HdsMetadata) md;
				HdsMetadata hm2 = (HdsMetadata) metadata;
				if (confirmUrl("""")) {
					hm1.setUrl(hm2.getUrl());
					hm1.setHeaders(hm2.getHeaders());
					hm1.save();
					showOkMsgAndClose();
					return true;
				}
			} else {
				boolean confirmed = false;
				if (md.getSize() > 0) {
					confirmed = md.getSize() == metadata.getSize();
				} else {
					confirmed = confirmUrl(StringResource.get(""MSG_REF_LINK_QUESTION""));
				}
				if (confirmed) {
					md.setUrl(metadata.getUrl());
					md.setHeaders(metadata.getHeaders());
					md.save();
					showOkMsgAndClose();
					return true;
				}
			}
		}
		return false;
	}"
xdman,xdman.ui.components.RefreshUrlPage,openLink,,6,8,6,3,0.3333,0.0926,0.75,1,2,0,1,"private void openLink() {
		if (!StringUtils.isNullOrEmptyOrBlank(md.getYdlUrl())) {
			MediaDownloaderWnd wnd = new MediaDownloaderWnd();
			wnd.launchWithUrl(md.getYdlUrl());
		}
	}"
xdman,xdman.ui.components.CircleProgressBar,paint,,34,202,128,9,0.0855,0.1009,1,8,3,0,1,"@Override
	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		if (g2 == null) {
			return;
		}
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
		// g2.setRenderingHint(RenderingHints.KEY_RENDERING,
		// RenderingHints.VALUE_RENDER_QUALITY);

		int sweep_angle = (int)(((float)value * 360) / 100);
		g2.setColor(Color.GRAY);
		g2.setStroke(stroke);
		g2.drawArc(padding, padding, getWidth() - 2 * padding, getHeight() - 2
				* padding, 90, -360);
		// g2.drawArc(2, 2, getWidth() - 12, getHeight() - 12, 90, -360);
		if (value > 0) {
			g2.setColor(foreColor);
			// g2.drawArc(2, 2, getWidth() - 12, getHeight() - 12, 90,
			// -sweep_angle);
			g2.drawArc(padding, padding, getWidth() - 2 * padding, getHeight()
					- 2 * padding, 90, -sweep_angle);
		}

		g2.setFont(FontResource.getItemFont());
		FontMetrics fm = g2.getFontMetrics();
		String str = value + ""%"";
		int w = (int) fm.getStringBounds(str, g2).getWidth();// fm.stringWidth(str);
		LineMetrics lm = fm.getLineMetrics(str, g2);
		int h = (int) (lm.getAscent() + lm.getDescent());
		g2.drawString(str, (getWidth()  - w) / 2,
				((getHeight()   + h) / 2) - lm.getDescent());
	}"
xdman,xdman.ui.components.AboutPage,AboutPage,,40,360,224,2,0.1138,0.1398,0.666666667,7,1,0,1,"public AboutPage(XDMFrame xframe) {
		super(StringResource.get(""TITLE_ABOUT""), 350, xframe);
		int y = 0;
		int h = 0;
		JPanel panel = new JPanel();
		panel.setLayout(null);
		panel.setOpaque(false);
		y += 10;
		h = 50;

		JLabel lblTitle = new JLabel(StringResource.get(""FULL_NAME""));
		lblTitle.setFont(FontResource.getBiggerFont());
		lblTitle.setForeground(Color.WHITE);
		lblTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblTitle);

		y += h;
		y += 20;

		String details = String.format(StringResource.get(""ABOUT_DETAILS""), XDMApp.APP_VERSION,
				System.getProperty(""java.version""), System.getProperty(""os.name""), ""http://xdman.sourceforge.net"");

		h = 250;
		JTextArea lblDetails = new JTextArea();
		lblDetails.setOpaque(false);
		lblDetails.setWrapStyleWord(true);
		lblDetails.setLineWrap(true);
		lblDetails.setEditable(false);
		lblDetails.setForeground(Color.WHITE);
		lblDetails.setText(details);
		lblDetails.setFont(FontResource.getBigFont());
		lblDetails.setBounds(15, y, 350 - 30, h);
		panel.add(lblDetails);
		y += h;

		panel.setPreferredSize(new Dimension(350, y));
		panel.setBounds(0, 0, 350, y);

		jsp.setViewportView(panel);
	}"
xdman,xdman.ui.components.MessageBox,MessageBox,,8,25,22,6,0.375,0.1667,0,1,1,0,1,"private MessageBox() {
		setLayout(null);
		MouseInputAdapter ma = new MouseInputAdapter() {
		};
		addMouseListener(ma);
		addMouseMotionListener(ma);
		init();
	}"
xdman,xdman.ui.components.MessageBox,show,,21,42,0,4,0.1597,0.3473,1,5,3,0,1,"public static int show(XDMFrame parent, String title, String msg, int buttons, int defaultButton) {
		if (msgBox == null) {
			msgBox = new MessageBox();
		}

		msgBox.parent = parent;
		msgBox.lblTitle.setText(title);
		msgBox.txtMessage.setText(msg);
		msgBox.setLocation((parent.getWidth() - 350) / 2, (parent.getHeight() - 210) / 2);

		if (buttons == OK_OPTION) {
			msgBox.panel2.setVisible(false);
			msgBox.panel3.setVisible(true);
		} else {
			msgBox.panel2.setVisible(true);
			msgBox.panel3.setVisible(false);
		}
		msgBox.defaultButton = defaultButton;
		parent.showModal(msgBox);
		return msgBox.res;
	}"
xdman,xdman.ui.components.MessageBox,selectDefaultButton,,9,17,13,4,0.2857,0.1833,0,0,4,0,1,"public void selectDefaultButton() {
		if (defaultButton == YES) {
			msgBox.cbBtnYes.requestFocusInWindow();
		} else if (defaultButton == NO) {
			msgBox.cbBtnNo.requestFocusInWindow();
		} else if (defaultButton == OK) {
			msgBox.cbBtnOk.requestFocusInWindow();
		}
	}"
xdman,xdman.ui.components.MessageBox,applyStyle,,13,42,6,5,0.1868,0.2222,1,1,1,0,1,"void applyStyle(JButton btn) {
		btn.addActionListener(this);
		btn.setBackground(ColorResource.getDarkerBgColor());// );
		btn.setForeground(Color.WHITE);
		btn.setFocusable(true);
		// btn.setForeground(Color.WHITE);
		btn.setFont(FontResource.getBigFont());
		btn.setBorderPainted(false);
		btn.setMargin(new Insets(0, 0, 0, 0));
		// btn.setFocusPainted(false);
		btn.getInputMap(WHEN_FOCUSED).put(KeyStroke.getKeyStroke(""ENTER""), ""pressed"");
		btn.getInputMap(WHEN_FOCUSED).put(KeyStroke.getKeyStroke(""released ENTER""), ""released"");
	}"
xdman,xdman.ui.components.MessageBox,actionPerformed,,11,41,37,7,0.14,0.0397,1,1,3,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == cbBtnOk) {
			res = OK;
		} else if (e.getSource() == cbBtnYes) {
			res = YES;
		} else {
			res = NO;
		}
		parent.hideModal(msgBox);
	}"
xdman,xdman.ui.components.UpdateNotifyPanel,UpdateNotifyPanel,,30,90,75,6,0.15,0.0657,0.714285714,4,1,0,1,"public UpdateNotifyPanel() {
		super(new BorderLayout());
		setBorder(new EmptyBorder(10, 15, 10, 15));
		JPanel p2 = new JPanel(new BorderLayout());
		lbl = new JLabel();
		lbl.setFont(FontResource.getItemFont());
		p2.add(lbl);
		desc = new JLabel();
		p2.add(desc, BorderLayout.SOUTH);
		add(p2, BorderLayout.CENTER);

		// b.add(Box.createHorizontalGlue());
		JButton btn = new JButton(StringResource.get(""LBL_INSTALL_NOW""));
		btn.setFont(FontResource.getItemFont());
		btn.setName(""OPT_UPDATE_FFMPEG"");
		btn.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				if (mode == UpdateChecker.APP_UPDATE_AVAILABLE) {
					XDMUtils.browseURL(""http://xdman.sourceforge.net/update/update.php?ver="" + XDMApp.APP_VERSION);
				} else {
					FFmpegDownloader fd = new FFmpegDownloader();
					fd.start();
				}
				XDMApp.getInstance().clearNotifications();
			}
		});
		add(btn, BorderLayout.EAST);
	}"
xdman,xdman.ui.components.DownloadListView,DownloadListView,,38,485,442,21,0.0697,0.0647,0.75,2,1,0,1,"public DownloadListView(JPanel container) {
		model = new DownloadTableModel();
		XDMApp.getInstance().addListener(model);
		table = new JTable(model);
		table.setTableHeader(null);
		table.setDefaultRenderer(DownloadEntry.class, new XDMTableCellRenderer());
		table.setRowHeight(70);
		table.setShowGrid(false);
		table.setFillsViewportHeight(true);
		table.setBorder(new EmptyBorder(0, 0, 0, 0));
		table.setDragEnabled(true);
//		table.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
//			@Override
//			public void valueChanged(ListSelectionEvent e) {
//				int selectedRow = e.getFirstIndex();
//				selectedId = model.getIdAt(selectedRow);
//				Logger.log(""Selected id1: "" + selectedId+"" row: ""+selectedRow);
//			}
//		});
//
//		model.addTableModelListener(new TableModelListener() {
//			@Override
//			public void tableChanged(TableModelEvent e) {
//				if(selectedId!=null){
//					int index=model.getIndexOfId(selectedId);
//					Logger.log(""Index of ""+selectedId+"" is: ""+index);
//					if(index>-1){
//						table.setRowSelectionInterval(index, index);
//					}
//				}
//			}
//		});

		JScrollPane jsp = new JScrollPane(table);
		jsp.setBorder(new EmptyBorder(0, 0, 0, 0));

		container.add(jsp);
	}"
xdman,xdman.ui.components.VideoDownloadWindow,VideoDownloadWindow,,24,41,37,7,0.15,0.0476,0.666666667,7,4,0,1,"public VideoDownloadWindow(HttpMetadata metadata, String file) {
		this.folder = Config.getInstance().getDownloadFolder();
		this.metadata = metadata;
		if (this.metadata == null) {
			this.metadata = new HttpMetadata();
		}

		initUI();

		if (file != null && file.length() > 0) {
			txtFile.setText(file);
		}

		getRootPane().setDefaultButton(btnDN);

		addWindowListener(new WindowAdapter() {
			@Override
			public void windowActivated(WindowEvent e) {
				txtFile.requestFocus();
			}
		});

		queueId = """";
	}"
xdman,xdman.ui.components.VideoDownloadWindow,actionPerformed,,30,160,130,8,0.19,0.1229,0,3,10,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() instanceof JComponent) {
			String name = ((JComponent) e.getSource()).getName();
			if (name.startsWith(""QUEUE"")) {
				System.out.println(name);
				String[] arr = name.split("":"");
				if (arr.length < 2) {
					queueId = """";
				} else {
					queueId = arr[1].trim();
				}
				createDownload(false);
			} else if (name.equals(""STREAM"")) {
				updateAppliableFormats();
			} else if (name.equals(""CLOSE"")) {
				dispose();
			} else if (name.equals(""DOWNLOAD_NOW"")) {
				queueId = """";
				createDownload(true);
			} else if (name.equals(""BTN_MORE"")) {
				if (pop == null) {
					createPopup();
				}
				pop.show(btnMore, 0, btnMore.getHeight());
			} else if (name.equals(""BROWSE_FOLDER"")) {
				choseFolder();
			}
		}
	}"
xdman,xdman.ui.components.VideoDownloadWindow,createDownload,,28,223,215,17,0.072,0.0256,0.75,2,3,0,1,"private void createDownload(boolean now) {
		String fileName = txtFile.getText();
		if (fileName.length() < 1) {
			JOptionPane.showMessageDialog(this, StringResource.get(""MSG_NO_URL""));
			return;
		}
		// if (!XDMUtils.validateURL(urlStr)) {
		// urlStr = ""http://"" + urlStr;
		// if (!XDMUtils.validateURL(urlStr)) {
		// JOptionPane.showMessageDialog(this,
		// StringResource.get(""MSG_INVALID_URL""));
		// return;
		// } else {
		// txtURL.setText(urlStr);
		// }
		// }
		// if (!urlStr.equals(metadata.getUrl())) {
		// metadata.setUrl(urlStr);
		// }
		dispose();
		Logger.log(""file: "" + txtFile.getText());
		if(txtFile.getText().length()<1) {
			JOptionPane.showMessageDialog(this, StringResource.get(""MSG_NO_FILE""));
			return;
		}
		XDMApp.getInstance().createDownload(txtFile.getText(), folder, metadata, now, queueId, 0,
				cmbStmAction.getSelectedIndex());
	}"
xdman,xdman.ui.components.VideoDownloadWindow,choseFolder,,7,11,7,3,0.25,0.0833,0.666666667,1,2,0,1,"private void choseFolder() {
		JFileChooser jfc = XDMFileChooser.getFileChooser(JFileChooser.DIRECTORIES_ONLY, new File(folder));
		if (jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
			folder = jfc.getSelectedFile().getAbsolutePath();
			Config.getInstance().setDownloadFolder(folder);
		}
	}"
xdman,xdman.ui.components.VideoDownloadWindow,update,,10,23,18,4,0.2031,0.0722,1,5,2,0,1,"void update(DocumentEvent e) {
		try {
			Document doc = e.getDocument();
			int len = doc.getLength();
			String text = doc.getText(0, len);
			txtFile.setText(XDMUtils.getFileName(text));
		} catch (Exception err) {
			Logger.log(err);
		}
	}"
xdman,xdman.ui.components.VideoDownloadWindow,initUI,,136,5263,4961,24,0.0369,0.0288,0.727272727,9,4,1,1,"private void initUI() {
		setUndecorated(true);

		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
					.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		} catch (Exception e) {
			Logger.log(e);
		}

		setIconImage(ImageResource.get(""icon.png"").getImage());
		setSize(400, 210);
		setLocationRelativeTo(null);
		setAlwaysOnTop(true);
		getContentPane().setLayout(null);
		getContentPane().setBackground(ColorResource.getDarkestBgColor());

		JPanel titlePanel = new TitlePanel(null, this);
		titlePanel.setOpaque(false);
		titlePanel.setBounds(0, 0, 400, 50);

		JButton closeBtn = new CustomButton();
		closeBtn.setBounds(365, 5, 30, 30);
		closeBtn.setBackground(ColorResource.getDarkestBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""CLOSE"");

		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.addActionListener(this);
		titlePanel.add(closeBtn);

		JLabel titleLbl = new JLabel(StringResource.get(""VID_TITLE""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(25, 15, 200, 30);
		titlePanel.add(titleLbl);

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, 55, 400, 1);
		lineLbl.setOpaque(true);
		add(lineLbl);

		txtFile = new JTextField();
		txtFile.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
		txtFile.setBackground(ColorResource.getDarkestBgColor());
		txtFile.setForeground(Color.WHITE);
		txtFile.setBounds(77, 79, 241, 20);
		txtFile.setCaretColor(ColorResource.getSelectionColor());

		add(txtFile);

		JButton browse = new CustomButton(""..."");
		browse.setName(""BROWSE_FOLDER"");
		browse.setMargin(new Insets(0, 0, 0, 0));
		browse.setBounds(325, 79, 40, 20);
		browse.setFocusPainted(false);
		browse.setBackground(ColorResource.getDarkestBgColor());
		browse.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
		browse.setForeground(Color.WHITE);
		browse.addActionListener(this);
		browse.setFont(FontResource.getItemFont());
		add(browse);

		add(titlePanel);

		JLabel lblFile = new JLabel(StringResource.get(""ND_FILE""), JLabel.RIGHT);
		lblFile.setFont(FontResource.getNormalFont());
		lblFile.setForeground(Color.WHITE);
		lblFile.setBounds(10, 79, 61, 23);
		add(lblFile);

//		JLabel lblFmt = new JLabel(StringResource.get(""O_VID_FMT""), JLabel.RIGHT);
//		lblFmt.setFont(FontResource.getNormalFont());
//		lblFmt.setForeground(Color.WHITE);
//		lblFmt.setBounds(10, 111, 61, 23);
//		add(lblFmt);

		formatListModel = new DefaultComboBoxModel<MediaFormat>(MediaFormats.getSupportedFormats());

		JLabel lblStream = new JLabel(StringResource.get(""O_STM_FTM""), JLabel.RIGHT);
		lblStream.setFont(FontResource.getNormalFont());
		lblStream.setForeground(Color.WHITE);
		lblStream.setBounds(10, 111, 61, 20);
		add(lblStream);

		cmbStmAction = new JComboBox<String>(new String[] { StringResource.get(""VID_FMT_BOTH""),
				StringResource.get(""VID_FMT_AUDIO""), StringResource.get(""VID_FMT_VIDEO"") });
		// cmbStmAction.setBackground(ColorResource.getDarkerBgColor());
		cmbStmAction.addActionListener(this);
		cmbStmAction.setOpaque(true);
		cmbStmAction.setBounds(77, 111, 291, 20);
		// cmbStmAction.setRenderer(new SimpleListRenderer());
		cmbStmAction.setName(""STREAM"");
		add(cmbStmAction);

		// txtFile = new JTextField();
		// txtFile.setBorder(new LineBorder(ColorResource.getSelectionColor(),
		// 1));
		// txtFile.setBackground(ColorResource.getDarkestBgColor());
		// txtFile.setForeground(Color.WHITE);
		// txtFile.setBounds(77, 111, 241, 20);
		// txtFile.setCaretColor(ColorResource.getSelectionColor());
		//
		// add(txtFile);

		JPanel panel = new JPanel(null);
		panel.setBounds(0, 155, 400, 55);
		panel.setBackground(Color.DARK_GRAY);
		add(panel);

		btnMore = new CustomButton(StringResource.get(""ND_MORE""));
		btnDN = new CustomButton(StringResource.get(""ND_DOWNLOAD_NOW""));
		btnCN = new CustomButton(StringResource.get(""ND_CANCEL""));

		btnMore.setBounds(0, 1, 120, 55);
		btnMore.setName(""BTN_MORE"");
		styleButton(btnMore);
		panel.add(btnMore);

		btnDN.setBounds(121, 1, 160, 55);
		btnDN.setName(""DOWNLOAD_NOW"");
		styleButton(btnDN);
		panel.add(btnDN);

		btnCN.setBounds(282, 1, 120, 55);
		btnCN.setName(""CLOSE"");
		styleButton(btnCN);
		panel.add(btnCN);

		Logger.log(""Dash metadata? "" + (metadata instanceof DashMetadata));
		cmbStmAction.setEnabled(metadata != null && metadata instanceof DashMetadata);
	}"
xdman,xdman.ui.components.VideoDownloadWindow,createPopup,,21,121,71,4,0.152,0.1488,1,2,1,0,1,"private void createPopup() {
		pop = new JPopupMenu();
		pop.setBackground(ColorResource.getDarkerBgColor());
		JMenu dl = new JMenu(StringResource.get(""ND_DOWNLOAD_LATER""));
		dl.setForeground(Color.WHITE);
		dl.setBorder(new EmptyBorder(5, 5, 5, 5));
		dl.addActionListener(this);
		dl.setBackground(ColorResource.getDarkerBgColor());
		dl.setBorderPainted(false);
		// dl.setBackground(C);
		pop.add(dl);

		createQueueItems(dl);

		JMenuItem ig = new JMenuItem(StringResource.get(""ND_IGNORE_URL""));
		ig.setName(""IGNORE_URL"");
		ig.setForeground(Color.WHITE);
		ig.addActionListener(this);
		pop.add(ig);
		pop.setInvoker(btnMore);
	}"
xdman,xdman.ui.components.VideoDownloadWindow,createQueueItems,,11,31,17,3,0.2143,0.1477,0.5,5,3,0,1,"private void createQueueItems(JMenuItem queueMenuItem) {
		ArrayList<DownloadQueue> queues = XDMApp.getInstance().getQueueList();
		for (int i = 0; i < queues.size(); i++) {
			DownloadQueue q = queues.get(i);
			JMenuItem mItem = new JMenuItem(q.getName().length() < 1 ? ""Default queue"" : q.getName());
			mItem.setName(""QUEUE:"" + q.getQueueId());
			mItem.setForeground(Color.WHITE);
			mItem.addActionListener(this);
			queueMenuItem.add(mItem);
		}
	}"
xdman,xdman.ui.components.VideoDownloadWindow,updateAppliableFormats,,20,50,22,3,0.2436,0.184,0.666666667,3,8,0,1,"private void updateAppliableFormats() {
		int index = cmbStmAction.getSelectedIndex();
		if (index < 0)
			return;
		MediaFormat[] fmts = MediaFormats.getSupportedFormats();
		formatListModel.removeAllElements();
		for (MediaFormat fmt : fmts) {
			if (index == 1) {
				if (fmt.isAudioOnly()) {
					formatListModel.addElement(fmt);
				}
			} else if (index == 2) {
				if (!fmt.isAudioOnly() && fmt.getWidth() > 0) {// skip default
					formatListModel.addElement(fmt);
				}
			} else {
				formatListModel.addElement(fmt);
			}
		}
	}"
xdman,xdman.ui.components.FFmpegExtractorWnd,progress,,17,64,50,4,0.1692,0.0779,1,5,5,0,1,"public void progress(int progress) {
		if (progress >= prg.getMinimum() && progress <= prg.getMaximum()) {
			prg.setValue(progress);
		}

		int prgDiff = progress - lastProgress;
		long now = System.currentTimeMillis();
		long timeSpend = now - prevTime;
		if (timeSpend > 0) {
			if (prgDiff > 0) {
				long eta = (timeSpend * (100 - progress) / 1000 * prgDiff);// prgDiff
				lastProgress = progress;
				statLbl.setText(""ETA: "" + FormatUtilities.hms((int) eta));
			}
			prevTime = now;
		}
	}"
xdman,xdman.ui.components.FFmpegExtractorWnd,actionPerformed,,15,26,16,5,0.3704,0.2424,0,2,5,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() instanceof JComponent) {
			String name = ((JComponent) e.getSource()).getName();
			if (name == null) {
				return;
			}
			if (name.equals(""CLOSE"")) {
				stop();
			}
			if (name.equals(""MIN"")) {
				this.setExtendedState(this.getExtendedState() | JFrame.ICONIFIED);
			}
		}
	}"
xdman,xdman.ui.components.FFmpegExtractorWnd,init,,79,1664,1498,10,0.0516,0.0455,0.875,2,3,1,1,"private void init() {
		setUndecorated(true);

		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
					.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		} catch (Exception e) {
			Logger.log(e);
		}

		setIconImage(ImageResource.get(""icon.png"").getImage());
		setSize(350, 200);
		setLocationRelativeTo(null);
		setResizable(false);

		getContentPane().setLayout(null);
		getContentPane().setBackground(ColorResource.getDarkestBgColor());

		titlePanel = new TitlePanel(null, this);
		titlePanel.setOpaque(false);
		titlePanel.setBounds(0, 0, 350, 50);

		closeBtn = new CustomButton();
		closeBtn.setBounds(320, 5, 24, 24);
		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.setBackground(ColorResource.getDarkestBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""CLOSE"");
		closeBtn.addActionListener(this);

		minBtn = new CustomButton();
		minBtn.setBounds(296, 5, 24, 24);
		minBtn.setIcon(ImageResource.get(""min_btn.png""));
		minBtn.setBackground(ColorResource.getDarkestBgColor());
		minBtn.setBorderPainted(false);
		minBtn.setFocusPainted(false);
		minBtn.setName(""MIN"");
		minBtn.addActionListener(this);

		titleLbl = new JLabel(StringResource.get(""TITLE_CONVERT""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(25, 15, 250, 30);

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, 55, 400, 2);
		lineLbl.setOpaque(true);

		prg = new JProgressBar();
		prg.setBounds(20, 85, 350 - 40, 5);

		statLbl = new JLabel();
		statLbl.setForeground(Color.WHITE);
		statLbl.setBounds(20, 100, 350 - 40, 25);

		titlePanel.add(titleLbl);
		titlePanel.add(minBtn);
		titlePanel.add(closeBtn);

		add(lineLbl);
		add(titlePanel);
		add(prg);
		add(statLbl);

		panel = new JPanel(null);
		panel.setBounds(0, 150, 350, 50);
		panel.setBackground(Color.DARK_GRAY);

		btnCN = new CustomButton(StringResource.get(""MENU_PAUSE""));
		btnCN.setBounds(0, 1, 350, 50);
		btnCN.setName(""CLOSE"");
		applyStyle(btnCN);
		panel.add(btnCN);
		add(panel);
	}"
xdman,xdman.ui.components.FFmpegExtractorWnd,stop,,11,24,20,5,0.25,0.14,1,1,3,0,1,"private void stop() {
		try {
			if (callback != null) {
				callback.stop();
				callback = null;
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		dispose();
	}"
xdman,xdman.ui.components.PopupAdapter,mouseReleased,,9,9,3,3,0.3889,0.2381,0,2,3,0,1,"@Override
	public void mouseReleased(MouseEvent e) {
		if (e.isPopupTrigger()) {
			if (e.getSource() instanceof JTextField) {
				this.txt = (JTextField) e.getSource();
				popup.show(txt, e.getX(), e.getY());
			}
		}
	}"
xdman,xdman.ui.components.PopupAdapter,actionPerformed,,18,60,29,4,0.3095,0.3222,0,2,6,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (txt == null)
			return;
		System.out.println(txt);
		String name = ((JComponent) e.getSource()).getName();
		if (""MENU_CUT"".equals(name)) {
			txt.cut();
		} else if (""MENU_COPY"".equals(name)) {
			txt.copy();
		} else if (""MENU_SELECT_ALL"".equals(name)) {
			txt.selectAll();
		} else if (""MENU_PASTE"".equals(name)) {
			txt.paste();
		}
		System.out.println(""set to null"");
		txt = null;
	}"
xdman,xdman.ui.components.MediaDownloaderWnd,initUI,,133,4724,4398,15,0.0321,0.0347,0.866666667,10,3,0,1,"private void initUI() {
		setUndecorated(true);

		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
					.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		} catch (Exception e) {
			Logger.log(e);
		}

		setIconImage(ImageResource.get(""icon.png"").getImage());
		setSize(500, 420);
		setLocationRelativeTo(null);
		getContentPane().setLayout(null);
		getContentPane().setBackground(ColorResource.getDarkestBgColor());

		JPanel titlePanel = new TitlePanel(null, this);
		titlePanel.setOpaque(false);
		titlePanel.setBounds(0, 0, getWidth(), 50);

		JButton closeBtn = new CustomButton();
		closeBtn.setBounds(getWidth() - 35, 5, 30, 30);
		closeBtn.setBackground(ColorResource.getDarkestBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""CLOSE"");

		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.addActionListener(this);
		titlePanel.add(closeBtn);

		JLabel titleLbl = new JLabel(StringResource.get(""TITLE_DOWN_VID""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(25, 15, 200, 30);
		titlePanel.add(titleLbl);

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, 55, getWidth(), 1);
		lineLbl.setOpaque(true);
		add(lineLbl);

		add(titlePanel);

		int y = 55;

		int h = 30;
		y += 15;

		prg = new JProgressBar();
		prg.setIndeterminate(true);
		prg.setBounds(15, y, getWidth() - 30, 5);
		prg.setBorder(null);
		prg.setVisible(false);
		add(prg);

		txtURL = new JTextField();
		PopupAdapter.registerTxtPopup(txtURL);
		txtURL.setBounds(15, y, getWidth() - 30 - 110, h);
		add(txtURL);

		btnStart = createButton(""BTN_SEARCH_VIDEO"");
		btnStart.setBounds(getWidth() - 15 - 100, y, 100, h);
		btnStart.setName(""START"");
		add(btnStart);

		VideoDownloadItem item1 = new VideoDownloadItem();
		item1.title = ""First item for text test"";
		item1.desc = ""Sample description for text tesing description"";
		h = 300;

		model = new VideoTableModel();
		table = new JTable(model);
		table.setRowHeight(70);
		table.setShowGrid(false);
		table.setOpaque(false);
		table.setBorder(new EmptyBorder(0, 0, 0, 0));
		table.setShowHorizontalLines(false);
		table.setShowVerticalLines(false);
		table.setDefaultRenderer(YdlVideo.class, new VideoItemRenderer());
		table.setDefaultEditor(YdlVideo.class, new VideoItemEditor());
		table.setTableHeader(null);

		// rootNode = new DefaultMutableTreeNode(""Videos"");
		// tree = new JTree(rootNode);
		// tree.setOpaque(false);

		jsp = new JScrollPane();
		// jsp = new JScrollPane(list);
		jsp.setBounds(15, y, getWidth() - 30, h);
		jsp.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
		jsp.getViewport().setOpaque(false);
		// jsp.setViewportView(tree);
		jsp.setViewportView(table);
		jsp.setOpaque(false);
		DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
		jsp.setVerticalScrollBar(scrollBar);
		jsp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		add(jsp);
		jsp.setVisible(false);

		y += h;
		y += 10;
		h = 30;
		btnDwn = createButton(""BTN_DOWNLOAD_NOW"");
		btnDwn.setBounds(getWidth() - 15 - 150, y, 150, h);
		btnDwn.setName(""DOWNLOAD"");
		btnDwn.setVisible(false);
		add(btnDwn);

		btnQ = createButton(""BTN_DOWNLOAD_LATER"");
		btnQ.setBounds(getWidth() - 15 - 150 - 160, y, 150, h);
		btnQ.setName(""BTN_Q"");
		add(btnQ);
		btnQ.setVisible(false);

		btnBack = createButton(""BTN_BACK"");
		btnBack.setBounds(15, y, 130, h);
		btnBack.setName(""BACK"");
		add(btnBack);
		btnBack.setVisible(false);

		addWindowListener(new WindowAdapter() {
			@Override
			public void windowActivated(WindowEvent e) {
				txtURL.requestFocus();
			}
		});

	}"
xdman,xdman.ui.components.MediaDownloaderWnd,actionPerformed,,52,764,708,16,0.064,0.0574,1,3,9,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		JComponent c = (JComponent) e.getSource();
		String name = c.getName();
		if (""START"".equals(name)) {
			model.clear();
			if (txtURL.getText().length() < 1) {
				JOptionPane.showMessageDialog(this, StringResource.get(""MSG_NO_URL""));
				return;
			}
			if(!XDMUtils.checkComponentsInstalled()) {
				JOptionPane.showMessageDialog(this, StringResource.get(""LBL_COMPONENT_MISSING""));
				return;
			}
			if (!txtURL.getText().startsWith(""http"")) {
				txtURL.setText(""http://"" + txtURL.getText());
			}
			jsp.setVisible(false);
			prg.setVisible(true);
			btnDwn.setVisible(true);
			btnDwn.setText(StringResource.get(""BTN_STOP_PROCESSING""));
			btnDwn.setName(""STOP"");
			btnStart.setVisible(false);
			txtURL.setVisible(false);
			stop = false;
			getVideoItems(txtURL.getText());
		}
		if (""DOWNLOAD"".equals(name)) {
			table.getDefaultEditor(YdlVideo.class).stopCellEditing();
			downloadVideo();
		}
		if (""CLOSE"".equals(name)) {
			stop();
			dispose();
		}
		if (""STOP"".equals(name)) {
			stop();
		}
		if (""BACK"".equals(name)) {
			table.getDefaultEditor(YdlVideo.class).stopCellEditing();
			model.clear();
			prg.setVisible(false);
			txtURL.setVisible(true);
			btnStart.setVisible(true);
			btnDwn.setName(""DOWNLOAD"");
			btnDwn.setText(StringResource.get(""BTN_DOWNLOAD_NOW""));
			btnDwn.setVisible(false);
			btnQ.setVisible(false);
			jsp.setVisible(false);
			btnBack.setVisible(false);
		}
	}"
xdman,xdman.ui.components.MediaDownloaderWnd,stop,,15,86,81,10,0.1,0.044,1,0,2,0,1,"private void stop() {
		prg.setVisible(false);
		txtURL.setVisible(true);
		btnStart.setVisible(true);
		btnDwn.setName(""DOWNLOAD"");
		btnDwn.setText(StringResource.get(""BTN_DOWNLOAD_NOW""));
		btnDwn.setVisible(false);
		btnQ.setVisible(false);
		jsp.setVisible(false);
		btnBack.setVisible(false);
		stop = true;
		if (ydl != null) {
			ydl.stop();
		}
	}"
xdman,xdman.ui.components.MediaDownloaderWnd,showVideoList,,12,42,39,8,0.1286,0.0455,1,0,1,0,1,"private void showVideoList() {
		btnStart.setVisible(false);
		txtURL.setVisible(false);
		prg.setVisible(false);
		jsp.setVisible(true);
		btnDwn.setName(""DOWNLOAD"");
		btnDwn.setText(StringResource.get(""BTN_DOWNLOAD_NOW""));
		// http://demo.unified-streaming.com/video/tears-of-steel/tears-of-steel.mp4/.m3u8
		btnDwn.setVisible(true);
		btnBack.setVisible(true);
		// btnQ.setVisible(true);
	}"
xdman,xdman.ui.components.MediaDownloaderWnd,downloadVideo,,51,626,472,3,0.0875,0.0724,0.571428571,14,11,0,1,"private void downloadVideo() {
		for (int index : table.getSelectedRows()) {
			YdlVideo video = (YdlVideo) model.getValueAt(index, 0);
			YdlMediaFormat fmt = video.mediaFormats.get(video.index);
			String title = video.title;
			System.out.println(title + "" "" + title + fmt.type);
			String file = XDMUtils.getFileName(title) + ""."" + fmt.ext;
			switch (fmt.type) {
			case YdlResponse.DASH_HTTP:
				DashMetadata dm = new DashMetadata();
				dm.setYdlUrl(txtURL.getText());
				dm.setUrl(fmt.videoSegments[0]);
				dm.setUrl2(fmt.audioSegments[0]);
				for (HttpHeader header : fmt.headers) {
					dm.getHeaders().addHeader(header);
				}
				for (HttpHeader header : fmt.headers2) {
					dm.getHeaders2().addHeader(header);
				}
				XDMApp.getInstance().addVideo(dm, file);
				break;
			case YdlResponse.HLS:
				HlsMetadata md = new HlsMetadata();
				md.setYdlUrl(txtURL.getText());
				md.setUrl(fmt.url);
				for (HttpHeader header : fmt.headers) {
					md.getHeaders().addHeader(header);
				}
				XDMApp.getInstance().addVideo(md, file);
				break;
			case YdlResponse.HDS:
				HdsMetadata hm = new HdsMetadata();
				hm.setYdlUrl(txtURL.getText());
				hm.setUrl(fmt.url);
				for (HttpHeader header : fmt.headers) {
					hm.getHeaders().addHeader(header);
				}
				XDMApp.getInstance().addVideo(hm, file);
				break;
			case YdlResponse.HTTP:
				HttpMetadata ht = new HttpMetadata();
				ht.setYdlUrl(txtURL.getText());
				ht.setUrl(fmt.url);
				for (HttpHeader header : fmt.headers) {
					ht.getHeaders().addHeader(header);
				}
				XDMApp.getInstance().addVideo(ht, file);
				break;
			}
		}
	}"
xdman,xdman.ui.components.CustomButton,init,,6,14,13,4,0.2,0.0238,0.5,0,1,0,1,"private void init() {
		rolloverBackground = ColorResource.getSelectionColor();
		rolloverForeground = Color.WHITE;
		pressedBackground = ColorResource.getDarkBgColor();
		pressedForeground = Color.WHITE;
	}"
xdman,xdman.ui.components.VideoPopupItem,toString,,10,5,4,3,0.4167,0.1333,1,0,4,0,1,"@Override
	public String toString() {
		if (StringUtils.isNullOrEmptyOrBlank(file)) {
			return """";
		}

		return (StringUtils.isNullOrEmptyOrBlank(info) ? """" : ""[ "" + info
				+ "" ]  "")
				+ (file.length() > 30 ? file.substring(0, 25) + ""..."" : file);
	}"
xdman,xdman.ui.components.NewDownloadWindow,NewDownloadWindow,,31,106,92,8,0.1106,0.0494,0.666666667,11,6,0,1,"public NewDownloadWindow(HttpMetadata metadata, String file) {
		initUI();
		this.folder = Config.getInstance().getDownloadFolder();
		this.metadata = metadata;
		if (this.metadata == null) {
			this.metadata = new HttpMetadata();
		}
		if (this.metadata.getUrl() != null) {
			txtURL.setText(this.metadata.getUrl());
		} else {
			try {
				URL url = new URL(XDMUtils.getClipBoardText());
				txtURL.setText(url.toString());
			} catch (Exception e) {
				Logger.log(e);
			}
		}
		if (file != null && file.length() > 0) {
			txtFile.setText(file);
		}
		getRootPane().setDefaultButton(btnDN);

		addWindowListener(new WindowAdapter() {
			@Override
			public void windowActivated(WindowEvent e) {
				txtURL.requestFocus();
			}
		});

		queueId = """";
	}"
xdman,xdman.ui.components.NewDownloadWindow,actionPerformed,,27,129,105,7,0.2,0.1256,0,3,9,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() instanceof JComponent) {
			String name = ((JComponent) e.getSource()).getName();
			if (name.startsWith(""QUEUE"")) {
				String[] arr = name.split("":"");
				if (arr.length < 2) {
					queueId = """";
				} else {
					queueId = arr[1].trim();
				}
				createDownload(false);
			} else if (name.equals(""CLOSE"")) {
				dispose();
			} else if (name.equals(""DOWNLOAD_NOW"")) {
				queueId = """";
				createDownload(true);
			} else if (name.equals(""BTN_MORE"")) {
				if (pop == null) {
					createPopup();
				}
				pop.show(btnMore, 0, btnMore.getHeight());
			} else if (name.equals(""BROWSE_FOLDER"")) {
				choseFolder();
			}
		}
	}"
xdman,xdman.ui.components.NewDownloadWindow,createDownload,,26,100,64,5,0.1448,0.1361,0.714285714,2,6,0,1,"private void createDownload(boolean now) {
		String urlStr = txtURL.getText();
		if (urlStr.length() < 1) {
			JOptionPane.showMessageDialog(this, StringResource.get(""MSG_NO_URL""));
			return;
		}
		if (!XDMUtils.validateURL(urlStr)) {
			urlStr = ""http://"" + urlStr;
			if (!XDMUtils.validateURL(urlStr)) {
				JOptionPane.showMessageDialog(this, StringResource.get(""MSG_INVALID_URL""));
				return;
			} else {
				txtURL.setText(urlStr);
			}
		}
		if (!urlStr.equals(metadata.getUrl())) {
			metadata.setUrl(urlStr);
		}
		dispose();
		Logger.log(""file: "" + txtFile.getText());
		if(txtFile.getText().length()<1) {
			JOptionPane.showMessageDialog(this, StringResource.get(""MSG_NO_FILE""));
			return;
		}
		XDMApp.getInstance().createDownload(txtFile.getText(), folder, metadata, now, queueId, 0, 0);
	}"
xdman,xdman.ui.components.NewDownloadWindow,choseFolder,,7,11,7,3,0.25,0.0833,0.666666667,1,2,0,1,"private void choseFolder() {
		JFileChooser jfc = XDMFileChooser.getFileChooser(JFileChooser.DIRECTORIES_ONLY, new File(folder));
		if (jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
			folder = jfc.getSelectedFile().getAbsolutePath();
			Config.getInstance().setDownloadFolder(folder);
		}
	}"
xdman,xdman.ui.components.NewDownloadWindow,update,,10,23,18,4,0.2031,0.0722,1,5,2,0,1,"void update(DocumentEvent e) {
		try {
			Document doc = e.getDocument();
			int len = doc.getLength();
			String text = doc.getText(0, len);
			txtFile.setText(XDMUtils.getFileName(text));
		} catch (Exception err) {
			Logger.log(err);
		}
	}"
xdman,xdman.ui.components.NewDownloadWindow,initUI,,117,3930,3582,10,0.0477,0.0396,0.727272727,9,3,1,1,"private void initUI() {
		setUndecorated(true);

		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
					.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		} catch (Exception e) {
			Logger.log(e);
		}

		setIconImage(ImageResource.get(""icon.png"").getImage());
		setSize(400, 210);
		setLocationRelativeTo(null);
		setAlwaysOnTop(true);
		getContentPane().setLayout(null);
		getContentPane().setBackground(ColorResource.getDarkestBgColor());

		JPanel titlePanel = new TitlePanel(null, this);
		titlePanel.setOpaque(false);
		titlePanel.setBounds(0, 0, 400, 50);

		JButton closeBtn = new CustomButton();
		closeBtn.setBounds(365, 5, 30, 30);
		closeBtn.setBackground(ColorResource.getDarkestBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""CLOSE"");

		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.addActionListener(this);
		titlePanel.add(closeBtn);

		JLabel titleLbl = new JLabel(StringResource.get(""ND_TITLE""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(25, 15, 200, 30);
		titlePanel.add(titleLbl);

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, 55, 400, 1);
		lineLbl.setOpaque(true);
		add(lineLbl);

		txtURL = new JTextField();
		PopupAdapter.registerTxtPopup(txtURL);
		txtURL.getDocument().addDocumentListener(this);
		txtURL.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
		txtURL.setBackground(ColorResource.getDarkestBgColor());
		txtURL.setForeground(Color.WHITE);
		txtURL.setBounds(77, 79, 291, 20);
		txtURL.setCaretColor(ColorResource.getSelectionColor());

		add(txtURL);

		txtFile = new JTextField();
		PopupAdapter.registerTxtPopup(txtFile);
		txtFile.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
		txtFile.setBackground(ColorResource.getDarkestBgColor());
		txtFile.setForeground(Color.WHITE);
		txtFile.setBounds(77, 111, 241, 20);
		txtFile.setCaretColor(ColorResource.getSelectionColor());

		add(txtFile);

		JButton browse = new CustomButton(""..."");
		browse.setName(""BROWSE_FOLDER"");
		browse.setMargin(new Insets(0, 0, 0, 0));
		browse.setBounds(325, 111, 40, 20);
		browse.setFocusPainted(false);
		browse.setBackground(ColorResource.getDarkestBgColor());
		browse.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
		browse.setForeground(Color.WHITE);
		browse.addActionListener(this);
		browse.setFont(FontResource.getItemFont());
		add(browse);

		add(titlePanel);

		JLabel lblURL = new JLabel(StringResource.get(""ND_ADDRESS""), JLabel.RIGHT);
		lblURL.setFont(FontResource.getNormalFont());
		lblURL.setForeground(Color.WHITE);
		lblURL.setBounds(10, 78, 61, 23);
		add(lblURL);

		JLabel lblFile = new JLabel(StringResource.get(""ND_FILE""), JLabel.RIGHT);
		lblFile.setFont(FontResource.getNormalFont());
		lblFile.setForeground(Color.WHITE);
		lblFile.setBounds(10, 108, 61, 23);
		add(lblFile);

		JPanel panel = new JPanel(null);
		panel.setBounds(0, 155, 400, 55);
		panel.setBackground(Color.DARK_GRAY);
		add(panel);

		btnMore = new CustomButton(StringResource.get(""ND_MORE""));
		btnDN = new CustomButton(StringResource.get(""ND_DOWNLOAD_NOW""));
		btnCN = new CustomButton(StringResource.get(""ND_CANCEL""));

		btnMore.setBounds(0, 1, 120, 55);
		btnMore.setName(""BTN_MORE"");
		styleButton(btnMore);
		panel.add(btnMore);

		btnDN.setBounds(121, 1, 160, 55);
		btnDN.setName(""DOWNLOAD_NOW"");
		styleButton(btnDN);
		panel.add(btnDN);

		btnCN.setBounds(282, 1, 120, 55);
		btnCN.setName(""CLOSE"");
		styleButton(btnCN);
		panel.add(btnCN);
	}"
xdman,xdman.ui.components.NewDownloadWindow,createPopup,,21,121,71,4,0.152,0.1488,1,2,1,0,1,"private void createPopup() {
		pop = new JPopupMenu();
		pop.setBackground(ColorResource.getDarkerBgColor());
		JMenu dl = new JMenu(StringResource.get(""ND_DOWNLOAD_LATER""));
		dl.setForeground(Color.WHITE);
		dl.setBorder(new EmptyBorder(5, 5, 5, 5));
		dl.addActionListener(this);
		dl.setBackground(ColorResource.getDarkerBgColor());
		dl.setBorderPainted(false);
		// dl.setBackground(C);
		pop.add(dl);

		createQueueItems(dl);

		JMenuItem ig = new JMenuItem(StringResource.get(""ND_IGNORE_URL""));
		ig.setName(""IGNORE_URL"");
		ig.setForeground(Color.WHITE);
		ig.addActionListener(this);
		pop.add(ig);
		pop.setInvoker(btnMore);
	}"
xdman,xdman.ui.components.NewDownloadWindow,createQueueItems,,11,31,17,3,0.2143,0.1477,0.5,5,3,0,1,"private void createQueueItems(JMenuItem queueMenuItem) {
		ArrayList<DownloadQueue> queues = XDMApp.getInstance().getQueueList();
		for (int i = 0; i < queues.size(); i++) {
			DownloadQueue q = queues.get(i);
			JMenuItem mItem = new JMenuItem(q.getName().length() < 1 ? ""Default queue"" : q.getName());
			mItem.setName(""QUEUE:"" + q.getQueueId());
			mItem.setForeground(Color.WHITE);
			mItem.addActionListener(this);
			queueMenuItem.add(mItem);
		}
	}"
xdman,xdman.ui.components.TrayHandler,createTray,,56,34,32,7,0.1389,0.0417,0.625,10,4,0,1,"public static void createTray() {
		if (!SystemTray.isSupported()) {
			Logger.log(""SystemTray is not supported"");
			return;
		}

		if (XDMUtils.detectOS() == XDMUtils.LINUX) {
			return;
		}

		final PopupMenu popup = new PopupMenu();
		final TrayIcon trayIcon = new TrayIcon(ImageResource.get(""icon.png"").getImage());
		trayIcon.setImageAutoSize(true);
		final SystemTray tray = SystemTray.getSystemTray();

		act = new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				MenuItem c = (MenuItem) e.getSource();
				String name = c.getName();
				System.out.println(name);
				if (""ADD_URL"".equals(name)) {
					XDMApp.getInstance().addDownload(null, null);
				} else if (""RESTORE"".equals(name)) {
					XDMApp.getInstance().showMainWindow();
				} else if (""EXIT"".equals(name)) {
					XDMApp.getInstance().exit();
				}
			}
		};

		// Create a pop-up menu components
		MenuItem addUrlItem = new MenuItem(StringResource.get(""MENU_ADD_URL""));
		addUrlItem.addActionListener(act);
		addUrlItem.setName(""ADD_URL"");
		MenuItem restoreItem = new MenuItem(StringResource.get(""MSG_RESTORE""));
		restoreItem.addActionListener(act);
		restoreItem.setName(""RESTORE"");
		MenuItem exitItem = new MenuItem(StringResource.get(""MENU_EXIT""));
		exitItem.addActionListener(act);
		exitItem.setName(""EXIT"");

		// Add components to pop-up menu
		popup.add(addUrlItem);
		popup.add(restoreItem);
		popup.add(exitItem);

		trayIcon.setPopupMenu(popup);

		try {
			tray.add(trayIcon);
		} catch (AWTException e) {
			Logger.log(""TrayIcon could not be added."");
		}
	}"
xdman,xdman.ui.components.DownloadWindow,update,,22,103,86,9,0.1058,0.0473,0.416666667,4,9,0,1,"public void update(Downloader d, String file) {
		titleLbl.setText(file);
		lblStat.setText(d.isAssembling() ? StringResource.get(""STAT_ASSEMBLING"") : StringResource.get(""DWN_TITLE""));
		// StringBuilder sb = new StringBuilder();
		// sb.append((d.isAssembling() ? StringResource.get(""STAT_ASSEMBLING"")
		// : StringResource.get(""DWN_DOWNLOAD"")));
		// sb.append("" "");
		// sb.append(FormatUtilities.formatSize(d.getDownloaded()));
		// sb.append("" "");
		// sb.append(d.getType()==XDMConstants.HTTP?)
		lblDet.setText((d.isAssembling() ? StringResource.get(""STAT_ASSEMBLING"") : StringResource.get(""DWN_DOWNLOAD""))
				+ "" "" + FormatUtilities.formatSize(d.getDownloaded()) + "" ""
				+ ((d.getType() == XDMConstants.HTTP || d.getType() == XDMConstants.DASH)
						? ""/ "" + FormatUtilities.formatSize(d.getSize())
						: ""( "" + d.getProgress() + "" % )""));
		lblSpeed.setText(FormatUtilities.formatSize(d.getDownloadSpeed()) + ""/s"");
		lblETA.setText(""ETA "" + d.getEta());
		prgCircle.setValue(d.getProgress());
		SegmentDetails segDet = d.getSegmentDetails();
		long sz = ((d.getType() == XDMConstants.HTTP || d.getType() == XDMConstants.DASH) ? d.getSize() : 100);
		segProgress.setValues(segDet, sz);
	}"
xdman,xdman.ui.components.DownloadWindow,createP2,,51,655,569,6,0.0554,0.0597,1,6,1,0,1,"private void createP2() {

		remove(prgCircle);
		remove(lblSpeed);
		remove(lblStat);
		remove(segProgress);
		remove(lblDet);
		remove(lblETA);
		remove(this.panel);

		titlePanel.remove(closeBtn);
		titlePanel.remove(minBtn);

		JPanel p2 = new JPanel(null);
		p2.setBounds(0, 60, 350, 190);
		p2.setBackground(ColorResource.getDarkestBgColor());

		txtError = new JTextArea(this.errMsg);
		txtError.setFont(FontResource.getBigFont());
		txtError.setEditable(false);
		txtError.setCaretPosition(0);
		txtError.setWrapStyleWord(true);
		txtError.setLineWrap(true);
		txtError.setBackground(ColorResource.getDarkestBgColor());
		txtError.setForeground(Color.WHITE);

		JScrollPane jsp = new JScrollPane(txtError);
		jsp.setBounds(25, 20, 300, 100);
		jsp.setBorder(null);

		CustomButton exitBtn = new CustomButton();
		exitBtn.setText(StringResource.get(""MSG_OK""));
		applyStyle(exitBtn);
		exitBtn.setBounds(0, 1, 350, 50);
		exitBtn.setName(""EXIT"");

		JPanel panel2 = new JPanel(null);
		panel2.setBounds(0, 140, 350, 50);
		panel2.setBackground(Color.DARK_GRAY);
		panel2.add(exitBtn);

		p2.add(jsp);
		p2.add(panel2);

		add(p2);

		titleLbl.setText(StringResource.get(""MSG_FAILED""));

		invalidate();
		repaint();
	}"
xdman,xdman.ui.components.DownloadWindow,init,,118,3608,3388,15,0.0389,0.0312,0.818181818,4,3,1,1,"private void init() {
		setUndecorated(true);
		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
					.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		} catch (Exception e) {
			Logger.log(e);
		}

		setTitle(""Downloading..."");
		setIconImage(ImageResource.get(""icon.png"").getImage());
		setSize(350, 250);
		setLocationRelativeTo(null);
		setResizable(false);

		getContentPane().setLayout(null);
		getContentPane().setBackground(ColorResource.getDarkestBgColor());

		titlePanel = new TitlePanel(null, this);
		titlePanel.setOpaque(false);
		titlePanel.setBounds(0, 0, 350, 50);

		closeBtn = new CustomButton();
		closeBtn.setBounds(320, 5, 24, 24);
		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.setBackground(ColorResource.getDarkestBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""PAUSE"");
		closeBtn.addActionListener(this);

		minBtn = new CustomButton();
		minBtn.setBounds(296, 5, 24, 24);
		minBtn.setIcon(ImageResource.get(""min_btn.png""));
		minBtn.setBackground(ColorResource.getDarkestBgColor());
		minBtn.setBorderPainted(false);
		minBtn.setFocusPainted(false);
		minBtn.setName(""MIN"");
		minBtn.addActionListener(this);

		titleLbl = new JLabel(StringResource.get(""DWN_TITLE""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(25, 15, 250, 30);

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, 55, 400, 2);
		lineLbl.setOpaque(true);

		prgCircle = new CircleProgressBar();
		prgCircle.setValue(0);

		prgCircle.setBounds(20, 80, 72, 72);

		titlePanel.add(titleLbl);
		titlePanel.add(minBtn);
		titlePanel.add(closeBtn);

		lblSpeed = new JLabel(""---"");
		lblSpeed.setHorizontalAlignment(JLabel.CENTER);
		lblSpeed.setBounds(15, 160, 80, 25);
		lblSpeed.setForeground(Color.WHITE);

		lblStat = new JLabel(StringResource.get(""DWN_TITLE""));
		lblStat.setBounds(120, 85, 200, 25);
		lblStat.setForeground(Color.WHITE);

		segProgress = new SegmentPanel();
		segProgress.setBounds(120, 115, 200, 5);

		lblDet = new JLabel(StringResource.get(""DWN_PLACEHOLDER""));
		lblDet.setBounds(120, 125, 200, 25);
		lblDet.setForeground(Color.WHITE);

		lblETA = new JLabel(""---"");
		lblETA.setBounds(120, 150, 200, 25);
		lblETA.setForeground(Color.WHITE);

		panel = new JPanel(null);
		panel.setBounds(0, 200, 350, 50);
		panel.setBackground(Color.DARK_GRAY);

		CustomButton btnMore = new CustomButton(StringResource.get(""DWN_HIDE""));
		// CustomButton btnDN = new
		// CustomButton(StringResource.get(""DWN_PREVIEW""));
		CustomButton btnCN = new CustomButton(StringResource.get(""MENU_PAUSE""));

		btnMore.setBounds(0, 1, 175, 50);
		btnMore.setName(""BACKGROUND"");
		applyStyle(btnMore);

		// btnDN.setBounds(101, 1, 144, 50);
		// btnDN.setName(""PREVIEW"");
		// applyStyle(btnDN);

		btnCN.setBounds(176, 1, 175, 50);
		btnCN.setName(""PAUSE"");
		applyStyle(btnCN);

		add(titlePanel);
		add(lineLbl);
		add(prgCircle);
		add(lblSpeed);
		add(lblStat);
		add(segProgress);
		add(lblDet);
		add(lblETA);

		panel.add(btnMore);
		// panel.add(btnDN);
		panel.add(btnCN);

		add(panel);

	}"
xdman,xdman.ui.components.DownloadWindow,actionPerformed,,15,63,48,8,0.2051,0.1984,0,2,6,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		String name = ((JComponent) e.getSource()).getName();
		if (""PAUSE"".equals(name)) {
			pause();
		} else if (""BACKGROUND"".equals(name)) {
			hideWnd();
		} else if (""PREVIEW"".equals(name)) {
			openPreviewFolder();
		} else if (""MIN"".equals(name)) {
			this.setExtendedState(this.getExtendedState() | JFrame.ICONIFIED);
		} else if (""EXIT"".equals(name)) {
			dispose();
		}
	}"
xdman,xdman.ui.components.DownloadWindow,showErrorMsg,,28,125,97,4,0.4444,0.2593,1,1,8,0,1,"private void showErrorMsg(int code) {
		switch (code) {
		case XDMConstants.ERR_CONN_FAILED:
			txtError.setText(StringResource.get(""ERR_CONN_FAILED""));
			return;
		case XDMConstants.ERR_SESSION_FAILED:
			txtError.setText(StringResource.get(""ERR_SESSION_FAILED""));
			return;
		case XDMConstants.ERR_NO_RESUME:
			txtError.setText(StringResource.get(""ERR_NO_RESUME""));
			return;
		case XDMConstants.ERR_INVALID_RESP:
			txtError.setText(StringResource.get(""ERR_INVALID_RESP""));
			return;
		case XDMConstants.ERR_ASM_FAILED:
			txtError.setText(StringResource.get(""ERR_ASM_FAILED""));
			return;
		case XDMConstants.RESUME_FAILED:
			txtError.setText(StringResource.get(""RESUME_FAILED""));
			return;
		case XDMConstants.DISK_FAIURE:
			txtError.setText(StringResource.get(""ERR_DISK_FAILED""));
			return;
		default:
			txtError.setText(StringResource.get(""ERR_INTERNAL""));
			return;
		}
	}"
xdman,xdman.ui.components.LayeredPanel,LayeredPanel,,11,33,30,7,0.1556,0.0769,0,2,1,0,1,"public LayeredPanel(int opacity) {
		bgColor = new Color(0, 0, 0, opacity);
		setOpaque(false);
		setLayout(null);

		MouseInputAdapter ma = new MouseInputAdapter() {
		};

		addMouseListener(ma);
		addMouseMotionListener(ma);
	}"
xdman,xdman.ui.components.MainWindow,MainWindow,,9,28,28,8,0.125,0,0.6,0,2,0,1,"public MainWindow() {
		setTitle(StringResource.get(""WINDOW_TITLE""));
		setWindowSizeAndPosition();
		initWindow();
		if (Config.getInstance().isFirstRun()) {
			SettingsPage.getInstance().showPanel(this, ""BTN_MONITORING"");
		}
		showNotification();
	}"
xdman,xdman.ui.components.MainWindow,actionPerformed,,177,5411,4827,15,0.0381,0.0562,0.37037037,27,68,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		Config config = Config.getInstance();
		if (e.getSource() instanceof JComponent) {
			String name = ((JComponent) e.getSource()).getName();
			if (name == null) {
				return;
			}
			if (name.startsWith(""STOP"")) {
				stopQueue(name);
			} else if (name.equals(""OPT_UPDATE_FFMPEG"")) {
				if (warningPanel != null) {
					warningPanel.setVisible(false);
				}
				updateFFmpeg();
			} else if (name.startsWith(""FORMAT"")) {
				convert(name);
			} else if (name.startsWith(""START"")) {
				startQueue(name);
			} else if (""ADD_URL"".equals(name) || ""MENU_ADD_URL"".equals(name)) {
				XDMApp.getInstance().addDownload(null, null);
			} else if (""ALL_DOWNLOADS"".equals(name)) {
				tabClicked(e);
				config.setStateFilter(XDMConstants.ALL);
				filter();
			} else if (""ALL_UNFINISHED"".equals(name)) {
				tabClicked(e);
				config.setStateFilter(XDMConstants.UNFINISHED);
				filter();
			} else if (""ALL_FINISHED"".equals(name)) {
				tabClicked(e);
				config.setStateFilter(XDMConstants.FINISHED);
				filter();
			} else if (""PAUSE"".equals(name) || ""MENU_PAUSE"".equals(name)) {
				String[] ids = lv.getSelectedIds();
				for (int i = 0; i < ids.length; i++) {
					XDMApp.getInstance().pauseDownload(ids[i]);
				}
			} else if (""CTX_COPY_URL"".equals(name)) {
				String[] ids = lv.getSelectedIds();
				if (ids.length > 0) {
					String id = ids[0];
					XDMUtils.copyURL(XDMApp.getInstance().getURL(id));
				}
			} else if (""MENU_RESTART"".equals(name)) {
				String[] ids = lv.getSelectedIds();
				for (int i = 0; i < ids.length; i++) {
					XDMApp.getInstance().restartDownload(ids[i]);
				}
			} else if (""RESUME"".equals(name) || ""MENU_RESUME"".equals(name)) {
				String[] ids = lv.getSelectedIds();
				for (int i = 0; i < ids.length; i++) {
					XDMApp.getInstance().resumeDownload(ids[i], true);
				}
			} else if (""CTX_OPEN_FILE"".equals(name)) {
				String[] ids = lv.getSelectedIds();
				if (ids.length > 0) {
					String id = ids[0];
					openFile(id);
				}
			} else if (""CTX_OPEN_FOLDER"".equals(name)) {
				String[] ids = lv.getSelectedIds();
				if (ids.length > 0) {
					String id = ids[0];
					openFolder(id);
				}
			} else if (""MENU_EXIT"".equals(name)) {
				XDMApp.getInstance().exit();
			} else if (""0"".equals(name)) {
				config.setSortField(0);
				filter();
			} else if (""1"".equals(name)) {
				config.setSortField(1);
				filter();
			} else if (""2"".equals(name)) {
				config.setSortField(2);
				filter();
			} else if (""3"".equals(name)) {
				config.setSortField(3);
				filter();
			} else if (""4"".equals(name)) {
				config.setSortAsc(true);
				filter();
			} else if (""5"".equals(name)) {
				config.setSortAsc(false);
				filter();
			} else if (""BTN_SEARCH"".equals(name)) {
				config.setSearchText(txtSearch.getText());
				filter();
			} else if (""CAT_DOCUMENTS"".equals(name)) {
				config.setCategoryFilter(XDMConstants.DOCUMENTS);
				updateSidePanel((JLabel) e.getSource());
			} else if (""CAT_COMPRESSED"".equals(name)) {
				config.setCategoryFilter(XDMConstants.COMPRESSED);
				updateSidePanel((JLabel) e.getSource());
			} else if (""CAT_MUSIC"".equals(name)) {
				config.setCategoryFilter(XDMConstants.MUSIC);
				updateSidePanel((JLabel) e.getSource());
			} else if (""CAT_PROGRAMS"".equals(name)) {
				config.setCategoryFilter(XDMConstants.PROGRAMS);
				updateSidePanel((JLabel) e.getSource());
			} else if (""CAT_VIDEOS"".equals(name)) {
				config.setCategoryFilter(XDMConstants.VIDEO);
				updateSidePanel((JLabel) e.getSource());
			} else if (""CAT_ALL"".equals(name)) {
				config.setCategoryFilter(XDMConstants.ALL);
				updateSidePanel((JLabel) e.getSource());
			} else if (""MENU_CLIP_ADD"".equals(name)) {
				int ret = MessageBox.show(this, ""sample title"",
						""sample textdgdfgdfgdfghdfh gfhsdgh gfgfh dfgdfqwewrqwerwerqwerqwerwerwqerqwerqwerqwerwerwegfterj jgh ker gwekl hwgklerhg ek hrkjlwhlk kj hgeklgh jkle herklj gheklwerjgh sample textdgdfgdfgdfghdfh gfhsdgh gfgfh dfgdfqwewrqwerwerqwerqwerwerwqerqwerqwerqwerwerwegfterj jgh ker gwekl hwgklerhg ek hrkjlwhlk kj hgeklgh jkle herklj gheklwerjgh"",
						MessageBox.OK_OPTION, MessageBox.OK);
				System.out.println(""After: "" + ret);
				// new DownloadCompleteWnd().setVisible(true);
			} else if (""MENU_OPTIONS"".equals(name) || ""OPTIONS"".equals(name)) {
				SettingsPage.getInstance().showPanel(this, ""PG_SETTINGS"");
			} else if (""MENU_REFRESH_LINK"".equals(name)) {
				openRefreshPage();
			} else if (""MENU_PROPERTIES"".equals(name)) {
				showProperties();
			} else if (""MENU_BROWSER_INT"".equals(name)) {
				SettingsPage.getInstance().showPanel(this, ""BTN_MONITORING"");
			} else if (""MENU_SPEED_LIMITER"".equals(name)) {
				SettingsPage.getInstance().showPanel(this, ""BTN_NETWORK"");
			} else if (""DESC_Q_TITLE"".equals(name)) {
				SettingsPage.getInstance().showPanel(this, ""Q_MAN"");
			} else if (""MENU_MEDIA_CONVERTER"".equals(name)) {
				VideoDownloadWindow vw = new VideoDownloadWindow(null, null);
				vw.setVisible(true);
			} else if (""MENU_DELETE_DWN"".equals(name) || ""DELETE"".equals(name)) {
				if (MessageBox.show(this, StringResource.get(""DEL_TITLE""), StringResource.get(""DEL_SEL_TEXT""),
						MessageBox.YES_NO_OPTION, MessageBox.YES) == MessageBox.YES) {
					String[] ids = lv.getSelectedIds();
					ArrayList<String> idList = new ArrayList<String>();
					for (int i = 0; i < ids.length; i++) {
						idList.add(ids[i]);
					}
					XDMApp.getInstance().deleteDownloads(idList);
				}
			} else if (""MENU_DELETE_COMPLETED"".equals(name)) {
				if (MessageBox.show(this, StringResource.get(""DEL_TITLE""), StringResource.get(""DEL_FINISHED_TEXT""),
						MessageBox.YES_NO_OPTION, MessageBox.YES) == MessageBox.YES) {
					XDMApp.getInstance().deleteCompleted();
				}
			} else if (""MENU_ABOUT"".equals(name)) {
				AboutPage aboutPage = new AboutPage(this);
				aboutPage.showPanel();
			} else if (""CTX_SAVE_AS"".equals(name)) {
				String[] ids = lv.getSelectedIds();
				if (ids.length > 0) {
					String id = ids[0];
					changeFile(id);
				}
			} else if (""MENU_VIDEO_DWN"".equals(name)) {
				showVideoDwnDlg();
			} else if (""MENU_IMPORT"".equals(name)) {
				JFileChooser jfc = new JFileChooser();
				if (jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
					File file = jfc.getSelectedFile();
					XDMApp.getInstance().loadDownloadList(file);
				}
			} else if (""MENU_EXPORT"".equals(name)) {
				JFileChooser jfc = new JFileChooser();
				if (jfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
					File file = jfc.getSelectedFile();
					XDMApp.getInstance().saveDownloadList(file);
				}
			} else if (""MENU_CONTENTS"".equals(name)) {
				XDMUtils.browseURL(""http://xdman.sourceforge.net/#help"");
			} else if (""MENU_HOME_PAGE"".equals(name)) {
				XDMUtils.browseURL(""http://xdman.sourceforge.net/"");
			} else if (""MENU_UPDATE"".equals(name)) {
				XDMUtils.browseURL(""http://xdman.sourceforge.net/update/update.php?ver=""+XDMApp.APP_VERSION);
			} else if (""MENU_LANG"".equals(name)) {
				showLanguageDlg();
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,updateSidePanel,,12,35,34,5,0.1333,0.0167,1,2,3,0,1,"private void updateSidePanel(JLabel lbl) {
		for (int i = 0; i < lblCatArr.length; i++) {
			if (lbl == lblCatArr[i]) {
				lblCatArr[i].setBackground(ColorResource.getActiveTabColor());
				lblCatArr[i].setOpaque(true);
			} else {
				lblCatArr[i].setOpaque(false);
			}
		}
		lv.refresh();
		sp.repaint();
	}"
xdman,xdman.ui.components.MainWindow,createToolbar,,42,224,97,6,0.1254,0.2067,0.833333333,4,2,0,1,"private JPanel createToolbar() {
		JPanel p = new JPanel(new BorderLayout());
		Box toolBox = Box.createHorizontalBox();
		toolBox.add(Box.createRigidArea(new Dimension(20, 60)));
		toolBox.setBackground(ColorResource.getTitleColor());
		toolBox.setOpaque(true);

		toolBox.add(createToolButton(""ADD_URL"", ""tool_add.png""));
		toolBox.add(Box.createRigidArea(new Dimension(10, 10)));
		toolBox.add(createToolButton(""DELETE"", ""tool_del.png""));
		toolBox.add(Box.createRigidArea(new Dimension(10, 10)));
		toolBox.add(createToolButton(""PAUSE"", ""tool_pause.png""));
		toolBox.add(Box.createRigidArea(new Dimension(10, 10)));
		toolBox.add(createToolButton(""RESUME"", ""tool_resume.png""));
		toolBox.add(Box.createRigidArea(new Dimension(10, 10)));
		toolBox.add(createToolButton(""OPTIONS"", ""tool_settings.png""));
		toolBox.add(Box.createHorizontalGlue());

		JLabel btnMonitoring = new JLabel(ImageResource.get(""on.png""));
		// btnMonitoring.setForeground(Color.WHITE);
		btnMonitoring.setIconTextGap(15);
		btnMonitoring.putClientProperty(""xdmbutton.norollover"", ""true"");
		// btnMonitoring.setBackground(ColorResource.getTitleColor());
		btnMonitoring.setName(""BROWSER_MONITORING"");
		btnMonitoring.setText(StringResource.get(""BROWSER_MONITORING""));
		btnMonitoring.setHorizontalTextPosition(JButton.LEADING);
		btnMonitoring.setFont(FontResource.getBigFont());

		btnMonitoring.setIcon(Config.getInstance().isBrowserMonitoringEnabled() ? ImageResource.get(""on.png"")
				: ImageResource.get(""off.png""));

		btnMonitoring.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent e) {
				toggleMonitoring((JLabel) e.getSource());
			}
		});
		toolBox.add(btnMonitoring);
		toolBox.add(Box.createRigidArea(new Dimension(25, 10)));
		p.add(toolBox);
		return p;
	}"
xdman,xdman.ui.components.MainWindow,createToolButton,,11,19,0,3,0.2545,0.3704,0.5,3,1,0,1,"private JButton createToolButton(String name, String icon) {
		CustomButton btn = new CustomButton(ImageResource.get(icon));
		btn.setPressedBackground(ColorResource.getDarkPressedColor());
		btn.setRolloverBackground(Color.DARK_GRAY);
		btn.setBorderPainted(false);
		btn.addActionListener(this);
		btn.setName(name);
		btn.setBackground(ColorResource.getTitleColor());
		btn.setMargin(new Insets(0, 0, 0, 0));
		return btn;
	}"
xdman,xdman.ui.components.MainWindow,createSidePanel,,29,247,241,9,0.0683,0.0225,1,3,2,0,1,"private SidePanel createSidePanel() {
		sp = new SidePanel();
		sp.setLayout(null);
		sp.setPreferredSize(new Dimension(150, 250));

		lblCatArr = new JLabel[6];

		lblCatArr[0] = createCategoryLabel(""CAT_ALL"");
		lblCatArr[1] = createCategoryLabel(""CAT_DOCUMENTS"");
		lblCatArr[2] = createCategoryLabel(""CAT_COMPRESSED"");
		lblCatArr[3] = createCategoryLabel(""CAT_MUSIC"");
		lblCatArr[4] = createCategoryLabel(""CAT_VIDEOS"");
		lblCatArr[5] = createCategoryLabel(""CAT_PROGRAMS"");

		lblCatArr[0].setBackground(ColorResource.getActiveTabColor());
		lblCatArr[0].setOpaque(true);

		for (int i = 0; i < 6; i++) {
			lblCatArr[i].setBounds(0, 20 + (i * 35), 149, 27);
			final int c = i;
			lblCatArr[i].addMouseListener(new MouseAdapter() {
				public void mouseReleased(MouseEvent e) {
					actionPerformed(new ActionEvent(lblCatArr[c], 0, """"));
				}
			});
			sp.add(lblCatArr[i]);
		}
		return sp;
	}"
xdman,xdman.ui.components.MainWindow,createMainMenu,,75,1477,1301,16,0.0822,0.0692,0.75,11,1,0,1,"private void createMainMenu() {
		JMenuBar bar = new JMenuBar();
		bar.setBorderPainted(false);
		bar.setForeground(ColorResource.getWhite());
		bar.setMaximumSize(new Dimension(bar.getMaximumSize().width, 30));
		bar.setBackground(ColorResource.getTitleColor());

		JMenu file = createMenu(StringResource.get(""MENU_FILE""));

		addMenuItem(""MENU_ADD_URL"", file);
		// addMenuItem(""MENU_BATCH_DOWNLOAD"", file);
		// addMenuItem(""MENU_CLIP_ADD"", file);
		addMenuItem(""MENU_VIDEO_DWN"", file);
		addMenuItem(""MENU_DELETE_DWN"", file);
		addMenuItem(""MENU_DELETE_COMPLETED"", file);
		addMenuItem(""MENU_EXPORT"", file);
		addMenuItem(""MENU_IMPORT"", file);
		addMenuItem(""MENU_EXIT"", file);

		JMenu dwn = createMenu(StringResource.get(""MENU_DOWNLOAD""));

		addMenuItem(""MENU_PAUSE"", dwn);
		addMenuItem(""MENU_RESUME"", dwn);
		addMenuItem(""MENU_RESTART"", dwn);
		addMenuItem(""DESC_Q_TITLE"", dwn);

		PopupMenuListener popupListener = new PopupMenuListener() {

			@Override
			public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
				loadQueueMenu(startQMenu);
				loadQueueMenu(stopQMenu);
			}

			@Override
			public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
			}

			@Override
			public void popupMenuCanceled(PopupMenuEvent e) {
			}
		};

		startQMenu = addSubMenu(""MENU_START_Q"", dwn, popupListener);
		stopQMenu = addSubMenu(""MENU_STOP_Q"", dwn, popupListener);

		JMenu tools = createMenu(StringResource.get(""MENU_TOOLS""));

		addMenuItem(""MENU_OPTIONS"", tools);
		addMenuItem(""MENU_REFRESH_LINK"", tools);
		addMenuItem(""MENU_PROPERTIES"", tools);
		// addMenuItem(""MENU_FORCE_ASSEMBLE"", tools);
		addMenuItem(""MENU_SPEED_LIMITER"", tools);
		addMenuItem(""MENU_LANG"", tools);
		// addMenuItem(""MENU_MEDIA_CONVERTER"", tools);
		addMenuItem(""MENU_BROWSER_INT"", tools);

		JMenu help = createMenu(StringResource.get(""MENU_HELP""));
		addMenuItem(""MENU_CONTENTS"", help);
		addMenuItem(""MENU_HOME_PAGE"", help);
		addMenuItem(""MENU_UPDATE"", help);
		addMenuItem(""OPT_UPDATE_FFMPEG"", help);
		addMenuItem(""MENU_ABOUT"", help);

		bar.add(file);
		bar.add(dwn);
		bar.add(tools);
		bar.add(help);

		Box menuBox = Box.createHorizontalBox();
		menuBox.add(Box.createHorizontalGlue());
		menuBox.add(bar);
		menuBox.add(Box.createHorizontalStrut(30));
		getTitlePanel().add(menuBox);
	}"
xdman,xdman.ui.components.MainWindow,addMenuItem,,8,18,8,4,0.225,0.16,1,3,1,0,1,"private void addMenuItem(String id, JComponent menu) {
		JMenuItem mitem = new JMenuItem(StringResource.get(id));
		// mitem.setForeground(ColorResource.getLightFontColor());
		mitem.setName(id);
		mitem.setFont(FontResource.getNormalFont());
		mitem.addActionListener(this);
		menu.add(mitem);
	}"
xdman,xdman.ui.components.MainWindow,addSubMenu,,12,38,10,5,0.1806,0.2306,1,4,1,0,1,"private JMenu addSubMenu(String id, JMenu parentMenu, PopupMenuListener popupListener) {
		JMenu menu = new JMenu(StringResource.get(id));
		menu.setName(id);
		menu.setFont(FontResource.getNormalFont());
		// menu.setForeground(ColorResource.getLightFontColor());
		menu.addActionListener(this);
		// menu.setBackground(ColorResource.getDarkerBgColor());
		menu.setBorderPainted(false);
		menu.getPopupMenu().addPopupMenuListener(popupListener);
		parentMenu.add(menu);
		return menu;
	}"
xdman,xdman.ui.components.MainWindow,createSearchPane,,87,1713,1473,2,0.0628,0.0658,0.625,7,3,0,1,"private Component createSearchPane() {

		btnSort = new CustomButton(""Newest on top"");
		btnSort.setBackground(ColorResource.getActiveTabColor());
		btnSort.setBorderPainted(false);
		btnSort.setFocusPainted(false);
		btnSort.setContentAreaFilled(false);
		btnSort.setFont(FontResource.getNormalFont());

		txtSearch = new JTextField();
		txtSearch.setBackground(Color.WHITE);
		txtSearch.setForeground(Color.BLACK);
		txtSearch.setBorder(null);
		txtSearch.setName(""BTN_SEARCH"");
		txtSearch.addActionListener(this);

		final CustomButton btnSearch = new CustomButton();
		btnSearch.setName(""BTN_SEARCH"");
		btnSearch.setRolloverBackground(Color.WHITE);
		btnSearch.setPressedBackground(Color.WHITE);
		btnSearch.addActionListener(this);
		btnSearch.setPreferredSize(new Dimension(20, 20));
		btnSearch.setBackground(Color.WHITE);
		btnSearch.setIcon(ImageResource.get(""search16.png""));
		btnSearch.setBorderPainted(false);
		btnSearch.setFocusPainted(false);

		txtSearch.addActionListener(this);

		Box b = Box.createHorizontalBox();
		b.setOpaque(true);
		b.setBackground(Color.WHITE);
		b.setPreferredSize(new Dimension(130, 20));
		b.setMaximumSize(new Dimension(130, 20));
		txtSearch.setPreferredSize(new Dimension(70, 20));
		txtSearch.setMaximumSize(new Dimension(txtSearch.getMaximumSize().width, 20));
		b.add(txtSearch);
		b.add(btnSearch);
		b.setBorder(new LineBorder(Color.LIGHT_GRAY, 1));

		Box bp = Box.createHorizontalBox();
		bp.setOpaque(false);
		bp.setBorder(new EmptyBorder(3, 3, 3, 10));
		bp.add(Box.createHorizontalGlue());
		bp.add(btnSort);
		bp.add(Box.createHorizontalStrut(10));
		bp.add(b);
		bp.add(Box.createHorizontalStrut(10));

		sortItems = new JMenuItem[6];

		sortItems[0] = new JMenuItem(StringResource.get(""SORT_DATE""));
		sortItems[0].setName(""0"");
		sortItems[1] = new JMenuItem(StringResource.get(""SORT_SIZE""));
		sortItems[1].setName(""1"");
		sortItems[2] = new JMenuItem(StringResource.get(""SORT_NAME""));
		sortItems[2].setName(""2"");
		sortItems[3] = new JMenuItem(StringResource.get(""SORT_TYPE""));
		sortItems[3].setName(""3"");

		sortItems[4] = new JMenuItem(StringResource.get(""SORT_ASC""));
		sortItems[4].setName(""4"");
		sortItems[5] = new JMenuItem(StringResource.get(""SORT_DESC""));
		sortItems[5].setName(""5"");

		final JPopupMenu popSort = new JPopupMenu();
		for (int i = 0; i < sortItems.length; i++) {
			popSort.add(sortItems[i]);
			if (i > 3) {
				sortItems[i].putClientProperty(""bgColor"", ColorResource.getDarkBgColor());
			}
			sortItems[i].addActionListener(this);
		}

		updateSortMenu();

		popSort.setInvoker(btnSort);

		btnSort.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				popSort.show(btnSort, 0, btnSort.getHeight());
			}
		});

		return bp;
	}"
xdman,xdman.ui.components.MainWindow,updateSortMenu,,23,43,20,2,0.3333,0.1919,0.428571429,1,9,0,1,"private void updateSortMenu() {
		for (int i = 0; i < sortItems.length; i++) {
			if (i >= 0 && i <= 3) {
				if (i == Config.getInstance().getSortField()) {
					sortItems[i].setFont(FontResource.getBoldFont());
					sortItems[i].setForeground(ColorResource.getLightFontColor());// (FontResource.getBoldFont());
				} else {
					sortItems[i].setFont(FontResource.getNormalFont());
					sortItems[i].setForeground(ColorResource.getDeepFontColor());
				}
			}
		}

		sortItems[4]
				.setFont(Config.getInstance().getSortAsc() ? FontResource.getBoldFont() : FontResource.getNormalFont());
		sortItems[4].setForeground(Config.getInstance().getSortAsc() ? ColorResource.getLightFontColor()
				: ColorResource.getDeepFontColor());
		sortItems[5].setFont(
				(!Config.getInstance().getSortAsc()) ? FontResource.getBoldFont() : FontResource.getNormalFont());
		sortItems[5].setForeground((!Config.getInstance().getSortAsc()) ? ColorResource.getLightFontColor()
				: ColorResource.getDeepFontColor());

	}"
xdman,xdman.ui.components.MainWindow,createTabs,,46,443,358,3,0.0909,0.0721,0.625,7,2,0,1,"private void createTabs() {
		CustomButton btnAllTab = new CustomButton(StringResource.get(""ALL_DOWNLOADS"")),
				btnIncompleteTab = new CustomButton(StringResource.get(""ALL_UNFINISHED"")),
				btnCompletedTab = new CustomButton(StringResource.get(""ALL_FINISHED""));

		btnTabArr = new CustomButton[3];
		btnTabArr[0] = btnAllTab;
		btnTabArr[0].setName(""ALL_DOWNLOADS"");
		btnTabArr[1] = btnIncompleteTab;
		btnTabArr[1].setName(""ALL_UNFINISHED"");
		btnTabArr[2] = btnCompletedTab;
		btnTabArr[2].setName(""ALL_FINISHED"");

		for (int i = 0; i < 3; i++) {
			btnTabArr[i].setFont(FontResource.getBigBoldFont());
			btnTabArr[i].setBorderPainted(false);
			btnTabArr[i].setFocusPainted(false);
			btnTabArr[i].addActionListener(this);
		}

		btnAllTab.setBackground(ColorResource.getActiveTabColor());
		btnAllTab.setForeground(ColorResource.getDarkBgColor());

		btnIncompleteTab.setBackground(ColorResource.getTitleColor());
		btnIncompleteTab.setForeground(ColorResource.getDeepFontColor());

		btnCompletedTab.setBackground(ColorResource.getTitleColor());
		btnCompletedTab.setForeground(ColorResource.getDeepFontColor());

		JPanel pp = new JPanel(new BorderLayout());
		pp.setOpaque(false);

		JPanel p = new JPanel(new GridLayout(1, 3, 5, 0));
		p.setOpaque(false);
		Dimension d = new Dimension(380, 30);
		p.setPreferredSize(d);
		p.setMaximumSize(d);
		p.setMinimumSize(d);
		p.setBackground(Color.WHITE);
		p.add(btnAllTab);
		p.add(btnIncompleteTab);
		p.add(btnCompletedTab);
		pp.add(p, BorderLayout.EAST);

		getTitlePanel().add(pp, BorderLayout.SOUTH);
	}"
xdman,xdman.ui.components.MainWindow,tabClicked,,11,21,14,3,0.2917,0.2407,0.25,2,3,0,1,"private void tabClicked(ActionEvent e) {
		for (int i = 0; i < 3; i++) {
			if (btnTabArr[i] == e.getSource()) {
				btnTabArr[i].setBackground(ColorResource.getActiveTabColor());
				btnTabArr[i].setForeground(ColorResource.getDarkBgColor());
			} else {
				btnTabArr[i].setBackground(ColorResource.getTitleColor());
				btnTabArr[i].setForeground(ColorResource.getDeepFontColor());
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,initWindow,,50,550,470,10,0.0741,0.0784,0.777777778,4,1,0,1,"private void initWindow() {
		setIconImage(ImageResource.get(""icon.png"").getImage());
		JLabel lblTitle = new JLabel(StringResource.get(""WINDOW_TITLE""));
		lblTitle.setBorder(new EmptyBorder(20, 20, 0, 0));
		lblTitle.setFont(FontResource.getBiggestFont());
		lblTitle.setForeground(ColorResource.getWhite());
		getTitlePanel().add(lblTitle, BorderLayout.WEST);
		createTabs();
		createMainMenu();

		BarPanel bp = new BarPanel();
		bp.setLayout(new BorderLayout());
		bp.add(Box.createRigidArea(new Dimension(0, 30)));
		bp.add(createSearchPane(), BorderLayout.EAST);

		JPanel panCenter = new JPanel(new BorderLayout());
		panCenter.setBackground(Color.WHITE);
		panCenter.add(bp, BorderLayout.NORTH);

		JPanel pClient = new JPanel(new BorderLayout());
		pClient.add(panCenter);
		pClient.add(createSidePanel(), BorderLayout.WEST);

		toolbar = createToolbar();
		pClient.add(toolbar, BorderLayout.SOUTH);

		add(pClient);

		sortStatusText = new String[4][2];

		sortStatusText[0][0] = StringResource.get(""SORT_DATE_DESC"");
		sortStatusText[0][1] = StringResource.get(""SORT_DATE_ASC"");

		sortStatusText[1][0] = StringResource.get(""SORT_SIZE_DESC"");
		sortStatusText[1][1] = StringResource.get(""SORT_SIZE_ASC"");

		sortStatusText[2][0] = StringResource.get(""SORT_NAME_DESC"");
		sortStatusText[2][1] = StringResource.get(""SORT_NAME_ASC"");

		sortStatusText[3][0] = StringResource.get(""SORT_TYPE_DESC"");
		sortStatusText[3][1] = StringResource.get(""SORT_TYPE_ASC"");
		// test ui

		setMenuActionListener(this);

		lv = new DownloadListView(panCenter);
		filter();

		createPopupMenu();
	}"
xdman,xdman.ui.components.MainWindow,stopQueue,,11,30,24,3,0.2222,0.101,0.666666667,4,3,0,1,"private void stopQueue(String name) {
		String queueId = """";
		String[] arr = name.split("":"");
		if (arr.length > 1) {
			queueId = arr[1].trim();
		}
		DownloadQueue q = XDMApp.getInstance().getQueueById(queueId);
		if (q != null) {
			q.stop();
		}
	}"
xdman,xdman.ui.components.MainWindow,startQueue,,11,30,24,3,0.2222,0.101,0.666666667,4,3,0,1,"private void startQueue(String name) {
		String queueId = """";
		String[] arr = name.split("":"");
		if (arr.length > 1) {
			queueId = arr[1].trim();
		}
		DownloadQueue q = XDMApp.getInstance().getQueueById(queueId);
		if (q != null) {
			q.start();
		}
	}"
xdman,xdman.ui.components.MainWindow,loadStopQueueMenu,,14,49,32,3,0.1875,0.1051,0.5,5,3,0,1,"private void loadStopQueueMenu(JMenu menu) {
		menu.removeAll();
		ArrayList<DownloadQueue> queues = XDMApp.getInstance().getQueueList();
		for (int i = 0; i < queues.size(); i++) {
			DownloadQueue q = queues.get(i);
			if (q.isRunning()) {
				JMenuItem mitem = new JMenuItem(q.getName());
				mitem.setForeground(ColorResource.getLightFontColor());
				mitem.setName(""STOP:"" + q.getQueueId());
				mitem.addActionListener(this);
				menu.add(mitem);
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,loadStartQueueMenu,,14,49,32,3,0.1875,0.1051,0.5,5,3,0,1,"private void loadStartQueueMenu(JMenu menu) {
		menu.removeAll();
		ArrayList<DownloadQueue> queues = XDMApp.getInstance().getQueueList();
		for (int i = 0; i < queues.size(); i++) {
			DownloadQueue q = queues.get(i);
			if (!q.isRunning()) {
				JMenuItem mitem = new JMenuItem(q.getName());
				mitem.setForeground(ColorResource.getLightFontColor());
				mitem.setName(""START:"" + q.getQueueId());
				mitem.addActionListener(this);
				menu.add(mitem);
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,createPopupMenu,,56,203,106,3,0.1077,0.2267,1,9,5,0,1,"private void createPopupMenu() {
		popupCtx = new JPopupMenu();
		addMenuItem(""CTX_OPEN_FILE"", popupCtx);
		addMenuItem(""CTX_OPEN_FOLDER"", popupCtx);
		addMenuItem(""CTX_SAVE_AS"", popupCtx);
		addMenuItem(""MENU_PAUSE"", popupCtx);
		addMenuItem(""MENU_RESUME"", popupCtx);
		addMenuItem(""MENU_DELETE_DWN"", popupCtx);
		addMenuItem(""MENU_REFRESH_LINK"", popupCtx);
		addMenuItem(""CTX_COPY_URL"", popupCtx);
		addMenuItem(""CTX_COPY_FILE"", popupCtx);
		convertMenu = createMenu(StringResource.get(""OPT_CONVERT""));
		convertMenu.setBorder(new EmptyBorder(5, 10, 5, 5));
		convertMenu.setFont(FontResource.getNormalFont());

		MediaFormat[] fmts = MediaFormats.getSupportedFormats();
		for (int i = 1; i < fmts.length; i++) {
			MediaFormat fmt = fmts[i];
			JMenuItem mitem = new JMenuItem(fmt.toString());
			mitem.setName(""FORMAT="" + i);
			mitem.addActionListener(this);
			convertMenu.add(mitem);
		}

		popupCtx.add(convertMenu);

		addMenuItem(""MENU_PROPERTIES"", popupCtx);
		popupCtx.setInvoker(lv.getTable());
		lv.getTable().addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent me) {
				// JOptionPane.showMessageDialog(null,""Mouse clicked:
				// ""+me.getButton()+"" ""+MouseEvent.BUTTON3);
				if (me.getButton() == MouseEvent.BUTTON3 || SwingUtilities.isRightMouseButton(me) || me.isPopupTrigger()
						|| isMacPopupTrigger(me)) {
					Point p = me.getPoint();
					JTable tbl = lv.getTable();
					if (tbl.getRowCount() < 1)
						return;
					if (tbl.getSelectedRow() < 0) {
						int row = tbl.rowAtPoint(p);
						if (row >= 0) {
							tbl.setRowSelectionInterval(row, row);
						}
					}
					if (tbl.getSelectedRows().length > 0) {
						popupCtx.show(lv.getTable(), me.getX(), me.getY());
					}
					// int row = tbl.rowAtPoint(p);
					// if (row < 0) {
					// tbl.setRowSelectionInterval(row, row);
					// }
				}
			}
		});
	}"
xdman,xdman.ui.components.MainWindow,showProperties,,36,265,205,3,0.1058,0.075,0.5,11,9,0,1,"private void showProperties() {
		String[] ids = lv.getSelectedIds();
		if (ids.length > 0) {
			String id = ids[0];
			DownloadEntry ent = XDMApp.getInstance().getEntry(id);
			if (id != null) {
				PropertiesPage propPage = PropertiesPage.getPage(this);
				HttpMetadata md = HttpMetadata.load(id);
				HeaderCollection headers = md.getHeaders();
				String referer = """";
				StringBuilder cookies = new StringBuilder();
				Iterator<HttpHeader> cookieIt = headers.getAll();
				while (cookieIt.hasNext()) {
					HttpHeader header = cookieIt.next();
					if (""referer"".equalsIgnoreCase(header.getName())) {
						referer = header.getValue();
					}
					if (""cookie"".equalsIgnoreCase(header.getName())) {
						cookies.append(header.getValue() + ""\n"");
					}
				}
				String type = ""HTTP"";
				if (md instanceof DashMetadata) {
					type = ""DASH"";
				} else if (md instanceof HlsMetadata) {
					type = ""HLS"";
				} else if (md instanceof HdsMetadata) {
					type = ""HDS"";
				}

				propPage.setDetails(ent.getFile(), ent.getFolder(), ent.getSize(), md.getUrl(), referer,
						ent.getDateStr(), cookies.toString(), type);
				propPage.showPanel();
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,openRefreshPage,,21,79,67,4,0.125,0.0541,0.666666667,6,6,0,1,"public void openRefreshPage() {
		String[] ids = lv.getSelectedIds();
		if (ids.length > 0) {
			String id = ids[0];
			DownloadEntry ent = XDMApp.getInstance().getEntry(id);
			if (ent == null) {
				return;
			}
			if (!(ent.getState() == XDMConstants.PAUSED || ent.getState() == XDMConstants.FAILED)) {
				return;
			}
			try {
				HttpMetadata md = HttpMetadata.load(id);
				RefreshUrlPage rp = RefreshUrlPage.getPage(this);
				rp.setDetails(md);
				rp.showPanel();
			} catch (Exception e2) {
				Logger.log(e2);
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,openFile,,16,43,31,5,0.1616,0.1281,0.666666667,4,5,0,1,"public void openFile(String id) {
		DownloadEntry ent = XDMApp.getInstance().getEntry(id);
		if (ent != null) {
			if (ent.getState() == XDMConstants.FINISHED) {
				try {
					XDMUtils.openFile(ent.getFile(), ent.getFolder());
				} catch (FileNotFoundException e) {
					Logger.log(e);
					MessageBox.show(this, StringResource.get(""ERR_MSG_FILE_NOT_FOUND""),
							StringResource.get(""ERR_MSG_FILE_NOT_FOUND_MSG""), MessageBox.OK, MessageBox.OK);
				} catch (Exception e) {
					Logger.log(e);
				}
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,openFolder,,16,43,31,5,0.1616,0.1281,0.666666667,4,5,0,1,"public void openFolder(String id) {
		DownloadEntry ent = XDMApp.getInstance().getEntry(id);
		if (ent != null) {
			if (ent.getState() == XDMConstants.FINISHED) {
				try {
					XDMUtils.openFolder(ent.getFile(), ent.getFolder());
				} catch (FileNotFoundException e) {
					Logger.log(e);
					MessageBox.show(this, StringResource.get(""ERR_MSG_FILE_NOT_FOUND""),
							StringResource.get(""ERR_MSG_FILE_NOT_FOUND_MSG""), MessageBox.OK, MessageBox.OK);
				} catch (Exception e) {
					Logger.log(e);
				}
			}
		}
	}"
xdman,xdman.ui.components.MainWindow,convert,,34,264,228,6,0.0863,0.0416,0.666666667,13,6,0,1,"private void convert(String name) {
		try {
			File inputFile = null, outputFile = null;
			String[] ids = lv.getSelectedIds();
			if (ids.length > 0) {
				String id = ids[0];
				DownloadEntry ent = XDMApp.getInstance().getEntry(id);
				if (ent.getState() != XDMConstants.FINISHED) {
					return;
				}
				inputFile = new File(ent.getFolder(), ent.getFile());
				if (!inputFile.exists()) {
					System.out.println(""Input file does not exists"");
				}

				int index = Integer.parseInt(name.split(""="")[1]);
				MediaFormat fmt = MediaFormats.getSupportedFormats()[index];
				String ext = fmt.getFormat();
				String newFileName = XDMUtils.getFileNameWithoutExtension(ent.getFile()) + ""."" + ext;
				JFileChooser jfc = new JFileChooser();
				jfc.setSelectedFile(new File(ent.getFolder(), newFileName));
				if (jfc.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) {
					return;
				}
				outputFile = jfc.getSelectedFile();
				System.out.println(outputFile);
				MediaConversionWnd wnd = new MediaConversionWnd(inputFile, outputFile, fmt, -1);
				wnd.setVisible(true);
				wnd.convert();
			}
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.ui.components.MainWindow,changeFile,,16,36,17,3,0.2159,0.1488,0.285714286,4,4,0,1,"private void changeFile(String id) {
		DownloadEntry ent = XDMApp.getInstance().getEntry(id);
		if (ent == null)
			return;
		if (ent.getState() == XDMConstants.FINISHED) {
			return;
		}
		JFileChooser jfc = new JFileChooser();
		jfc.setSelectedFile(
				new File(XDMApp.getInstance().getOutputFolder(id), XDMApp.getInstance().getOutputFile(id, false)));
		if (jfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
			File f = jfc.getSelectedFile();
			ent.setFolder(f.getParent());
			ent.setFile(f.getName());
		}
	}"
xdman,xdman.ui.components.MainWindow,showNotification,,14,46,37,6,0.1818,0.0852,0.5,1,3,0,1,"public void showNotification() {
		int mode=XDMApp.getInstance().getNotification();
		if(mode==-1) {
			clearNotification();
			return;
		}
		if (updateNotifyPanel == null) {
			updateNotifyPanel = new UpdateNotifyPanel();
			toolbar.add(updateNotifyPanel, BorderLayout.SOUTH);
		}
		updateNotifyPanel.setDetails(mode);
		revalidate();
		repaint();
	}"
xdman,xdman.ui.components.XDMFrame,XDMFrame,,27,275,225,6,0.0931,0.0521,1,1,1,0,1,"public XDMFrame() {
		setUndecorated(true);
		createCursors();
		contentPane = new JPanel(new BorderLayout());
		modalPane = new LayeredPanel(150);
		modalPane.setVisible(false);
		dialogPane = new LayeredPanel(40);
		dialogPane.setVisible(false);
		createResizeGrip();
		panTitle = new TitlePanel(new BorderLayout(), this);
		panTitle.setBackground(ColorResource.getTitleColor());
		panTitle.setBorder(new EmptyBorder(5, 5, 0, 5));
		panTitle.setOpaque(true);
		registerTitlePanel(panTitle);
		panClient = new JPanel(new BorderLayout());
		panClient.setBackground(Color.WHITE);
		JPanel panContent = new JPanel(new BorderLayout());
		panContent.add(panTitle, BorderLayout.NORTH);
		panContent.add(panClient);
		contentPane.add(panContent);
		layeredPane = new JLayeredPane();
		layeredPane.add(contentPane, new Integer(DEFAULT_LAYER));
		layeredPane.add(modalPane, new Integer(MODAL_LAYER));
		layeredPane.add(dialogPane, new Integer(DIALOG_LAYER));
		super.add(layeredPane);
		super.addComponentListener(this);
	}"
xdman,xdman.ui.components.XDMFrame,createResizeGrip,,79,1781,1671,36,0.0842,0.0372,1,29,2,1,1,"private void createResizeGrip() {
		GripMouseAdapter gma = new GripMouseAdapter();
		lblRightGrip = new JLabel();
		lblRightGrip.setMaximumSize(new Dimension(2, lblRightGrip.getMaximumSize().height));
		lblRightGrip.setPreferredSize(new Dimension(2, lblRightGrip.getPreferredSize().height));
		lblRightGrip.setBackground(Color.BLACK);
		lblRightGrip.setOpaque(true);
		contentPane.add(lblRightGrip, BorderLayout.EAST);

		lblBottomGrip = new JLabel();
		lblBottomGrip.setMaximumSize(new Dimension(lblBottomGrip.getPreferredSize().width, 2));
		lblBottomGrip.setPreferredSize(new Dimension(lblBottomGrip.getPreferredSize().width, 2));
		lblBottomGrip.setBackground(Color.BLACK);
		lblBottomGrip.setOpaque(true);
		contentPane.add(lblBottomGrip, BorderLayout.SOUTH);

		lblLeftGrip = new JLabel();
		lblLeftGrip.setMaximumSize(new Dimension(2, lblLeftGrip.getPreferredSize().height));
		lblLeftGrip.setPreferredSize(new Dimension(2, lblLeftGrip.getPreferredSize().height));
		lblLeftGrip.setBackground(Color.BLACK);
		lblLeftGrip.setOpaque(true);
		contentPane.add(lblLeftGrip, BorderLayout.WEST);

		lblTopGrip = new JLabel();
		lblTopGrip.setMaximumSize(new Dimension(lblTopGrip.getPreferredSize().width, 2));
		lblTopGrip.setPreferredSize(new Dimension(lblTopGrip.getPreferredSize().width, 2));
		lblTopGrip.setBackground(Color.BLACK);
		lblTopGrip.setOpaque(true);
		contentPane.add(lblTopGrip, BorderLayout.NORTH);

		if (isResizable()) {

			lblTopGrip.addMouseListener(gma);

			lblTopGrip.addMouseMotionListener(new MouseMotionAdapter() {
				@Override
				public void mouseDragged(MouseEvent me) {
					int y = me.getYOnScreen();
					int diff = XDMFrame.this.getLocationOnScreen().y - y;
					XDMFrame.this.setLocation(XDMFrame.this.getLocation().x, me.getLocationOnScreen().y);
					XDMFrame.this.setSize(XDMFrame.this.getWidth(), XDMFrame.this.getHeight() + diff);
				}
			});

			lblRightGrip.addMouseListener(gma);

			lblRightGrip.addMouseMotionListener(new MouseMotionAdapter() {
				@Override
				public void mouseDragged(MouseEvent me) {
					int x = me.getXOnScreen();
					int diff = x - XDMFrame.this.getLocationOnScreen().x;
					XDMFrame.this.setSize(diff, XDMFrame.this.getHeight());
				}
			});

			lblLeftGrip.addMouseListener(gma);

			lblLeftGrip.addMouseMotionListener(new MouseMotionAdapter() {
				@Override
				public void mouseDragged(MouseEvent me) {
					int x = me.getXOnScreen();
					int diff = XDMFrame.this.getLocationOnScreen().x - x;
					XDMFrame.this.setLocation(me.getLocationOnScreen().x, XDMFrame.this.getLocation().y);
					XDMFrame.this.setSize(diff + XDMFrame.this.getWidth(), XDMFrame.this.getHeight());
				}
			});

			lblBottomGrip.addMouseListener(gma);

			lblBottomGrip.addMouseMotionListener(new MouseMotionAdapter() {
				@Override
				public void mouseDragged(MouseEvent me) {
					int y = me.getYOnScreen();
					int diff = y - XDMFrame.this.getLocationOnScreen().y;
					XDMFrame.this.setSize(XDMFrame.this.getWidth(), diff);
				}
			});
		}
	}"
xdman,xdman.ui.components.XDMFrame,registerTitlePanel,,56,1392,1353,39,0.04,0.0171,1,5,3,0,1,"void registerTitlePanel(JPanel panel) {

		vBox = Box.createVerticalBox();
		vBox.setOpaque(true);
		vBox.setBackground(ColorResource.getTitleColor());
		Box hBox = Box.createHorizontalBox();
		hBox.setBackground(ColorResource.getTitleColor());

		// if (menuBox) {
		// // JButton btn2 =
		// createTransparentButton(ImageResource.get(""exit.png""), new
		// Dimension(30, 30), null);
		// // btn2.setName(""MENU_OPEN"");
		// // // btn.setRolloverIcon(ImageResource.get(""min_btn_r.png""));
		// // hBox.add(btn2);
		// // JButton btn =
		// createTransparentButton(ImageResource.get(""drop.png""), new
		// Dimension(30, 30), null);
		// // btn.setName(""MENU_OPEN"");
		// // // btn.setRolloverIcon(ImageResource.get(""min_btn_r.png""));
		// // hBox.add(btn);
		// // hBox.add(Box.createRigidArea(new Dimension(10, 1)));
		// // // hBox.add(Box.createHorizontalStrut(10));
		//
		// JLabel lbl = new JLabel();
		// lbl.setMaximumSize(new Dimension(1, 12));
		// lbl.setPreferredSize(new Dimension(1, 12));
		// lbl.setBackground(new Color(65,65,65));
		// lbl.setOpaque(true);
		// hBox.add(lbl);
		// hBox.add(Box.createRigidArea(new Dimension(10, 1)));
		// //menuBtn = btn;
		// // hBox.add(Box.createHorizontalStrut(10));
		// }

		if (minimizeBox) {
			JButton btn = createTransparentButton(ImageResource.get(""min_btn.png""), new Dimension(30, 30), actMin);
			// btn.setRolloverIcon(ImageResource.get(""min_btn_r.png""));
			hBox.add(btn);
		}

		if (maximizeBox) {
			JButton btn = createTransparentButton(ImageResource.get(""max_btn.png""), new Dimension(30, 30), actMax);
			// btn.setRolloverIcon(ImageResource.get(""max_btn_r.png""));
			hBox.add(btn);
		}

		JButton btn = createTransparentButton(ImageResource.get(""close_btn.png""), new Dimension(30, 30), actClose);
		// btn.setRolloverIcon(ImageResource.get(""close_btn_r.png""));
		hBox.add(btn);

		vBox.add(hBox);
		vBox.add(Box.createVerticalGlue());

		panel.add(vBox, BorderLayout.EAST);
	}"
xdman,xdman.ui.components.XDMFrame,createTransparentButton,,10,17,0,3,0.24,0.3636,1,4,1,0,1,"JButton createTransparentButton(ImageIcon icon, Dimension d, ActionListener actionListener) {
		CustomButton btn = new CustomButton(icon);
		btn.setBackground(ColorResource.getTitleColor());
		btn.setBorderPainted(false);
		btn.setContentAreaFilled(false);
		btn.setFocusPainted(false);
		btn.setPreferredSize(d);
		btn.addActionListener(actionListener);
		return btn;
	}"
xdman,xdman.ui.components.XDMFrame,componentResized,,7,15,15,4,0.1667,0,0,1,1,0,1,"@Override
	public void componentResized(ComponentEvent c) {
		contentPane.setSize(super.getWidth(), super.getHeight());
		modalPane.setSize(super.getWidth(), super.getHeight());
		dialogPane.setSize(super.getWidth(), super.getHeight());
		revalidate();
	}"
xdman,xdman.ui.components.XDMFrame,showModal,,10,37,29,5,0.2667,0.1429,1,1,1,0,1,"public void showModal(MessageBox component) {
		lastFocusOwner = getMostRecentFocusOwner();
		System.out.println(""Last focus owner: ""+lastFocusOwner);
		modalPane.add(component);
		component.setVisible(true);
		modalPane.setVisible(true);
		revalidate();
		component.selectDefaultButton();
		startModal(component);
	}"
xdman,xdman.ui.components.XDMFrame,hideModal,,12,42,39,7,0.2,0.0571,0,1,2,0,1,"public void hideModal(MessageBox component) {
		modalPane.remove(component);
		component.setVisible(false);
		modalPane.setVisible(false);
		revalidate();
		stopModal();
		if (lastFocusOwner == null) {
			requestFocusInWindow();
		} else {
			lastFocusOwner.requestFocusInWindow();
		}
	}"
xdman,xdman.ui.components.XDMFrame,showDialog,,7,17,13,4,0.3571,0.1389,0,1,1,0,1,"public void showDialog(JComponent component) {
		dialogPane.removeAll();
		dialogPane.add(component);
		component.setVisible(true);
		dialogPane.setVisible(true);
		revalidate();
	}"
xdman,xdman.ui.components.XDMFrame,hideDialog,,6,13,11,4,0.3333,0.0833,0,1,1,0,1,"public void hideDialog(JComponent component) {
		dialogPane.remove(component);
		component.setVisible(false);
		dialogPane.setVisible(false);
		revalidate();
	}"
xdman,xdman.ui.components.XDMFrame,startModal,,25,88,56,6,0.1875,0.146,0,5,8,0,1,"private synchronized void startModal(Component comp) {
		try {
			if (SwingUtilities.isEventDispatchThread()) {
				EventQueue theQueue = Toolkit.getDefaultToolkit().getSystemEventQueue();
				while (comp.isVisible()) {
					AWTEvent event = theQueue.getNextEvent();
					Object source = event.getSource();
					if (event instanceof ActiveEvent) {
						((ActiveEvent) event).dispatch();
					} else if (source instanceof Component) {
						((Component) source).dispatchEvent(event);
					} else if (source instanceof MenuComponent) {
						((MenuComponent) source).dispatchEvent(event);
					} else {
						System.err.println(""Unable to dispatch: "" + event);
					}
				}
			} else {
				while (comp.isVisible()) {
					wait();
				}
			}
		} catch (InterruptedException ignored) {
		}
	}"
xdman,xdman.ui.components.VideoPopup,addVideo,,29,224,97,6,0.1222,0.2004,0.444444444,5,3,0,1,"public synchronized void addVideo(HttpMetadata metadata, String file, String info) {
		VideoPopupItem item = new VideoPopupItem();
		item.setMetadata(metadata);
		item.setInfo(info);
		item.setFile(file);
		item.setTimestamp(System.currentTimeMillis());
		if (addItem(item)) {
			CustomButton cb = new CustomButton();
			cb.setHorizontalAlignment(JButton.LEFT);
			cb.setHorizontalTextPosition(JButton.LEFT);
			cb.setMargin(new Insets(0, 0, 0, 0));
			cb.setForeground(Color.WHITE);
			cb.setName(metadata.getId());
			cb.setText(item.toString());
			cb.setBackground(ColorResource.getDarkestBgColor());
			cb.setBorderPainted(false);
			cb.setFocusPainted(false);
			cb.setPreferredSize(new Dimension(250, 30));
			cb.setMinimumSize(new Dimension(250, 30));
			cb.setMaximumSize(new Dimension(250, 30));
			cb.addActionListener(this);
			menuBox.add(cb, 0);
			if (!isVisible()) {
				setVisible(true);
			}
			revalidate();
			repaint();
		}
	}"
xdman,xdman.ui.components.VideoPopup,arrangeList,,9,20,12,3,0.25,0.1235,0,2,2,0,1,"private void arrangeList() {
		videoItems.clear();
		ArrayList<VideoPopupItem> itemsCopy = new ArrayList<VideoPopupItem>();
		itemsCopy.addAll(itemList);
		Collections.sort(itemsCopy, this);
		for (VideoPopupItem item : itemsCopy) {
			videoItems.addElement(item);
		}
	}"
xdman,xdman.ui.components.VideoPopup,init,,110,3657,3486,52,0.0341,0.0284,0.888888889,10,4,1,1,"private void init() {
		try {
			setUndecorated(true);
			setSize(250, 40);
			setIconImage(ImageResource.get(""icon.png"").getImage());
			setFocusableWindowState(false);
			setType(Type.UTILITY);
			setAlwaysOnTop(true);

			try {
				if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice()
						.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
					setOpacity(0.85f);
				}
			} catch (Exception e) {
				Logger.log(e);
			}

			panel = new JPanel(new BorderLayout());
			panel.setBackground(ColorResource.getDarkestBgColor());
			add(panel);

			bottomPanel = new TitlePanel(new BorderLayout(), this);
			bottomPanel.setBorder(new EmptyBorder(0, 20, 0, 0));
			bottomPanel.setOpaque(true);
			bottomPanel.setBackground(ColorResource.getDarkerBgColor());
			panel.add(bottomPanel);

			JButton closeBtn = new CustomButton();
			closeBtn.setPreferredSize(new Dimension(30, 40));
			closeBtn.setMinimumSize(new Dimension(30, 40));
			closeBtn.setBackground(ColorResource.getDarkerBgColor());
			closeBtn.setBorderPainted(false);
			closeBtn.setFocusPainted(false);
			closeBtn.setName(""CLOSE"");

			closeBtn.setIcon(ImageResource.get(""close_btn.png""));
			closeBtn.setMargin(new Insets(0, 0, 0, 0));
			closeBtn.addActionListener(this);
			bottomPanel.add(closeBtn, BorderLayout.EAST);

			JButton popupBtn = new CustomButton();
			popupBtn.setBackground(ColorResource.getDarkerBgColor());
			popupBtn.setFont(FontResource.getItemFont());
			popupBtn.setPreferredSize(new Dimension(200, 40));
			popupBtn.setMinimumSize(new Dimension(200, 40));
			popupBtn.setBorderPainted(false);
			popupBtn.setForeground(Color.WHITE);
			popupBtn.setText(""DOWNLOAD VIDEO"");
			popupBtn.setFocusPainted(false);
			popupBtn.setName(""EXPAND"");
			popupBtn.addActionListener(this);
			bottomPanel.add(popupBtn);

			itemPanel = new JPanel(new BorderLayout());
			// itemPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
			itemPanel.setOpaque(false);

			itemListBox = new JList<VideoPopupItem>(videoItems);
			itemListBox.setOpaque(false);
			itemListBox.setCellRenderer(new SimpleListRenderer());
			itemListBox.addMouseMotionListener(new MouseAdapter() {
				public void mouseMoved(MouseEvent me) {
					Point p = new Point(me.getX(), me.getY());
					int index = itemListBox.locationToIndex(p);
					if (index != mHoveredJListIndex) {
						mHoveredJListIndex = index;
						if (mHoveredJListIndex != -1) {
							itemListBox.setSelectedIndex(mHoveredJListIndex);
						} else {
							itemListBox.clearSelection();
						}
					}
				}

				@Override
				public void mouseExited(MouseEvent e) {
					itemListBox.clearSelection();
					itemListBox.repaint();
				}
			});

			JScrollPane jsp = new JScrollPane();
			jsp.setOpaque(false);
			jsp.setBorder(null);
			jsp.getViewport().setOpaque(false);

			DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
			jsp.setVerticalScrollBar(scrollBar);
			jsp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
			jsp.getVerticalScrollBar().setUnitIncrement(10);
			jsp.getVerticalScrollBar().setBlockIncrement(25);

			menuBox = Box.createVerticalBox();
			menuBox.add(Box.createVerticalGlue());

			jsp.setViewportView(menuBox);
			itemPanel.add(jsp);

			closePopupBtn = new CustomButton();
			closePopupBtn.setBackground(ColorResource.getDarkerBgColor());
			closePopupBtn.setBorderPainted(false);
			closePopupBtn.setFocusPainted(false);
			closePopupBtn.setName(""COLAPSE"");

			closePopupBtn.addActionListener(this);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}"
xdman,xdman.ui.components.VideoPopup,actionPerformed,,26,152,133,7,0.1053,0.0568,0.571428571,4,7,0,1,"// public static void main(String[] args) {
	// SwingUtilities.invokeLater(new Runnable() {
	//
	// @Override
	// public void run() {
	// new VideoPopup().setVisible(true);
	//
	// }
	// });
	//
	// }

	@Override
	public void actionPerformed(ActionEvent e) {
		String name = ((JComponent) e.getSource()).getName();
		for (VideoPopupItem item : itemList) {
			if (name.equals(item.getMetadata().getId())) {
				collapse();
				HttpMetadata md = item.getMetadata().derive();
				Logger.log(""dash metdata ? "" + (md instanceof DashMetadata));
				XDMApp.getInstance().addVideo(md, item.getFile());
			}
		}
		if (name.equals(""CLOSE"")) {
			collapse();
			setVisible(false);
			menuBox.removeAll();
			itemList.clear();
		} else if (name.equals(""COLAPSE"")) {
			collapse();
		} else if (name.equals(""EXPAND"")) {
			if (!expanded) {
				expand();
			} else {
				collapse();
			}
		}
	}"
xdman,xdman.ui.components.VideoPopup,expand,,38,341,276,8,0.1172,0.0618,1,7,4,0,1,"private void expand() {
		initialY = getLocationOnScreen().y;
		int screenHeight = Toolkit.getDefaultToolkit().getScreenSize().height;

		int preferedExpandedHeight = 400;
		int bottomTaskbarHeight, topTaskbarHeight;
		Insets scnMax = Toolkit.getDefaultToolkit().getScreenInsets(this.getGraphicsConfiguration());
		bottomTaskbarHeight = scnMax.bottom;
		topTaskbarHeight = scnMax.top;

		upward = initialY > (screenHeight - (bottomTaskbarHeight + topTaskbarHeight)) / 2;

		arrangeList();
		panel.remove(bottomPanel);
		panel.add(itemPanel);

		if (upward) {
			if (getY() - topTaskbarHeight < preferedExpandedHeight) {
				preferedExpandedHeight = getY() - topTaskbarHeight;
			}
			setLocation(getX(), initialY - preferedExpandedHeight + getHeight());
			panel.add(bottomPanel, BorderLayout.SOUTH);
			itemPanel.add(closePopupBtn, BorderLayout.NORTH);
			closePopupBtn.setIcon(ImageResource.get(""down_arrow.png""));

		} else {
			if (screenHeight - getY() - bottomTaskbarHeight < preferedExpandedHeight) {
				preferedExpandedHeight = screenHeight - getY() - bottomTaskbarHeight;
			}
			panel.add(bottomPanel, BorderLayout.NORTH);
			itemPanel.add(closePopupBtn, BorderLayout.SOUTH);
			closePopupBtn.setIcon(ImageResource.get(""up_arrow.png""));
		}
		setSize(getWidth(), preferedExpandedHeight);
		revalidate();
		repaint();
		expanded = true;
	}"
xdman,xdman.ui.components.VideoPopup,collapse,,16,85,79,9,0.1327,0.0453,0,2,2,0,1,"private void collapse() {
		panel.remove(bottomPanel);
		panel.remove(itemPanel);
		int height = getHeight();
		int locationY = getY() + height - 40;
		setSize(getWidth(), 40);
		if (upward) {
			setLocation(getX(), locationY);
		}

		panel.add(bottomPanel);
		revalidate();
		repaint();
		expanded = false;
		upward = false;
	}"
xdman,xdman.ui.components.VideoPopup,compare,,10,15,9,4,0.25,0.225,1,3,4,0,1,"@Override
	public int compare(VideoPopupItem item1, VideoPopupItem item2) {
		int ret = 0;
		if (item1.getTimestamp() > item2.getTimestamp()) {
			ret = 1;
		} else if (item1.getTimestamp() < item2.getTimestamp()) {
			ret = 1;
		}
		return upward ? ret : -ret;
	}"
xdman,xdman.ui.components.VideoPopup,addItem,,26,60,29,3,0.2321,0.1489,0.75,7,7,0,1,"private boolean addItem(VideoPopupItem item) {
		if (item.getMetadata() == null) {
			return false;
		}
		for (int i = 0; i < itemList.size(); i++) {
			VideoPopupItem p = itemList.get(i);
			HttpMetadata m1 = item.getMetadata();
			HttpMetadata m2 = p.getMetadata();
			if (m1.getType() == m2.getType()) {
				if (m1.getUrl().equals(m2.getUrl())) {
					if (m1 instanceof DashMetadata) {
						DashMetadata dm1 = (DashMetadata) m1;
						DashMetadata dm2 = (DashMetadata) m2;
						if (dm1.getUrl2().equals(dm2.getUrl2())) {
							return false;
						}
					} else {
						return false;
					}
				}
			}
		}

		itemList.add(item);
		return true;
	}"
xdman,xdman.ui.components.SettingsPage,SettingsPage,,29,191,151,11,0.101,0.1448,1,2,1,0,1,"public SettingsPage() {
		setOpaque(false);
		setLayout(null);
		bgColor = new Color(0, 0, 0, 200);
		MouseInputAdapter ma = new MouseInputAdapter() {
		};

		addMouseListener(ma);
		addMouseMotionListener(ma);

		jsp = new JScrollPane();
		jsp.setOpaque(false);
		jsp.setBorder(null);
		jsp.getViewport().setOpaque(false);

		DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
		jsp.setVerticalScrollBar(scrollBar);
		jsp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		jsp.getVerticalScrollBar().setUnitIncrement(10);
		jsp.getVerticalScrollBar().setBlockIncrement(25);

		add(jsp);

		registerMouseListener();

		init();

		pageStack = new ArrayList<JPanel>();
	}"
xdman,xdman.ui.components.SettingsPage,showPanel,,15,43,31,5,0.1616,0.0818,1,5,1,0,1,"public void showPanel(XDMFrame xframe, String pageName) {
		this.parent = xframe;
		int x = xframe.getWidth() - 350;
		jsp.setBounds(0, y, 350, xframe.getHeight() - y);
		setBounds(x, 0, 350, xframe.getHeight());
		JScrollBar vertical = jsp.getVerticalScrollBar();
		vertical.setValue(vertical.getMinimum());
		setPage(pageName);
		xframe.showDialog(this);
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				jsp.getVerticalScrollBar().setValue(0);
			}
		});
	}"
xdman,xdman.ui.components.SettingsPage,init,,51,19,2,2,0.2222,0.1815,1,2,1,0,1,"private void init() {
		y = 25;
		h = 40;

		btnNav = new JLabel(ImageResource.get(""back24.png""));
		btnNav.setFont(FontResource.getBiggerFont());
		btnNav.setForeground(ColorResource.getSelectionColor());
		btnNav.setBounds(15, y, 25, h);
		add(btnNav);

		btnNav.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent e) {
				if (currentPage == overviewPanel) {
					saveOverviewSettings();
				} else if (currentPage == browserIntPanel) {
					saveMonitoringSettings();
				} else if (currentPage == networkPanel) {
					saveNetworkSettings();
				} else if (currentPage == advPanel) {
					saveAdvSettings();
				}
				if (level == 0) {
					close();
				}
				if (level == 1) {
					level = 0;
					setPage(""PG_SETTINGS"");
				}
			}
		});

		titleLbl = new JLabel(StringResource.get(""TITLE_SETTINGS""));
		titleLbl.setFont(FontResource.getBiggerFont());
		titleLbl.setForeground(ColorResource.getSelectionColor());
		titleLbl.setBounds(50, y, 200, h);
		add(titleLbl);

		y += h;
		y += 10;
		h = 2;

		JLabel lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getSelectionColor());
		lineLbl.setBounds(0, y, 400, h);
		lineLbl.setOpaque(true);
		add(lineLbl);

		y += h;

	}"
xdman,xdman.ui.components.SettingsPage,createOverviewPanel,,253,19374,15312,20,0.0423,0.0899,0.666666667,22,1,0,1,"private JPanel createOverviewPanel() {
		JPanel panel = new JPanel();
		panel.setOpaque(false);
		panel.setLayout(null);

		int y = 0, h = 0;
		y += 10;

		y += 10;
		h = 30;
		JLabel lblMonitorHeader = new JLabel(StringResource.get(""SETTINGS_MONITORING""));
		lblMonitorHeader.setForeground(Color.WHITE);
		lblMonitorHeader.setFont(FontResource.getItemFont());
		lblMonitorHeader.setBounds(15, y, 350 - 30, h);
		panel.add(lblMonitorHeader);
		y += h;
		y += 10;

		h = 50;
		JTextArea lblMonitoringTitle = new JTextArea();
		lblMonitoringTitle.setOpaque(false);
		lblMonitoringTitle.setWrapStyleWord(true);
		lblMonitoringTitle.setLineWrap(true);
		lblMonitoringTitle.setEditable(false);
		lblMonitoringTitle.setForeground(Color.WHITE);
		lblMonitoringTitle.setText(StringResource.get(""HINT_BROWSER_MON""));
		lblMonitoringTitle.setFont(FontResource.getNormalFont());
		lblMonitoringTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblMonitoringTitle);
		y += h;

		JButton btViewMonitoring = createButton1(""SETTINGS_VIEW"", 15, y);
		btViewMonitoring.setName(""BTN_MONITORING"");
		panel.add(btViewMonitoring);
		y += btViewMonitoring.getHeight();

		y += 10;
		y += 20;

		h = 30;
		JLabel lblGenHeader = new JLabel(StringResource.get(""SETTINGS_GENERAL""));
		lblGenHeader.setForeground(Color.WHITE);
		lblGenHeader.setFont(FontResource.getItemFont());
		lblGenHeader.setBounds(15, y, 350 - 30, h);
		panel.add(lblGenHeader);
		y += h;

		y += 10;
		h = 30;
		chkPrgWnd = createCheckBox(""SHOW_DWN_PRG"");
		chkPrgWnd.setBounds(15, y, 350 - 30, h);
		panel.add(chkPrgWnd);
		y += h;

		h = 30;
		chkEndWnd = createCheckBox(""SHOW_DWN_COMPLETE"");
		chkEndWnd.setBounds(15, y, 350 - 30, h);
		panel.add(chkEndWnd);
		y += h;

		y += 10;
		h = 30;
		JLabel lblMaxTitle = new JLabel(StringResource.get(""MSG_MAX_DOWNLOAD""));
		lblMaxTitle.setForeground(Color.WHITE);
		lblMaxTitle.setFont(FontResource.getNormalFont());
		lblMaxTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblMaxTitle);
		y += 3;

		h = 25;
		cmbMax = new JComboBox<String>(new String[] { ""1"", ""2"", ""5"", ""10"", ""50"", ""N/A"" });
		cmbMax.setBackground(ColorResource.getDarkerBgColor());
		cmbMax.setBounds(250, y, 75, h);
		cmbMax.setRenderer(new SimpleListRenderer());
		panel.add(cmbMax);
		y += h;
		y += 10;

		// h = 30;
		// JLabel lblDupTitle = new JLabel(StringResource.get(""SHOW_DUP_ACT""));
		// lblDupTitle.setForeground(Color.WHITE);
		// lblDupTitle.setFont(FontResource.getNormalFont());
		// lblDupTitle.setBounds(15, y, 350 - 30, h);
		// panel.add(lblDupTitle);
		// y += h;
		//
		// h = 25;
		// cmbDupAction = new JComboBox<String>(
		// new String[] { StringResource.get(""DUT_ACT_RENAME""),
		// StringResource.get(""DUP_ACT_OVERWRITE""),
		// StringResource.get(""DUP_ACT_OPEN""),
		// StringResource.get(""DUP_ACT_PROMPT"") });
		// cmbDupAction.setBackground(ColorResource.getDarkerBgColor());
		// cmbDupAction.setOpaque(false);
		// cmbDupAction.setBounds(15, y, 350 - 40, h);
		// cmbDupAction.setRenderer(new SimpleListRenderer());
		// panel.add(cmbDupAction);
		// y += h;

		y += 10;

		y += 10;
		h = 30;
		JLabel lblFolderTitle = new JLabel(StringResource.get(""SETTINGS_FOLDER""));
		lblFolderTitle.setForeground(Color.WHITE);
		lblFolderTitle.setFont(FontResource.getNormalFont());
		lblFolderTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblFolderTitle);
		y += h;

		h = 25;
		txtDefFolder = new JTextField();
		txtDefFolder.setBounds(15, y, 350 - 30 - 110, h);
		txtDefFolder.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtDefFolder.setEditable(false);
		txtDefFolder.setForeground(Color.WHITE);
		txtDefFolder.setOpaque(false);
		panel.add(txtDefFolder);
		JButton btnBrowseFolder = createButton2(""SETTINGS_FOLDER_CHANGE"");
		btnBrowseFolder.setName(""SETTINGS_FOLDER_CHANGE"");
		btnBrowseFolder.setBackground(ColorResource.getDarkBtnColor());
		btnBrowseFolder.setFont(FontResource.getNormalFont());
		btnBrowseFolder.setBounds(15 + 350 - 30 - 110 + 10, y, 90, h);
		panel.add(btnBrowseFolder);
		y += h;

		y += 10;
		y += 20;

		y += 10;
		h = 30;
		JLabel lblNetHeader = new JLabel(StringResource.get(""SETTINGS_NETWORK""));
		lblNetHeader.setForeground(Color.WHITE);
		lblNetHeader.setFont(FontResource.getItemFont());
		lblNetHeader.setBounds(15, y, 350 - 30, h);
		panel.add(lblNetHeader);
		y += h;

		h = 40;
		JTextArea lblNetworkTitle = new JTextArea();
		lblNetworkTitle.setOpaque(false);
		lblNetworkTitle.setWrapStyleWord(true);
		lblNetworkTitle.setLineWrap(true);
		lblNetworkTitle.setEditable(false);
		lblNetworkTitle.setForeground(Color.WHITE);
		lblNetworkTitle.setText(StringResource.get(""HINT_NETWORK""));
		lblNetworkTitle.setFont(FontResource.getNormalFont());
		lblNetworkTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblNetworkTitle);
		y += h;

		JButton btViewNet = createButton1(""SETTINGS_VIEW"", 15, y);
		btViewNet.setName(""BTN_NETWORK"");
		panel.add(btViewNet);
		y += btViewNet.getHeight();

		y += 10;
		y += 10;

		y += 10;
		h = 30;
		JLabel lblSchHeader = new JLabel(StringResource.get(""SETTINGS_SCHEDULER""));
		lblSchHeader.setForeground(Color.WHITE);
		lblSchHeader.setFont(FontResource.getItemFont());
		lblSchHeader.setBounds(15, y, 350 - 30, h);
		panel.add(lblSchHeader);
		y += h;

		h = 50;
		JTextArea lblScheduleTitle = new JTextArea();
		lblScheduleTitle.setOpaque(false);
		lblScheduleTitle.setWrapStyleWord(true);
		lblScheduleTitle.setLineWrap(true);
		lblScheduleTitle.setEditable(false);
		lblScheduleTitle.setForeground(Color.WHITE);
		lblScheduleTitle.setText(StringResource.get(""HINT_SCHEDULER""));
		lblScheduleTitle.setFont(FontResource.getNormalFont());
		lblScheduleTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblScheduleTitle);
		y += h;

		JButton btViewScheduler = createButton1(""SETTINGS_VIEW"", 15, y);
		btViewScheduler.setName(""Q_MAN"");
		panel.add(btViewScheduler);
		y += btViewScheduler.getHeight();

		y += 10;
		y += 10;

		y += 10;
		h = 30;
		JLabel lblPwdHeader = new JLabel(StringResource.get(""SETTINGS_CRED""));
		lblPwdHeader.setForeground(Color.WHITE);
		lblPwdHeader.setFont(FontResource.getItemFont());
		lblPwdHeader.setBounds(15, y, 350 - 30, h);
		panel.add(lblPwdHeader);
		y += h;

		h = 40;
		JTextArea lblCredTitle = new JTextArea();
		lblCredTitle.setOpaque(false);
		lblCredTitle.setWrapStyleWord(true);
		lblCredTitle.setLineWrap(true);
		lblCredTitle.setEditable(false);
		lblCredTitle.setForeground(Color.WHITE);
		lblCredTitle.setText(StringResource.get(""HINT_PASSWORD""));
		lblCredTitle.setFont(FontResource.getNormalFont());
		lblCredTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblCredTitle);
		y += h;

		JButton btViewCred = createButton1(""SETTINGS_VIEW"", 15, y);
		btViewCred.setName(""PASS_MAN"");
		panel.add(btViewCred);
		y += btViewCred.getHeight();

		y += 10;
		y += 10;

		y += 10;
		h = 30;
		JLabel lblAdvHeader = new JLabel(StringResource.get(""SETTINGS_ADV""));
		lblAdvHeader.setForeground(Color.WHITE);
		lblAdvHeader.setFont(FontResource.getItemFont());
		lblAdvHeader.setBounds(15, y, 350 - 30, h);
		panel.add(lblAdvHeader);
		y += h;

		h = 50;
		JTextArea lblAdvTitle = new JTextArea();
		lblAdvTitle.setOpaque(false);
		lblAdvTitle.setWrapStyleWord(true);
		lblAdvTitle.setLineWrap(true);
		lblAdvTitle.setEditable(false);
		lblAdvTitle.setForeground(Color.WHITE);
		lblAdvTitle.setText(StringResource.get(""HINT_ADV""));
		lblAdvTitle.setFont(FontResource.getNormalFont());
		lblAdvTitle.setBounds(15, y, 350 - 30, h);
		panel.add(lblAdvTitle);
		y += h;

		JButton btViewAdv = createButton1(""SETTINGS_VIEW"", 15, y);
		btViewAdv.setName(""ADV_MAN"");
		panel.add(btViewAdv);
		y += btViewAdv.getHeight();

		y += 10;

		h = 30;
		panel.setPreferredSize(new Dimension(300, y + 50));
		// panel.setMinimumSize(new Dimension(300, 700));
		return panel;
	}"
xdman,xdman.ui.components.SettingsPage,createButton1,,12,21,0,3,0.1905,0.3795,1,5,1,0,1,"private JButton createButton1(String name, int x, int y) {
		JButton btn = new CustomButton(StringResource.get(name));
		btn.setBackground(ColorResource.getDarkBtnColor());
		btn.setBorderPainted(false);
		btn.setFocusPainted(false);
		btn.setForeground(Color.WHITE);
		btn.setFont(FontResource.getNormalFont());
		Dimension d = btn.getPreferredSize();
		btn.setBounds(x, y, d.width, d.height);
		btn.addActionListener(this);
		return btn;
	}"
xdman,xdman.ui.components.SettingsPage,createCheckBox,,11,19,0,3,0.2955,0.4198,1,3,1,0,1,"private JCheckBox createCheckBox(String name, Font font) {
		JCheckBox chk = new JCheckBox(StringResource.get(name));
		chk.setName(name);
		chk.setIcon(ImageResource.get(""unchecked.png""));
		chk.setSelectedIcon(ImageResource.get(""checked.png""));
		chk.setOpaque(false);
		chk.setFocusPainted(false);
		chk.setForeground(Color.WHITE);
		chk.setFont(font);
		return chk;
	}"
xdman,xdman.ui.components.SettingsPage,actionPerformed,,165,4235,3319,29,0.0359,0.0917,0.6,19,38,0,1,"@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() instanceof JRadioButton) {
			JRadioButton chk = (JRadioButton) e.getSource();
			if (""Q_DAILY"".equals(chk.getName()) || ""Q_ONCE"".equals(chk.getName())) {
				enableSchedulerFields();
			}
		}
		if (e.getSource() instanceof JMenuItem) {
			String name = ((JMenuItem) e.getSource()).getName();
			if (name != null) {
				if (name.startsWith(""Q_MOVE_TO:"")) {
					String targetQ = """";
					if (name.endsWith("":"")) {
						targetQ = """";
					} else {
						targetQ = name.split("":"")[1].trim();
					}
					int index = qItemsList.getSelectedIndex();
					if (index < 0)
						return;
					String id = queuedItemsModel.get(index);
					Logger.log(""Moving to target queue: "" + targetQ);
					index = qList.getSelectedIndex();
					if (index < 0)
						return;
					DownloadQueue sourceQ = queueModel.getElementAt(index);
					sourceQ.removeFromQueue(id);
					QueueManager.getInstance().getQueueById(targetQ).addToQueue(id);
					loadSchedulerSettings(index);
				}
				return;
			}
		}
		if (e.getSource() instanceof JCheckBox) {
			JCheckBox chk = (JCheckBox) e.getSource();
			if (""MSG_Q_START"".equals(chk.getName())) {
				enableSchedulerFields();
			}
		} else if (e.getSource() instanceof JButton) {
			JButton btn = (JButton) e.getSource();
			String name = btn.getName();
			if (""BTN_Q_SAVE"".equals(name)) {
				saveQueue();
				return;
			}
			if (""Q_MOVE_TO"".equals(name)) {
				showMoveQPopup(btn);
				return;
			}
			if (""BTN_Q_DEL"".equals(name)) {
				removeQueue();
			}
			if (""Q_MOVE_UP"".equals(name)) {
				queueMoveUp();
				return;
			}
			if (""Q_MOVE_DN"".equals(name)) {
				queueMoveDown();
				return;
			}
			if (""BTN_Q_NEW"".equals(name)) {
				createNewQueue();
				return;
			}
			if (""BTN_DEF_FILE_EXT"".equals(name)) {
				txtFileTyp.setText(XDMUtils.appendArray2Str(Config.getInstance().getDefaultFileTypes()));
				return;
			}
			if (""BTN_DEF_VID_EXT"".equals(name)) {
				txtVidType.setText(XDMUtils.appendArray2Str(Config.getInstance().getDefaultVideoTypes()));
				return;
			}
			if (""BTN_Q_NEW"".equals(name)) {
				createNewQueue();
				return;
			}
			if (""DEL_CRED"".equals(name)) {
				int index = passList.getSelectedIndex();
				if (index > -1) {
					PasswordItem item = passListModel.get(index);
					CredentialManager.getInstance().removeSavedCredential(item.host);
					loadPasswordSettings();
				}
			}
			if (""NEW_CRED"".equals(name)) {
				txtCredHostName.setText("""");
				txtUserName.setText("""");
				txtPassword.setText("""");
			}
			if (""SAVE_CRED"".equals(name)) {
				savePasswordSettings();
			}
			if (""BROWSE_ANTIVIR"".equals(name)) {
				JFileChooser jfc = new JFileChooser();
				if (jfc.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
					txtAntivirCmd.setText(jfc.getSelectedFile().getAbsolutePath());
				}
			}
			if (""SETTINGS_FOLDER_CHANGE"".equals(name)) {
				JFileChooser jfc = new JFileChooser();
				jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
				if (jfc.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
					txtDefFolder.setText(jfc.getSelectedFile().getAbsolutePath());
				}
			}
			if (""FF_INSTALL"".equals(name)) {
				if (!BrowserLauncher.launchFirefox(ffAMOURL)) {
					String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Mozilla Firefox"", ffAMOURL);
					MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,
							MessageBox.OK);
				}
			}
			if (""CR_INSTALL"".equals(name)) {
				if (!BrowserLauncher.launchChrome(chromeWebStoreURL)) {
					String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Google Chrome"",
							chromeWebStoreURL);
					MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,
							MessageBox.OK);
				}
			}
			if (""CM_INSTALL"".equals(name)) {
				String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Chromium"", chromeWebStoreURL);
				MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,
						MessageBox.OK);
			}
			if (""VL_INSTALL"".equals(name)) {
				String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Vivaldi"", chromeWebStoreURL);
				MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,
						MessageBox.OK);
			}
			if (""OP_INSTALL"".equals(name)) {
				String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Opera"", operaExtURL);
				MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,
						MessageBox.OK);
			}
			//
			// if (""GEN_INSTALL1"".equals(name)) {
			// String msg =
			// String.format(StringResource.get(""MSG_GENERIC_ADDON_DESC1""),
			// oldSignedPrivateMozillaExt,
			// ffAMOURL);
			// MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""),
			// msg, MessageBox.OK_OPTION,
			// MessageBox.OK);
			// }
			// if (""GEN_INSTALL2"".equals(name)) {
			// String msg =
			// String.format(StringResource.get(""MSG_GENERIC_ADDON_DESC2""),
			// chromeWebStoreURL,
			// directCRXURL);
			// MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""),
			// msg, MessageBox.OK_OPTION,
			// MessageBox.OK);
			// }
			if (setPage(name)) {
				level = 1;
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						jsp.getVerticalScrollBar().setValue(0);
					}
				});
			}
		}
	}"
xdman,xdman.ui.components.SettingsPage,loadSchedulerSettings,,8,18,15,4,0.2571,0.0917,0.5,2,2,0,1,"private void loadSchedulerSettings(int selectedQ) {
		queueModel.clear();
		for (DownloadQueue q : QueueManager.getInstance().getQueueList()) {
			queueModel.addElement(q);
		}
		qList.setSelectedIndex(selectedQ);
		qList.ensureIndexIsVisible(selectedQ);
	}"
xdman,xdman.ui.components.SettingsPage,loadOverviewSettings,,9,21,6,4,0.2037,0.1768,0.2,1,2,0,1,"private void loadOverviewSettings() {
		Config config = Config.getInstance();
		chkPrgWnd.setSelected(config.showDownloadWindow());
		System.out.println(config.showDownloadCompleteWindow());
		chkEndWnd.setSelected(config.showDownloadCompleteWindow());
		cmbMax.setSelectedItem(config.getMaxDownloads() > 0 ? config.getMaxDownloads() + """" : ""N/A"");
		// cmbDupAction.setSelectedIndex(config.getDuplicateAction());
		txtDefFolder.setText(config.getDownloadFolder());
	}"
xdman,xdman.ui.components.SettingsPage,loadNetworkSettings,,46,291,176,6,0.0874,0.1317,0.076923077,2,17,0,1,"private void loadNetworkSettings() {
		Config config = Config.getInstance();
		cmbSeg.setSelectedItem(config.getMaxSegments() + """");
		cmbTimeout.setSelectedItem(config.getNetworkTimeout() > 1 ? config.getNetworkTimeout() + """" : ""N/A"");
		cmbTcp.setSelectedItem(config.getTcpWindowSize() + """");
		txtSpeedLimit.setText(config.getSpeedLimit() < 1 ? ""N/A"" : config.getSpeedLimit() + """");
		int proxyMode = config.getProxyMode();
		if (proxyMode == 0) {
			chkUsePac.setSelected(false);
			chkUseProxy.setSelected(false);
			chkUseSocks.setSelected(false);
		} else if (proxyMode == 1) {
			chkUsePac.setSelected(true);
		} else if (proxyMode == 2) {
			chkUseProxy.setSelected(true);
		} else if (proxyMode == 3) {
			chkUseSocks.setSelected(true);
		}

		txtPACUrl.setText(config.getProxyPac());
		if (config.getProxyHost() == null || config.getProxyHost().length() < 1) {
			txtProxyHostnPort.setText("""");
		} else {
			txtProxyHostnPort
					.setText(config.getProxyHost() + (config.getProxyPort() > 0 ? "":"" + config.getProxyPort() : """"));
		}

		if (config.getSocksHost() == null || config.getSocksHost().length() < 1) {
			txtSocksHostnPort.setText("""");
		} else {
			txtSocksHostnPort
					.setText(config.getSocksHost() + (config.getSocksPort() > 0 ? "":"" + config.getSocksPort() : """"));
		}

		if (config.getProxyUser() == null || config.getProxyUser().length() < 1) {
			txtProxyUser.setText("""");
			txtProxyPass.setText("""");
		} else {
			txtProxyUser.setText(config.getProxyUser());
			if (config.getProxyPass() == null || config.getProxyPass().length() < 1) {
				txtProxyPass.setText("""");
			} else {
				txtProxyPass.setText(config.getProxyPass());
			}
		}
	}"
xdman,xdman.ui.components.SettingsPage,loadPasswordSettings,,16,87,69,6,0.14,0.0785,0.666666667,4,2,0,1,"private void loadPasswordSettings() {
		passListModel.clear();
		txtCredHostName.setText("""");
		txtUserName.setText("""");
		txtPassword.setText("""");
		Set<Entry<String, PasswordAuthentication>> credentials = CredentialManager.getInstance().getCredentials();
		Iterator<Entry<String, PasswordAuthentication>> it = credentials.iterator();
		while (it.hasNext()) {
			Entry<String, PasswordAuthentication> ent = it.next();
			PasswordItem item = new PasswordItem();
			item.host = ent.getKey();
			item.user = ent.getValue().getUserName();
			item.password = new String(ent.getValue().getPassword());
			passListModel.addElement(item);
		}
	}"
xdman,xdman.ui.components.SettingsPage,savePasswordSettings,,15,42,29,4,0.1727,0.074,0.6,4,3,0,1,"private void savePasswordSettings() {
		String host = txtCredHostName.getText();
		String user = txtUserName.getText();
		String password = txtPassword.getText();

		Logger.log(host + "" "" + user);

		if (StringUtils.isNullOrEmptyOrBlank(host) || StringUtils.isNullOrEmptyOrBlank(user)) {
			return;
		}
		CredentialManager mgr = CredentialManager.getInstance();
		mgr.addCredentialForHost(host, user, password, true);
		mgr.save();
		loadPasswordSettings();
	}"
xdman,xdman.ui.components.SettingsPage,createTextArea,,11,19,0,3,0.2727,0.5015,1,3,1,0,1,"private JTextArea createTextArea(String name, Font font) {
		JTextArea textArea = new JTextArea();
		textArea.setOpaque(false);
		textArea.setWrapStyleWord(true);
		textArea.setLineWrap(true);
		textArea.setEditable(false);
		textArea.setForeground(Color.WHITE);
		textArea.setText(StringResource.get(name));
		textArea.setFont(font);
		return textArea;
	}"
xdman,xdman.ui.components.SettingsPage,createBrowserIntPanel,,209,2068,1435,2,0.083,0.1174,0.75,26,1,0,1,"private JPanel createBrowserIntPanel() {
		JPanel p = new JPanel();
		p.setLayout(null);
		p.setOpaque(false);

		int y = 30;
		int h = 70;

		JTextArea txt1 = createTextArea(""DESC_MONITORING_1"");
		txt1.setBounds(15, y, 350 - 30, h);
		p.add(txt1);
		y += h;
		y += 30;

		h = 25;
		JLabel lblFirefox = new JLabel(StringResource.get(""DESC_MOZILLA_FIREFOX""));
		lblFirefox.setFont(FontResource.getBigFont());
		lblFirefox.setBounds(15, y, 135, h);
		p.add(lblFirefox);

		JLabel lblChrome = new JLabel(StringResource.get(""DESC_GOOGLE_CHROME""));
		lblChrome.setFont(FontResource.getBigFont());
		lblChrome.setBounds(180, y, 135, h);
		p.add(lblChrome);

		y += h;

		JButton btnFF = createButton2(""DESC_INSTALL"");
		btnFF.setName(""FF_INSTALL"");
		btnFF.setBounds(15, y, 140, h);
		p.add(btnFF);
		JButton btnCr = createButton2(""DESC_INSTALL"");
		btnCr.setName(""CR_INSTALL"");
		btnCr.setBounds(180, y, 140, h);
		p.add(btnCr);
		y += h;

		y += 15;
		h = 25;

		JLabel lblOpera = new JLabel(StringResource.get(""DESC_OPERA""));
		lblOpera.setFont(FontResource.getBigFont());
		lblOpera.setBounds(15, y, 135, h);
		p.add(lblOpera);

		JLabel lblCm = new JLabel(StringResource.get(""DESC_CHROMIUM""));
		lblCm.setFont(FontResource.getBigFont());
		lblCm.setBounds(180, y, 135, h);
		p.add(lblCm);

		y += h;

		JButton btnOp = createButton2(""DESC_INSTALL"");
		btnOp.setName(""OP_INSTALL"");
		btnOp.setBounds(15, y, 140, h);
		p.add(btnOp);
		JButton btnCm = createButton2(""DESC_INSTALL"");
		btnCm.setName(""CM_INSTALL"");
		btnCm.setBounds(180, y, 140, h);
		p.add(btnCm);
		y += h;

		y += 15;
		h = 25;

		JLabel lblEdge = new JLabel(StringResource.get(""DESC_VIVALDI""));
		lblEdge.setFont(FontResource.getBigFont());
		lblEdge.setName(""VL_INSTALL"");
		lblEdge.setBounds(15, y, 135, h);
		p.add(lblEdge);

		y += h;
		JButton btnEdge = createButton2(""DESC_INSTALL"");
		btnEdge.setName(""VL_INSTALL"");
		btnEdge.addActionListener(this);
		btnEdge.setBounds(15, y, 140, h);
		p.add(btnEdge);
		y += h;
		y += 40;

		h = 50;
		JTextArea txt2 = createTextArea(""DESC_OTHER_BROWSERS"");
		txt2.setBounds(15, y, 350 - 30, h);
		p.add(txt2);
		y += h;

		h = 30;
		JLabel labelMoz = new JLabel(StringResource.get(""DESC_MOZ""));
		labelMoz.setCursor(new Cursor(Cursor.HAND_CURSOR));
		labelMoz.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				showMsgFF();
			}
		});
		Font font = FontResource.getNormalFont();
		Map attributes = font.getAttributes();
		attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
		labelMoz.setBounds(15, y, 350 - 30, h);
		labelMoz.setFont(font.deriveFont(attributes));
		labelMoz.setForeground(Color.WHITE);
		p.add(labelMoz);
		y += h;

		h = 30;
		JLabel labelCr = new JLabel(StringResource.get(""DESC_CHROME""));
		labelCr.setCursor(new Cursor(Cursor.HAND_CURSOR));
		labelCr.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				showMsgChrome();
			}
		});
		labelCr.setBounds(15, y, 350 - 30, h);
		labelCr.setFont(font.deriveFont(attributes));
		labelCr.setForeground(Color.WHITE);
		p.add(labelCr);
		y += h;
		y += 40;

		h = 40;
		JTextArea txt3 = createTextArea(""DESC_FILETYPES"");
		txt3.setBounds(15, y, 350 - 40, h);
		p.add(txt3);
		y += h;

		h = 70;
		txtFileTyp = new JTextArea();
		txtFileTyp.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
		txtFileTyp.setOpaque(false);
		txtFileTyp.setWrapStyleWord(true);
		txtFileTyp.setLineWrap(true);
		txtFileTyp.setForeground(Color.WHITE);
		txtFileTyp.setFont(FontResource.getNormalFont());
		txtFileTyp.setBounds(15, y, 350 - 40, h);
		p.add(txtFileTyp);
		y += h;

		y += 10;
		h = 25;
		JButton btnDef1 = createButton2(""DESC_DEF"");
		btnDef1.setName(""BTN_DEF_FILE_EXT"");
		btnDef1.setBounds(310 - 125, y, 140, h);
		p.add(btnDef1);
		y += h;

		y += 40;

		h = 30;
		chkVidPan = createCheckBox(""OPT_VID_PANE"");
		chkVidPan.setBounds(15, y, 350 - 30, h);
		p.add(chkVidPan);
		y += h;
		y += 10;

		h = 40;
		JTextArea txt4 = createTextArea(""DESC_VIDEOTYPES"");
		txt4.setBounds(15, y, 350 - 40, h);
		p.add(txt4);
		y += h;

		h = 70;
		txtVidType = new JTextArea();
		txtVidType.setOpaque(false);
		txtVidType.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
		txtVidType.setWrapStyleWord(true);
		txtVidType.setLineWrap(true);
		txtVidType.setForeground(Color.WHITE);
		txtVidType.setFont(FontResource.getNormalFont());
		txtVidType.setBounds(15, y, 350 - 40, h);
		p.add(txtVidType);
		y += h;
		y += 10;

		h = 25;
		JButton btnDef2 = createButton2(""DESC_DEF"");
		btnDef2.setName(""BTN_DEF_VID_EXT"");
		btnDef2.setBounds(310 - 125, y, 140, h);
		p.add(btnDef2);
		y += h;

		y += 40;

		h = 40;
		JTextArea txt6 = createTextArea(""DESC_SITEEXCEPTIONS"");
		txt6.setBounds(15, y, 350 - 30, h);
		p.add(txt6);
		y += h;

		h = 70;
		txtBlockedHosts = new JTextArea();
		txtBlockedHosts.setOpaque(false);
		txtBlockedHosts.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
		txtBlockedHosts.setWrapStyleWord(true);
		txtBlockedHosts.setLineWrap(true);
		txtBlockedHosts.setForeground(Color.WHITE);
		txtBlockedHosts.setFont(FontResource.getNormalFont());
		txtBlockedHosts.setBounds(15, y, 350 - 40, h);
		p.add(txtBlockedHosts);
		y += h;

		y += 20;

		y += 30;

		p.setPreferredSize(new Dimension(350, y));

		return p;
	}"
xdman,xdman.ui.components.SettingsPage,createNetworkPanel,,208,12587,9243,3,0.0524,0.1099,0.571428571,12,1,0,1,"private JPanel createNetworkPanel() {
		JPanel p = new JPanel();
		p.setLayout(null);
		p.setOpaque(false);

		int y = 20;
		int h = 50;

		h = 30;
		JLabel lbl1 = new JLabel(StringResource.get(""DESC_NET""));
		lbl1.setForeground(Color.WHITE);
		lbl1.setFont(FontResource.getItemFont());
		lbl1.setBounds(15, y, 350 - 30, h);
		p.add(lbl1);
		y += h;

		y += 20;
		h = 25;
		JLabel lbl2 = new JLabel(StringResource.get(""DESC_NET1""));
		lbl2.setForeground(Color.WHITE);
		lbl2.setFont(FontResource.getNormalFont());
		lbl2.setBounds(15, y, 200, h);
		p.add(lbl2);
		y += 5;

		h = 20;
		cmbTimeout = new JComboBox<String>(new String[] { ""10"", ""30"", ""60"", ""120"", ""180"", ""360"", ""N/A"" });
		cmbTimeout.setBackground(ColorResource.getDarkerBgColor());
		cmbTimeout.setBounds(250, y, 75, h);
		cmbTimeout.setRenderer(new SimpleListRenderer());
		p.add(cmbTimeout);
		y += h;

		y += 10;
		h = 25;
		JLabel lbl3 = new JLabel(StringResource.get(""DESC_NET2""));
		lbl3.setForeground(Color.WHITE);
		lbl3.setFont(FontResource.getNormalFont());
		lbl3.setBounds(15, y, 200, h);
		p.add(lbl3);
		y += 5;

		h = 20;
		cmbSeg = new JComboBox<String>(new String[] { ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10"", ""11"", ""12"",
				""13"", ""14"", ""15"", ""16"", ""20"", ""25"", ""30"", ""32"" });

		cmbSeg.setBackground(ColorResource.getDarkerBgColor());
		cmbSeg.setBounds(250, y, 75, h);
		cmbSeg.setRenderer(new SimpleListRenderer());
		p.add(cmbSeg);
		y += h;

		y += 10;
		h = 25;
		JLabel lbl4 = new JLabel(StringResource.get(""DESC_NET3""));
		lbl4.setForeground(Color.WHITE);
		lbl4.setFont(FontResource.getNormalFont());
		lbl4.setBounds(15, y, 200, h);
		p.add(lbl4);
		y += 5;

		h = 20;
		cmbTcp = new JComboBox<String>(new String[] { ""8"", ""16"", ""32"", ""64"" });

		cmbTcp.setBackground(ColorResource.getDarkerBgColor());
		cmbTcp.setBounds(250, y, 75, h);
		cmbTcp.setRenderer(new SimpleListRenderer());
		p.add(cmbTcp);
		y += h;

		y += 50;

		h = 30;
		JLabel lbl51 = new JLabel(StringResource.get(""SPEED_LIMIT_TITLE""));
		lbl51.setForeground(Color.WHITE);
		lbl51.setFont(FontResource.getItemFont());
		lbl51.setBounds(15, y, 350 - 30, h);
		p.add(lbl51);
		y += h;

		h = 30;
		JLabel lbl71 = new JLabel(StringResource.get(""MSG_SPEED_LIMIT""));
		lbl71.setForeground(Color.WHITE);
		lbl71.setFont(FontResource.getNormalFont());
		lbl71.setBounds(15, y, 350 - 30, h);
		p.add(lbl71);
		y += h;

		h = 25;
		txtSpeedLimit = new JTextField();
		txtSpeedLimit.setBounds(15, y, 350 - 250, h);
		txtSpeedLimit.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtSpeedLimit.setEditable(true);
		txtSpeedLimit.setCaretColor(ColorResource.getActiveTabColor());
		txtSpeedLimit.setForeground(Color.WHITE);
		txtSpeedLimit.setOpaque(false);
		p.add(txtSpeedLimit);
		y += h;

		y += 50;

		h = 30;
		JLabel lbl5 = new JLabel(StringResource.get(""DESC_NET4""));
		lbl5.setForeground(Color.WHITE);
		lbl5.setFont(FontResource.getItemFont());
		lbl5.setBounds(15, y, 350 - 30, h);
		p.add(lbl5);
		y += h;

		y += 10;
		h = 30;
		chkUsePac = createCheckBox(""DESC_NET5"");
		chkUsePac.setBounds(15, y, 350 - 30, h);
		p.add(chkUsePac);
		y += h;

		h = 25;
		txtPACUrl = new JTextField();
		txtPACUrl.setBounds(15, y, 350 - 30 - 10, h);
		txtPACUrl.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtPACUrl.setEditable(true);
		txtPACUrl.setForeground(Color.WHITE);
		txtPACUrl.setCaretColor(ColorResource.getActiveTabColor());
		txtPACUrl.setOpaque(false);
		p.add(txtPACUrl);
		y += h;

		y += 10;
		h = 30;
		chkUseProxy = createCheckBox(""DESC_NET6"");
		chkUseProxy.setBounds(15, y, 350 - 30, h);
		p.add(chkUseProxy);
		y += h;

		h = 25;
		txtProxyHostnPort = new JTextField();
		txtProxyHostnPort.setBounds(15, y, 350 - 30 - 10, h);
		txtProxyHostnPort.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtProxyHostnPort.setEditable(true);
		txtProxyHostnPort.setCaretColor(ColorResource.getActiveTabColor());
		txtProxyHostnPort.setForeground(Color.WHITE);
		txtProxyHostnPort.setOpaque(false);
		p.add(txtProxyHostnPort);
		y += h;

		y += 10;
		h = 30;
		chkUseSocks = createCheckBox(""DESC_NET9"");
		chkUseSocks.setBounds(15, y, 350 - 30, h);
		p.add(chkUseSocks);
		y += h;

		h = 25;
		txtSocksHostnPort = new JTextField();
		txtSocksHostnPort.setBounds(15, y, 350 - 30 - 10, h);
		txtSocksHostnPort.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtSocksHostnPort.setEditable(true);
		txtSocksHostnPort.setCaretColor(ColorResource.getActiveTabColor());
		txtSocksHostnPort.setForeground(Color.WHITE);
		txtSocksHostnPort.setOpaque(false);
		p.add(txtSocksHostnPort);
		y += h;
		y += 10;

		h = 30;
		JLabel lbl6 = new JLabel(StringResource.get(""DESC_NET7""));
		lbl6.setForeground(Color.WHITE);
		lbl6.setFont(FontResource.getNormalFont());
		lbl6.setBounds(15, y, 350 - 30, h);
		p.add(lbl6);
		y += h;

		h = 25;
		txtProxyUser = new JTextField();
		txtProxyUser.setBounds(15, y, 350 - 30 - 10, h);
		txtProxyUser.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtProxyUser.setCaretColor(ColorResource.getActiveTabColor());
		txtProxyUser.setEditable(true);
		txtProxyUser.setForeground(Color.WHITE);
		txtProxyUser.setOpaque(false);
		p.add(txtProxyUser);
		y += h;
		y += 10;
		h = 30;
		JLabel lbl7 = new JLabel(StringResource.get(""DESC_NET8""));
		lbl7.setForeground(Color.WHITE);
		lbl7.setFont(FontResource.getNormalFont());
		lbl7.setBounds(15, y, 350 - 30, h);
		p.add(lbl7);
		y += h;

		h = 25;
		txtProxyPass = new JPasswordField();
		txtProxyPass.setBounds(15, y, 320 - 10, h);
		txtProxyPass.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtProxyPass.setCaretColor(ColorResource.getActiveTabColor());
		txtProxyPass.setEditable(true);
		txtProxyPass.setForeground(Color.WHITE);
		txtProxyPass.setOpaque(false);
		p.add(txtProxyPass);
		y += h;

		y += 50;

		p.setPreferredSize(new Dimension(350, y));

		return p;
	}"
xdman,xdman.ui.components.SettingsPage,createSchedulerPanel,,243,18643,16171,3,0.0258,0.0558,0.777777778,30,9,0,1,"private JPanel createSchedulerPanel() {
		JPanel p = new JPanel();
		p.setLayout(null);
		p.setOpaque(false);

		int y = 5;

		h = 30;
		JLabel lbl67 = new JLabel(StringResource.get(""Q_LIST_DESC""));
		lbl67.setForeground(Color.WHITE);
		lbl67.setFont(FontResource.getNormalFont());
		lbl67.setBounds(15, y, 350 - 30, h);
		p.add(lbl67);
		y += h;

		int h = 100;

		queueModel = new DefaultListModel<DownloadQueue>();
		qList = new JList<DownloadQueue>(queueModel);
		qList.setCellRenderer(new QueueListRenderer());
		qList.setBorder(null);
		qList.setOpaque(false);
		qList.setSelectedIndex(0);
		qList.addListSelectionListener(this);

		JScrollPane jsp2 = new JScrollPane();
		jsp2.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
		jsp2.getViewport().setOpaque(false);
		jsp2.setViewportView(qList);
		jsp2.setBounds(15, y, 350 - 40, h);
		jsp2.setOpaque(false);
		DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
		jsp2.setVerticalScrollBar(scrollBar);
		jsp2.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		p.add(jsp2);
		y += h;
		y += 10;

		h = 25;
		JButton btnSave = createButton2(""DESC_PASS_NEW"");
		btnSave.setName(""BTN_Q_NEW"");
		btnSave.setBounds(15, y, 80, h);
		p.add(btnSave);
		JButton btnDel = createButton2(""DESC_PASS_DEL"");
		btnDel.setName(""BTN_Q_DEL"");
		btnDel.setBounds(15 + 80 + 10, y, 80, h);
		p.add(btnDel);
		JButton btnNew = createButton2(""DESC_SAVE_Q"");
		btnNew.setName(""BTN_Q_SAVE"");
		btnNew.setBounds(350 - 25 - 80, y, 80, h);
		p.add(btnNew);
		y += h;
		y += 20;

		h = 30;
		JLabel lbl6 = new JLabel(StringResource.get(""MSG_QNAME""));
		lbl6.setForeground(Color.WHITE);
		lbl6.setFont(FontResource.getNormalFont());
		lbl6.setBounds(15, y, 350 - 30, h);
		p.add(lbl6);
		y += h;

		h = 25;
		txtQueueName = new JTextField();
		txtQueueName.setCaretColor(Color.WHITE);
		txtQueueName.setBounds(15, y, 350 - 30 - 10, h);
		txtQueueName.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtQueueName.setEditable(true);
		txtQueueName.setForeground(Color.WHITE);
		txtQueueName.setOpaque(false);
		p.add(txtQueueName);
		y += h;
		y += 20;

		h = 30;
		JLabel lbl69 = new JLabel(StringResource.get(""Q_LIST_FILES""));
		lbl69.setForeground(Color.WHITE);
		lbl69.setFont(FontResource.getNormalFont());
		lbl69.setBounds(15, y, 350 - 30, h);
		p.add(lbl69);
		y += h;

		h = 100;

		queuedItemsModel = new DefaultListModel<String>();
		qItemsList = new JList<String>(queuedItemsModel);
		qItemsList.setCellRenderer(new QueuedItemsRenderer());
		qItemsList.setBorder(null);
		qItemsList.setOpaque(false);
		qItemsList.addListSelectionListener(this);

		JScrollPane jsp3 = new JScrollPane();
		jsp3.setBorder(new LineBorder(ColorResource.getDarkBgColor()));
		jsp3.getViewport().setOpaque(false);
		jsp3.setViewportView(qItemsList);
		jsp3.setBounds(15, y, 350 - 40, h);
		jsp3.setOpaque(false);
		DarkScrollBar scrollBar2 = new DarkScrollBar(JScrollBar.VERTICAL);
		jsp3.setVerticalScrollBar(scrollBar2);
		jsp3.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		jsp3.setAutoscrolls(true);
		p.add(jsp3);
		y += h;
		y += 10;

		h = 25;
		JButton btnQMoveUp = createButton2(""Q_MOVE_UP"");
		btnQMoveUp.setName(""Q_MOVE_UP"");
		btnQMoveUp.setBounds(15, y, 100, h);
		p.add(btnQMoveUp);
		JButton btnQMoveDown = createButton2(""Q_MOVE_DN"");
		btnQMoveDown.setName(""Q_MOVE_DN"");
		btnQMoveDown.setBounds(15 + 100 + 5, y, 100, h);
		p.add(btnQMoveDown);
		btnQMoveTo = createButton2(""Q_MOVE_TO"");
		btnQMoveTo.setName(""Q_MOVE_TO"");
		btnQMoveTo.setBounds(350 - 25 - 100, y, 100, h);
		p.add(btnQMoveTo);
		y += h;
		y += 20;

		h = 30;
		JLabel lbl68 = new JLabel(StringResource.get(""Q_SCHEDULE_TXT""));
		lbl68.setForeground(Color.WHITE);
		lbl68.setFont(FontResource.getNormalFont());
		lbl68.setBounds(15, y, 350 - 30, h);
		p.add(lbl68);
		y += h;
		y += 10;

		h = 20;
		chkQStart = createCheckBox(""MSG_Q_START"");
		chkQStart.setBounds(15, y, 150, h);
		chkQStart.addActionListener(this);
		p.add(chkQStart);

		spinnerDateModel1 = new SpinnerDateModel(new Date(), null, null, Calendar.HOUR_OF_DAY);
		spStartTime = new JSpinner(spinnerDateModel1);
		spStartTime.setForeground(Color.WHITE);
		spStartTime.setBackground(ColorResource.getDarkBgColor());
		spStartTime.setBorder(null);
		JSpinner.DateEditor ed1 = new JSpinner.DateEditor(spStartTime, ""hh:mm a"");
		int n = ed1.getComponentCount();
		for (int i = 0; i < n; i++) {
			Component c = ed1.getComponent(i);
			if (c instanceof JTextField) {
				c.setForeground(Color.WHITE);
				c.setBackground(ColorResource.getDarkBtnColor());
			}
		}

		spStartTime.setEditor(ed1);
		spStartTime.setBounds(210, y, 115, h);
		p.add(spStartTime);
		y += h;
		y += 5;

		h = 20;
		chkQStop = createCheckBox(""MSG_Q_STOP"");
		chkQStop.setBounds(15, y, 150, h);
		p.add(chkQStop);
		spinnerDateModel2 = new SpinnerDateModel(new Date(), null, null, Calendar.HOUR_OF_DAY);
		spEndTime = new JSpinner(spinnerDateModel2);
		spEndTime.setBorder(null);
		JSpinner.DateEditor ed2 = new JSpinner.DateEditor(spEndTime, ""hh:mm a"");
		n = ed2.getComponentCount();
		for (int i = 0; i < n; i++) {
			Component c = ed2.getComponent(i);
			if (c instanceof JTextField) {
				c.setForeground(Color.WHITE);
				c.setBackground(ColorResource.getDarkBtnColor());
			}
		}
		spEndTime.setEditor(ed2);
		spEndTime.setBounds(210, y, 115, h);
		p.add(spEndTime);

		y += h;

		y += 20;

		ButtonGroup radioGroup = new ButtonGroup();

		h = 30;
		radOnetime = createRadioButton(""MSQ_Q_ONETIME"", FontResource.getNormalFont());
		radOnetime.setName(""Q_ONCE"");
		radOnetime.addActionListener(this);
		radOnetime.setBounds(15, y, 120, h);
		p.add(radOnetime);
		radOnetime.setEnabled(false);
		radioGroup.add(radOnetime);
		y += 5;

		h = 20;
		spinnerDateModel3 = new SpinnerDateModel(new Date(), DateTimeUtils.getBeginDate(), DateTimeUtils.getEndDate(),
				Calendar.DAY_OF_MONTH);
		spExecDate = new JSpinner(spinnerDateModel3);
		spExecDate.setBorder(null);
		JSpinner.DateEditor ed3 = new JSpinner.DateEditor(spExecDate, ""dd-MMM-yy"");
		n = ed3.getComponentCount();
		for (int i = 0; i < n; i++) {
			Component c = ed3.getComponent(i);
			if (c instanceof JTextField) {
				c.setForeground(Color.WHITE);
				c.setBackground(ColorResource.getDarkBtnColor());
			}
		}
		spExecDate.setEditor(ed3);
		spExecDate.setBounds(120, y, 205, h);
		p.add(spExecDate);
		y += h;
		y += 15;

		radPeriodic = createRadioButton(""MSG_Q_DAILY"", FontResource.getNormalFont());
		radPeriodic.setName(""Q_DAILY"");
		radPeriodic.addActionListener(this);
		radPeriodic.setBounds(15, y, 100, h);
		p.add(radPeriodic);
		radioGroup.add(radPeriodic);

		h = 20;
		int x = 120;
		chkDays = new JCheckBox[7];
		for (int i = 1; i < 8; i++) {
			JCheckBox chkDay = createCheckBox(""MSG_Q_D"" + i, FontResource.getNormalFont());
			chkDay.setBounds(x, y, 100, h);
			p.add(chkDay);
			chkDays[i - 1] = chkDay;
			x += 100;
			if (i % 2 == 0) {
				x = 120;
				y += h;
			}
		}

		y += h;
		y += 20;

		y += 50;

		p.setPreferredSize(new Dimension(350, y));
		return p;
	}"
xdman,xdman.ui.components.SettingsPage,createAdvPanel,,94,2501,1599,3,0.0849,0.1388,1,6,1,0,1,"private JPanel createAdvPanel() {
		JPanel p = new JPanel();
		p.setLayout(null);
		p.setOpaque(false);

		int y = 20;
		int h = 0;
		y += h;

		h = 30;
		chkHaltAfterFinish = createCheckBox(""MSG_HALT"");
		chkHaltAfterFinish.setBounds(15, y, 350, h);
		p.add(chkHaltAfterFinish);
		y += h;

		h = 30;
		chkKeepAwake = createCheckBox(""MSG_AWAKE"");
		chkKeepAwake.setBounds(15, y, 350, h);
		p.add(chkKeepAwake);
		y += h;

		h = 30;
		chkExecCmd = createCheckBox(""EXEC_CMD"");
		chkExecCmd.setBounds(15, y, 350, h);
		p.add(chkExecCmd);
		y += h;

		h = 25;
		txtCustomCmd = new JTextField();
		txtCustomCmd.setBounds(15, y, 350 - 30 - 10, h);
		txtCustomCmd.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtCustomCmd.setForeground(Color.WHITE);
		txtCustomCmd.setOpaque(false);
		p.add(txtCustomCmd);
		y += h;
		y += 20;

		h = 30;
		chkExecAntivir = createCheckBox(""EXE_ANTI_VIR"");
		chkExecAntivir.setBounds(15, y, 350, h);
		p.add(chkExecAntivir);
		y += h;
		y += 5;

		h = 30;
		JLabel lbl12 = new JLabel(StringResource.get(""ANTIVIR_CMD""));
		lbl12.setForeground(Color.WHITE);
		lbl12.setFont(FontResource.getNormalFont());
		lbl12.setBounds(15, y, 350 - 30, h);
		p.add(lbl12);
		y += h;

		h = 25;
		txtAntivirCmd = new JTextField();
		txtAntivirCmd.setBounds(15, y, 350 - 30 - 10 - 100, h);
		txtAntivirCmd.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtAntivirCmd.setForeground(Color.WHITE);
		txtAntivirCmd.setOpaque(false);
		p.add(txtAntivirCmd);
		JButton btnBrowse = createButton2(""BTN_BROWSE"");
		btnBrowse.setName(""BROWSE_ANTIVIR"");
		btnBrowse.setBackground(ColorResource.getDarkBtnColor());
		btnBrowse.setFont(FontResource.getNormalFont());
		btnBrowse.setBounds(15 + 350 - 30 - 110 + 10, y, 90, h);
		p.add(btnBrowse);
		y += h;

		h = 30;
		JLabel lbl1 = new JLabel(StringResource.get(""ANTIVIR_ARGS""));
		lbl1.setForeground(Color.WHITE);
		lbl1.setFont(FontResource.getNormalFont());
		lbl1.setBounds(15, y, 350 - 30, h);
		p.add(lbl1);
		y += h;

		h = 25;
		txtAntivirArgs = new JTextField();
		txtAntivirArgs.setBounds(15, y, 350 - 30 - 10, h);
		txtAntivirArgs.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
		txtAntivirArgs.setForeground(Color.WHITE);
		txtAntivirArgs.setOpaque(false);
		p.add(txtAntivirArgs);
		y += h;
		y += 20;
		h = 30;
		chkAutoStart = createCheckBox(""AUTO_START"");
		chkAutoStart.setBounds(15, y, 350, h);
		p.add(chkAutoStart);
		y += h;
		y += 50;

		p.setPreferredSize(new Dimension(350, y));
		return p;
	}"
xdman,xdman.ui.components.SettingsPage,loadAdvSettings,,14,27,0,4,0.1591,0.159,0.3,1,4,0,1,"private void loadAdvSettings() {
		Config config = Config.getInstance();
		chkHaltAfterFinish.setSelected(config.isAutoShutdown());
		chkKeepAwake.setSelected(config.isKeepAwake());
		chkExecCmd.setSelected(config.isExecCmd());
		chkExecAntivir.setSelected(config.isExecAntivir());
		chkAutoStart.setSelected(XDMUtils.isAlreadyAutoStart());
		if (!StringUtils.isNullOrEmptyOrBlank(config.getCustomCmd()))
			txtCustomCmd.setText(config.getCustomCmd());
		if (!StringUtils.isNullOrEmptyOrBlank(config.getAntivirCmd()))
			txtAntivirArgs.setText(config.getAntivirCmd());
		if (!StringUtils.isNullOrEmptyOrBlank(config.getAntivirExe()))
			txtAntivirCmd.setText(config.getAntivirExe());
	}"
xdman,xdman.ui.components.SettingsPage,saveAdvSettings,,19,104,72,6,0.105,0.0852,0.2,4,2,0,1,"private void saveAdvSettings() {
		Config config = Config.getInstance();
		config.setAutoShutdown(chkHaltAfterFinish.isSelected());
		config.setKeepAwake(chkKeepAwake.isSelected());
		config.setExecCmd(chkExecCmd.isSelected());
		config.setExecAntivir(chkExecAntivir.isSelected());
		if (chkAutoStart.isSelected()) {
			XDMUtils.addToStartup();
		} else {
			XDMUtils.removeFromStartup();
		}
		// config.setAutoStart(chkAutoStart.isSelected());
		String customCmd = txtCustomCmd.getText();
		config.setCustomCmd(customCmd);
		String antivirExec = txtAntivirCmd.getText();
		config.setAntivirExe(antivirExec);
		String antivirCmd = txtAntivirArgs.getText();
		config.setAntivirCmd(antivirCmd);
	}"
xdman,xdman.ui.components.SettingsPage,updateSchedulerFields,,55,533,436,8,0.066,0.057,0.25,10,12,0,1,"private void updateSchedulerFields() {
		int index = qList.getSelectedIndex();
		if (index < 0)
			return;

		DownloadQueue q = queueModel.getElementAt(index);
		txtQueueName.setText(q.getName());

		loadQueuedItems(q);

		btnQMoveTo.setEnabled(QueueManager.getInstance().getQueueList().size() > 1 && q.getQueuedItems().size() > 0);

		Date startTime = DateTimeUtils.addTimePart(q.getStartTime());
		Date endTime = DateTimeUtils.addTimePart(q.getEndTime());

		if (startTime == null) {
			endTime = null;
		}

		chkQStart.setSelected(startTime != null);
		chkQStop.setSelected(endTime != null);

		if (startTime == null) {
			startTime = DateTimeUtils.getDefaultStart();
		}
		if (endTime == null || endTime.before(startTime)) {
			endTime = DateTimeUtils.getDefaultEnd();
		}

		spinnerDateModel1.setValue(startTime);
		spinnerDateModel2.setValue(endTime);

		for (int i = 1; i <= 7; i++) {
			JCheckBox chk = chkDays[i - 1];
			chk.setSelected(false);
		}

		int mask = 0x01;
		if (q.isPeriodic()) {
			for (int i = 1; i <= 7; i++) {
				JCheckBox chk = chkDays[i - 1];
				chk.setSelected((q.getDayMask() & mask) == mask);
				mask = mask << 1;
			}
			radPeriodic.setSelected(true);
		} else {
			Date execDate = q.getExecDate();
			if (execDate == null || execDate.before(new Date())) {
				execDate = new Date();
			}
			radOnetime.setSelected(true);
			spinnerDateModel3.setValue(execDate);
		}
		enableSchedulerFields();
	}"
xdman,xdman.ui.components.SettingsPage,loadQueuedItems,,10,21,14,4,0.25,0.108,1,3,3,0,1,"private void loadQueuedItems(DownloadQueue q) {
		queuedItemsModel.clear();
		ArrayList<String> idList = q.getQueuedItems();
		for (int i = 0; i < idList.size(); i++) {
			queuedItemsModel.addElement(idList.get(i));
		}
		if (idList.size() > 0) {
			qItemsList.setSelectedIndex(0);
		}
	}"
xdman,xdman.ui.components.SettingsPage,enableSchedulerFields,,14,17,0,3,0.225,0.2278,0,1,4,0,1,"private void enableSchedulerFields() {
		radOnetime.setEnabled(chkQStart.isSelected());
		radPeriodic.setEnabled(chkQStart.isSelected());
		spExecDate.setEnabled(chkQStart.isSelected());
		spStartTime.setEnabled(chkQStart.isSelected());
		spEndTime.setEnabled(chkQStart.isSelected());
		chkQStop.setEnabled(chkQStart.isSelected());
		spExecDate.setEnabled(radOnetime.isSelected() && chkQStart.isSelected());

		for (int i = 0; i < 7; i++) {
			chkDays[i].setEnabled(chkQStart.isSelected() && radPeriodic.isSelected());
		}

	}"
xdman,xdman.ui.components.SettingsPage,saveQueue,,49,428,328,6,0.0758,0.0926,0.3,8,9,0,1,"private void saveQueue() {
		int index = qList.getSelectedIndex();
		if (index < 0)
			return;
		DownloadQueue q = queueModel.getElementAt(index);
		if (txtQueueName.getText().length() > 0) {
			q.setName(txtQueueName.getText());
		}
		if (chkQStart.isSelected()) {

			q.setStartTime(DateTimeUtils.getTimePart(spinnerDateModel1.getDate()));
			System.out.println(spinnerDateModel1.getDate());
			if (chkQStop.isSelected()) {
				q.setEndTime(DateTimeUtils.getTimePart(spinnerDateModel2.getDate()));
			} else {
				q.setEndTime(-1);
			}
			if (radOnetime.isSelected()) {
				q.setPeriodic(false);
				q.setExecDate(spinnerDateModel3.getDate());
				q.setDayMask(0);
			} else {
				q.setPeriodic(true);
				q.setExecDate(null);
				int dayMask = 0;
				int mask = 0x01;
				for (int i = 1; i <= 7; i++) {
					JCheckBox chk = chkDays[i - 1];
					if (chk.isSelected()) {
						dayMask |= mask;
					}
					mask = mask << 1;
				}
				q.setDayMask(dayMask);
			}
		} else {
			q.setStartTime(-1);
		}

		ArrayList<String> newOrder = new ArrayList<String>(queuedItemsModel.size());

		for (int i = 0; i < queuedItemsModel.size(); i++) {
			newOrder.add(queuedItemsModel.get(i));
		}

		q.reorderItems(newOrder);

		QueueManager.getInstance().saveQueues();
	}"
xdman,xdman.ui.components.SettingsPage,queueMoveUp,,17,19,0,3,0.3636,0.3086,0,3,3,0,1,"private void queueMoveUp() {
		int index = qItemsList.getSelectedIndex();
		if (index < 0) {
			return;
		}
		if (index == 0) {
			return;
		}
		String prevId = queuedItemsModel.get(index - 1);
		String nextId = queuedItemsModel.get(index);

		queuedItemsModel.set(index, prevId);
		queuedItemsModel.set(index - 1, nextId);

		qItemsList.setSelectedIndex(index - 1);
		qItemsList.ensureIndexIsVisible(index - 1);
	}"
xdman,xdman.ui.components.SettingsPage,queueMoveDown,,16,19,0,3,0.3247,0.2556,0,3,3,0,1,"private void queueMoveDown() {
		int index = qItemsList.getSelectedIndex();
		if (index < 0)
			return;
		if (index == queuedItemsModel.size() - 1) {
			return;
		}
		String prevId = queuedItemsModel.get(index);
		String nextId = queuedItemsModel.get(index + 1);

		queuedItemsModel.set(index + 1, prevId);
		queuedItemsModel.set(index, nextId);

		qItemsList.setSelectedIndex(index + 1);
		qItemsList.ensureIndexIsVisible(index + 1);
	}"
xdman,xdman.ui.components.SettingsPage,removeQueue,,8,13,5,3,0.2857,0.1375,0.5,2,3,0,1,"private void removeQueue() {
		int index = qList.getSelectedIndex();
		if (index < 1)
			return;
		DownloadQueue q = queueModel.get(index);
		QueueManager.getInstance().removeQueue(q.getQueueId());
		loadSchedulerSettings(index < QueueManager.getInstance().getQueueList().size() ? index : index - 1);
	}"
xdman,xdman.ui.components.SettingsPage,createNewQueue,,6,10,5,3,0.3889,0.1429,0.333333333,2,2,0,1,"private void createNewQueue() {
		int index = QueueManager.getInstance().getQueueList().size();
		QueueManager.getInstance().createNewQueue();
		int count = QueueManager.getInstance().getQueueList().size();
		loadSchedulerSettings(index < count ? index : 0);
	}"
xdman,xdman.ui.components.SettingsPage,showMoveQPopup,,25,139,107,3,0.1255,0.0843,0.6,8,5,0,1,"private void showMoveQPopup(JButton btn) {
		int index = qList.getSelectedIndex();
		if (index < 0) {
			return;
		}
		DownloadQueue q = queueModel.get(index);
		String qid = q.getQueueId();
		if (qid == null)
			return;
		JPopupMenu popupMenu = new JPopupMenu();
		for (int i = 0; i < QueueManager.getInstance().getQueueList().size(); i++) {
			DownloadQueue tq = QueueManager.getInstance().getQueueList().get(i);
			if (qid.equals(tq.getQueueId())) {
				continue;
			}
			JMenuItem item = new JMenuItem(tq.getName());
			item.setName(""Q_MOVE_TO:"" + tq.getQueueId());
			item.addActionListener(this);
			item.setForeground(Color.WHITE);
			item.setFont(FontResource.getNormalFont());
			popupMenu.add(item);
		}
		popupMenu.setInvoker(btn);
		popupMenu.show(btn, 0, btn.getHeight());
	}"
xdman,xdman.ui.components.SettingsPage,saveOverviewSettings,,14,42,18,4,0.1667,0.1548,0.166666667,2,2,0,1,"private void saveOverviewSettings() {
		Config config = Config.getInstance();
		config.setShowDownloadWindow(chkPrgWnd.isSelected());
		config.setShowDownloadCompleteWindow(chkEndWnd.isSelected());
		String text = cmbMax.getSelectedItem() + """";
		if (""N/A"".equals(text)) {
			config.setMaxDownloads(0);
		} else {
			config.setMaxDownloads(Integer.parseInt(text));
		}
		// config.setDuplicateAction(cmbDupAction.getSelectedIndex());
		config.setDownloadFolder(txtDefFolder.getText());
		config.save();
	}"
xdman,xdman.ui.components.SettingsPage,saveNetworkSettings,,71,1294,1103,10,0.0552,0.0506,0.076923077,14,18,0,1,"private void saveNetworkSettings() {
		Config config = Config.getInstance();
		config.setNetworkTimeout(
				cmbTimeout.getSelectedItem().equals(""N/A"") ? 0 : Integer.parseInt(cmbTimeout.getSelectedItem() + """"));
		config.setMaxSegments(Integer.parseInt(cmbSeg.getSelectedItem() + """"));
		config.setTcpWindowSize(Integer.parseInt(cmbTcp.getSelectedItem() + """"));
		try {
			int speedLimit = Integer.parseInt(txtSpeedLimit.getText());
			config.setSpeedLimit(speedLimit);
		} catch (Exception e) {
		}

		int proxyMode = 0;
		if (chkUsePac.isSelected()) {
			proxyMode = 1;
		} else if (chkUseProxy.isSelected()) {
			proxyMode = 2;
		} else if (chkUseSocks.isSelected()) {
			proxyMode = 3;
		}

		config.setProxyMode(proxyMode);

		config.setProxyPac(txtPACUrl.getText());
		String proxyText = txtProxyHostnPort.getText();
		if (proxyText.length() > 0) {
			String host = null;
			int port = 80;
			if (proxyText.indexOf("":"") != -1) {
				String[] arr = proxyText.split("":"");
				host = arr[0];
				try {
					port = Integer.parseInt(arr[1]);
				} catch (Exception e) {
					host = null;
					port = 0;
				}
			} else {
				host = proxyText;
			}
			if (port > 0 && host != null && host.length() > 0) {
				config.setProxyHost(host);
				config.setProxyPort(port);
			}
		}

		String socksText = txtSocksHostnPort.getText();
		if (socksText.length() > 0) {
			String host = null;
			int port = 1080;
			if (socksText.indexOf("":"") != -1) {
				String[] arr = socksText.split("":"");
				host = arr[0];
				try {
					port = Integer.parseInt(arr[1]);
				} catch (Exception e) {
					host = null;
					port = 0;
				}
			} else {
				host = socksText;
			}
			if (port > 0 && host != null && host.length() > 0) {
				config.setSocksHost(host);
				config.setSocksPort(port);
			}
		}

		config.setProxyUser(txtProxyUser.getText());
		config.setProxyPass(txtProxyPass.getText());
	}"
xdman,xdman.ui.components.DownloadTableModel,listItemUpdated,,8,12,9,4,0.25,0.119,1,2,2,0,1,"@Override
	public void listItemUpdated(String id) {
		Logger.log(""List updated"");
		Integer index = idIndexMap.get(id);
		if (index != null) {
			fireTableRowsUpdated(index, index);
		}
	}"
xdman,xdman.ui.components.DownloadSorter,compare,,30,60,29,4,0.2347,0.1795,0.333333333,5,8,0,1,"@Override
	public int compare(String id1, String id2) {
		DownloadEntry o1 = XDMApp.getInstance().getEntry(id1);
		DownloadEntry o2 = XDMApp.getInstance().getEntry(id2);
		int res = 0;
		//System.out.println(Config.getInstance().getSortField()+"" ""+Config.getInstance().getSortAsc());
		switch (Config.getInstance().getSortField()) {
		case 0:// sort by date
			res = o1.getDate() > o2.getDate() ? 1 : -1;
			break;
		case 1:// sort by size
			res = o1.getSize() > o2.getSize() ? 1 : -1;
			break;
		case 2:// sort by name
			res = o1.getFile().compareTo(o2.getFile());
			break;
		case 3:// sort by type
			res = o1.getCategory() - o2.getCategory();
			break;
		default:
			break;
		}
		if (Config.getInstance().getSortAsc()) {
			// asc
			return res;
		} else {
			// desc
			return -res;
		}
	}"
xdman,xdman.ui.components.XDMTableCellRenderer,XDMTableCellRenderer,,59,1031,886,7,0.0755,0.0603,0.75,4,1,0,1,"public XDMTableCellRenderer() {
		titleLbl = new JLabel(""This is sample title text"");
		titleLbl.setForeground(Color.BLACK);
		iconLbl = new JLabel();
		iconLbl.setForeground(Color.BLACK);
		statLbl = new JLabel(""This is sample status text"");
		statLbl.setForeground(Color.BLACK);
		dateLbl = new JLabel(""Yesterday"");
		dateLbl.setForeground(Color.BLACK);
		lineLbl = new JLabel();

		iconLbl.setOpaque(false);
		iconLbl.setPreferredSize(new Dimension(56, 56));
		iconLbl.setIcon(ImageResource.get(""doc.png""));
		// iconLbl.setBorder(new EmptyBorder(5,5,5,5));

		titleLbl.setBackground(Color.WHITE);
		titleLbl.setFont(FontResource.getItemFont());
		titleLbl.setOpaque(false);
		// title.setPreferredSize(new Dimension(64, 64));

		statLbl.setBackground(Color.WHITE);
		statLbl.setFont(FontResource.getNormalFont());
		statLbl.setOpaque(false);
		// status.setPreferredSize(new Dimension(64, 64));

		dateLbl.setBackground(Color.WHITE);
		dateLbl.setOpaque(false);
		dateLbl.setFont(FontResource.getNormalFont());
		// date.setPreferredSize(new Dimension(64, 64));

		lineLbl = new JLabel();
		lineLbl.setBackground(ColorResource.getWhite());
		lineLbl.setOpaque(true);
		lineLbl.setMinimumSize(new Dimension(10, 1));
		lineLbl.setMaximumSize(new Dimension(lineLbl.getMaximumSize().width, 1));
		lineLbl.setPreferredSize(new Dimension(lineLbl.getPreferredSize().width, 1));

		pcell = new JPanel(new BorderLayout());
		pcell.setBackground(Color.WHITE);

		pcell.add(iconLbl, BorderLayout.WEST);

		Box box = Box.createHorizontalBox();
		box.add(statLbl);
		box.add(Box.createHorizontalGlue());
		box.add(dateLbl);
		box.setBorder(new EmptyBorder(0, 0, 10, 0));

		JPanel p = new JPanel(new BorderLayout());
		p.setOpaque(false);
		p.add(titleLbl);
		p.add(box, BorderLayout.SOUTH);
		p.setBorder(new EmptyBorder(5, 0, 5, 5));

		pcell.add(p);
		pcell.add(lineLbl, BorderLayout.SOUTH);
		pcell.setBorder(new EmptyBorder(0, 15, 0, 15));
	}"
xdman,xdman.ui.laf.XDMLookAndFeel,initClassDefaults,,67,19,17,5,0.1667,0.0247,0,1,1,0,1,"@Override
	public void initClassDefaults(UIDefaults table) {
		super.initClassDefaults(table);
		table.putDefaults(new Object[] { ""ButtonUI"", XDMButtonUI.class.getName(), ""ScrollBarUI"",
				XDMScrollBarUI.class.getName(), ""MenuItemUI"", XDMMenuItemUI.class.getName(), ""MenuUI"",
				XDMMenuUI.class.getName(), ""CheckBoxMenuItemUI"", XDMMenuItemUI.class.getName(), ""TreeUI"",
				XDMTreeUI.class.getName(), ""SpinnerUI"", XDMSpinnerUI.class.getName(), ""ProgressBarUI"",
				XDMProgressBarUI.class.getName(), ""ComboBoxUI"", XDMComboBoxUI.class.getName() });
		System.setProperty(""xdm.defaulttheme"", ""true"");

		UIManager.put(""Table.focusCellHighlightBorder"", new EmptyBorder(1, 1, 1, 1));
		UIManager.put(""ComboBox.rendererUseListColors"", Boolean.TRUE);
		// UIManager.put(""TabbedPane.selected"", new Color(220, 220, 220));
		// UIManager.put(""TabbedPane.borderHightlightColor"", Color.LIGHT_GRAY);
		// UIManager.put(""TabbedPane.contentAreaColor"", Color.LIGHT_GRAY);
		// UIManager.put(""TabbedPane.contentOpaque"", Boolean.FALSE);
		// UIManager.put(""OptionPane.background"", new
		// ColorUIResource(Color.WHITE));
		// UIManager.put(""Panel.background"", new ColorUIResource(Color.WHITE));
		// UIManager.put(""CheckBox.background"", new
		// ColorUIResource(Color.WHITE));
		// UIManager.put(""PopupMenu.border"", new
		// LineBorder(ColorResource.getDarkBgColor()));
		// UIManager.put(""PopupMenu.background"",
		// ColorResource.getDarkerBgColor());
		// UIManager.put(""MenuItem.selectionForeground"", Color.WHITE);
		// UIManager.put(""Menu.selectionForeground"", Color.WHITE);
		// UIManager.put(""Button.foreground"", Color.WHITE);
		// UIManager.put(""PopupMenuItem.selectionForeground"", Color.WHITE);
		// UIManager.put(""MenuItem.font"", FontResource.getNormalFont());
		// UIManager.put(""ComboBox.selectionBackground"",
		// ColorResource.getSelectionColor());
		// UIManager.put(""ComboBox.selectionForeground"", Color.WHITE);
		// UIManager.put(""ComboBox.disabledForeground"", Color.GRAY);
		// UIManager.put(""ComboBox.disabledBackground"",
		// ColorResource.getDarkerBgColor());
		// UIManager.put(""ComboBox.foreground"", Color.WHITE);
		// UIManager.put(""ComboBox.background"",
		// ColorResource.getDarkerBgColor());
		// UIManager.put(""Label.foreground"", Color.WHITE);
		// UIManager.put(""Panel.background"", ColorResource.getDarkerBgColor());
		// UIManager.put(""ScrollBar.width"", new Integer(15));
		// UIManager.put(""Popup.background"", ColorResource.getDarkerBgColor());
		// UIManager.put(""TextField.background"",
		// ColorResource.getDarkerBgColor());
		// UIManager.put(""TextField.border"", new
		// LineBorder(ColorResource.getDarkBgColor(), 1));
		// UIManager.put(""TextField.foreground"", Color.WHITE);
		// UIManager.put(""ComboBox.border"", new
		// LineBorder(ColorResource.getDarkBgColor(), 1));
		// UIManager.put(""TextField.selectionBackground"",
		// ColorResource.getSelectionColor());
		// UIManager.put(""TextField.selectionForeground"", Color.WHITE);
		// UIManager.put(""List.selectionBackground"",
		// ColorResource.getSelectionColor());
		// UIManager.put(""List.selectionForeground"", Color.WHITE);
		// UIManager.put(""List.focusCellHighlightBorder"",
		// ColorResource.getSelectionColor());
		// UIManager.put(""List.border"", new LineBorder(Color.WHITE, 1));
		// UIManager.put(""ScrollPane.border"", new
		// LineBorder(ColorResource.getDarkBgColor(), 1));
		// UIManager.put(""TableHeader.background"",
		// ColorResource.getDarkerBgColor());
		// UIManager.put(""TableHeader.cellBorder"", new
		// LineBorder(ColorResource.getDarkBgColor(), 1));
		// UIManager.put(""TableHeader.foreground"", Color.WHITE);
	}"
xdman,xdman.ui.laf.XDMProgressBarUI,paint,,17,10,0,2,0.3929,0.246,0,3,3,0,1,"@Override
	public void paint(Graphics g, JComponent c) {

		if (!(g instanceof Graphics2D)) {
			return;
		}

		Graphics2D g2 = (Graphics2D) g;
		g2.setPaint(Color.GRAY);
		g2.fillRect(0, 0, c.getWidth(), c.getHeight());
		if (progressBar.isIndeterminate()) {
			paintIndeterminate(g, c);
		} else {
			paintDeterminate(g, c);
		}

	}"
xdman,xdman.ui.laf.XDMProgressBarUI,paintIndeterminate,,19,37,29,5,0.175,0.0682,1,6,4,0,1,"@Override
	protected void paintIndeterminate(Graphics g, JComponent c) {
		Insets b = progressBar.getInsets(); // area for border
		int barRectWidth = progressBar.getWidth() - (b.right + b.left);
		int barRectHeight = progressBar.getHeight() - (b.top + b.bottom);

		if (barRectWidth <= 0 || barRectHeight <= 0) {
			return;
		}

		Graphics2D g2 = (Graphics2D) g;

		// Paint the bouncing box.
		boxRect = getBox(boxRect);
		if (boxRect != null) {
			g2.setPaint(ColorResource.getSelectionColor());
			g2.fillRect(boxRect.x, boxRect.y, boxRect.width, boxRect.height);
		}
	}"
xdman,xdman.ui.laf.XDMProgressBarUI,paintDeterminate,,27,29,13,2,0.2222,0.117,1,7,4,0,1,"@Override
	protected void paintDeterminate(Graphics g, JComponent c) {
		Insets b = progressBar.getInsets(); // area for border
		int barRectWidth = progressBar.getWidth() - (b.right + b.left);
		int barRectHeight = progressBar.getHeight() - (b.top + b.bottom);

		if (barRectWidth <= 0 || barRectHeight <= 0) {
			return;
		}

		// amount of progress to draw
		int amountFull = getAmountFull(b, barRectWidth, barRectHeight);

		Graphics2D g2 = (Graphics2D) g;
		g2.setColor(ColorResource.getSelectionColor());

		if (progressBar.getOrientation() == JProgressBar.HORIZONTAL) {
			g2.fillRect(0, 0, amountFull, c.getHeight());
		} else { // VERTICAL
		}

		// Deal with possible text painting
		// if (progressBar.isStringPainted()) {
		// paintString(g, b.left, b.top, barRectWidth, barRectHeight,
		// amountFull, b);
		// }
	}"
xdman,xdman.ui.laf.XDMScrollBarUI,installUI,,11,16,11,4,0.3333,0.1481,0,1,4,0,1,"@Override
	public void installUI(JComponent c) {
		super.installUI(c);

		darkMode = scrollbar instanceof DarkScrollBar;
		if ((scrollbar.getOrientation() == JScrollBar.HORIZONTAL)) {
			c.setPreferredSize(new Dimension(15, darkMode ? 8 : 15));
		} else {
			c.setPreferredSize(new Dimension(darkMode ? 8 : 15, 15));
		}
	}"
xdman,xdman.ui.laf.XDMScrollBarUI,paintThumb,,25,92,79,7,0.1273,0.0498,0,6,6,0,1,"protected void paintThumb(Graphics g, JComponent c, Rectangle thumbBounds) {
		if (thumbBounds.isEmpty() || !scrollbar.isEnabled()) {
			return;
		}

		int w = thumbBounds.width;
		int h = thumbBounds.height;

		g.translate(thumbBounds.x, thumbBounds.y);

		Graphics2D g2 = (Graphics2D) g;

		if (isThumbRollover()) {
			g2.setColor(darkMode ? roColor2 : roColor1);
		} else {
			g2.setColor(darkMode ? barColor2 : barColor1);
		}

		// g.fillRect(1, 0, w - 3, h - 1);
		g.fillRect(0, 0, w, h);

		// g2.setColor(borderColor);
		// g.drawRect(1, 0, w - 3, h - 1);
		g.translate(-thumbBounds.x, -thumbBounds.y);
	}"
xdman,xdman.ui.laf.XDMScrollBarUI,paintTrack,,8,9,3,3,0.2667,0.1929,0,3,2,0,1,"@Override
	protected void paintTrack(Graphics g, JComponent c, Rectangle r) {
		g.setColor(darkMode ? trackColor2 : trackColor1);
		g.translate(r.x, r.y);
		g.fillRect(0, 0, r.width, r.height);
		g.translate(-r.x, -r.y);
		// super.paintTrack(g, c, r);
	}"
xdman,xdman.ui.laf.XDMScrollBarUI,createScrollButton,,31,162,48,5,0.1458,0.2159,1,2,7,0,1,"private JButton createScrollButton(int orientation) {
		darkMode = scrollbar instanceof DarkScrollBar;

		if (darkMode) {
			return createZeroButton();
		}

		CustomButton btn = new CustomButton();
		btn.setBackground(darkMode ? trackColor2 : trackColor1);
		btn.setContentAreaFilled(false);
		btn.setHorizontalAlignment(JButton.CENTER);
		btn.setMargin(new Insets(0, 0, 0, 0));
		btn.setBorderPainted(false);
		if (orientation == SwingConstants.NORTH) {
			btn.setIcon(ImageResource.get(""up_arrow.png""));
			btn.setPreferredSize(new Dimension(15, 18));
		}
		if (orientation == SwingConstants.SOUTH) {
			btn.setIcon(ImageResource.get(""down_arrow.png""));
			btn.setPreferredSize(new Dimension(15, 18));
		}
		if (orientation == SwingConstants.EAST) {
			btn.setIcon(ImageResource.get(""right_arrow.png""));
			btn.setPreferredSize(new Dimension(18, 15));
		}
		if (orientation == SwingConstants.WEST) {
			btn.setIcon(ImageResource.get(""left_arrow.png""));
			btn.setPreferredSize(new Dimension(18, 15));
		}
		return btn;
	}"
xdman,xdman.ui.laf.XDMMenuItemUI,installUI,,18,57,48,7,0.2222,0.1144,0,2,2,0,1,"@Override
	public void installUI(JComponent c) {
		super.installUI(c);
		c.setBorder(null);
		if (c instanceof AbstractButton) {
			AbstractButton btn = (AbstractButton) c;
			// btn.setMargin(new Insets(10,10,10,10));
			btn.setBorder(new EmptyBorder(5, 10, 5, 10));
			// btn.setIcon(new XDMBlankIcon(15, 10));
			btn.setBorderPainted(false);
			// btn.setMargin(new Insets(10, 10, 10, 10));
			// btn.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));
		}
		// this.lightColor = Color.WHITE;
		// this.darkColor = new Color(230, 230, 230);
		// this.lightColor2 = new Color(245, 245, 245);
		// chkIcon = UIManager.getIcon(""CheckBoxMenuItem.checkIcon"");
	}"
xdman,xdman.ui.laf.XDMMenuItemUI,paintButtonPressed,,7,15,9,3,0.2857,0.1333,0,4,1,0,1,"protected void paintButtonPressed(Graphics g, AbstractButton b) {
		Color c = g.getColor();
		Graphics2D g2 = (Graphics2D) g;
		g2.setPaint(colorSelect);
		g2.fillRect(0, 0, b.getWidth(), b.getHeight());
		g.setColor(c);
	}"
xdman,xdman.ui.laf.XDMMenuItemUI,paintBackground,,36,228,180,11,0.1354,0.0855,0,8,7,0,1,"@Override
	protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor) {
		ButtonModel model = menuItem.getModel();
		Color oldColor = g.getColor();
		int menuWidth = menuItem.getWidth();
		int menuHeight = menuItem.getHeight();

		Color bgc = (Color) menuItem.getClientProperty(""bgColor"");
		if (bgc != null) {
			g.setColor(bgc);
		} else {
			g.setColor(colorBg);
		}
		g.fillRect(0, 0, menuWidth, menuHeight);

		if (model.isArmed()
				|| (menuItem instanceof JMenu && model.isSelected())) {
			paintButtonPressed(g, menuItem);
		} else {
			// if (menuItem.getIcon() != null) {
			// int gap = menuItem.getIcon().getIconWidth() + 2;
			// g.setColor(this.darkColor);
			// g.drawLine(gap, 0, gap, menuItem.getHeight());
			// g.setColor(this.lightColor);
			// g.drawLine(gap + 1, 0, gap + 1, menuItem.getHeight());
			// }
		}

		if (menuItem instanceof JCheckBoxMenuItem) {
			if (((JCheckBoxMenuItem) menuItem).isSelected()) {
				// chkIcon.paintIcon(menuItem, g, 5, 5);
			}
		}

		g.setColor(oldColor);
	}"
xdman,xdman.ui.laf.XDMButtonUI,installUI,,12,20,4,3,0.3333,0.3095,1,2,3,0,1,"@Override
	public void installUI(JComponent c) {
		super.installUI(c);
		if (c instanceof JButton) {
			JButton btn = (JButton) c;
			if (!(c instanceof CustomButton)) {
				c.setForeground(Color.WHITE);
				c.setBackground(ColorResource.getButtonBackColor());
				btn.setBorderPainted(false);
			}
		}
	}"
xdman,xdman.ui.laf.XDMButtonUI,paintButtonNormal,,7,10,5,3,0.3889,0.1905,0,3,2,0,1,"protected void paintButtonNormal(Graphics g, AbstractButton b) {
		if (!b.isOpaque()) {
			Graphics2D g2 = (Graphics2D) g;
			g2.setPaint(b.getBackground());
			g2.fillRect(0, 0, b.getWidth(), b.getHeight());
		}
	}"
xdman,xdman.ui.laf.XDMButtonUI,paint,,13,26,16,4,0.2667,0.119,0,5,3,0,1,"public void paint(Graphics g, JComponent c) {
		try {
			AbstractButton b = (AbstractButton) c;
			ButtonModel bm = b.getModel();
			if (bm.isRollover()) {
				paintButtonRollOver(g, b);
			} else {
				paintButtonNormal(g, b);
			}
			super.paint(g, c);
		} catch (Exception e) {
		}
	}"
xdman,xdman.ui.laf.XDMMenuUI,installUI,,13,49,43,7,0.2121,0.0833,0,2,2,0,1,"@Override
	public void installUI(JComponent c) {
		super.installUI(c);
		if (c instanceof AbstractButton) {
			AbstractButton btn = (AbstractButton) c;
			// btn.setMargin(new Insets(10,10,10,10));
			btn.setBorder(new EmptyBorder(5, 10, 5, 10));
			// btn.setIcon(new XDMBlankIcon(15, 10));
			btn.setBorderPainted(false);
			// btn.setMargin(new Insets(10, 10, 10, 10));
			// btn.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));
		}
	}"
xdman,xdman.ui.laf.XDMMenuUI,paintButtonPressed,,31,319,313,22,0.0769,0.0232,0,4,1,0,1,"protected void paintButtonPressed(Graphics g, AbstractButton b) {
		Color c = g.getColor();

		Graphics2D g2 = (Graphics2D) g;
		g2.setPaint(colorSelect);
		g2.fillRect(0, 0, b.getWidth(), b.getHeight());

		// if (""THEME"".equals(b.getName()) || ""CTX_SORT"".equals(b.getName())) {
		// g2.setPaint(gradPressed);
		// int gapx = 0;
		//
		// g2.fillRect(gapx + 2, 0, b.getWidth() - (4 + gapx + 2), b
		// .getHeight() - 2);
		// g2.setColor(Color.LIGHT_GRAY);
		// g2.drawRect(gapx + 2, 0, b.getWidth() - (4 + gapx + 2), b
		// .getHeight() - 2);
		// if (menuItem.getIcon() != null) {
		// int gap = menuItem.getIcon().getIconWidth() + 2;
		// g.setColor(this.darkColor);
		// g.drawLine(gap, 1, gap, menuItem.getHeight() - 3);
		// g.setColor(this.lightColor2);
		// g.drawLine(gap + 1, 1, gap + 1, menuItem.getHeight() - 3);
		// }
		// } else {
		// g2.setPaint(gradPressed);
		// g2.fillRoundRect(0, 0, b.getWidth() - 1, b.getHeight() - 1, 4, 4);
		// g2.setColor(Color.LIGHT_GRAY);
		// g2.drawRoundRect(0, 0, b.getWidth() - 1, b.getHeight() - 1, 4, 4);
		// }
		g.setColor(c);
	}"
xdman,xdman.ui.laf.XDMMenuUI,paintBackground,,22,144,135,13,0.1333,0.0498,0,6,4,0,1,"@Override
	protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor) {
		ButtonModel model = menuItem.getModel();
		Color oldColor = g.getColor();
		if (model.isArmed() || (menuItem instanceof JMenu && model.isSelected())) {
			paintButtonPressed(g, menuItem);
		} else {
			g.setColor(this.colorBg);
			// g.fillRect(0, 0, menuItem.getWidth(), menuItem.getHeight());
			// g.fillRect(0, 0, menuItem.getWidth(), menuItem.getHeight());//(0,
			// 0, gap + 1, menuItem.getHeight());
			// g.drawLine(gap + 1, 0, gap + 1, menuItem.getHeight());
			// if (menuItem.getIcon() != null) {
			// int gap = menuItem.getIcon().getIconWidth() + 2;
			// g.setColor(this.darkColor);
			// g.drawLine(gap, 0, gap, menuItem.getHeight());
			// g.setColor(this.lightColor);
			// g.drawLine(gap + 1, 0, gap + 1, menuItem.getHeight());
			// }
		}
		g.setColor(oldColor);
	}"
xdman,xdman.ui.laf.XDMTheme,addCustomEntriesToTable,,63,54,0,2,0.3527,0.6499,0.2,1,1,1,1,"// @Override
	// protected ColorUIResource getPrimary1() {
	// return sc1;
	// }

	public void addCustomEntriesToTable(UIDefaults table) {
		super.addCustomEntriesToTable(table);
		table.put(""Menu.foreground"", ColorResource.getDeepFontColor());
		table.put(""PopupMenu.border"", new LineBorder(ColorResource.getDarkBgColor()));
		table.put(""PopupMenu.background"", ColorResource.getDarkerBgColor());
		table.put(""MenuItem.foreground"", ColorResource.getDeepFontColor());
		table.put(""MenuItem.selectionForeground"", Color.WHITE);
		table.put(""Menu.selectionForeground"", Color.WHITE);
		table.put(""ComboBox.selectionBackground"", ColorResource.getSelectionColor());
		table.put(""ComboBox.selectionForeground"", Color.WHITE);
		table.put(""ComboBox.disabledForeground"", Color.GRAY);
		table.put(""ComboBox.disabledBackground"", ColorResource.getDarkerBgColor());
		table.put(""ComboBox.foreground"", Color.WHITE);
		table.put(""ComboBox.background"", ColorResource.getDarkBgColor());
		table.put(""Label.foreground"", Color.WHITE);
		table.put(""Panel.background"", ColorResource.getDarkerBgColor());
		table.put(""ScrollBar.width"", new Integer(15));
		table.put(""Popup.background"", ColorResource.getDarkerBgColor());

		table.put(""TextArea.background"", ColorResource.getDarkerBgColor());
		table.put(""TextArea.foreground"", Color.WHITE);
		table.put(""TextArea.selectionBackground"", ColorResource.getSelectionColor());
		table.put(""TextArea.selectionForeground"", Color.WHITE);
		table.put(""TextArea.caretForeground"", ColorResource.getSelectionColor());

		table.put(""TextField.background"", ColorResource.getDarkerBgColor());
		table.put(""TextField.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
		table.put(""TextField.foreground"", Color.WHITE);
		table.put(""TextField.selectionBackground"", ColorResource.getSelectionColor());
		table.put(""TextField.selectionForeground"", Color.WHITE);
		table.put(""TextField.caretForeground"", ColorResource.getSelectionColor());

		table.put(""PasswordField.background"", ColorResource.getDarkerBgColor());
		table.put(""PasswordField.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
		table.put(""PasswordField.foreground"", Color.WHITE);
		table.put(""PasswordField.selectionBackground"", ColorResource.getSelectionColor());
		table.put(""PasswordField.selectionForeground"", Color.WHITE);
		table.put(""PasswordField.caretForeground"", ColorResource.getSelectionColor());

		table.put(""ComboBox.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
		table.put(""List.selectionBackground"", ColorResource.getSelectionColor());
		table.put(""List.selectionForeground"", Color.WHITE);
		table.put(""List.focusCellHighlightBorder"", ColorResource.getSelectionColor());
		table.put(""List.border"", new LineBorder(Color.WHITE, 1));
		table.put(""ScrollPane.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
		table.put(""TableHeader.background"", ColorResource.getDarkerBgColor());
		table.put(""TableHeader.cellBorder"", new LineBorder(ColorResource.getDarkBgColor(), 1));
		table.put(""TableHeader.foreground"", Color.WHITE);
		table.put(""OptionPane.messageForeground"", Color.WHITE);
		table.put(""OptionPane.background"", ColorResource.getDarkerBgColor());

		table.put(""Tree.textBackground"", ColorResource.getDarkestBgColor());
		table.put(""Tree.selectionBackground"", ColorResource.getSelectionColor());
		table.put(""Tree.selectionForeground"", Color.WHITE);
		table.put(""Tree.selectionBorderColor"", ColorResource.getSelectionColor());
		table.put(""Tree.textForeground"", Color.WHITE);

		table.put(""ToggleButton.background"", ColorResource.getDarkerBgColor());
		table.put(""ToggleButton.border"", new LineBorder(ColorResource.getDarkBgColor(), 1));
		table.put(""ToggleButton.foreground"", Color.WHITE);
		table.put(""ToggleButton.select"", ColorResource.getSelectionColor());

	}"
xdman,xdman.ui.laf.XDMToolBarButtonUI,paint,,10,18,8,3,0.3438,0.1543,0,4,2,0,1,"public void paint(Graphics g, JComponent c) {
		AbstractButton b = (AbstractButton) c;
		ButtonModel bm = b.getModel();
		if (bm.isRollover()) {
			paintButtonRollOver(g, b);
		} else {
			paintButtonNormal(g, b);
		}
		super.paint(g, c);
	}"
xdman,xdman.ui.res.FontResource,loadNoto,,16,32,19,3,0.2286,0.1174,1,4,3,0,1,"private static Font loadNoto(String sfont) {
		try {
			InputStream inStream = StringResource.class
					.getResourceAsStream(""/fonts/"" + sfont);
			if (inStream == null) {
				inStream = new FileInputStream(""fonts/"" + sfont);
			}
			Logger.log(""Loading ""+sfont);
			Font font = Font.createFont(Font.TRUETYPE_FONT, inStream);
			Logger.log(""Loaded ""+font);
			return font;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}"
xdman,xdman.ui.res.FontResource,loadNotoRegular,,10,12,9,4,0.2778,0.1429,1,0,3,0,1,"private static Font loadNotoRegular() {
		if (notoNormal == null) {
			notoNormal = loadNoto(""NotoSansUI-Regular.ttf"");
			if (notoNormal == null) {
				Logger.log(""Noto regular font could not be loaded"");
				notoNormal = new Font(Font.DIALOG, Font.PLAIN, 12);
			}
		}
		return notoNormal;
	}"
xdman,xdman.ui.res.FontResource,loadNotoBold,,10,18,15,5,0.2,0.1,1,0,3,0,1,"private static Font loadNotoBold() {
		if (notoBold == null) {
			notoBold = loadNoto(""NotoSansUI-Bold.ttf"");
			if (notoBold == null) {
				Logger.log(""Noto regular font could not be loaded"");
				notoBold = new Font(Font.DIALOG, Font.BOLD, 12);
			}
		}
		return notoBold;
	}"
xdman,xdman.ui.res.StringResource,loadDefaultLanguage,,8,14,7,3,0.2857,0.1833,0,1,2,0,1,"private static void loadDefaultLanguage() throws Exception {
		strings = new Properties();
		InputStream inStream = StringResource.class.getResourceAsStream(""/lang/en.txt"");
		if (inStream == null) {
			inStream = new FileInputStream(""lang/en.txt"");
		}
		strings.load(inStream);
	}"
xdman,xdman.util.LinuxUtils,initShutdown,,13,32,28,5,0.1667,0.0452,1,5,4,0,1,"public static void initShutdown() {
		for (int i = 0; i < shutdownCmds.length; i++) {
			String cmd = shutdownCmds[0];
			try {
				Process proc = Runtime.getRuntime().exec(cmd);
				int ret = proc.waitFor();
				if (ret == 0)
					break;
			} catch (Exception e) {
				Logger.log(e);
			}
		}
	}"
xdman,xdman.util.LinuxUtils,open,,12,31,26,5,0.2222,0.0909,1,3,3,0,1,"public static void open(final File f) throws FileNotFoundException {
		if (!f.exists()) {
			throw new FileNotFoundException();
		}
		try {
			ProcessBuilder pb = new ProcessBuilder();
			pb.command(""xdg-open"", f.getAbsolutePath());
			pb.start();// .waitFor();
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.LinuxUtils,keepAwakePing,,8,9,8,4,0.2667,0.0556,1,1,2,0,1,"public static void keepAwakePing() {
		try {
			Runtime.getRuntime().exec(
					""dbus-send --print-reply --type=method_call --dest=org.freedesktop.ScreenSaver /ScreenSaver org.freedesktop.ScreenSaver.SimulateUserActivity"");
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.LinuxUtils,addToStartup,,19,65,52,5,0.1648,0.0985,1,5,4,0,1,"public static void addToStartup() {
		File dir = new File(System.getProperty(""user.home""), "".config/autostart"");
		dir.mkdirs();
		File f = new File(dir, ""xdman.desktop"");
		FileOutputStream fs = null;
		try {
			fs = new FileOutputStream(f);
			fs.write(getDesktopFileString().getBytes());
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				if (fs != null)
					fs.close();
			} catch (Exception e2) {
			}
		}
		f.setExecutable(true);
	}"
xdman,xdman.util.LinuxUtils,isAlreadyAutoStart,,25,102,84,5,0.1307,0.0637,1,8,6,0,1,"public static boolean isAlreadyAutoStart() {
		File f = new File(System.getProperty(""user.home""), "".config/autostart/xdman.desktop"");
		if (!f.exists())
			return false;
		FileInputStream in = null;
		byte[] buf = new byte[(int) f.length()];
		try {
			in = new FileInputStream(f);
			if (in.read(buf) != f.length()) {
				return false;
			}
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				if (in != null)
					in.close();
			} catch (Exception e2) {
			}
		}
		String str=new String(buf);
		String s1 = getProperPath(System.getProperty(""java.home""));
		String s2 = XDMUtils.getJarFile().getAbsolutePath();
		return str.contains(s1)&&str.contains(s2);
	}"
xdman,xdman.util.LinuxUtils,browseURL,,9,17,13,4,0.25,0.125,1,3,2,0,1,"public static void browseURL(final String url) {
		try {
			ProcessBuilder pb = new ProcessBuilder();
			pb.command(""xdg-open"", url);
			pb.start();// .waitFor();
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.FFmpegDownloader,FFmpegDownloader,,18,50,34,5,0.2292,0.2462,0.333333333,0,6,0,1,"public FFmpegDownloader() {
		if (XDMUtils.detectOS() == XDMUtils.WINDOWS) {
			if (XDMUtils.below7()) {
				url += ""xp.zip.xz"";
			} else {
				url += ""win.zip.xz"";
			}
		} else if (XDMUtils.detectOS() == XDMUtils.MAC) {
			url += ""mac.zip.xz"";
		} else if (XDMUtils.detectOS() == XDMUtils.LINUX) {
			if (XDMUtils.getOsArch() == 32) {
				url += ""linux86.zip.xz"";
			} else {
				url += ""linux64.zip.xz"";
			}
		}
		tmpFile = UUID.randomUUID().toString();
	}"
xdman,xdman.util.FFmpegDownloader,start,,10,33,21,3,0.2,0.0782,0.666666667,1,1,0,1,"public void start() {
		HttpMetadata metadata = new HttpMetadata();
		metadata.setUrl(url);
		System.out.println(url);
		d = new HttpDownloader(metadata.getId(), Config.getInstance().getTemporaryFolder(), metadata);
		d.registerListener(this);
		d.start();
		wnd = new DownloadWindow(metadata.getId(), this);
		wnd.setVisible(true);
	}"
xdman,xdman.util.FFmpegDownloader,deleteTmpFiles,,16,70,35,4,0.225,0.1322,0.5,6,4,0,1,"private void deleteTmpFiles(String id) {
		Logger.log(""Deleting metadata for "" + id);
		File mf = new File(Config.getInstance().getMetadataFolder(), id);
		boolean deleted = mf.delete();
		Logger.log(""Deleted manifest "" + id + "" "" + deleted);
		File df = new File(Config.getInstance().getTemporaryFolder(), id);
		File[] files = df.listFiles();
		if (files != null && files.length > 0) {
			for (File f : files) {
				deleted = f.delete();
				Logger.log(""Deleted tmp file "" + id + "" "" + deleted);
			}
		}
		deleted = df.delete();
		Logger.log(""Deleted tmp folder "" + id + "" "" + deleted);
	}"
xdman,xdman.util.FFmpegDownloader,extractFFmpeg,,41,331,284,6,0.0952,0.0673,0.6,10,8,0,1,"private void extractFFmpeg() {
		ZipInputStream zipIn = null;
		OutputStream out = null;
		wnd2 = new FFmpegExtractorWnd(this);
		wnd2.setVisible(true);
		try {
			File input = new File(Config.getInstance().getTemporaryFolder(), tmpFile);
			zipIn = null;

			while (true) {
				ZipEntry ent = zipIn.getNextEntry();
				if (ent == null)
					break;
				String name = ent.getName();
				File outFile = new File(Config.getInstance().getDataFolder(), name);
				out = new FileOutputStream(outFile);
				byte[] buf = new byte[8192];
				while (true) {
					int x = zipIn.read(buf);
					if (x == -1)
						break;
					out.write(buf, 0, x);
				}
				out.close();
				out = null;
				outFile.setExecutable(true);
			}
			input.delete();
			wnd2.dispose();
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				zipIn.close();
				if (out != null)
					out.close();
			} catch (Exception e) {
				Logger.log(e);
			}
		}
	}"
xdman,xdman.util.NetUtils,readLine,,13,13,5,3,0.381,0.2083,0,3,5,0,1,"public static final String readLine(InputStream in) throws IOException {
		StringBuffer buf = new StringBuffer();
		while (true) {
			int x = in.read();
			if (x == -1)
				throw new IOException(
						""Unexpected EOF while reading header line"");
			if (x == '\n')
				return buf.toString();
			if (x != '\r')
				buf.append((char) x);
		}
	}"
xdman,xdman.util.NetUtils,skipRemainingStream,,19,38,21,3,0.2338,0.1389,0,6,7,0,1,"public static void skipRemainingStream(InputStream inStream, long length)
			throws IOException {
		byte buf[] = new byte[8192];
		if (length > 0) {
			while (length > 0) {
				int r = (int) (length > buf.length ? buf.length : length);
				int x = inStream.read(buf, 0, r);
				if (x == -1)
					break;
				length -= x;
			}
		} else {
			while (true) {
				int x = inStream.read(buf);
				if (x == -1)
					break;
			}
		}
	}"
xdman,xdman.util.UpdateChecker,isUpdateAvailable,,20,49,32,3,0.1771,0.1374,0.6,6,5,0,1,"private static boolean isUpdateAvailable(boolean app, String version) {
		JavaHttpClient client = null;
		try {
			client = new JavaHttpClient((app ? APP_UPDAT_URL : COMPONENTS_UPDATE_URL) + ""?ver="" + version);
			client.connect();
			int resp = client.getStatusCode();
			Logger.log(""manifest download response: "" + resp);
			if (resp == 200) {
				return true;
			}
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				client.dispose();
			} catch (Exception e) {
			}
		}
		return false;
	}"
xdman,xdman.util.MacUtils,open,,14,31,26,5,0.2222,0.0909,1,3,4,0,1,"public static void open(final File f) throws FileNotFoundException {
		if (!f.exists()) {
			throw new FileNotFoundException();
		}
		try {
			ProcessBuilder pb = new ProcessBuilder();
			pb.command(""open"", f.getAbsolutePath());
			if(pb.start().waitFor()!=0) {
				throw new FileNotFoundException();
			}
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.MacUtils,openFolder,,22,55,44,5,0.1806,0.0833,1,5,4,0,1,"public static void openFolder(String folder, String file) throws FileNotFoundException {
		File f = new File(folder, file);
		if (!f.exists()) {
			throw new FileNotFoundException();
		}
		try {
			ProcessBuilder pb = new ProcessBuilder();
			Logger.log(""Opening folder: "" + f.getAbsolutePath());
			pb.command(""open"", ""-R"", f.getAbsolutePath());
			if(pb.start().waitFor()!=0) {
				throw new FileNotFoundException();
			}
		} catch (Exception e) {
			Logger.log(e);
		}
		// try {
		// Runtime.getRuntime().exec(new String[] { ""open -R \"""" + f.getAbsolutePath() +
		// ""\"""" });
		// } catch (Exception e) {
		// Logger.log(e);
		// }
	}"
xdman,xdman.util.MacUtils,launchApp,,14,32,28,6,0.1778,0.0722,1,4,3,0,1,"public static boolean launchApp(String app, String args) {
		try {
			ProcessBuilder pb = new ProcessBuilder();
			pb.command(""open"", ""-n"", ""-a"", app, ""--args"", args);
			if(pb.start().waitFor()!=0) {
				throw new FileNotFoundException();
			}
			//Runtime.getRuntime().exec(new String[] { ""open \"""" + app + ""\"" "" + args });
			return true;
		} catch (Exception e) {
			Logger.log(e);
			return false;
		}
	}"
xdman,xdman.util.MacUtils,keepAwakePing,,7,9,8,4,0.2667,0.0556,1,1,2,0,1,"public static void keepAwakePing() {
		try {
			Runtime.getRuntime().exec(""caffeinate -i -t 3"");
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.MacUtils,addToStartup,,19,65,52,5,0.1648,0.0985,1,5,4,0,1,"public static void addToStartup() {
		File dir = new File(System.getProperty(""user.home""), ""Library/LaunchAgents"");
		dir.mkdirs();
		File f = new File(dir, ""org.sdg.xdman.plist"");
		FileOutputStream fs = null;
		try {
			fs = new FileOutputStream(f);
			fs.write(getStartupPlist().getBytes());
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				if (fs != null)
					fs.close();
			} catch (Exception e2) {
			}
		}
		f.setExecutable(true);
	}"
xdman,xdman.util.MacUtils,isAlreadyAutoStart,,25,102,84,5,0.1307,0.0637,1,8,6,0,1,"public static boolean isAlreadyAutoStart() {
		File f = new File(System.getProperty(""user.home""), ""Library/LaunchAgents/org.sdg.xdman.plist"");
		if (!f.exists())
			return false;
		FileInputStream in = null;
		byte[] buf = new byte[(int) f.length()];
		try {
			in = new FileInputStream(f);
			if (in.read(buf) != f.length()) {
				return false;
			}
		} catch (Exception e) {
			Logger.log(e);
		} finally {
			try {
				if (in != null)
					in.close();
			} catch (Exception e2) {
			}
		}
		String str = new String(buf);
		String s1 = getProperPath(System.getProperty(""java.home""));
		String s2 = XDMUtils.getJarFile().getAbsolutePath();
		return str.contains(s1) && str.contains(s2);
	}"
xdman,xdman.util.MacUtils,browseURL,,9,17,13,4,0.25,0.125,1,3,2,0,1,"public static void browseURL(final String url) {
		try {
			ProcessBuilder pb = new ProcessBuilder();
			pb.command(""open"", url);
			pb.start();// .waitFor();
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.HttpDateParser,parseHttpDate,,15,28,20,4,0.2037,0.119,1,2,4,0,1,"public static Date parseHttpDate(String lastModified) {
		if (StringUtils.isNullOrEmptyOrBlank(lastModified)) {
			return null;
		}
		if (fmt == null) {
			fmt = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z"", Locale.US);
			fmt.setTimeZone(TimeZone.getTimeZone(""GMT""));
		}
		try {
			return fmt.parse(lastModified);
		} catch (ParseException e) {
			Logger.log(e);
		}
		return null;
	}"
xdman,xdman.util.DateTimeUtils,addTimePart,,12,23,1,3,0.3333,0.3598,0,2,2,0,1,"public static Date addTimePart(long sec) {
		if (sec < 0) {
			return null;
		}
		Calendar cal = Calendar.getInstance();
		cal.set(Calendar.HOUR_OF_DAY, 0);
		cal.set(Calendar.MINUTE, 0);
		cal.set(Calendar.SECOND, 0);
		cal.set(Calendar.MILLISECOND, 0);
		cal.add(Calendar.SECOND, (int) sec);
		return cal.getTime();
	}"
xdman,xdman.util.BrowserLauncher,launchFirefox,,22,66,54,2,0.1538,0.1204,0.666666667,6,7,0,1,"public static boolean launchFirefox(String args) {
		int os = XDMUtils.detectOS();
		if (os == XDMUtils.WINDOWS) {
			File[] ffPaths = { new File(System.getenv(""PROGRAMFILES""), ""Mozilla Firefox\\firefox.exe""),
					new File(System.getenv(""PROGRAMFILES(X86)""), ""Mozilla Firefox\\firefox.exe"") };
			for (int i = 0; i < ffPaths.length; i++) {
				System.out.println(ffPaths[i]);
				if (ffPaths[i].exists()) {
					return XDMUtils.exec(""\"""" + ffPaths[i] + ""\"" "" + args);
				}
			}
		}
		if (os == XDMUtils.MAC) {
			File[] ffPaths = { new File(""/Applications/Firefox.app"") };
			for (int i = 0; i < ffPaths.length; i++) {
				if (ffPaths[i].exists()) {
					return MacUtils.launchApp(ffPaths[i].getAbsolutePath(), args);
				}
			}
		}
		return false;
	}"
xdman,xdman.util.BrowserLauncher,launchChrome,,22,66,54,3,0.1538,0.1204,0.666666667,6,7,0,1,"public static boolean launchChrome(String args) {
		int os = XDMUtils.detectOS();
		if (os == XDMUtils.WINDOWS) {
			File[] ffPaths = { new File(System.getenv(""PROGRAMFILES""), ""Google\\Chrome\\Application\\chrome.exe""),
					new File(System.getenv(""PROGRAMFILES(X86)""), ""Google\\Chrome\\Application\\chrome.exe""),
					new File(System.getenv(""LOCALAPPDATA""), ""Google\\Chrome\\Application\\chrome.exe"") };
			for (int i = 0; i < ffPaths.length; i++) {
				if (ffPaths[i].exists()) {
					return XDMUtils.exec(""\"""" + ffPaths[i] + ""\"" "" + args);
				}
			}
		}
		if (os == XDMUtils.MAC) {
			File[] ffPaths = { new File(""/Applications/Google Chrome.app"") };
			for (int i = 0; i < ffPaths.length; i++) {
				if (ffPaths[i].exists()) {
					return MacUtils.launchApp(ffPaths[i].getAbsolutePath(), args);
				}
			}
		}
		return false;
	}"
xdman,xdman.util.Base64,encode,,34,209,40,3,0.1709,0.1719,0,6,5,1,1,"public static String encode(byte[] bytes) {
		int length = bytes.length;
		if (length == 0)
			return """";
		StringBuffer buffer = new StringBuffer(
				(int) Math.ceil((double) length / 3d) * 4);
		int remainder = length % 3;
		length -= remainder;
		int block;
		int i = 0;
		while (i < length) {
			block = ((bytes[i++] & 0xff) << 16) | ((bytes[i++] & 0xff) << 8)
					| (bytes[i++] & 0xff);
			buffer.append(ALPHABET.charAt(block >>> 18));
			buffer.append(ALPHABET.charAt((block >>> 12) & 0x3f));
			buffer.append(ALPHABET.charAt((block >>> 6) & 0x3f));
			buffer.append(ALPHABET.charAt(block & 0x3f));
		}
		if (remainder == 0)
			return buffer.toString();
		if (remainder == 1) {
			block = (bytes[i] & 0xff) << 4;
			buffer.append(ALPHABET.charAt(block >>> 6));
			buffer.append(ALPHABET.charAt(block & 0x3f));
			buffer.append(""=="");
			return buffer.toString();
		}
		block = (((bytes[i++] & 0xff) << 8) | ((bytes[i]) & 0xff)) << 2;
		buffer.append(ALPHABET.charAt(block >>> 12));
		buffer.append(ALPHABET.charAt((block >>> 6) & 0x3f));
		buffer.append(ALPHABET.charAt(block & 0x3f));
		buffer.append(""="");
		return buffer.toString();
	}"
xdman,xdman.util.Base64,decode,,24,83,46,3,0.1771,0.096,0,8,7,0,1,"public static byte[] decode(String string) {
		int length = string.length();
		if (length == 0)
			return new byte[0];
		int pad = (string.charAt(length - 2) == '=') ? 2 : (string
				.charAt(length - 1) == '=') ? 1 : 0;
		int size = length * 3 / 4 - pad;
		byte[] buffer = new byte[size];
		int block;
		int i = 0;
		int index = 0;
		while (i < length) {
			block = (ALPHABET.indexOf(string.charAt(i++)) & 0xff) << 18
					| (ALPHABET.indexOf(string.charAt(i++)) & 0xff) << 12
					| (ALPHABET.indexOf(string.charAt(i++)) & 0xff) << 6
					| (ALPHABET.indexOf(string.charAt(i++)) & 0xff);
			buffer[index++] = (byte) (block >>> 16);
			if (index < size)
				buffer[index++] = (byte) ((block >>> 8) & 0xff);
			if (index < size)
				buffer[index++] = (byte) (block & 0xff);
		}
		return buffer;
	}"
xdman,xdman.util.XDMUtils,decodeFileName,,19,45,12,3,0.2692,0.2234,0,5,12,0,1,"public static String decodeFileName(String str) {
		char ch[] = str.toCharArray();
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < ch.length; i++) {
			if (ch[i] == '/' || ch[i] == '\\' || ch[i] == '""' || ch[i] == '?' || ch[i] == '*' || ch[i] == '<'
					|| ch[i] == '>' || ch[i] == ':')
				continue;
			if (ch[i] == '%') {
				if (i + 2 < ch.length) {
					int c = Integer.parseInt(ch[i + 1] + """" + ch[i + 2], 16);
					buf.append((char) c);
					i += 2;
					continue;
				}
			}
			buf.append(ch[i]);
		}
		return buf.toString();
	}"
xdman,xdman.util.XDMUtils,createSafeFileName,,9,13,5,3,0.3571,0.1792,0,3,3,0,1,"private static String createSafeFileName(String str) {
		String safe_name = str;
		for (int i = 0; i < invalid_chars.length; i++) {
			if (safe_name.indexOf(invalid_chars[i]) != -1) {
				safe_name = safe_name.replace(invalid_chars[i], '_');
			}
		}
		return safe_name;
	}"
xdman,xdman.util.XDMUtils,validateURL,,12,52,49,9,0.1169,0.0556,0,2,5,0,1,"public static boolean validateURL(String url) {
		try {
			url = url.toLowerCase();
			if (url.startsWith(""http://"") || url.startsWith(""https://"") || url.startsWith(""ftp://"")) {
				new URL(url);
				return true;
			}
			return false;
		} catch (Exception e) {
			return false;
		}
	}"
xdman,xdman.util.XDMUtils,findCategory,,29,151,131,9,0.0965,0.0466,0,7,11,0,1,"public static int findCategory(String filename) {
		String file = filename.toLowerCase();
		for (int i = 0; i < doc.length; i++) {
			if (file.endsWith(doc[i])) {
				return XDMConstants.DOCUMENTS;
			}
		}
		for (int i = 0; i < cmp.length; i++) {
			if (file.endsWith(cmp[i])) {
				return XDMConstants.COMPRESSED;
			}
		}
		for (int i = 0; i < music.length; i++) {
			if (file.endsWith(music[i])) {
				return XDMConstants.MUSIC;
			}
		}
		for (int i = 0; i < prog.length; i++) {
			if (file.endsWith(prog[i])) {
				return XDMConstants.PROGRAMS;
			}
		}
		for (int i = 0; i < vid.length; i++) {
			if (file.endsWith(vid[i])) {
				return XDMConstants.VIDEO;
			}
		}
		return XDMConstants.OTHER;
	}"
xdman,xdman.util.XDMUtils,appendArray2Str,,12,35,25,4,0.25,0.178,0,4,3,0,1,"public static String appendArray2Str(String[] arr) {
		boolean first = true;
		StringBuffer buf = new StringBuffer();
		for (String s : arr) {
			if (!first) {
				buf.append("","");
			}
			buf.append(s);
			first = false;
		}
		return buf.toString();
	}"
xdman,xdman.util.XDMUtils,appendStr2Array,,12,30,15,3,0.25,0.1307,0,5,3,0,1,"public static String[] appendStr2Array(String str) {
		String[] arr = str.split("","");
		ArrayList<String> arrList = new ArrayList<String>();
		for (String s : arr) {
			String txt = s.trim();
			if (txt.length() > 0) {
				arrList.add(txt);
			}
		}
		arr = new String[arrList.size()];
		return arrList.toArray(arr);
	}"
xdman,xdman.util.XDMUtils,copyStream,,21,70,49,5,0.1494,0.089,0,7,8,0,1,"public static void copyStream(InputStream instream, OutputStream outstream, long size) throws Exception {
		byte[] b = new byte[8192];
		long rem = size;
		while (true) {
			int bs = (int) (size > 0 ? (rem > b.length ? b.length : rem) : b.length);
			int x = instream.read(b, 0, bs);
			if (x == -1) {
				if (size > 0) {
					throw new EOFException(""Unexpected EOF"");
				} else {
					break;
				}
			}
			outstream.write(b, 0, x);
			rem -= x;
			if (size > 0) {
				if (rem <= 0)
					break;
			}
		}
	}"
xdman,xdman.util.XDMUtils,detectOS,,12,20,19,6,0.1786,0.05,0,1,7,0,1,"public static final int detectOS() {
		String os = System.getProperty(""os.name"").toLowerCase(Locale.ENGLISH);
		if (os.contains(""mac"") || os.contains(""darwin"") || os.contains(""os x"") || os.contains(""os x"")) {
			return MAC;
		} else if (os.contains(""linux"")) {
			return LINUX;
		} else if (os.contains(""windows"")) {
			return WINDOWS;
		} else {
			return -1;
		}
	}"
xdman,xdman.util.XDMUtils,openFile,,17,56,46,4,0.1167,0.05,1,4,4,0,1,"public static void openFile(String file, String folder) throws Exception {
		int os = detectOS();
		File f = new File(folder, file);
		switch (os) {
		case WINDOWS:
			WinUtils.open(f);
			break;
		case LINUX:
			LinuxUtils.open(f);
			break;
		case MAC:
			MacUtils.open(f);
			break;
		default:
			Desktop.getDesktop().open(f);
		}
	}"
xdman,xdman.util.XDMUtils,openFolder,,18,70,62,4,0.1189,0.0347,1,5,4,0,1,"public static void openFolder(String file, String folder) throws Exception {
		int os = detectOS();
		switch (os) {
		case WINDOWS:
			WinUtils.openFolder(folder, file);
			break;
		case LINUX:
			File f = new File(folder);
			LinuxUtils.open(f);
			break;
		case MAC:
			MacUtils.openFolder(folder, file);
			break;
		default:
			File ff = new File(folder);
			Desktop.getDesktop().open(ff);
		}
	}"
xdman,xdman.util.XDMUtils,copyURL,,7,9,8,4,0.24,0.0556,1,2,2,0,1,"public static void copyURL(String url) {
		try {
			Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(url), null);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.XDMUtils,exec,,10,12,9,3,0.2917,0.0833,1,2,2,0,1,"public static boolean exec(String args) {
		try {
			Logger.log(""Launching: "" + args);
			Runtime.getRuntime().exec(args);
		} catch (IOException e) {
			Logger.log(e);
			return false;
		}
		return true;
	}"
xdman,xdman.util.XDMUtils,keepAwakePing,,14,41,37,7,0.15,0.0455,1,2,5,0,1,"public static void keepAwakePing() {
		try {
			int os = detectOS();
			if (os == LINUX) {
				LinuxUtils.keepAwakePing();
			} else if (os == WINDOWS) {
				WinUtils.keepAwakePing();
			} else if (os == MAC) {
				MacUtils.keepAwakePing();
			}
		} catch (Throwable e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.XDMUtils,isAlreadyAutoStart,,16,41,37,7,0.15,0.0455,1,2,5,0,1,"public static boolean isAlreadyAutoStart() {
		try {
			int os = detectOS();
			if (os == LINUX) {
				return LinuxUtils.isAlreadyAutoStart();
			} else if (os == WINDOWS) {
				return WinUtils.isAlreadyAutoStart();
			} else if (os == MAC) {
				return MacUtils.isAlreadyAutoStart();
			}
			return false;
		} catch (Throwable e) {
			Logger.log(e);
		}
		return false;
	}"
xdman,xdman.util.XDMUtils,addToStartup,,14,41,37,7,0.15,0.0455,1,2,5,0,1,"public static void addToStartup() {
		try {
			int os = detectOS();
			if (os == LINUX) {
				LinuxUtils.addToStartup();
			} else if (os == WINDOWS) {
				WinUtils.addToStartup();
			} else if (os == MAC) {
				MacUtils.addToStartup();
			}
		} catch (Throwable e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.XDMUtils,removeFromStartup,,14,41,37,7,0.15,0.0455,1,2,5,0,1,"public static void removeFromStartup() {
		try {
			int os = detectOS();
			if (os == LINUX) {
				LinuxUtils.removeFromStartup();
			} else if (os == WINDOWS) {
				WinUtils.removeFromStartup();
			} else if (os == MAC) {
				MacUtils.removeFromStartup();
			}
		} catch (Throwable e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.XDMUtils,browseURL,,10,22,16,4,0.2143,0.0926,1,2,4,0,1,"public static void browseURL(String url) {
		int os = detectOS();
		if (os == WINDOWS) {
			WinUtils.browseURL(url);
		} else if (os == LINUX) {
			LinuxUtils.browseURL(url);
		} else if (os == MAC) {
			MacUtils.browseURL(url);
		}
	}"
xdman,xdman.util.WinUtils,open,,16,51,36,4,0.2167,0.1436,1,4,3,0,1,"public static void open(File f) throws FileNotFoundException {
		if (!f.exists()) {
			throw new FileNotFoundException();
		}
		try {
			ProcessBuilder builder = new ProcessBuilder();
			ArrayList<String> lst = new ArrayList<String>();
			lst.add(""rundll32"");
			lst.add(""url.dll,FileProtocolHandler"");
			lst.add(f.getAbsolutePath());
			builder.command(lst);
			builder.start();
		} catch (IOException e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.WinUtils,openFolder,,17,74,57,5,0.1633,0.1127,1,6,3,0,1,"public static void openFolder(String folder, String file) throws FileNotFoundException {
		try {
			File f = new File(folder, file);
			if (!f.exists()) {
				throw new FileNotFoundException();
			}
			ProcessBuilder builder = new ProcessBuilder();
			ArrayList<String> lst = new ArrayList<String>();
			lst.add(""explorer"");
			lst.add(""/select,"");
			lst.add(f.getAbsolutePath());
			builder.command(lst);
			builder.start();
		} catch (IOException e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.WinUtils,browseURL,,13,41,27,4,0.2182,0.1636,1,4,2,0,1,"public static void browseURL(String url) {
		try {
			ProcessBuilder builder = new ProcessBuilder();
			ArrayList<String> lst = new ArrayList<String>();
			lst.add(""rundll32"");
			lst.add(""url.dll,FileProtocolHandler"");
			lst.add(url);
			builder.command(lst);
			builder.start();
		} catch (IOException e) {
			Logger.log(e);
		}
	}"
xdman,xdman.util.FormatUtilities,formatDate,,7,11,7,3,0.3333,0.1667,0,2,2,0,1,"public static String formatDate(long date) {
		if (_format == null) {
			_format = new SimpleDateFormat(""yyyy-MM-dd"");
		}
		Date dt = new Date(date);
		return _format.format(dt);
	}"
xdman,xdman.util.FormatUtilities,hms,,8,18,8,3,0.2917,0.1198,0,4,1,0,1,"public static String hms(int sec) {
		int hrs = 0, min = 0;
		hrs = sec / 3600;
		min = (sec % 3600) / 60;
		sec = sec % 60;
		String str = String.format(""%02d:%02d:%02d"", hrs, min, sec);
		return str;
	}"
xdman,xdman.util.ParamUtils,sendParam,,40,320,262,5,0.0893,0.0725,1,13,6,0,1,"public static void sendParam(Map<String, String> params) {
		StringBuffer sb = new StringBuffer();
		Iterator<String> paramIter = params.keySet().iterator();
		while (paramIter.hasNext()) {
			String key = paramIter.next();
			String value = params.get(key);
			sb.append(key + "":"" + value + ""\n"");
		}

		InetAddress addr = InetAddress.getLoopbackAddress();

		StringBuffer reqBuf = new StringBuffer();
		reqBuf.append(""GET /cmd HTTP/1.1\r\n"");
		reqBuf.append(""Content-Length: "" + sb.length() + ""\r\n"");
		reqBuf.append(""Host: "" + addr.getHostName() + ""\r\n"");
		reqBuf.append(""Connection: close\r\n\r\n"");
		reqBuf.append(sb);
		String resp = null;
		Socket sock = null;
		try {
			sock = new Socket(InetAddress.getLoopbackAddress(), 9614);
			InputStream in = sock.getInputStream();
			OutputStream out = sock.getOutputStream();
			out.write(reqBuf.toString().getBytes());
			resp = NetUtils.readLine(in);
			resp = resp.split("" "")[1];
		} catch (Exception e) {
		} finally {
			if (sock != null) {
				try {
					sock.close();
				} catch (Exception e2) {
				}
			}
		}

		if (!""200"".equals(resp)) {
			JOptionPane.showMessageDialog(null, ""An older version of XDM is already running."");
		}
	}"
xdman,xdman.videoparser.YdlResponse,createFormat,,57,836,726,21,0.0653,0.0666,0,8,12,0,1,"public static String createFormat(String ext, String fmt1, String fmt2, String acodec, String vcodec, int width,
			int height) {
		StringBuffer sb = new StringBuffer();
		ext = nvl(ext);
		if (ext.length() > 0) {
			sb.append(ext.toUpperCase());
		}

		if (width > 0 && height > 0) {
			if (sb.length() > 0)
				sb.append("" "");
			sb.append(width + ""x"" + height);
		}

		// fmt1 = nvl(fmt1);
		// if (fmt1.length() > 0) {
		// if (sb.length() > 0)
		// sb.append("" "");
		// sb.append(fmt1);
		// }
		//
		// fmt2 = nvl(fmt2);
		// if (fmt2.length() > 0) {
		// if (sb.length() > 0)
		// sb.append("" "");
		// sb.append(fmt2);
		// }

		acodec = nvl(acodec);
		if (acodec.contains(""none"")) {
			acodec = """";
		}

		vcodec = nvl(vcodec);
		if (vcodec.contains(""none"")) {
			vcodec = """";
		}

		if (acodec.length() > 0) {
			if (sb.length() > 0)
				sb.append("" "");
			sb.append(acodec);
		}

		if (vcodec.length() > 0) {
			if (sb.length() > 0) {
				if (acodec.length() > 0) {
					sb.append(""+"");
				} else {
					sb.append("" "");
				}
			}
			sb.append(vcodec);
		}

		return sb.toString();
	}"
xdman,xdman.videoparser.YoutubeDLHandler,start,,42,401,367,10,0.0684,0.0368,1,10,5,0,1,"public void start() {
		try {
			ByteArrayOutputStream bout = new ByteArrayOutputStream(8192);
			List<String> args = new ArrayList<String>();
			args.add(ydlLocation);
			args.add(""--no-warnings"");
			args.add(""-J"");
			//args.add(""--proxy"");
			//args.add(""http://127.0.0.1:8888"");
			args.add(url);

			ProcessBuilder pb = new ProcessBuilder(args);
			pb.redirectErrorStream(true);
			proc = pb.start();

			InputStream in = proc.getInputStream();
			byte[] buf = new byte[8192];
			while (true) {
				int x = in.read(buf);
				if (x == -1)
					break;
				bout.write(buf, 0, x);
			}

			// OutputStream out = new FileOutputStream(""test.txt"");
			// out.write(bout.toByteArray());
			// out.close();

			String json = new String(bout.toByteArray());
			System.out.println(""----json: "" + json);
			System.out.println(""----json end ----"");
			exitCode = proc.waitFor();
			if (exitCode == 0) {
				StringBuilder title = new StringBuilder();
				videos.addAll(YdlResponse.parse(new ByteArrayInputStream(bout.toByteArray())));
				this.title = title.toString();
			}
		} catch (Exception e) {
			Logger.log(e);
		}

	}"
xdman,xdman.videoparser.YoutubeDLHandler,stop,,7,9,8,4,0.2667,0.0556,1,1,2,0,1,"public void stop() {
		try {
			proc.destroy();
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
xdman,xdman.win32.NativeMethods,NativeMethods,,8,13,11,4,0.2778,0.1071,1,2,2,0,1,"private NativeMethods() {
		String dllPath = new File(XDMUtils.getJarFile().getParentFile(), ""xdm_native.dll"").getAbsolutePath();
		try {
			System.load(dllPath);
		} catch (Exception e) {
			Logger.log(e);
		}
	}"
